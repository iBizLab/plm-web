var sp = Object.defineProperty;
var ip = (s, e, t) => e in s ? sp(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;
var E = (s, e, t) => (ip(s, typeof e != "symbol" ? e + "" : e, t), t);
import { defineComponent as ye, ref as L, shallowRef as au, watch as Be, onBeforeUnmount as Lo, onMounted as fn, nextTick as Ye, createVNode as S, resolveComponent as Ee, createTextVNode as at, computed as qe, Fragment as rp, onUnmounted as fr, mergeProps as op, reactive as lu, withDirectives as gi, resolveDirective as Vi, vModelText as Pl, h as cs, createApp as vs, defineAsyncComponent as ap } from "vue";
import { PluginStaticResource as cu, ScriptFactory as Dt, Srfuf as lp, ControllerEvent as hu, convertNavData as Hi, OpenAppViewCommand as cp, EditorController as hp, getDeACMode as up, registerEditorProvider as dp } from "@ibiz-template/runtime";
import { getHtmlProps as _l, useNamespace as me, useClickOutside as fp, getEditorEmits as gp, withInstall as pp } from "@ibiz-template/vue3-util";
import { Editor as uu, Toolbar as du } from "@wangeditor/editor-for-vue";
import { SlateEditor as ne, SlateElement as Ui, SlateText as pe, SlateNode as xs, SlatePath as hs, SlateTransforms as He, SlateRange as ct, DomEditor as we, SlatePoint as so, Boot as ht, createEditor as mp } from "@wangeditor/editor";
import { getCookie as Ol, createUUID as nt, QXEvent as fu } from "qx-util";
import { isNil as wp, clone as yp } from "ramda";
import { CoreConst as Tl, debounce as Ll, getToken as bp, awaitTimeout as vp, RuntimeError as io, listenJSEvent as pi, NOOP as Pt, strToBase64 as ro, HttpError as xp, base64ToStr as Ha, clone as Nr, downloadFileFromBlob as Cp } from "@ibiz-template/core";
import Nl, { ElMessageBox as gu, ElInput as Mc, ElSlider as kc, ElButton as Pc } from "element-plus";
import { debounce as pu, startCase as Ep, camelCase as No, isObject as Pi, clamp as Mt, upperFirst as _c, lowerFirst as Sp, isPlainObject as gn, defaultsDeep as mu, cloneDeep as Ae, sortedIndex as Ap, merge as De, uniq as wu, difference as Mp, sortedIndexBy as kp, union as Oc, isEqual as on, defaults as Pp, isEmpty as yu, sortBy as _p, groupBy as Tc, max as Op, has as Dr, clone as Ua, isNumber as Lc, throttle as Tp, toNumber as Lp } from "lodash-es";
import qa from "dayjs";
class bu {
  constructor(e, t) {
    /**
     * 模态实例
     * @memberof ModalUtil
     */
    E(this, "modalOrPanel");
    /**
     * 富文本Ref
     * @memberof ModalUtil
     */
    E(this, "htmlRef");
    this.modalOrPanel = e, this.htmlRef = t, this.calcModalPosition(), window.addEventListener("resize", this.handleResize.bind(this));
  }
  /**
   * 计算模态定位
   * @memberof ModalUtil
   */
  calcModalPosition() {
    if (!["dropPanel", "selectList"].includes(this.modalOrPanel.type))
      return;
    const { $elem: t } = this.modalOrPanel, n = t[0], i = this.htmlRef.$el, r = i.querySelector(".w-e-bar"), o = n.previousElementSibling, a = o.getAttribute("data-menu-key"), l = n.parentNode.parentNode.parentNode;
    if (!["bgColor", "color", "headerSelect"].includes(a) || !i || !r || !o || l.getAttribute("data-w-e-toolbar") === "true")
      return;
    const u = n.clientWidth, d = n.clientHeight, f = r.clientHeight, g = o.getBoundingClientRect(), p = g.bottom, m = g.right, w = g.top, v = g.left, y = "".concat(w + f, "px"), b = "".concat(v, "px"), x = "".concat(p - d - f, "px"), C = "".concat(m - u, "px"), A = { position: "fixed", left: b, top: y }, k = window.innerWidth, O = window.innerHeight;
    k - v < u && Object.assign(A, { left: C }), O - w - f < d && Object.assign(A, { top: x }), Object.assign(n.style, { top: "", bottom: "", left: "", right: "" }), Object.assign(n.style, A);
  }
  /**
   * 监听窗口变化
   * @memberof ModalUtil
   */
  handleResize() {
    this.calcModalPosition();
  }
  /**
   * 销毁
   * @memberof ModalUtil
   */
  destroy() {
    window.removeEventListener("resize", this.handleResize);
  }
}
const Np = new cu(import.meta.url), oo = /* @__PURE__ */ ye({
  name: "IBizHtmlContent",
  props: _l(),
  emits: ["change", "blur", "focus", "enter", "infoTextChange", "link", "itemClick"],
  setup(s, {
    emit: e
  }) {
    const t = me("html"), n = me("html-comment"), i = s.controller, r = L(), o = L({});
    let a = null, l = 0;
    const c = L(), u = L(), d = au(), f = L(), g = L(""), p = L({
      Authorization: "Bearer ".concat(Ol(Tl.TOKEN))
    }), m = L(""), w = L(""), v = L(!0), y = L(!1), b = L(!1), x = L(!1), C = L(!1), A = L(""), k = L([]), O = L(!1), P = L([]);
    let D = "";
    const N = i.model;
    N.editorParams && (N.editorParams.enableEdit && (y.value = !0, b.value = !0, v.value = i.toBoolean(N.editorParams.enableEdit) && !s.readonly && !s.disabled), N.editorParams.enableFullScreen && (x.value = i.toBoolean(N.editorParams.enableFullScreen)));
    const F = (j) => {
      if (!d.value)
        return;
      const {
        eventArg: z
      } = j;
      z && (d.value.setHtml(z), Ye(() => {
        d.value.focus(!0), e("focus");
      }));
    }, ee = () => {
      d.value && (d.value.blur(), d.value.setHtml(""));
    }, X = () => {
      d.value && (d.value.focus(!0), e("focus"));
    }, _ = () => {
      d.value && d.value.focus(!0);
    }, I = () => {
      d.value && d.value.focus(!1);
    };
    i.evt.on("setHtml", F), i.evt.on("clear", ee), i.evt.on("onSetReply", X), i.evt.on("focus", _), i.evt.on("blur", I);
    const W = (j) => {
      const z = j.includes(".") ? j.split(".").pop() : "";
      return ["jpeg", "jpg", "gif", "png", "bmp", "svg"].includes(z) ? "image" : z;
    }, oe = (j) => {
      const {
        value: z
      } = j, q = JSON.parse(z);
      P.value = q.map((ae) => ({
        ...ae,
        type: W(ae.name)
      })), i.hasFile.value = P.value.length > 0;
    };
    i.evt.on("fileChange", oe);
    const re = (j) => {
      console.log("handleFileRemove"), P.value = P.value.filter((ke) => ke.id !== j), i.hasFile.value = P.value.length > 0;
      const z = P.value.map((ke) => ({
        name: ke.name,
        id: ke.id
      })), q = z.length > 0 ? JSON.stringify(z) : "";
      i.parent.setDataValue(q, D);
    };
    Be(() => s.data, (j) => {
      if (j) {
        const z = ibiz.util.file.calcFileUpDownUrl(i.context, i.params, j);
        m.value = z.uploadUrl, w.value = z.downloadUrl;
        const q = i.expFields.find((ae) => ae.name === "file");
        if (q) {
          D = q.value;
          const ae = s.data[D], ke = ae ? JSON.parse(ae) : [];
          P.value = ke.map((rt) => ({
            ...rt,
            type: W(rt.name)
          })), i.hasFile.value = P.value.length > 0;
        }
      }
    }, {
      immediate: !0,
      deep: !0
    });
    const xe = (j, z) => {
      if (z)
        return !0;
    }, ce = (j) => j, bt = {
      toolbarKeys: [{
        key: "group-add-style",
        // 必填，要以 group 开头
        title: "添加",
        // 必填
        iconSvg: '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fit="" height="1em" width="1em" preserveAspectRatio="xMidYMid meet" focusable="false"><g id="arvaction/plus-circle-fill" stroke-width="1" fill-rule="evenodd"><path d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16zm-.6-8.6H4v1.2h3.4V12h1.2V8.6H12V7.4H8.6V4H7.4v3.4z" id="arv形状结合"></path></g></svg>',
        // 可选
        menuKeys: i.expMenuKeys.replace("file", "attachments").replace("code", "codesnippet").replace("page", "page").split(";")
      }, "|", {
        key: "group-inline-style",
        // 必填，要以 group 开头
        title: "文本格式",
        // 必填
        iconSvg: '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fit="" height="1em" width="1em" preserveAspectRatio="xMidYMid meet" focusable="false"><g id="ahdeditor/color-tt" stroke-width="1" fill-rule="evenodd"><path id="ahdsecondary-color" d="M1.999 15.011h11.998V13.81H1.999z"></path><path d="M6.034 7.59h4.104L8.086 2.297 6.034 7.59zm-.465 1.2l-1.437 3.707H2.845L7.301 1h1.287l-.001.004h.286l4.454 11.492h-1.288L10.603 8.79H5.569z" id="ahd合并形状"></path></g></svg>',
        // 可选
        menuKeys: ["bold", "italic", "underline", "through", "code", "numberedList", "bulletedList", "insertLink"]
      }, "codeBlock", "mention", "marker", "emoji"]
    };
    i.chatCompletion && bt.toolbarKeys.push("aichart");
    const ut = {
      placeholder: i.placeHolder,
      readOnly: y.value ? b.value : s.readonly,
      MENU_CONF: {
        // 图片上传
        uploadImage: {
          // 上传地址
          server: m.value,
          // form-data fieldName ，默认值 'wangeditor-uploaded-image'
          fieldName: "file",
          // 单个文件的最大体积限制，默认为 2M
          maxFileSize: 10 * 1024 * 1024,
          // 10M
          // 最多可上传几个文件，默认为 100
          maxNumberOfFiles: 10,
          // 选择文件时的类型限制，默认为 ['image/*'] 。如不想限制，则设置为 []
          allowedFileTypes: [],
          // 自定义增加 http  header
          headers: p.value,
          // 跨域是否传递 cookie ，默认为 false
          withCredentials: !0,
          // 上传之前触发
          onBeforeUpload(j) {
            return j;
          },
          // 上传进度的回调函数
          onProgress(j) {
            console.log("progress", j);
          },
          // 单个文件上传成功之后
          onSuccess(j, z) {
            console.log("".concat(j.name, " 上传成功"), z);
          },
          // 单个文件上传失败
          onFailed(j, z) {
            console.log("".concat(j.name, " 上传失败"), z);
          },
          // 上传错误，或者触发 timeout 超时
          onError(j, z, q) {
            console.log("".concat(j.name, " 上传出错"), z, q);
          },
          // 自定义插入图片
          async customInsert(j, z) {
            const q = w.value.replace("%fileId%", j.id), ae = j.filename;
            z(q, ae, "");
          }
        },
        // 插入链接
        insertLink: {
          checkLink: xe,
          // 也支持 async 函数
          parseLinkUrl: ce
          // 也支持 async 函数
        },
        // 更新链接
        editLink: {
          checkLink: xe,
          // 也支持 async 函数
          parseLinkUrl: ce
          // 也支持 async 函数
        }
      },
      hoverbarKeys: {
        link: {
          menuKeys: ["editLink", "unLink", "customViewLink"]
        }
      }
    }, Ft = async (j) => {
      const z = j.src;
      if (b.value)
        st(z);
      else {
        const q = ne.nodes(d.value, {
          match: (ae) => !!(Ui.isElement(ae) && ae.type === "image"),
          universal: !0
        });
        if (q)
          for (const ae of q) {
            const [ke] = ae;
            ke.type === "image" && z.endsWith(ke.src) && st(ke.src);
          }
      }
    }, dt = (j) => {
      i.handleClick(j), e("itemClick", j);
    }, st = async (j) => {
      if (A.value = j, k.value = [j], await Ye(), f.value) {
        const {
          container: z
        } = f.value.$refs;
        z && z.children[0].click();
      }
    }, Jn = (j) => {
      const z = j.getEditableContainer();
      z && z.querySelectorAll("img").forEach((ae) => {
        ae.onclick = (ke) => {
          const rt = ke.target;
          rt && Ft(rt);
        };
      });
    }, Yn = (j) => {
      if (f.value) {
        const {
          container: z
        } = f.value.$refs;
        if (z) {
          const q = z.querySelector(".el-image-viewer__wrapper");
          q == null || q[j]("keydown", $t);
        }
      }
    }, $t = async (j) => {
      (j.key === "Escape" || j.keyCode === 27) && (j.stopPropagation(), j.preventDefault(), await Ye(), Yn("removeEventListener"), k.value = []);
    }, ia = async () => {
      await Ye(), Yn("addEventListener");
    };
    let ks;
    const ra = async () => {
      var j;
      if (i.deService) {
        const z = await import("@ibiz-template-plugin/ai-chat"), q = z.chat || z.default.chat;
        ks = q;
        const ae = q.create({
          question: async (rt) => {
            var H;
            const T = nt(), B = new AbortController();
            return await ((H = i.deService) == null ? void 0 : H.aiChatSse((U) => {
              if (ibiz.log.info("aiChatSse", U), U.actionstate === 20 && U.actionresult)
                ae.addMessage({
                  messageid: T,
                  state: U.actionstate,
                  type: "DEFAULT",
                  role: "ASSISTANT",
                  content: U.actionresult
                });
              else if (U.actionstate === 30 && U.actionresult) {
                const je = JSON.parse(U.actionresult), {
                  choices: Ne
                } = je;
                Ne && Ne.length > 0 && ae.replaceMessage({
                  messageid: T,
                  state: U.actionstate,
                  type: "DEFAULT",
                  role: "ASSISTANT",
                  content: Ne[0].content || ""
                });
              } else
                U.actionstate === 40 && ae.replaceMessage({
                  messageid: T,
                  state: U.actionstate,
                  type: "ERROR",
                  role: "ASSISTANT",
                  content: U.actionresult
                });
            }, B, i.context, {}, {
              messages: rt
            })), ae.addMessage({
              messageid: T,
              state: 10,
              type: "DEFAULT",
              role: "ASSISTANT",
              content: ""
            }), !0;
          },
          action: (rt, T) => {
            rt === "backfill" && (e("change", T.content), O.value = !0);
          },
          closed: () => {
            d.value && s.value && d.value && d.value.focus(!0);
          }
        }), ke = await ((j = i.deService) == null ? void 0 : j.aiChatHistory(i.context, {}));
        ke.data && Array.isArray(ke.data) && ke.data.forEach((rt) => {
          const T = {
            messageid: nt(),
            state: 30,
            type: "DEFAULT",
            role: rt.role,
            content: rt.content
          };
          ae.addMessage(T);
        });
      }
    };
    Lo(() => {
      ks && ks.close();
      const j = d.value;
      j != null && j.destroy();
    });
    const Xn = (j) => {
      d.value = j;
      let z;
      j.on("modalOrPanelShow", (q) => {
        z = new bu(q, u.value);
      }), j.on("modalOrPanelHide", () => {
        z && z.destroy();
      }), j.setHtml(g.value), j.on("aiClick", () => {
        ra();
      }), i.onCreated(d.value, s.data, bt);
    }, zt = (j) => {
      const z = j.getHtml();
      Jn(j);
      const q = z === "<p><br></p>" ? "" : z;
      q === s.value || q === "" && wp(s.value) || y.value || (e("change", q), i.evt.emit("onChange", {
        eventArg: q
      }));
    }, it = (j) => {
      i.evt.off("setHtml", F), i.evt.off("clear", ee), i.evt.off("onSetReply", X), i.evt.off("focus", _), i.evt.off("blur", I);
    }, kr = () => {
      e("focus"), i.evt.emit("onFocus", {
        eventArg: s.value
      });
    }, Si = () => {
      e("blur"), i.evt.emit("onBlur", {
        eventArg: s.value
      });
    }, Pr = (j, z) => {
      alert("【自定义提示】".concat(z, " - ").concat(j));
    }, Ps = (j, z, q) => {
      q(!0);
    }, oa = (j) => {
      const z = d.value;
      z != null && z.insertText(j);
    }, aa = () => {
      const j = d.value;
      j != null && console.log(j.getHtml());
    }, Zn = () => {
      const j = d.value;
      j != null && j.disable();
    }, Kn = () => {
      const j = d.value;
      j != null && j.enable();
    }, _r = () => {
      if (r.value && c.value) {
        const j = r.value.offsetHeight;
        a = new ResizeObserver((z) => {
          const {
            height: q
          } = z[0].contentRect;
          if (q !== l) {
            const ae = {
              height: "".concat(j - z[0].contentRect.height, "px")
            };
            o.value = t.cssVarBlock(ae), l = q;
          }
        }), a.observe(c.value.selector);
      }
    }, Or = () => {
      var j, z;
      if (s.value) {
        const q = s.value.indexOf("</p>");
        if (q >= 0) {
          const ae = (j = d.value.selection.anchor) == null ? void 0 : j.offset, ke = (z = d.value.selection.anchor) == null ? void 0 : z.path;
          ae === 0 && ke.length > 0 && ke[0] === 0 && d.value.move(q - 3);
        }
      }
    }, _s = () => {
      b.value = !b.value, b.value ? Zn() : (Kn(), d.value.focus(), Or());
    }, Tr = () => S("div", {
      class: t.be("message", "message-content")
    }, [S("p", null, [at("确定要取消编辑吗？")]), S("p", {
      class: t.bem("message", "message-content", "message-tip")
    }, [at("取消编辑将无法保存修改的内容，且不能找回。")])]), Lr = () => {
      s.value !== g.value ? gu({
        title: "确认取消",
        type: "warning",
        customClass: t.b("message"),
        message: Tr(),
        showCancelButton: !0,
        cancelButtonClass: t.be("message", "message-cancel"),
        confirmButtonClass: t.be("message", "message-comfire")
      }).then(() => {
        if (s.value) {
          const j = i.parseNode(s.value);
          g.value = j;
        } else
          g.value = "";
        _s();
      }).catch(() => {
        d.value.focus();
      }) : _s();
    }, la = () => {
      b.value = !0, d.value.disable();
      const {
        value: j
      } = g;
      e("change", j), C.value && (C.value = !1);
    }, ca = () => y.value ? S("div", {
      class: [t.b("footer"), {
        [t.b("footer-dialog")]: C.value
      }]
    }, [S("div", {
      class: t.be("footer", "cancel"),
      onClick: () => Lr()
    }, [at("取消")]), S("div", {
      class: t.be("footer", "save"),
      onClick: () => la()
    }, [at("保存")])]) : null, vn = () => {
      C.value = !C.value, Ye(() => {
        b.value ? Zn() : (Kn(), d.value.focus());
      });
    }, Os = () => x.value ? C.value ? S("i", {
      class: "fa fa-compress",
      "aria-hidden": "true",
      title: "缩小",
      onClick: () => vn()
    }, null) : S("i", {
      class: "fa fa-expand",
      "aria-hidden": "true",
      title: "放大",
      onClick: () => vn()
    }, null) : null, ha = (j) => S("div", {
      class: n.e("images")
    }, [j.map((z) => {
      const q = w.value.replace("%fileId%", z.id);
      return S("div", {
        class: n.e("image")
      }, [S(Ee("el-image"), {
        fit: "contain",
        src: q,
        "preview-src-list": [q]
      }, null), S(Ee("ion-icon"), {
        name: "close-circle-outline",
        onClick: () => re(z.id)
      }, null)]);
    })]), ua = (j) => S("div", {
      class: n.e("node")
    }, [S("img", {
      src: Np.dir("assets/images/".concat(j.type, ".svg")),
      style: "margin-right:6px",
      alt: ""
    }, null), S("div", {
      class: n.e("node-right")
    }, [S("div", {
      class: n.e("node-name")
    }, [j.name]), S("div", {
      class: n.e("node-type")
    }, [j.type.toUpperCase()])]), S("div", {
      class: n.e("node-toolbar"),
      onClick: () => re(j.id)
    }, [S(Ee("ion-icon"), {
      name: "trash-outline"
    }, null)])]), Ai = () => {
      if (!P.value)
        return;
      const j = P.value.filter((q) => q.type === "image"), z = P.value.filter((q) => q.type !== "image");
      return S("div", {
        class: n.e("file-container")
      }, [ha(j), S("div", {
        class: n.e("nodes")
      }, [z.map((q) => ua(q))])]);
    }, da = () => y.value || x.value ? S("div", {
      class: t.b("custom-toolbar")
    }, [y.value && v.value && b.value ? S("i", {
      class: "fa fa-edit",
      "aria-hidden": "true",
      title: "启用编辑",
      onClick: () => _s()
    }, null) : null, Os()]) : null, fa = () => {
      if (i.reply.value) {
        const j = Dt.execScriptFn({
          value: i.reply.value,
          controller: i
        }, i.replyScript, {
          singleRowReturn: !0,
          isAsync: !1
        });
        return S("div", {
          class: t.b("reply")
        }, [S("div", {
          class: t.be("reply", "content"),
          innerHTML: j
        }, null), S(Ee("ion-icon"), {
          name: "close-outline",
          onClick: () => i.removeReply()
        }, null)]);
      }
    }, ga = () => i.hidden.value ? null : S("div", {
      class: t.b("content"),
      ref: "htmlContent",
      style: o.value
    }, [S(uu, {
      ref: "htmlRef",
      class: t.b("editor"),
      modelValue: g.value,
      "onUpdate:modelValue": (j) => g.value = j,
      "default-config": ut,
      mode: "default",
      onClick: dt,
      onOnCreated: Xn,
      onOnChange: zt,
      onOnDestroyed: it,
      onOnFocus: kr,
      onOnBlur: Si,
      oncustomAlert: Pr,
      oncustomPaste: Ps
    }, null), fa(), S(du, {
      ref: "toolbarRef",
      editor: d.value,
      "default-config": bt,
      mode: "default",
      class: t.b("toolbar")
    }, null)]), pa = () => S(Ee("el-image"), {
      class: t.e("preview"),
      ref: "previewRef",
      "zoom-rate": 1.1,
      src: A.value,
      "preview-src-list": k.value,
      "hide-on-click-modal": !0,
      onShow: ia,
      fit: "cover"
    }, null);
    return fn(() => {
      _r(), Be(() => s.value, (j, z) => {
        j !== z && (typeof s.value == "string" || j == null) && (j == null ? g.value = "" : g.value = j, O.value && (d.value && Ye(() => {
          d.value.focus(!0);
        }), O.value = !1));
      }, {
        immediate: !0
      }), Be(() => s.disabled, (j, z) => {
        j !== z && (j === !0 ? Zn() : Kn());
      }, {
        immediate: !0
      });
    }), {
      ns: t,
      editorRef: d,
      previewRef: f,
      mode: "default",
      valueHtml: g,
      toolbarConfig: bt,
      editorConfig: ut,
      handleCreated: Xn,
      handleChange: zt,
      handleDestroyed: it,
      handleFocus: kr,
      handleBlur: Si,
      customAlert: Pr,
      customPaste: Ps,
      insertText: oa,
      printHtml: aa,
      disable: Zn,
      enable: Kn,
      renderHeaserToolbar: da,
      renderEditorContent: ga,
      renderFooter: ca,
      htmlContent: r,
      hasEnableEdit: y,
      cssVars: o,
      toolbarRef: c,
      htmlRef: u,
      isFullScreen: C,
      readonlyState: b,
      changeFullScreenState: vn,
      renderPreview: pa,
      renderFileList: Ai
    };
  },
  render() {
    return this.isFullScreen ? S(Ee("el-dialog"), {
      modelValue: this.isFullScreen,
      "onUpdate:modelValue": (s) => this.isFullScreen = s,
      width: "80%",
      top: "10vh",
      class: this.ns.b("dialog-full-screen"),
      onClose: () => this.changeFullScreenState()
    }, {
      default: () => [S("div", {
        class: [this.ns.b(), {
          [this.ns.b("editor-readonly")]: this.readonlyState
        }]
      }, [this.renderHeaserToolbar(), this.renderEditorContent(), this.renderFileList(), this.hasEnableEdit && !this.readonlyState ? this.renderFooter() : null])]
    }) : S("div", {
      class: [this.ns.b(), {
        [this.ns.b("editor-readonly")]: this.readonlyState
      }]
    }, [this.renderHeaserToolbar(), this.renderEditorContent(), this.renderFileList(), this.renderPreview(), this.hasEnableEdit && !this.readonlyState ? this.renderFooter() : null]);
  }
}), Dp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: oo
}, Symbol.toStringTag, { value: "Module" })), Ip = [
  "insert",
  "|",
  "headerSelect",
  "blockquote",
  "|",
  "bold",
  "underline",
  "italic",
  {
    key: "group-more-style",
    title: "更多",
    iconSvg: '<svg viewBox="0 0 1024 1024"><path d="M204.8 505.6m-76.8 0a76.8 76.8 0 1 0 153.6 0 76.8 76.8 0 1 0-153.6 0Z"></path><path d="M505.6 505.6m-76.8 0a76.8 76.8 0 1 0 153.6 0 76.8 76.8 0 1 0-153.6 0Z"></path><path d="M806.4 505.6m-76.8 0a76.8 76.8 0 1 0 153.6 0 76.8 76.8 0 1 0-153.6 0Z"></path></svg>',
    menuKeys: ["through", "code", "sup", "sub", "clearStyle"]
  },
  "color",
  "bgColor",
  "|",
  "fontSize",
  "fontFamily",
  "lineHeight",
  "|",
  "bulletedList",
  "numberedList",
  "todo",
  {
    key: "group-justify",
    title: "对齐",
    iconSvg: '<svg viewBox="0 0 1024 1024"><path d="M768 793.6v102.4H51.2v-102.4h716.8z m204.8-230.4v102.4H51.2v-102.4h921.6z m-204.8-230.4v102.4H51.2v-102.4h716.8zM972.8 102.4v102.4H51.2V102.4h921.6z"></path></svg>',
    menuKeys: [
      "justifyLeft",
      "justifyRight",
      "justifyCenter",
      "justifyJustify"
    ]
  },
  {
    key: "group-indent",
    title: "缩进",
    iconSvg: '<svg viewBox="0 0 1024 1024"><path d="M0 64h1024v128H0z m384 192h640v128H384z m0 192h640v128H384z m0 192h640v128H384zM0 832h1024v128H0z m0-128V320l256 192z"></path></svg>',
    menuKeys: ["indent", "delIndent"]
  },
  "|",
  "emoji",
  "insertLink",
  {
    key: "group-image",
    title: "图片",
    iconSvg: '<svg viewBox="0 0 1024 1024"><path d="M959.877 128l0.123 0.123v767.775l-0.123 0.122H64.102l-0.122-0.122V128.123l0.122-0.123h895.775zM960 64H64C28.795 64 0 92.795 0 128v768c0 35.205 28.795 64 64 64h896c35.205 0 64-28.795 64-64V128c0-35.205-28.795-64-64-64zM832 288.01c0 53.023-42.988 96.01-96.01 96.01s-96.01-42.987-96.01-96.01S682.967 192 735.99 192 832 234.988 832 288.01zM896 832H128V704l224.01-384 256 320h64l224.01-192z"></path></svg>',
    menuKeys: ["insertImage", "uploadImage"]
  },
  "files",
  {
    key: "group-video",
    title: "视频",
    iconSvg: '<svg viewBox="0 0 1024 1024"><path d="M981.184 160.096C837.568 139.456 678.848 128 512 128S186.432 139.456 42.816 160.096C15.296 267.808 0 386.848 0 512s15.264 244.16 42.816 351.904C186.464 884.544 345.152 896 512 896s325.568-11.456 469.184-32.096C1008.704 756.192 1024 637.152 1024 512s-15.264-244.16-42.816-351.904zM384 704V320l320 192-320 192z"></path></svg>',
    menuKeys: ["insertVideo", "uploadVideo"]
  },
  "insertTable",
  "codeBlock",
  "divider",
  "|",
  "undo",
  "redo"
], Tt = () => /* @__PURE__ */ new Map(), Ga = (s) => {
  const e = Tt();
  return s.forEach((t, n) => {
    e.set(n, t);
  }), e;
}, zn = (s, e, t) => {
  let n = s.get(e);
  return n === void 0 && s.set(e, n = t()), n;
}, jp = (s, e) => {
  const t = [];
  for (const [n, i] of s)
    t.push(e(i, n));
  return t;
}, Rp = (s, e) => {
  for (const [t, n] of s)
    if (e(n, t))
      return !0;
  return !1;
}, Hs = () => /* @__PURE__ */ new Set(), wa = (s) => s[s.length - 1], Bp = (s, e) => {
  for (let t = 0; t < e.length; t++)
    s.push(e[t]);
}, Ln = Array.from, Fp = (s, e) => {
  for (let t = 0; t < s.length; t++)
    if (e(s[t], t, s))
      return !0;
  return !1;
}, Wa = Array.isArray;
class vu {
  constructor() {
    this._observers = Tt();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(e, t) {
    return zn(
      this._observers,
      /** @type {string} */
      e,
      Hs
    ).add(t), t;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(e, t) {
    const n = (...i) => {
      this.off(
        e,
        /** @type {any} */
        n
      ), t(...i);
    };
    this.on(
      e,
      /** @type {any} */
      n
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(e, t) {
    const n = this._observers.get(e);
    n !== void 0 && (n.delete(t), n.size === 0 && this._observers.delete(e));
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(e, t) {
    return Ln((this._observers.get(e) || Tt()).values()).forEach((n) => n(...t));
  }
  destroy() {
    this._observers = Tt();
  }
}
const Nn = Math.floor, Jr = Math.abs, xu = (s, e) => s < e ? s : e, Cs = (s, e) => s > e ? s : e, Cu = (s) => s !== 0 ? s < 0 : 1 / s < 0, Nc = 1, Dc = 2, ya = 4, ba = 8, qi = 32, an = 64, mt = 128, Do = 31, Ja = 63, is = 127, $p = 2147483647, Eu = Number.MAX_SAFE_INTEGER, zp = Number.isInteger || ((s) => typeof s == "number" && isFinite(s) && Nn(s) === s), Vp = (s) => s.toLowerCase(), Hp = /^\s*/g, Up = (s) => s.replace(Hp, ""), qp = /([A-Z])/g, Ic = (s, e) => Up(s.replace(qp, (t) => "".concat(e).concat(Vp(t)))), Gp = (s) => {
  const e = unescape(encodeURIComponent(s)), t = e.length, n = new Uint8Array(t);
  for (let i = 0; i < t; i++)
    n[i] = /** @type {number} */
    e.codePointAt(i);
  return n;
}, Gi = (
  /** @type {TextEncoder} */
  typeof TextEncoder < "u" ? new TextEncoder() : null
), Wp = (s) => Gi.encode(s), Jp = Gi ? Wp : Gp;
let Ni = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
Ni && Ni.decode(new Uint8Array()).length === 1 && (Ni = null);
let gr = class {
  constructor() {
    this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = [];
  }
};
const pr = () => new gr(), Yp = (s) => {
  let e = s.cpos;
  for (let t = 0; t < s.bufs.length; t++)
    e += s.bufs[t].length;
  return e;
}, Ot = (s) => {
  const e = new Uint8Array(Yp(s));
  let t = 0;
  for (let n = 0; n < s.bufs.length; n++) {
    const i = s.bufs[n];
    e.set(i, t), t += i.length;
  }
  return e.set(new Uint8Array(s.cbuf.buffer, 0, s.cpos), t), e;
}, Xp = (s, e) => {
  const t = s.cbuf.length;
  t - s.cpos < e && (s.bufs.push(new Uint8Array(s.cbuf.buffer, 0, s.cpos)), s.cbuf = new Uint8Array(Cs(t, e) * 2), s.cpos = 0);
}, Ve = (s, e) => {
  const t = s.cbuf.length;
  s.cpos === t && (s.bufs.push(s.cbuf), s.cbuf = new Uint8Array(t * 2), s.cpos = 0), s.cbuf[s.cpos++] = e;
}, Wi = Ve, te = (s, e) => {
  for (; e > is; )
    Ve(s, mt | is & e), e = Nn(e / 128);
  Ve(s, is & e);
}, Io = (s, e) => {
  const t = Cu(e);
  for (t && (e = -e), Ve(s, (e > Ja ? mt : 0) | (t ? an : 0) | Ja & e), e = Nn(e / 64); e > 0; )
    Ve(s, (e > is ? mt : 0) | is & e), e = Nn(e / 128);
}, Ya = new Uint8Array(3e4), Zp = Ya.length / 3, Kp = (s, e) => {
  if (e.length < Zp) {
    const t = Gi.encodeInto(e, Ya).written || 0;
    te(s, t);
    for (let n = 0; n < t; n++)
      Ve(s, Ya[n]);
  } else
    ft(s, Jp(e));
}, Qp = (s, e) => {
  const t = unescape(encodeURIComponent(e)), n = t.length;
  te(s, n);
  for (let i = 0; i < n; i++)
    Ve(
      s,
      /** @type {number} */
      t.codePointAt(i)
    );
}, rs = Gi && /** @type {any} */
Gi.encodeInto ? Kp : Qp, jo = (s, e) => {
  const t = s.cbuf.length, n = s.cpos, i = xu(t - n, e.length), r = e.length - i;
  s.cbuf.set(e.subarray(0, i), n), s.cpos += i, r > 0 && (s.bufs.push(s.cbuf), s.cbuf = new Uint8Array(Cs(t * 2, r)), s.cbuf.set(e.subarray(i)), s.cpos = r);
}, ft = (s, e) => {
  te(s, e.byteLength), jo(s, e);
}, Dl = (s, e) => {
  Xp(s, e);
  const t = new DataView(s.cbuf.buffer, s.cpos, e);
  return s.cpos += e, t;
}, e1 = (s, e) => Dl(s, 4).setFloat32(0, e, !1), t1 = (s, e) => Dl(s, 8).setFloat64(0, e, !1), n1 = (s, e) => (
  /** @type {any} */
  Dl(s, 8).setBigInt64(0, e, !1)
), jc = new DataView(new ArrayBuffer(4)), s1 = (s) => (jc.setFloat32(0, s), jc.getFloat32(0) === s), Ji = (s, e) => {
  switch (typeof e) {
    case "string":
      Ve(s, 119), rs(s, e);
      break;
    case "number":
      zp(e) && Jr(e) <= $p ? (Ve(s, 125), Io(s, e)) : s1(e) ? (Ve(s, 124), e1(s, e)) : (Ve(s, 123), t1(s, e));
      break;
    case "bigint":
      Ve(s, 122), n1(s, e);
      break;
    case "object":
      if (e === null)
        Ve(s, 126);
      else if (Wa(e)) {
        Ve(s, 117), te(s, e.length);
        for (let t = 0; t < e.length; t++)
          Ji(s, e[t]);
      } else if (e instanceof Uint8Array)
        Ve(s, 116), ft(s, e);
      else {
        Ve(s, 118);
        const t = Object.keys(e);
        te(s, t.length);
        for (let n = 0; n < t.length; n++) {
          const i = t[n];
          rs(s, i), Ji(s, e[i]);
        }
      }
      break;
    case "boolean":
      Ve(s, e ? 120 : 121);
      break;
    default:
      Ve(s, 127);
  }
};
class Rc extends gr {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(e) {
    super(), this.w = e, this.s = null, this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(e) {
    this.s === e ? this.count++ : (this.count > 0 && te(this, this.count - 1), this.count = 1, this.w(this, e), this.s = e);
  }
}
const Bc = (s) => {
  s.count > 0 && (Io(s.encoder, s.count === 1 ? s.s : -s.s), s.count > 1 && te(s.encoder, s.count - 2));
};
class Yr {
  constructor() {
    this.encoder = new gr(), this.s = 0, this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(e) {
    this.s === e ? this.count++ : (Bc(this), this.count = 1, this.s = e);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return Bc(this), Ot(this.encoder);
  }
}
const Fc = (s) => {
  if (s.count > 0) {
    const e = s.diff * 2 + (s.count === 1 ? 0 : 1);
    Io(s.encoder, e), s.count > 1 && te(s.encoder, s.count - 2);
  }
};
class va {
  constructor() {
    this.encoder = new gr(), this.s = 0, this.count = 0, this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(e) {
    this.diff === e - this.s ? (this.s = e, this.count++) : (Fc(this), this.count = 1, this.diff = e - this.s, this.s = e);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return Fc(this), Ot(this.encoder);
  }
}
class i1 {
  constructor() {
    this.sarr = [], this.s = "", this.lensE = new Yr();
  }
  /**
   * @param {string} string
   */
  write(e) {
    this.s += e, this.s.length > 19 && (this.sarr.push(this.s), this.s = ""), this.lensE.write(e.length);
  }
  toUint8Array() {
    const e = new gr();
    return this.sarr.push(this.s), this.s = "", rs(e, this.sarr.join("")), jo(e, this.lensE.toUint8Array()), Ot(e);
  }
}
const Dn = (s) => new Error(s), Gt = () => {
  throw Dn("Method unimplemented");
}, _t = () => {
  throw Dn("Unexpected case");
}, Su = Dn("Unexpected end of array"), Au = Dn("Integer out of Range");
let Ro = class {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(e) {
    this.arr = e, this.pos = 0;
  }
};
const Es = (s) => new Ro(s), Mu = (s) => s.pos !== s.arr.length, r1 = (s, e) => {
  const t = new Uint8Array(s.arr.buffer, s.pos + s.arr.byteOffset, e);
  return s.pos += e, t;
}, gt = (s) => r1(s, Q(s)), Us = (s) => s.arr[s.pos++], Q = (s) => {
  let e = 0, t = 1;
  const n = s.arr.length;
  for (; s.pos < n; ) {
    const i = s.arr[s.pos++];
    if (e = e + (i & is) * t, t *= 128, i < mt)
      return e;
    if (e > Eu)
      throw Au;
  }
  throw Su;
}, Bo = (s) => {
  let e = s.arr[s.pos++], t = e & Ja, n = 64;
  const i = (e & an) > 0 ? -1 : 1;
  if (!(e & mt))
    return i * t;
  const r = s.arr.length;
  for (; s.pos < r; ) {
    if (e = s.arr[s.pos++], t = t + (e & is) * n, n *= 128, e < mt)
      return i * t;
    if (t > Eu)
      throw Au;
  }
  throw Su;
}, o1 = (s) => {
  let e = Q(s);
  if (e === 0)
    return "";
  {
    let t = String.fromCodePoint(Us(s));
    if (--e < 100)
      for (; e--; )
        t += String.fromCodePoint(Us(s));
    else
      for (; e > 0; ) {
        const n = e < 1e4 ? e : 1e4, i = s.arr.subarray(s.pos, s.pos + n);
        s.pos += n, t += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          i
        ), e -= n;
      }
    return decodeURIComponent(escape(t));
  }
}, a1 = (s) => (
  /** @type any */
  Ni.decode(gt(s))
), os = Ni ? a1 : o1, Il = (s, e) => {
  const t = new DataView(s.arr.buffer, s.arr.byteOffset + s.pos, e);
  return s.pos += e, t;
}, l1 = (s) => Il(s, 4).getFloat32(0, !1), c1 = (s) => Il(s, 8).getFloat64(0, !1), h1 = (s) => (
  /** @type {any} */
  Il(s, 8).getBigInt64(0, !1)
), u1 = [
  (s) => {
  },
  // CASE 127: undefined
  (s) => null,
  // CASE 126: null
  Bo,
  // CASE 125: integer
  l1,
  // CASE 124: float32
  c1,
  // CASE 123: float64
  h1,
  // CASE 122: bigint
  (s) => !1,
  // CASE 121: boolean (false)
  (s) => !0,
  // CASE 120: boolean (true)
  os,
  // CASE 119: string
  (s) => {
    const e = Q(s), t = {};
    for (let n = 0; n < e; n++) {
      const i = os(s);
      t[i] = Yi(s);
    }
    return t;
  },
  (s) => {
    const e = Q(s), t = [];
    for (let n = 0; n < e; n++)
      t.push(Yi(s));
    return t;
  },
  gt
  // CASE 116: Uint8Array
], Yi = (s) => u1[127 - Us(s)](s);
class $c extends Ro {
  /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */
  constructor(e, t) {
    super(e), this.reader = t, this.s = null, this.count = 0;
  }
  read() {
    return this.count === 0 && (this.s = this.reader(this), Mu(this) ? this.count = Q(this) + 1 : this.count = -1), this.count--, /** @type {T} */
    this.s;
  }
}
class Xr extends Ro {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(e) {
    super(e), this.s = 0, this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = Bo(this);
      const e = Cu(this.s);
      this.count = 1, e && (this.s = -this.s, this.count = Q(this) + 2);
    }
    return this.count--, /** @type {number} */
    this.s;
  }
}
class xa extends Ro {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(e) {
    super(e), this.s = 0, this.count = 0, this.diff = 0;
  }
  /**
   * @return {number}
   */
  read() {
    if (this.count === 0) {
      const e = Bo(this), t = e & 1;
      this.diff = Nn(e / 2), this.count = 1, t && (this.count = Q(this) + 2);
    }
    return this.s += this.diff, this.count--, this.s;
  }
}
class d1 {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(e) {
    this.decoder = new Xr(e), this.str = os(this.decoder), this.spos = 0;
  }
  /**
   * @return {string}
   */
  read() {
    const e = this.spos + this.decoder.read(), t = this.str.slice(this.spos, e);
    return this.spos = e, t;
  }
}
const f1 = crypto.getRandomValues.bind(crypto), ku = () => f1(new Uint32Array(1))[0], g1 = [1e7] + -1e3 + -4e3 + -8e3 + -1e11, p1 = () => g1.replace(
  /[018]/g,
  /** @param {number} c */
  (s) => (s ^ ku() & 15 >> s / 4).toString(16)
), m1 = Date.now, zc = (s) => (
  /** @type {Promise<T>} */
  new Promise(s)
);
Promise.all.bind(Promise);
const Vc = (s) => s === void 0 ? null : s;
let w1 = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(e, t) {
    this.map.set(e, t);
  }
  /**
   * @param {string} key
   */
  getItem(e) {
    return this.map.get(e);
  }
}, Pu = new w1(), y1 = !0;
try {
  typeof localStorage < "u" && localStorage && (Pu = localStorage, y1 = !1);
} catch (s) {
}
const b1 = Pu, v1 = Object.assign, x1 = Object.keys, C1 = (s, e) => {
  for (const t in s)
    e(s[t], t);
}, Hc = (s) => x1(s).length, E1 = (s) => {
  for (const e in s)
    return !1;
  return !0;
}, S1 = (s, e) => {
  for (const t in s)
    if (!e(s[t], t))
      return !1;
  return !0;
}, A1 = (s, e) => Object.prototype.hasOwnProperty.call(s, e), M1 = (s, e) => s === e || Hc(s) === Hc(e) && S1(s, (t, n) => (t !== void 0 || A1(e, n)) && e[n] === t), jl = (s, e, t = 0) => {
  try {
    for (; t < s.length; t++)
      s[t](...e);
  } finally {
    t < s.length && jl(s, e, t + 1);
  }
}, k1 = (s) => s, P1 = (s, e) => e.includes(s), Xi = typeof process < "u" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]";
let Ht;
const _1 = () => {
  if (Ht === void 0)
    if (Xi) {
      Ht = Tt();
      const s = process.argv;
      let e = null;
      for (let t = 0; t < s.length; t++) {
        const n = s[t];
        n[0] === "-" ? (e !== null && Ht.set(e, ""), e = n) : e !== null && (Ht.set(e, n), e = null);
      }
      e !== null && Ht.set(e, "");
    } else
      typeof location == "object" ? (Ht = Tt(), (location.search || "?").slice(1).split("&").forEach((s) => {
        if (s.length !== 0) {
          const [e, t] = s.split("=");
          Ht.set("--".concat(Ic(e, "-")), t), Ht.set("-".concat(Ic(e, "-")), t);
        }
      })) : Ht = Tt();
  return Ht;
}, Xa = (s) => _1().has(s), Za = (s) => Vc(Xi ? process.env[s.toUpperCase().replaceAll("-", "_")] : b1.getItem(s)), _u = (s) => Xa("--" + s) || Za(s) !== null;
_u("production");
const O1 = Xi && P1(process.env.FORCE_COLOR, ["true", "1", "2"]), T1 = O1 || !Xa("--no-colors") && // @todo deprecate --no-colors
!_u("no-color") && (!Xi || process.stdout.isTTY) && (!Xi || Xa("--color") || Za("COLORTERM") !== null || (Za("TERM") || "").includes("color")), L1 = (s) => new Uint8Array(s), N1 = (s) => {
  const e = L1(s.byteLength);
  return e.set(s), e;
};
class D1 {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(e, t) {
    this.left = e, this.right = t;
  }
}
const Qt = (s, e) => new D1(s, e);
typeof DOMParser < "u" && new DOMParser();
const I1 = (s) => jp(s, (e, t) => "".concat(t, ":").concat(e, ";")).join(""), pn = Symbol, Ou = pn(), Tu = pn(), j1 = pn(), R1 = pn(), B1 = pn(), Lu = pn(), F1 = pn(), Rl = pn(), $1 = pn(), z1 = (s) => {
  var i;
  s.length === 1 && ((i = s[0]) == null ? void 0 : i.constructor) === Function && (s = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  s[0]());
  const e = [], t = [];
  let n = 0;
  for (; n < s.length; n++) {
    const r = s[n];
    if (r === void 0)
      break;
    if (r.constructor === String || r.constructor === Number)
      e.push(r);
    else if (r.constructor === Object)
      break;
  }
  for (n > 0 && t.push(e.join("")); n < s.length; n++) {
    const r = s[n];
    r instanceof Symbol || t.push(r);
  }
  return t;
}, V1 = {
  [Ou]: Qt("font-weight", "bold"),
  [Tu]: Qt("font-weight", "normal"),
  [j1]: Qt("color", "blue"),
  [B1]: Qt("color", "green"),
  [R1]: Qt("color", "grey"),
  [Lu]: Qt("color", "red"),
  [F1]: Qt("color", "purple"),
  [Rl]: Qt("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [$1]: Qt("color", "black")
}, H1 = (s) => {
  var o;
  s.length === 1 && ((o = s[0]) == null ? void 0 : o.constructor) === Function && (s = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  s[0]());
  const e = [], t = [], n = Tt();
  let i = [], r = 0;
  for (; r < s.length; r++) {
    const a = s[r], l = V1[a];
    if (l !== void 0)
      n.set(l.left, l.right);
    else {
      if (a === void 0)
        break;
      if (a.constructor === String || a.constructor === Number) {
        const c = I1(n);
        r > 0 || c.length > 0 ? (e.push("%c" + a), t.push(c)) : e.push(a);
      } else
        break;
    }
  }
  for (r > 0 && (i = t, i.unshift(e.join(""))); r < s.length; r++) {
    const a = s[r];
    a instanceof Symbol || i.push(a);
  }
  return i;
}, Nu = T1 ? H1 : z1, U1 = (...s) => {
  console.log(...Nu(s)), Du.forEach((e) => e.print(s));
}, q1 = (...s) => {
  console.warn(...Nu(s)), s.unshift(Rl), Du.forEach((e) => e.print(s));
}, Du = Hs(), Iu = (s) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next: s
}), G1 = (s, e) => Iu(() => {
  let t;
  do
    t = s.next();
  while (!t.done && !e(t.value));
  return t;
}), Ca = (s, e) => Iu(() => {
  const { done: t, value: n } = s.next();
  return { done: t, value: t ? void 0 : e(n) };
});
class Bl {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(e, t) {
    this.clock = e, this.len = t;
  }
}
class mi {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
}
const qs = (s, e, t) => e.clients.forEach((n, i) => {
  const r = (
    /** @type {Array<GC|Item>} */
    s.doc.store.clients.get(i)
  );
  for (let o = 0; o < n.length; o++) {
    const a = n[o];
    Zu(s, r, a.clock, a.len, t);
  }
}), W1 = (s, e) => {
  let t = 0, n = s.length - 1;
  for (; t <= n; ) {
    const i = Nn((t + n) / 2), r = s[i], o = r.clock;
    if (o <= e) {
      if (e < o + r.len)
        return i;
      t = i + 1;
    } else
      n = i - 1;
  }
  return null;
}, mr = (s, e) => {
  const t = s.clients.get(e.client);
  return t !== void 0 && W1(t, e.clock) !== null;
}, Fl = (s) => {
  s.clients.forEach((e) => {
    e.sort((i, r) => i.clock - r.clock);
    let t, n;
    for (t = 1, n = 1; t < e.length; t++) {
      const i = e[n - 1], r = e[t];
      i.clock + i.len >= r.clock ? i.len = Cs(i.len, r.clock + r.len - i.clock) : (n < t && (e[n] = r), n++);
    }
    e.length = n;
  });
}, Ka = (s) => {
  const e = new mi();
  for (let t = 0; t < s.length; t++)
    s[t].clients.forEach((n, i) => {
      if (!e.clients.has(i)) {
        const r = n.slice();
        for (let o = t + 1; o < s.length; o++)
          Bp(r, s[o].clients.get(i) || []);
        e.clients.set(i, r);
      }
    });
  return Fl(e), e;
}, Zi = (s, e, t, n) => {
  zn(s.clients, e, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new Bl(t, n));
}, J1 = () => new mi(), Y1 = (s) => {
  const e = J1();
  return s.clients.forEach((t, n) => {
    const i = [];
    for (let r = 0; r < t.length; r++) {
      const o = t[r];
      if (o.deleted) {
        const a = o.id.clock;
        let l = o.length;
        if (r + 1 < t.length)
          for (let c = t[r + 1]; r + 1 < t.length && c.deleted; c = t[++r + 1])
            l += c.length;
        i.push(new Bl(a, l));
      }
    }
    i.length > 0 && e.clients.set(n, i);
  }), e;
}, wi = (s, e) => {
  te(s.restEncoder, e.clients.size), Ln(e.clients.entries()).sort((t, n) => n[0] - t[0]).forEach(([t, n]) => {
    s.resetDsCurVal(), te(s.restEncoder, t);
    const i = n.length;
    te(s.restEncoder, i);
    for (let r = 0; r < i; r++) {
      const o = n[r];
      s.writeDsClock(o.clock), s.writeDsLen(o.len);
    }
  });
}, $l = (s) => {
  const e = new mi(), t = Q(s.restDecoder);
  for (let n = 0; n < t; n++) {
    s.resetDsCurVal();
    const i = Q(s.restDecoder), r = Q(s.restDecoder);
    if (r > 0) {
      const o = zn(e.clients, i, () => (
        /** @type {Array<DeleteItem>} */
        []
      ));
      for (let a = 0; a < r; a++)
        o.push(new Bl(s.readDsClock(), s.readDsLen()));
    }
  }
  return e;
}, Uc = (s, e, t) => {
  const n = new mi(), i = Q(s.restDecoder);
  for (let r = 0; r < i; r++) {
    s.resetDsCurVal();
    const o = Q(s.restDecoder), a = Q(s.restDecoder), l = t.clients.get(o) || [], c = _e(t, o);
    for (let u = 0; u < a; u++) {
      const d = s.readDsClock(), f = d + s.readDsLen();
      if (d < c) {
        c < f && Zi(n, o, c, f - c);
        let g = Jt(l, d), p = l[g];
        for (!p.deleted && p.id.clock < d && (l.splice(g + 1, 0, go(e, p, d - p.id.clock)), g++); g < l.length && (p = l[g++], p.id.clock < f); )
          p.deleted || (f < p.id.clock + p.length && l.splice(g, 0, go(e, p, f - p.id.clock)), p.delete(e));
      } else
        Zi(n, o, d, f - d);
    }
  }
  if (n.clients.size > 0) {
    const r = new us();
    return te(r.restEncoder, 0), wi(r, n), r.toUint8Array();
  }
  return null;
}, ju = ku;
class yi extends vu {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid: e = p1(), collectionid: t = null, gc: n = !0, gcFilter: i = () => !0, meta: r = null, autoLoad: o = !1, shouldLoad: a = !0 } = {}) {
    super(), this.gc = n, this.gcFilter = i, this.clientID = ju(), this.guid = e, this.collectionid = t, this.share = /* @__PURE__ */ new Map(), this.store = new Yu(), this._transaction = null, this._transactionCleanups = [], this.subdocs = /* @__PURE__ */ new Set(), this._item = null, this.shouldLoad = a, this.autoLoad = o, this.meta = r, this.isLoaded = !1, this.isSynced = !1, this.whenLoaded = zc((c) => {
      this.on("load", () => {
        this.isLoaded = !0, c(this);
      });
    });
    const l = () => zc((c) => {
      const u = (d) => {
        (d === void 0 || d === !0) && (this.off("sync", u), c());
      };
      this.on("sync", u);
    });
    this.on("sync", (c) => {
      c === !1 && this.isSynced && (this.whenSynced = l()), this.isSynced = c === void 0 || c === !0, this.isSynced && !this.isLoaded && this.emit("load", [this]);
    }), this.whenSynced = l();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const e = this._item;
    e !== null && !this.shouldLoad && he(
      /** @type {any} */
      e.parent.doc,
      (t) => {
        t.subdocsLoaded.add(this);
      },
      null,
      !0
    ), this.shouldLoad = !0;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(Ln(this.subdocs).map((e) => e.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(e, t = null) {
    return he(this, e, t);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
   *
   * After this method is called, the type is also available on `ydoc.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Y.Doc instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const ydoc = new Y.Doc(..)
   *   const appState = {
   *     document: ydoc.getText('document')
   *     comments: ydoc.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(e, t = (
    /** @type {any} */
    Ke
  )) {
    const n = zn(this.share, e, () => {
      const r = new t();
      return r._integrate(this, null), r;
    }), i = n.constructor;
    if (t !== Ke && i !== t)
      if (i === Ke) {
        const r = new t();
        r._map = n._map, n._map.forEach(
          /** @param {Item?} n */
          (o) => {
            for (; o !== null; o = o.left)
              o.parent = r;
          }
        ), r._start = n._start;
        for (let o = r._start; o !== null; o = o.right)
          o.parent = r;
        return r._length = n._length, this.share.set(e, r), r._integrate(this, null), /** @type {InstanceType<Type>} */
        r;
      } else
        throw new Error("Type with the name ".concat(e, " has already been defined with a different constructor"));
    return (
      /** @type {InstanceType<Type>} */
      n
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(e = "") {
    return (
      /** @type {YArray<T>} */
      this.get(e, Bs)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(e = "") {
    return this.get(e, Js);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(e = "") {
    return (
      /** @type {YMap<T>} */
      this.get(e, Ws)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(e = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(e, Ys)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(e = "") {
    return this.get(e, ds);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const e = {};
    return this.share.forEach((t, n) => {
      e[n] = t.toJSON();
    }), e;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    Ln(this.subdocs).forEach((t) => t.destroy());
    const e = this._item;
    if (e !== null) {
      this._item = null;
      const t = (
        /** @type {ContentDoc} */
        e.content
      );
      t.doc = new yi({ guid: this.guid, ...t.opts, shouldLoad: !1 }), t.doc._item = e, he(
        /** @type {any} */
        e.parent.doc,
        (n) => {
          const i = t.doc;
          e.deleted || n.subdocsAdded.add(i), n.subdocsRemoved.add(this);
        },
        null,
        !0
      );
    }
    this.emit("destroyed", [!0]), this.emit("destroy", [this]), super.destroy();
  }
}
class Ru {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(e) {
    this.restDecoder = e;
  }
  resetDsCurVal() {
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return Q(this.restDecoder);
  }
  /**
   * @return {number}
   */
  readDsLen() {
    return Q(this.restDecoder);
  }
}
class Bu extends Ru {
  /**
   * @return {ID}
   */
  readLeftID() {
    return K(Q(this.restDecoder), Q(this.restDecoder));
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return K(Q(this.restDecoder), Q(this.restDecoder));
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return Q(this.restDecoder);
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return Us(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readString() {
    return os(this.restDecoder);
  }
  /**
   * @return {boolean} isKey
   */
  readParentInfo() {
    return Q(this.restDecoder) === 1;
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readTypeRef() {
    return Q(this.restDecoder);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */
  readLen() {
    return Q(this.restDecoder);
  }
  /**
   * @return {any}
   */
  readAny() {
    return Yi(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return N1(gt(this.restDecoder));
  }
  /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */
  readJSON() {
    return JSON.parse(os(this.restDecoder));
  }
  /**
   * @return {string}
   */
  readKey() {
    return os(this.restDecoder);
  }
}
class X1 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(e) {
    this.dsCurrVal = 0, this.restDecoder = e;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return this.dsCurrVal += Q(this.restDecoder), this.dsCurrVal;
  }
  /**
   * @return {number}
   */
  readDsLen() {
    const e = Q(this.restDecoder) + 1;
    return this.dsCurrVal += e, e;
  }
}
class Gs extends X1 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(e) {
    super(e), this.keys = [], Q(e), this.keyClockDecoder = new xa(gt(e)), this.clientDecoder = new Xr(gt(e)), this.leftClockDecoder = new xa(gt(e)), this.rightClockDecoder = new xa(gt(e)), this.infoDecoder = new $c(gt(e), Us), this.stringDecoder = new d1(gt(e)), this.parentInfoDecoder = new $c(gt(e), Us), this.typeRefDecoder = new Xr(gt(e)), this.lenDecoder = new Xr(gt(e));
  }
  /**
   * @return {ID}
   */
  readLeftID() {
    return new js(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return new js(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return this.clientDecoder.read();
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return (
      /** @type {number} */
      this.infoDecoder.read()
    );
  }
  /**
   * @return {string}
   */
  readString() {
    return this.stringDecoder.read();
  }
  /**
   * @return {boolean}
   */
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  /**
   * @return {number} An unsigned 8-bit integer
   */
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */
  readLen() {
    return this.lenDecoder.read();
  }
  /**
   * @return {any}
   */
  readAny() {
    return Yi(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return gt(this.restDecoder);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */
  readJSON() {
    return Yi(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readKey() {
    const e = this.keyClockDecoder.read();
    if (e < this.keys.length)
      return this.keys[e];
    {
      const t = this.stringDecoder.read();
      return this.keys.push(t), t;
    }
  }
}
class Fu {
  constructor() {
    this.restEncoder = pr();
  }
  toUint8Array() {
    return Ot(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(e) {
    te(this.restEncoder, e);
  }
  /**
   * @param {number} len
   */
  writeDsLen(e) {
    te(this.restEncoder, e);
  }
}
class wr extends Fu {
  /**
   * @param {ID} id
   */
  writeLeftID(e) {
    te(this.restEncoder, e.client), te(this.restEncoder, e.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(e) {
    te(this.restEncoder, e.client), te(this.restEncoder, e.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(e) {
    te(this.restEncoder, e);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(e) {
    Wi(this.restEncoder, e);
  }
  /**
   * @param {string} s
   */
  writeString(e) {
    rs(this.restEncoder, e);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(e) {
    te(this.restEncoder, e ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(e) {
    te(this.restEncoder, e);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(e) {
    te(this.restEncoder, e);
  }
  /**
   * @param {any} any
   */
  writeAny(e) {
    Ji(this.restEncoder, e);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(e) {
    ft(this.restEncoder, e);
  }
  /**
   * @param {any} embed
   */
  writeJSON(e) {
    rs(this.restEncoder, JSON.stringify(e));
  }
  /**
   * @param {string} key
   */
  writeKey(e) {
    rs(this.restEncoder, e);
  }
}
class $u {
  constructor() {
    this.restEncoder = pr(), this.dsCurrVal = 0;
  }
  toUint8Array() {
    return Ot(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(e) {
    const t = e - this.dsCurrVal;
    this.dsCurrVal = e, te(this.restEncoder, t);
  }
  /**
   * @param {number} len
   */
  writeDsLen(e) {
    e === 0 && _t(), te(this.restEncoder, e - 1), this.dsCurrVal += e;
  }
}
class us extends $u {
  constructor() {
    super(), this.keyMap = /* @__PURE__ */ new Map(), this.keyClock = 0, this.keyClockEncoder = new va(), this.clientEncoder = new Yr(), this.leftClockEncoder = new va(), this.rightClockEncoder = new va(), this.infoEncoder = new Rc(Wi), this.stringEncoder = new i1(), this.parentInfoEncoder = new Rc(Wi), this.typeRefEncoder = new Yr(), this.lenEncoder = new Yr();
  }
  toUint8Array() {
    const e = pr();
    return te(e, 0), ft(e, this.keyClockEncoder.toUint8Array()), ft(e, this.clientEncoder.toUint8Array()), ft(e, this.leftClockEncoder.toUint8Array()), ft(e, this.rightClockEncoder.toUint8Array()), ft(e, Ot(this.infoEncoder)), ft(e, this.stringEncoder.toUint8Array()), ft(e, Ot(this.parentInfoEncoder)), ft(e, this.typeRefEncoder.toUint8Array()), ft(e, this.lenEncoder.toUint8Array()), jo(e, Ot(this.restEncoder)), Ot(e);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(e) {
    this.clientEncoder.write(e.client), this.leftClockEncoder.write(e.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(e) {
    this.clientEncoder.write(e.client), this.rightClockEncoder.write(e.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(e) {
    this.clientEncoder.write(e);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(e) {
    this.infoEncoder.write(e);
  }
  /**
   * @param {string} s
   */
  writeString(e) {
    this.stringEncoder.write(e);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(e) {
    this.parentInfoEncoder.write(e ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(e) {
    this.typeRefEncoder.write(e);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(e) {
    this.lenEncoder.write(e);
  }
  /**
   * @param {any} any
   */
  writeAny(e) {
    Ji(this.restEncoder, e);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(e) {
    ft(this.restEncoder, e);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(e) {
    Ji(this.restEncoder, e);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(e) {
    const t = this.keyMap.get(e);
    t === void 0 ? (this.keyClockEncoder.write(this.keyClock++), this.stringEncoder.write(e)) : this.keyClockEncoder.write(t);
  }
}
const Z1 = (s, e, t, n) => {
  n = Cs(n, e[0].id.clock);
  const i = Jt(e, n);
  te(s.restEncoder, e.length - i), s.writeClient(t), te(s.restEncoder, n);
  const r = e[i];
  r.write(s, n - r.id.clock);
  for (let o = i + 1; o < e.length; o++)
    e[o].write(s, 0);
}, zl = (s, e, t) => {
  const n = /* @__PURE__ */ new Map();
  t.forEach((i, r) => {
    _e(e, r) > i && n.set(r, i);
  }), Fo(e).forEach((i, r) => {
    t.has(r) || n.set(r, 0);
  }), te(s.restEncoder, n.size), Ln(n.entries()).sort((i, r) => r[0] - i[0]).forEach(([i, r]) => {
    Z1(
      s,
      /** @type {Array<GC|Item>} */
      e.clients.get(i),
      i,
      r
    );
  });
}, K1 = (s, e) => {
  const t = Tt(), n = Q(s.restDecoder);
  for (let i = 0; i < n; i++) {
    const r = Q(s.restDecoder), o = new Array(r), a = s.readClient();
    let l = Q(s.restDecoder);
    t.set(a, { i: 0, refs: o });
    for (let c = 0; c < r; c++) {
      const u = s.readInfo();
      switch (Do & u) {
        case 0: {
          const d = s.readLen();
          o[c] = new St(K(a, l), d), l += d;
          break;
        }
        case 10: {
          const d = Q(s.restDecoder);
          o[c] = new At(K(a, l), d), l += d;
          break;
        }
        default: {
          const d = (u & (an | mt)) === 0, f = new fe(
            K(a, l),
            null,
            // left
            (u & mt) === mt ? s.readLeftID() : null,
            // origin
            null,
            // right
            (u & an) === an ? s.readRightID() : null,
            // right origin
            d ? s.readParentInfo() ? e.get(s.readString()) : s.readLeftID() : null,
            // parent
            d && (u & qi) === qi ? s.readString() : null,
            // parentSub
            yd(s, u)
            // item content
          );
          o[c] = f, l += f.length;
        }
      }
    }
  }
  return t;
}, Q1 = (s, e, t) => {
  const n = [];
  let i = Ln(t.keys()).sort((g, p) => g - p);
  if (i.length === 0)
    return null;
  const r = () => {
    if (i.length === 0)
      return null;
    let g = (
      /** @type {{i:number,refs:Array<GC|Item>}} */
      t.get(i[i.length - 1])
    );
    for (; g.refs.length === g.i; )
      if (i.pop(), i.length > 0)
        g = /** @type {{i:number,refs:Array<GC|Item>}} */
        t.get(i[i.length - 1]);
      else
        return null;
    return g;
  };
  let o = r();
  if (o === null)
    return null;
  const a = new Yu(), l = /* @__PURE__ */ new Map(), c = (g, p) => {
    const m = l.get(g);
    (m == null || m > p) && l.set(g, p);
  };
  let u = (
    /** @type {any} */
    o.refs[
      /** @type {any} */
      o.i++
    ]
  );
  const d = /* @__PURE__ */ new Map(), f = () => {
    for (const g of n) {
      const p = g.id.client, m = t.get(p);
      m ? (m.i--, a.clients.set(p, m.refs.slice(m.i)), t.delete(p), m.i = 0, m.refs = []) : a.clients.set(p, [g]), i = i.filter((w) => w !== p);
    }
    n.length = 0;
  };
  for (; ; ) {
    if (u.constructor !== At) {
      const p = zn(d, u.id.client, () => _e(e, u.id.client)) - u.id.clock;
      if (p < 0)
        n.push(u), c(u.id.client, u.id.clock - 1), f();
      else {
        const m = u.getMissing(s, e);
        if (m !== null) {
          n.push(u);
          const w = t.get(
            /** @type {number} */
            m
          ) || { refs: [], i: 0 };
          if (w.refs.length === w.i)
            c(
              /** @type {number} */
              m,
              _e(e, m)
            ), f();
          else {
            u = w.refs[w.i++];
            continue;
          }
        } else
          (p === 0 || p < u.length) && (u.integrate(s, p), d.set(u.id.client, u.id.clock + u.length));
      }
    }
    if (n.length > 0)
      u = /** @type {GC|Item} */
      n.pop();
    else if (o !== null && o.i < o.refs.length)
      u = /** @type {GC|Item} */
      o.refs[o.i++];
    else {
      if (o = r(), o === null)
        break;
      u = /** @type {GC|Item} */
      o.refs[o.i++];
    }
  }
  if (a.clients.size > 0) {
    const g = new us();
    return zl(g, a, /* @__PURE__ */ new Map()), te(g.restEncoder, 0), { missing: l, update: g.toUint8Array() };
  }
  return null;
}, e0 = (s, e) => zl(s, e.doc.store, e.beforeState), t0 = (s, e, t, n = new Gs(s)) => he(e, (i) => {
  i.local = !1;
  let r = !1;
  const o = i.doc, a = o.store, l = K1(n, o), c = Q1(i, a, l), u = a.pendingStructs;
  if (u) {
    for (const [f, g] of u.missing)
      if (g < _e(a, f)) {
        r = !0;
        break;
      }
    if (c) {
      for (const [f, g] of c.missing) {
        const p = u.missing.get(f);
        (p == null || p > g) && u.missing.set(f, g);
      }
      u.update = lo([u.update, c.update]);
    }
  } else
    a.pendingStructs = c;
  const d = Uc(n, i, a);
  if (a.pendingDs) {
    const f = new Gs(Es(a.pendingDs));
    Q(f.restDecoder);
    const g = Uc(f, i, a);
    d && g ? a.pendingDs = lo([d, g]) : a.pendingDs = d || g;
  } else
    a.pendingDs = d;
  if (r) {
    const f = (
      /** @type {{update: Uint8Array}} */
      a.pendingStructs.update
    );
    a.pendingStructs = null, zu(i.doc, f);
  }
}, t, !1), zu = (s, e, t, n = Gs) => {
  const i = Es(e);
  t0(i, s, t, new n(i));
}, n0 = (s, e, t) => zu(s, e, t, Bu), s0 = (s, e, t = /* @__PURE__ */ new Map()) => {
  zl(s, e.store, t), wi(s, Y1(e.store));
}, i0 = (s, e = new Uint8Array([0]), t = new us()) => {
  const n = Vu(e);
  s0(t, s, n);
  const i = [t.toUint8Array()];
  if (s.store.pendingDs && i.push(s.store.pendingDs), s.store.pendingStructs && i.push(k0(s.store.pendingStructs.update, e)), i.length > 1) {
    if (t.constructor === wr)
      return A0(i.map((r, o) => o === 0 ? r : _0(r)));
    if (t.constructor === us)
      return lo(i);
  }
  return i[0];
}, r0 = (s, e) => i0(s, e, new wr()), o0 = (s) => {
  const e = /* @__PURE__ */ new Map(), t = Q(s.restDecoder);
  for (let n = 0; n < t; n++) {
    const i = Q(s.restDecoder), r = Q(s.restDecoder);
    e.set(i, r);
  }
  return e;
}, Vu = (s) => o0(new Ru(Es(s))), Hu = (s, e) => (te(s.restEncoder, e.size), Ln(e.entries()).sort((t, n) => n[0] - t[0]).forEach(([t, n]) => {
  te(s.restEncoder, t), te(s.restEncoder, n);
}), s), a0 = (s, e) => Hu(s, Fo(e.store)), l0 = (s, e = new $u()) => (s instanceof Map ? Hu(e, s) : a0(e, s), e.toUint8Array()), c0 = (s) => l0(s, new Fu());
class h0 {
  constructor() {
    this.l = [];
  }
}
const qc = () => new h0(), Gc = (s, e) => s.l.push(e), Wc = (s, e) => {
  const t = s.l, n = t.length;
  s.l = t.filter((i) => e !== i), n === s.l.length && console.error("[yjs] Tried to remove event handler that doesn't exist.");
}, Uu = (s, e, t) => jl(s.l, [e, t]);
class js {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(e, t) {
    this.client = e, this.clock = t;
  }
}
const Is = (s, e) => s === e || s !== null && e !== null && s.client === e.client && s.clock === e.clock, K = (s, e) => new js(s, e), Jc = (s, e) => {
  te(s, e.client), te(s, e.clock);
}, Yc = (s) => K(Q(s), Q(s)), qu = (s) => {
  for (const [e, t] of s.doc.share.entries())
    if (t === s)
      return e;
  throw _t();
}, ao = (s, e) => {
  for (; e !== null; ) {
    if (e.parent === s)
      return !0;
    e = /** @type {AbstractType<any>} */
    e.parent._item;
  }
  return !1;
};
class Vl {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(e, t, n, i = 0) {
    this.type = e, this.tname = t, this.item = n, this.assoc = i;
  }
}
const u0 = (s) => {
  var e;
  return new Vl(s.type == null ? null : K(s.type.client, s.type.clock), (e = s.tname) != null ? e : null, s.item == null ? null : K(s.item.client, s.item.clock), s.assoc == null ? 0 : s.assoc);
};
class d0 {
  /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */
  constructor(e, t, n = 0) {
    this.type = e, this.index = t, this.assoc = n;
  }
}
const f0 = (s, e, t = 0) => new d0(s, e, t), Ir = (s, e, t) => {
  let n = null, i = null;
  return s._item === null ? i = qu(s) : n = K(s._item.id.client, s._item.id.clock), new Vl(n, i, e, t);
}, Gu = (s, e, t = 0) => {
  let n = s._start;
  if (t < 0) {
    if (e === 0)
      return Ir(s, null, t);
    e--;
  }
  for (; n !== null; ) {
    if (!n.deleted && n.countable) {
      if (n.length > e)
        return Ir(s, K(n.id.client, n.id.clock + e), t);
      e -= n.length;
    }
    if (n.right === null && t < 0)
      return Ir(s, n.lastId, t);
    n = n.right;
  }
  return Ir(s, null, t);
}, g0 = (s, e) => {
  const { type: t, tname: n, item: i, assoc: r } = e;
  if (i !== null)
    te(s, 0), Jc(s, i);
  else if (n !== null)
    Wi(s, 1), rs(s, n);
  else if (t !== null)
    Wi(s, 2), Jc(s, t);
  else
    throw _t();
  return Io(s, r), s;
}, p0 = (s) => {
  const e = pr();
  return g0(e, s), Ot(e);
}, m0 = (s) => {
  let e = null, t = null, n = null;
  switch (Q(s)) {
    case 0:
      n = Yc(s);
      break;
    case 1:
      t = os(s);
      break;
    case 2:
      e = Yc(s);
  }
  const i = Mu(s) ? Bo(s) : 0;
  return new Vl(e, t, n, i);
}, Wu = (s) => m0(Es(s)), Ju = (s, e, t = !0) => {
  const n = e.store, i = s.item, r = s.type, o = s.tname, a = s.assoc;
  let l = null, c = 0;
  if (i !== null) {
    if (_e(n, i.client) <= i.clock)
      return null;
    const u = t ? nl(n, i) : { item: Rs(n, i), diff: 0 }, d = u.item;
    if (!(d instanceof fe))
      return null;
    if (l = /** @type {AbstractType<any>} */
    d.parent, l._item === null || !l._item.deleted) {
      c = d.deleted || !d.countable ? 0 : u.diff + (a >= 0 ? 0 : 1);
      let f = d.left;
      for (; f !== null; )
        !f.deleted && f.countable && (c += f.length), f = f.left;
    }
  } else {
    if (o !== null)
      l = e.get(o);
    else if (r !== null) {
      if (_e(n, r.client) <= r.clock)
        return null;
      const { item: u } = t ? nl(n, r) : { item: Rs(n, r) };
      if (u instanceof fe && u.content instanceof Kt)
        l = u.content.type;
      else
        return null;
    } else
      throw _t();
    a >= 0 ? c = l._length : c = 0;
  }
  return f0(l, c, s.assoc);
}, Xc = (s, e) => s === e || s !== null && e !== null && s.tname === e.tname && Is(s.item, e.item) && Is(s.type, e.type) && s.assoc === e.assoc, Ns = (s, e) => e === void 0 ? !s.deleted : e.sv.has(s.id.client) && (e.sv.get(s.id.client) || 0) > s.id.clock && !mr(e.ds, s.id), Qa = (s, e) => {
  const t = zn(s.meta, Qa, Hs), n = s.doc.store;
  t.has(e) || (e.sv.forEach((i, r) => {
    i < _e(n, r) && lt(s, K(r, i));
  }), qs(s, e.ds, (i) => {
  }), t.add(e));
};
class Yu {
  constructor() {
    this.clients = /* @__PURE__ */ new Map(), this.pendingStructs = null, this.pendingDs = null;
  }
}
const Fo = (s) => {
  const e = /* @__PURE__ */ new Map();
  return s.clients.forEach((t, n) => {
    const i = t[t.length - 1];
    e.set(n, i.id.clock + i.length);
  }), e;
}, _e = (s, e) => {
  const t = s.clients.get(e);
  if (t === void 0)
    return 0;
  const n = t[t.length - 1];
  return n.id.clock + n.length;
}, Xu = (s, e) => {
  let t = s.clients.get(e.id.client);
  if (t === void 0)
    t = [], s.clients.set(e.id.client, t);
  else {
    const n = t[t.length - 1];
    if (n.id.clock + n.length !== e.id.clock)
      throw _t();
  }
  t.push(e);
}, Jt = (s, e) => {
  let t = 0, n = s.length - 1, i = s[n], r = i.id.clock;
  if (r === e)
    return n;
  let o = Nn(e / (r + i.length - 1) * n);
  for (; t <= n; ) {
    if (i = s[o], r = i.id.clock, r <= e) {
      if (e < r + i.length)
        return o;
      t = o + 1;
    } else
      n = o - 1;
    o = Nn((t + n) / 2);
  }
  throw _t();
}, w0 = (s, e) => {
  const t = s.clients.get(e.client);
  return t[Jt(t, e.clock)];
}, Rs = (
  /** @type {function(StructStore,ID):Item} */
  w0
), el = (s, e, t) => {
  const n = Jt(e, t), i = e[n];
  return i.id.clock < t && i instanceof fe ? (e.splice(n + 1, 0, go(s, i, t - i.id.clock)), n + 1) : n;
}, lt = (s, e) => {
  const t = (
    /** @type {Array<Item>} */
    s.doc.store.clients.get(e.client)
  );
  return t[el(s, t, e.clock)];
}, Zc = (s, e, t) => {
  const n = e.clients.get(t.client), i = Jt(n, t.clock), r = n[i];
  return t.clock !== r.id.clock + r.length - 1 && r.constructor !== St && n.splice(i + 1, 0, go(s, r, t.clock - r.id.clock + 1)), r;
}, y0 = (s, e, t) => {
  const n = (
    /** @type {Array<GC|Item>} */
    s.clients.get(e.id.client)
  );
  n[Jt(n, e.id.clock)] = t;
}, Zu = (s, e, t, n, i) => {
  if (n === 0)
    return;
  const r = t + n;
  let o = el(s, e, t), a;
  do
    a = e[o++], r < a.id.clock + a.length && el(s, e, r), i(a);
  while (o < e.length && e[o].id.clock < r);
};
class b0 {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(e, t, n) {
    this.doc = e, this.deleteSet = new mi(), this.beforeState = Fo(e.store), this.afterState = /* @__PURE__ */ new Map(), this.changed = /* @__PURE__ */ new Map(), this.changedParentTypes = /* @__PURE__ */ new Map(), this._mergeStructs = [], this.origin = t, this.meta = /* @__PURE__ */ new Map(), this.local = n, this.subdocsAdded = /* @__PURE__ */ new Set(), this.subdocsRemoved = /* @__PURE__ */ new Set(), this.subdocsLoaded = /* @__PURE__ */ new Set(), this._needFormattingCleanup = !1;
  }
}
const Kc = (s, e) => e.deleteSet.clients.size === 0 && !Rp(e.afterState, (t, n) => e.beforeState.get(n) !== t) ? !1 : (Fl(e.deleteSet), e0(s, e), wi(s, e.deleteSet), !0), Qc = (s, e, t) => {
  const n = e._item;
  (n === null || n.id.clock < (s.beforeState.get(n.id.client) || 0) && !n.deleted) && zn(s.changed, e, Hs).add(t);
}, Zr = (s, e) => {
  let t = s[e], n = s[e - 1], i = e;
  for (; i > 0; t = n, n = s[--i - 1]) {
    if (n.deleted === t.deleted && n.constructor === t.constructor && n.mergeWith(t)) {
      t instanceof fe && t.parentSub !== null && /** @type {AbstractType<any>} */
      t.parent._map.get(t.parentSub) === t && t.parent._map.set(
        t.parentSub,
        /** @type {Item} */
        n
      );
      continue;
    }
    break;
  }
  const r = e - i;
  return r && s.splice(e + 1 - r, r), r;
}, v0 = (s, e, t) => {
  for (const [n, i] of s.clients.entries()) {
    const r = (
      /** @type {Array<GC|Item>} */
      e.clients.get(n)
    );
    for (let o = i.length - 1; o >= 0; o--) {
      const a = i[o], l = a.clock + a.len;
      for (let c = Jt(r, a.clock), u = r[c]; c < r.length && u.id.clock < l; u = r[++c]) {
        const d = r[c];
        if (a.clock + a.len <= d.id.clock)
          break;
        d instanceof fe && d.deleted && !d.keep && t(d) && d.gc(e, !1);
      }
    }
  }
}, x0 = (s, e) => {
  s.clients.forEach((t, n) => {
    const i = (
      /** @type {Array<GC|Item>} */
      e.clients.get(n)
    );
    for (let r = t.length - 1; r >= 0; r--) {
      const o = t[r], a = xu(i.length - 1, 1 + Jt(i, o.clock + o.len - 1));
      for (let l = a, c = i[l]; l > 0 && c.id.clock >= o.clock; c = i[l])
        l -= 1 + Zr(i, l);
    }
  });
}, Ku = (s, e) => {
  if (e < s.length) {
    const t = s[e], n = t.doc, i = n.store, r = t.deleteSet, o = t._mergeStructs;
    try {
      Fl(r), t.afterState = Fo(t.doc.store), n.emit("beforeObserverCalls", [t, n]);
      const a = [];
      t.changed.forEach(
        (l, c) => a.push(() => {
          (c._item === null || !c._item.deleted) && c._callObserver(t, l);
        })
      ), a.push(() => {
        t.changedParentTypes.forEach((l, c) => {
          c._dEH.l.length > 0 && (c._item === null || !c._item.deleted) && (l = l.filter(
            (u) => u.target._item === null || !u.target._item.deleted
          ), l.forEach((u) => {
            u.currentTarget = c, u._path = null;
          }), l.sort((u, d) => u.path.length - d.path.length), Uu(c._dEH, l, t));
        });
      }), a.push(() => n.emit("afterTransaction", [t, n])), jl(a, []), t._needFormattingCleanup && H0(t);
    } finally {
      n.gc && v0(r, i, n.gcFilter), x0(r, i), t.afterState.forEach((u, d) => {
        const f = t.beforeState.get(d) || 0;
        if (f !== u) {
          const g = (
            /** @type {Array<GC|Item>} */
            i.clients.get(d)
          ), p = Cs(Jt(g, f), 1);
          for (let m = g.length - 1; m >= p; )
            m -= 1 + Zr(g, m);
        }
      });
      for (let u = o.length - 1; u >= 0; u--) {
        const { client: d, clock: f } = o[u].id, g = (
          /** @type {Array<GC|Item>} */
          i.clients.get(d)
        ), p = Jt(g, f);
        p + 1 < g.length && Zr(g, p + 1) > 1 || p > 0 && Zr(g, p);
      }
      if (!t.local && t.afterState.get(n.clientID) !== t.beforeState.get(n.clientID) && (U1(Rl, Ou, "[yjs] ", Tu, Lu, "Changed the client-id because another client seems to be using it."), n.clientID = ju()), n.emit("afterTransactionCleanup", [t, n]), n._observers.has("update")) {
        const u = new wr();
        Kc(u, t) && n.emit("update", [u.toUint8Array(), t.origin, n, t]);
      }
      if (n._observers.has("updateV2")) {
        const u = new us();
        Kc(u, t) && n.emit("updateV2", [u.toUint8Array(), t.origin, n, t]);
      }
      const { subdocsAdded: a, subdocsLoaded: l, subdocsRemoved: c } = t;
      (a.size > 0 || c.size > 0 || l.size > 0) && (a.forEach((u) => {
        u.clientID = n.clientID, u.collectionid == null && (u.collectionid = n.collectionid), n.subdocs.add(u);
      }), c.forEach((u) => n.subdocs.delete(u)), n.emit("subdocs", [{ loaded: l, added: a, removed: c }, n, t]), c.forEach((u) => u.destroy())), s.length <= e + 1 ? (n._transactionCleanups = [], n.emit("afterAllTransactions", [n, s])) : Ku(s, e + 1);
    }
  }
}, he = (s, e, t = null, n = !0) => {
  const i = s._transactionCleanups;
  let r = !1, o = null;
  s._transaction === null && (r = !0, s._transaction = new b0(s, t, n), i.push(s._transaction), i.length === 1 && s.emit("beforeAllTransactions", [s]), s.emit("beforeTransaction", [s._transaction, s]));
  try {
    o = e(s._transaction);
  } finally {
    if (r) {
      const a = s._transaction === i[0];
      s._transaction = null, a && Ku(i, 0);
    }
  }
  return o;
};
class C0 {
  /**
   * @param {DeleteSet} deletions
   * @param {DeleteSet} insertions
   */
  constructor(e, t) {
    this.insertions = t, this.deletions = e, this.meta = /* @__PURE__ */ new Map();
  }
}
const eh = (s, e, t) => {
  qs(s, t.deletions, (n) => {
    n instanceof fe && e.scope.some((i) => ao(i, n)) && Xl(n, !1);
  });
}, th = (s, e, t) => {
  let n = null;
  const i = s.doc, r = s.scope;
  he(i, (a) => {
    for (; e.length > 0 && s.currStackItem === null; ) {
      const l = i.store, c = (
        /** @type {StackItem} */
        e.pop()
      ), u = /* @__PURE__ */ new Set(), d = [];
      let f = !1;
      qs(a, c.insertions, (g) => {
        if (g instanceof fe) {
          if (g.redone !== null) {
            let { item: p, diff: m } = nl(l, g.id);
            m > 0 && (p = lt(a, K(p.id.client, p.id.clock + m))), g = p;
          }
          !g.deleted && r.some((p) => ao(
            p,
            /** @type {Item} */
            g
          )) && d.push(g);
        }
      }), qs(a, c.deletions, (g) => {
        g instanceof fe && r.some((p) => ao(p, g)) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
        !mr(c.insertions, g.id) && u.add(g);
      }), u.forEach((g) => {
        f = wd(a, g, u, c.insertions, s.ignoreRemoteMapChanges, s) !== null || f;
      });
      for (let g = d.length - 1; g >= 0; g--) {
        const p = d[g];
        s.deleteFilter(p) && (p.delete(a), f = !0);
      }
      s.currStackItem = f ? c : null;
    }
    a.changed.forEach((l, c) => {
      l.has(null) && c._searchMarker && (c._searchMarker.length = 0);
    }), n = a;
  }, s);
  const o = s.currStackItem;
  if (o != null) {
    const a = n.changedParentTypes;
    s.emit("stack-item-popped", [{ stackItem: o, type: t, changedParentTypes: a, origin: s }, s]), s.currStackItem = null;
  }
  return o;
};
class E0 extends vu {
  /**
   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types
   * @param {UndoManagerOptions} options
   */
  constructor(e, {
    captureTimeout: t = 500,
    captureTransaction: n = (l) => !0,
    deleteFilter: i = () => !0,
    trackedOrigins: r = /* @__PURE__ */ new Set([null]),
    ignoreRemoteMapChanges: o = !1,
    doc: a = (
      /** @type {Doc} */
      Wa(e) ? e[0].doc : e.doc
    )
  } = {}) {
    super(), this.scope = [], this.doc = a, this.addToScope(e), this.deleteFilter = i, r.add(this), this.trackedOrigins = r, this.captureTransaction = n, this.undoStack = [], this.redoStack = [], this.undoing = !1, this.redoing = !1, this.currStackItem = null, this.lastChange = 0, this.ignoreRemoteMapChanges = o, this.captureTimeout = t, this.afterTransactionHandler = (l) => {
      if (!this.captureTransaction(l) || !this.scope.some((w) => l.changedParentTypes.has(w)) || !this.trackedOrigins.has(l.origin) && (!l.origin || !this.trackedOrigins.has(l.origin.constructor)))
        return;
      const c = this.undoing, u = this.redoing, d = c ? this.redoStack : this.undoStack;
      c ? this.stopCapturing() : u || this.clear(!1, !0);
      const f = new mi();
      l.afterState.forEach((w, v) => {
        const y = l.beforeState.get(v) || 0, b = w - y;
        b > 0 && Zi(f, v, y, b);
      });
      const g = m1();
      let p = !1;
      if (this.lastChange > 0 && g - this.lastChange < this.captureTimeout && d.length > 0 && !c && !u) {
        const w = d[d.length - 1];
        w.deletions = Ka([w.deletions, l.deleteSet]), w.insertions = Ka([w.insertions, f]);
      } else
        d.push(new C0(l.deleteSet, f)), p = !0;
      !c && !u && (this.lastChange = g), qs(
        l,
        l.deleteSet,
        /** @param {Item|GC} item */
        (w) => {
          w instanceof fe && this.scope.some((v) => ao(v, w)) && Xl(w, !0);
        }
      );
      const m = [{ stackItem: d[d.length - 1], origin: l.origin, type: c ? "redo" : "undo", changedParentTypes: l.changedParentTypes }, this];
      p ? this.emit("stack-item-added", m) : this.emit("stack-item-updated", m);
    }, this.doc.on("afterTransaction", this.afterTransactionHandler), this.doc.on("destroy", () => {
      this.destroy();
    });
  }
  /**
   * @param {Array<AbstractType<any>> | AbstractType<any>} ytypes
   */
  addToScope(e) {
    e = Wa(e) ? e : [e], e.forEach((t) => {
      this.scope.every((n) => n !== t) && (t.doc !== this.doc && q1("[yjs#509] Not same Y.Doc"), this.scope.push(t));
    });
  }
  /**
   * @param {any} origin
   */
  addTrackedOrigin(e) {
    this.trackedOrigins.add(e);
  }
  /**
   * @param {any} origin
   */
  removeTrackedOrigin(e) {
    this.trackedOrigins.delete(e);
  }
  clear(e = !0, t = !0) {
    (e && this.canUndo() || t && this.canRedo()) && this.doc.transact((n) => {
      e && (this.undoStack.forEach((i) => eh(n, this, i)), this.undoStack = []), t && (this.redoStack.forEach((i) => eh(n, this, i)), this.redoStack = []), this.emit("stack-cleared", [{ undoStackCleared: e, redoStackCleared: t }]);
    });
  }
  /**
   * UndoManager merges Undo-StackItem if they are created within time-gap
   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
   * StackItem won't be merged.
   *
   *
   * @example
   *     // without stopCapturing
   *     ytext.insert(0, 'a')
   *     ytext.insert(1, 'b')
   *     um.undo()
   *     ytext.toString() // => '' (note that 'ab' was removed)
   *     // with stopCapturing
   *     ytext.insert(0, 'a')
   *     um.stopCapturing()
   *     ytext.insert(0, 'b')
   *     um.undo()
   *     ytext.toString() // => 'a' (note that only 'b' was removed)
   *
   */
  stopCapturing() {
    this.lastChange = 0;
  }
  /**
   * Undo last changes on type.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  undo() {
    this.undoing = !0;
    let e;
    try {
      e = th(this, this.undoStack, "undo");
    } finally {
      this.undoing = !1;
    }
    return e;
  }
  /**
   * Redo last undo operation.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  redo() {
    this.redoing = !0;
    let e;
    try {
      e = th(this, this.redoStack, "redo");
    } finally {
      this.redoing = !1;
    }
    return e;
  }
  /**
   * Are undo steps available?
   *
   * @return {boolean} `true` if undo is possible
   */
  canUndo() {
    return this.undoStack.length > 0;
  }
  /**
   * Are redo steps available?
   *
   * @return {boolean} `true` if redo is possible
   */
  canRedo() {
    return this.redoStack.length > 0;
  }
  destroy() {
    this.trackedOrigins.delete(this), this.doc.off("afterTransaction", this.afterTransactionHandler), super.destroy();
  }
}
function* S0(s) {
  const e = Q(s.restDecoder);
  for (let t = 0; t < e; t++) {
    const n = Q(s.restDecoder), i = s.readClient();
    let r = Q(s.restDecoder);
    for (let o = 0; o < n; o++) {
      const a = s.readInfo();
      if (a === 10) {
        const l = Q(s.restDecoder);
        yield new At(K(i, r), l), r += l;
      } else if (Do & a) {
        const l = (a & (an | mt)) === 0, c = new fe(
          K(i, r),
          null,
          // left
          (a & mt) === mt ? s.readLeftID() : null,
          // origin
          null,
          // right
          (a & an) === an ? s.readRightID() : null,
          // right origin
          // @ts-ignore Force writing a string here.
          l ? s.readParentInfo() ? s.readString() : s.readLeftID() : null,
          // parent
          l && (a & qi) === qi ? s.readString() : null,
          // parentSub
          yd(s, a)
          // item content
        );
        yield c, r += c.length;
      } else {
        const l = s.readLen();
        yield new St(K(i, r), l), r += l;
      }
    }
  }
}
class Hl {
  /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */
  constructor(e, t) {
    this.gen = S0(e), this.curr = null, this.done = !1, this.filterSkips = t, this.next();
  }
  /**
   * @return {Item | GC | Skip |null}
   */
  next() {
    do
      this.curr = this.gen.next().value || null;
    while (this.filterSkips && this.curr !== null && this.curr.constructor === At);
    return this.curr;
  }
}
class Ul {
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  constructor(e) {
    this.currClient = 0, this.startClock = 0, this.written = 0, this.encoder = e, this.clientStructs = [];
  }
}
const A0 = (s) => lo(s, Bu, wr), M0 = (s, e) => {
  if (s.constructor === St) {
    const { client: t, clock: n } = s.id;
    return new St(K(t, n + e), s.length - e);
  } else if (s.constructor === At) {
    const { client: t, clock: n } = s.id;
    return new At(K(t, n + e), s.length - e);
  } else {
    const t = (
      /** @type {Item} */
      s
    ), { client: n, clock: i } = t.id;
    return new fe(
      K(n, i + e),
      null,
      K(n, i + e - 1),
      null,
      t.rightOrigin,
      t.parent,
      t.parentSub,
      t.content.splice(e)
    );
  }
}, lo = (s, e = Gs, t = us) => {
  if (s.length === 1)
    return s[0];
  const n = s.map((u) => new e(Es(u)));
  let i = n.map((u) => new Hl(u, !0)), r = null;
  const o = new t(), a = new Ul(o);
  for (; i = i.filter((f) => f.curr !== null), i.sort(
    /** @type {function(any,any):number} */
    (f, g) => {
      if (f.curr.id.client === g.curr.id.client) {
        const p = f.curr.id.clock - g.curr.id.clock;
        return p === 0 ? f.curr.constructor === g.curr.constructor ? 0 : f.curr.constructor === At ? 1 : -1 : p;
      } else
        return g.curr.id.client - f.curr.id.client;
    }
  ), i.length !== 0; ) {
    const u = i[0], d = (
      /** @type {Item | GC} */
      u.curr.id.client
    );
    if (r !== null) {
      let f = (
        /** @type {Item | GC | null} */
        u.curr
      ), g = !1;
      for (; f !== null && f.id.clock + f.length <= r.struct.id.clock + r.struct.length && f.id.client >= r.struct.id.client; )
        f = u.next(), g = !0;
      if (f === null || // current decoder is empty
      f.id.client !== d || // check whether there is another decoder that has has updates from `firstClient`
      g && f.id.clock > r.struct.id.clock + r.struct.length)
        continue;
      if (d !== r.struct.id.client)
        An(a, r.struct, r.offset), r = { struct: f, offset: 0 }, u.next();
      else if (r.struct.id.clock + r.struct.length < f.id.clock)
        if (r.struct.constructor === At)
          r.struct.length = f.id.clock + f.length - r.struct.id.clock;
        else {
          An(a, r.struct, r.offset);
          const p = f.id.clock - r.struct.id.clock - r.struct.length;
          r = { struct: new At(K(d, r.struct.id.clock + r.struct.length), p), offset: 0 };
        }
      else {
        const p = r.struct.id.clock + r.struct.length - f.id.clock;
        p > 0 && (r.struct.constructor === At ? r.struct.length -= p : f = M0(f, p)), r.struct.mergeWith(
          /** @type {any} */
          f
        ) || (An(a, r.struct, r.offset), r = { struct: f, offset: 0 }, u.next());
      }
    } else
      r = { struct: (
        /** @type {Item | GC} */
        u.curr
      ), offset: 0 }, u.next();
    for (let f = u.curr; f !== null && f.id.client === d && f.id.clock === r.struct.id.clock + r.struct.length && f.constructor !== At; f = u.next())
      An(a, r.struct, r.offset), r = { struct: f, offset: 0 };
  }
  r !== null && (An(a, r.struct, r.offset), r = null), ql(a);
  const l = n.map((u) => $l(u)), c = Ka(l);
  return wi(o, c), o.toUint8Array();
}, k0 = (s, e, t = Gs, n = us) => {
  const i = Vu(e), r = new n(), o = new Ul(r), a = new t(Es(s)), l = new Hl(a, !1);
  for (; l.curr; ) {
    const u = l.curr, d = u.id.client, f = i.get(d) || 0;
    if (l.curr.constructor === At) {
      l.next();
      continue;
    }
    if (u.id.clock + u.length > f)
      for (An(o, u, Cs(f - u.id.clock, 0)), l.next(); l.curr && l.curr.id.client === d; )
        An(o, l.curr, 0), l.next();
    else
      for (; l.curr && l.curr.id.client === d && l.curr.id.clock + l.curr.length <= f; )
        l.next();
  }
  ql(o);
  const c = $l(a);
  return wi(r, c), r.toUint8Array();
}, Qu = (s) => {
  s.written > 0 && (s.clientStructs.push({ written: s.written, restEncoder: Ot(s.encoder.restEncoder) }), s.encoder.restEncoder = pr(), s.written = 0);
}, An = (s, e, t) => {
  s.written > 0 && s.currClient !== e.id.client && Qu(s), s.written === 0 && (s.currClient = e.id.client, s.encoder.writeClient(e.id.client), te(s.encoder.restEncoder, e.id.clock + t)), e.write(s.encoder, t), s.written++;
}, ql = (s) => {
  Qu(s);
  const e = s.encoder.restEncoder;
  te(e, s.clientStructs.length);
  for (let t = 0; t < s.clientStructs.length; t++) {
    const n = s.clientStructs[t];
    te(e, n.written), jo(e, n.restEncoder);
  }
}, P0 = (s, e, t, n) => {
  const i = new t(Es(s)), r = new Hl(i, !1), o = new n(), a = new Ul(o);
  for (let c = r.curr; c !== null; c = r.next())
    An(a, e(c), 0);
  ql(a);
  const l = $l(i);
  return wi(o, l), o.toUint8Array();
}, _0 = (s) => P0(s, k1, Gs, wr), nh = "You must not compute changes after the event-handler fired.";
class $o {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(e, t) {
    this.target = e, this.currentTarget = e, this.transaction = t, this._changes = null, this._keys = null, this._delta = null, this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = O0(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(e) {
    return mr(this.transaction.deleteSet, e.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw Dn(nh);
      const e = /* @__PURE__ */ new Map(), t = this.target;
      /** @type Set<string|null> */
      this.transaction.changed.get(t).forEach((i) => {
        if (i !== null) {
          const r = (
            /** @type {Item} */
            t._map.get(i)
          );
          let o, a;
          if (this.adds(r)) {
            let l = r.left;
            for (; l !== null && this.adds(l); )
              l = l.left;
            if (this.deletes(r))
              if (l !== null && this.deletes(l))
                o = "delete", a = wa(l.content.getContent());
              else
                return;
            else
              l !== null && this.deletes(l) ? (o = "update", a = wa(l.content.getContent())) : (o = "add", a = void 0);
          } else if (this.deletes(r))
            o = "delete", a = wa(
              /** @type {Item} */
              r.content.getContent()
            );
          else
            return;
          e.set(i, { action: o, oldValue: a });
        }
      }), this._keys = e;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(e) {
    return e.id.clock >= (this.transaction.beforeState.get(e.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let e = this._changes;
    if (e === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw Dn(nh);
      const t = this.target, n = Hs(), i = Hs(), r = [];
      if (e = {
        added: n,
        deleted: i,
        delta: r,
        keys: this.keys
      }, /** @type Set<string|null> */
      this.transaction.changed.get(t).has(null)) {
        let a = null;
        const l = () => {
          a && r.push(a);
        };
        for (let c = t._start; c !== null; c = c.right)
          c.deleted ? this.deletes(c) && !this.adds(c) && ((a === null || a.delete === void 0) && (l(), a = { delete: 0 }), a.delete += c.length, i.add(c)) : this.adds(c) ? ((a === null || a.insert === void 0) && (l(), a = { insert: [] }), a.insert = a.insert.concat(c.content.getContent()), n.add(c)) : ((a === null || a.retain === void 0) && (l(), a = { retain: 0 }), a.retain += c.length);
        a !== null && a.retain === void 0 && l();
      }
      this._changes = e;
    }
    return (
      /** @type {any} */
      e
    );
  }
}
const O0 = (s, e) => {
  const t = [];
  for (; e._item !== null && e !== s; ) {
    if (e._item.parentSub !== null)
      t.unshift(e._item.parentSub);
    else {
      let n = 0, i = (
        /** @type {AbstractType<any>} */
        e._item.parent._start
      );
      for (; i !== e._item && i !== null; )
        !i.deleted && i.countable && (n += i.length), i = i.right;
      t.unshift(n);
    }
    e = /** @type {AbstractType<any>} */
    e._item.parent;
  }
  return t;
}, ed = 80;
let Gl = 0;
class T0 {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(e, t) {
    e.marker = !0, this.p = e, this.index = t, this.timestamp = Gl++;
  }
}
const L0 = (s) => {
  s.timestamp = Gl++;
}, td = (s, e, t) => {
  s.p.marker = !1, s.p = e, e.marker = !0, s.index = t, s.timestamp = Gl++;
}, N0 = (s, e, t) => {
  if (s.length >= ed) {
    const n = s.reduce((i, r) => i.timestamp < r.timestamp ? i : r);
    return td(n, e, t), n;
  } else {
    const n = new T0(e, t);
    return s.push(n), n;
  }
}, zo = (s, e) => {
  if (s._start === null || e === 0 || s._searchMarker === null)
    return null;
  const t = s._searchMarker.length === 0 ? null : s._searchMarker.reduce((r, o) => Jr(e - r.index) < Jr(e - o.index) ? r : o);
  let n = s._start, i = 0;
  for (t !== null && (n = t.p, i = t.index, L0(t)); n.right !== null && i < e; ) {
    if (!n.deleted && n.countable) {
      if (e < i + n.length)
        break;
      i += n.length;
    }
    n = n.right;
  }
  for (; n.left !== null && i > e; )
    n = n.left, !n.deleted && n.countable && (i -= n.length);
  for (; n.left !== null && n.left.id.client === n.id.client && n.left.id.clock + n.left.length === n.id.clock; )
    n = n.left, !n.deleted && n.countable && (i -= n.length);
  return t !== null && Jr(t.index - i) < /** @type {YText|YArray<any>} */
  n.parent.length / ed ? (td(t, n, i), t) : N0(s._searchMarker, n, i);
}, Ki = (s, e, t) => {
  for (let n = s.length - 1; n >= 0; n--) {
    const i = s[n];
    if (t > 0) {
      let r = i.p;
      for (r.marker = !1; r && (r.deleted || !r.countable); )
        r = r.left, r && !r.deleted && r.countable && (i.index -= r.length);
      if (r === null || r.marker === !0) {
        s.splice(n, 1);
        continue;
      }
      i.p = r, r.marker = !0;
    }
    (e < i.index || t > 0 && e === i.index) && (i.index = Cs(e, i.index + t));
  }
}, Vo = (s, e, t) => {
  const n = s, i = e.changedParentTypes;
  for (; zn(i, s, () => []).push(t), s._item !== null; )
    s = /** @type {AbstractType<any>} */
    s._item.parent;
  Uu(n._eH, t, e);
};
class Ke {
  constructor() {
    this._item = null, this._map = /* @__PURE__ */ new Map(), this._start = null, this.doc = null, this._length = 0, this._eH = qc(), this._dEH = qc(), this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(e, t) {
    this.doc = e, this._item = t;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw Gt();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw Gt();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(e) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let e = this._start;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, t) {
    !e.local && this._searchMarker && (this._searchMarker.length = 0);
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(e) {
    Gc(this._eH, e);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(e) {
    Gc(this._dEH, e);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(e) {
    Wc(this._eH, e);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(e) {
    Wc(this._dEH, e);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
}
const nd = (s, e, t) => {
  e < 0 && (e = s._length + e), t < 0 && (t = s._length + t);
  let n = t - e;
  const i = [];
  let r = s._start;
  for (; r !== null && n > 0; ) {
    if (r.countable && !r.deleted) {
      const o = r.content.getContent();
      if (o.length <= e)
        e -= o.length;
      else {
        for (let a = e; a < o.length && n > 0; a++)
          i.push(o[a]), n--;
        e = 0;
      }
    }
    r = r.right;
  }
  return i;
}, sd = (s) => {
  const e = [];
  let t = s._start;
  for (; t !== null; ) {
    if (t.countable && !t.deleted) {
      const n = t.content.getContent();
      for (let i = 0; i < n.length; i++)
        e.push(n[i]);
    }
    t = t.right;
  }
  return e;
}, Qi = (s, e) => {
  let t = 0, n = s._start;
  for (; n !== null; ) {
    if (n.countable && !n.deleted) {
      const i = n.content.getContent();
      for (let r = 0; r < i.length; r++)
        e(i[r], t++, s);
    }
    n = n.right;
  }
}, id = (s, e) => {
  const t = [];
  return Qi(s, (n, i) => {
    t.push(e(n, i, s));
  }), t;
}, D0 = (s) => {
  let e = s._start, t = null, n = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (t === null) {
        for (; e !== null && e.deleted; )
          e = e.right;
        if (e === null)
          return {
            done: !0,
            value: void 0
          };
        t = e.content.getContent(), n = 0, e = e.right;
      }
      const i = t[n++];
      return t.length <= n && (t = null), {
        done: !1,
        value: i
      };
    }
  };
}, rd = (s, e) => {
  const t = zo(s, e);
  let n = s._start;
  for (t !== null && (n = t.p, e -= t.index); n !== null; n = n.right)
    if (!n.deleted && n.countable) {
      if (e < n.length)
        return n.content.getContent()[e];
      e -= n.length;
    }
}, co = (s, e, t, n) => {
  let i = t;
  const r = s.doc, o = r.clientID, a = r.store, l = t === null ? e._start : t.right;
  let c = [];
  const u = () => {
    c.length > 0 && (i = new fe(K(o, _e(a, o)), i, i && i.lastId, l, l && l.id, e, null, new fs(c)), i.integrate(s, 0), c = []);
  };
  n.forEach((d) => {
    if (d === null)
      c.push(d);
    else
      switch (d.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          c.push(d);
          break;
        default:
          switch (u(), d.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              i = new fe(K(o, _e(a, o)), i, i && i.lastId, l, l && l.id, e, null, new yr(new Uint8Array(
                /** @type {Uint8Array} */
                d
              ))), i.integrate(s, 0);
              break;
            case yi:
              i = new fe(K(o, _e(a, o)), i, i && i.lastId, l, l && l.id, e, null, new br(
                /** @type {Doc} */
                d
              )), i.integrate(s, 0);
              break;
            default:
              if (d instanceof Ke)
                i = new fe(K(o, _e(a, o)), i, i && i.lastId, l, l && l.id, e, null, new Kt(d)), i.integrate(s, 0);
              else
                throw new Error("Unexpected content type in insert operation");
          }
      }
  }), u();
}, od = () => Dn("Length exceeded!"), ad = (s, e, t, n) => {
  if (t > e._length)
    throw od();
  if (t === 0)
    return e._searchMarker && Ki(e._searchMarker, t, n.length), co(s, e, null, n);
  const i = t, r = zo(e, t);
  let o = e._start;
  for (r !== null && (o = r.p, t -= r.index, t === 0 && (o = o.prev, t += o && o.countable && !o.deleted ? o.length : 0)); o !== null; o = o.right)
    if (!o.deleted && o.countable) {
      if (t <= o.length) {
        t < o.length && lt(s, K(o.id.client, o.id.clock + t));
        break;
      }
      t -= o.length;
    }
  return e._searchMarker && Ki(e._searchMarker, i, n.length), co(s, e, o, n);
}, I0 = (s, e, t) => {
  let i = (e._searchMarker || []).reduce((r, o) => o.index > r.index ? o : r, { index: 0, p: e._start }).p;
  if (i)
    for (; i.right; )
      i = i.right;
  return co(s, e, i, t);
}, ld = (s, e, t, n) => {
  if (n === 0)
    return;
  const i = t, r = n, o = zo(e, t);
  let a = e._start;
  for (o !== null && (a = o.p, t -= o.index); a !== null && t > 0; a = a.right)
    !a.deleted && a.countable && (t < a.length && lt(s, K(a.id.client, a.id.clock + t)), t -= a.length);
  for (; n > 0 && a !== null; )
    a.deleted || (n < a.length && lt(s, K(a.id.client, a.id.clock + n)), a.delete(s), n -= a.length), a = a.right;
  if (n > 0)
    throw od();
  e._searchMarker && Ki(
    e._searchMarker,
    i,
    -r + n
    /* in case we remove the above exception */
  );
}, ho = (s, e, t) => {
  const n = e._map.get(t);
  n !== void 0 && n.delete(s);
}, Wl = (s, e, t, n) => {
  const i = e._map.get(t) || null, r = s.doc, o = r.clientID;
  let a;
  if (n == null)
    a = new fs([n]);
  else
    switch (n.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        a = new fs([n]);
        break;
      case Uint8Array:
        a = new yr(
          /** @type {Uint8Array} */
          n
        );
        break;
      case yi:
        a = new br(
          /** @type {Doc} */
          n
        );
        break;
      default:
        if (n instanceof Ke)
          a = new Kt(n);
        else
          throw new Error("Unexpected content type");
    }
  new fe(K(o, _e(r.store, o)), i, i && i.lastId, null, null, e, t, a).integrate(s, 0);
}, Jl = (s, e) => {
  const t = s._map.get(e);
  return t !== void 0 && !t.deleted ? t.content.getContent()[t.length - 1] : void 0;
}, cd = (s) => {
  const e = {};
  return s._map.forEach((t, n) => {
    t.deleted || (e[n] = t.content.getContent()[t.length - 1]);
  }), e;
}, hd = (s, e) => {
  const t = s._map.get(e);
  return t !== void 0 && !t.deleted;
}, j0 = (s, e) => {
  const t = {};
  return s._map.forEach((n, i) => {
    let r = n;
    for (; r !== null && (!e.sv.has(r.id.client) || r.id.clock >= (e.sv.get(r.id.client) || 0)); )
      r = r.left;
    r !== null && Ns(r, e) && (t[i] = r.content.getContent()[r.length - 1]);
  }), t;
}, jr = (s) => G1(
  s.entries(),
  /** @param {any} entry */
  (e) => !e[1].deleted
);
class R0 extends $o {
}
class Bs extends Ke {
  constructor() {
    super(), this._prelimContent = [], this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(e) {
    const t = new Bs();
    return t.push(e), t;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, t) {
    super._integrate(e, t), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new Bs();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YArray<T>}
   */
  clone() {
    const e = new Bs();
    return e.insert(0, this.toArray().map(
      (t) => t instanceof Ke ? (
        /** @type {typeof el} */
        t.clone()
      ) : t
    )), e;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, t) {
    super._callObserver(e, t), Vo(this, e, new R0(this, e));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(e, t) {
    this.doc !== null ? he(this.doc, (n) => {
      ad(
        n,
        this,
        e,
        /** @type {any} */
        t
      );
    }) : this._prelimContent.splice(e, 0, ...t);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(e) {
    this.doc !== null ? he(this.doc, (t) => {
      I0(
        t,
        this,
        /** @type {any} */
        e
      );
    }) : this._prelimContent.push(...e);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<T>} content Array of content to prepend.
   */
  unshift(e) {
    this.insert(0, e);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(e, t = 1) {
    this.doc !== null ? he(this.doc, (n) => {
      ld(n, this, e, t);
    }) : this._prelimContent.splice(e, t);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(e) {
    return rd(this, e);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return sd(this);
  }
  /**
   * Returns a portion of this YArray into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(e = 0, t = this.length) {
    return nd(this, e, t);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((e) => e instanceof Ke ? e.toJSON() : e);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(e) {
    return id(
      this,
      /** @type {any} */
      e
    );
  }
  /**
   * Executes a provided function once on every element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    Qi(this, e);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return D0(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(om);
  }
}
const B0 = (s) => new Bs();
class F0 extends $o {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(e, t, n) {
    super(e, t), this.keysChanged = n;
  }
}
class Ws extends Ke {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(e) {
    super(), this._prelimContent = null, e === void 0 ? this._prelimContent = /* @__PURE__ */ new Map() : this._prelimContent = new Map(e);
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, t) {
    super._integrate(e, t), this._prelimContent.forEach((n, i) => {
      this.set(i, n);
    }), this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new Ws();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YMap<MapType>}
   */
  clone() {
    const e = new Ws();
    return this.forEach((t, n) => {
      e.set(n, t instanceof Ke ? (
        /** @type {typeof value} */
        t.clone()
      ) : t);
    }), e;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, t) {
    Vo(this, e, new F0(this, e, t));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    const e = {};
    return this._map.forEach((t, n) => {
      if (!t.deleted) {
        const i = t.content.getContent()[t.length - 1];
        e[n] = i instanceof Ke ? i.toJSON() : i;
      }
    }), e;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...jr(this._map)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return Ca(
      jr(this._map),
      /** @param {any} v */
      (e) => e[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return Ca(
      jr(this._map),
      /** @param {any} v */
      (e) => e[1].content.getContent()[e[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return Ca(
      jr(this._map),
      /** @param {any} v */
      (e) => (
        /** @type {any} */
        [e[0], e[1].content.getContent()[e[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    this._map.forEach((t, n) => {
      t.deleted || e(t.content.getContent()[t.length - 1], n, this);
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(e) {
    this.doc !== null ? he(this.doc, (t) => {
      ho(t, this, e);
    }) : this._prelimContent.delete(e);
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(e, t) {
    return this.doc !== null ? he(this.doc, (n) => {
      Wl(
        n,
        this,
        e,
        /** @type {any} */
        t
      );
    }) : this._prelimContent.set(e, t), t;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(e) {
    return (
      /** @type {any} */
      Jl(this, e)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(e) {
    return hd(this, e);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    this.doc !== null ? he(this.doc, (e) => {
      this.forEach(function(t, n, i) {
        ho(e, i, n);
      });
    }) : this._prelimContent.clear();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(am);
  }
}
const $0 = (s) => new Ws(), kn = (s, e) => s === e || typeof s == "object" && typeof e == "object" && s && e && M1(s, e);
class tl {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(e, t, n, i) {
    this.left = e, this.right = t, this.index = n, this.currentAttributes = i;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    switch (this.right === null && _t(), this.right.content.constructor) {
      case Fe:
        this.right.deleted || bi(
          this.currentAttributes,
          /** @type {ContentFormat} */
          this.right.content
        );
        break;
      default:
        this.right.deleted || (this.index += this.right.length);
        break;
    }
    this.left = this.right, this.right = this.right.right;
  }
}
const sh = (s, e, t) => {
  for (; e.right !== null && t > 0; ) {
    switch (e.right.content.constructor) {
      case Fe:
        e.right.deleted || bi(
          e.currentAttributes,
          /** @type {ContentFormat} */
          e.right.content
        );
        break;
      default:
        e.right.deleted || (t < e.right.length && lt(s, K(e.right.id.client, e.right.id.clock + t)), e.index += e.right.length, t -= e.right.length);
        break;
    }
    e.left = e.right, e.right = e.right.right;
  }
  return e;
}, Rr = (s, e, t, n) => {
  const i = /* @__PURE__ */ new Map(), r = n ? zo(e, t) : null;
  if (r) {
    const o = new tl(r.p.left, r.p, r.index, i);
    return sh(s, o, t - r.index);
  } else {
    const o = new tl(null, e._start, 0, i);
    return sh(s, o, t);
  }
}, ud = (s, e, t, n) => {
  for (; t.right !== null && (t.right.deleted === !0 || t.right.content.constructor === Fe && kn(
    n.get(
      /** @type {ContentFormat} */
      t.right.content.key
    ),
    /** @type {ContentFormat} */
    t.right.content.value
  )); )
    t.right.deleted || n.delete(
      /** @type {ContentFormat} */
      t.right.content.key
    ), t.forward();
  const i = s.doc, r = i.clientID;
  n.forEach((o, a) => {
    const l = t.left, c = t.right, u = new fe(K(r, _e(i.store, r)), l, l && l.lastId, c, c && c.id, e, null, new Fe(a, o));
    u.integrate(s, 0), t.right = u, t.forward();
  });
}, bi = (s, e) => {
  const { key: t, value: n } = e;
  n === null ? s.delete(t) : s.set(t, n);
}, dd = (s, e) => {
  var t;
  for (; s.right !== null; ) {
    if (!(s.right.deleted || s.right.content.constructor === Fe && kn(
      (t = e[
        /** @type {ContentFormat} */
        s.right.content.key
      ]) != null ? t : null,
      /** @type {ContentFormat} */
      s.right.content.value
    )))
      break;
    s.forward();
  }
}, fd = (s, e, t, n) => {
  var a;
  const i = s.doc, r = i.clientID, o = /* @__PURE__ */ new Map();
  for (const l in n) {
    const c = n[l], u = (a = t.currentAttributes.get(l)) != null ? a : null;
    if (!kn(u, c)) {
      o.set(l, u);
      const { left: d, right: f } = t;
      t.right = new fe(K(r, _e(i.store, r)), d, d && d.lastId, f, f && f.id, e, null, new Fe(l, c)), t.right.integrate(s, 0), t.forward();
    }
  }
  return o;
}, Ea = (s, e, t, n, i) => {
  t.currentAttributes.forEach((f, g) => {
    i[g] === void 0 && (i[g] = null);
  });
  const r = s.doc, o = r.clientID;
  dd(t, i);
  const a = fd(s, e, t, i), l = n.constructor === String ? new Yt(
    /** @type {string} */
    n
  ) : n instanceof Ke ? new Kt(n) : new Ss(n);
  let { left: c, right: u, index: d } = t;
  e._searchMarker && Ki(e._searchMarker, t.index, l.getLength()), u = new fe(K(o, _e(r.store, o)), c, c && c.lastId, u, u && u.id, e, null, l), u.integrate(s, 0), t.right = u, t.index = d, t.forward(), ud(s, e, t, a);
}, ih = (s, e, t, n, i) => {
  const r = s.doc, o = r.clientID;
  dd(t, i);
  const a = fd(s, e, t, i);
  e:
    for (; t.right !== null && (n > 0 || a.size > 0 && (t.right.deleted || t.right.content.constructor === Fe)); ) {
      if (!t.right.deleted)
        switch (t.right.content.constructor) {
          case Fe: {
            const { key: l, value: c } = (
              /** @type {ContentFormat} */
              t.right.content
            ), u = i[l];
            if (u !== void 0) {
              if (kn(u, c))
                a.delete(l);
              else {
                if (n === 0)
                  break e;
                a.set(l, c);
              }
              t.right.delete(s);
            } else
              t.currentAttributes.set(l, c);
            break;
          }
          default:
            n < t.right.length && lt(s, K(t.right.id.client, t.right.id.clock + n)), n -= t.right.length;
            break;
        }
      t.forward();
    }
  if (n > 0) {
    let l = "";
    for (; n > 0; n--)
      l += "\n";
    t.right = new fe(K(o, _e(r.store, o)), t.left, t.left && t.left.lastId, t.right, t.right && t.right.id, e, null, new Yt(l)), t.right.integrate(s, 0), t.forward();
  }
  ud(s, e, t, a);
}, gd = (s, e, t, n, i) => {
  var c, u;
  let r = e;
  const o = Tt();
  for (; r && (!r.countable || r.deleted); ) {
    if (!r.deleted && r.content.constructor === Fe) {
      const d = (
        /** @type {ContentFormat} */
        r.content
      );
      o.set(d.key, d);
    }
    r = r.right;
  }
  let a = 0, l = !1;
  for (; e !== r; ) {
    if (t === e && (l = !0), !e.deleted) {
      const d = e.content;
      switch (d.constructor) {
        case Fe: {
          const { key: f, value: g } = (
            /** @type {ContentFormat} */
            d
          ), p = (c = n.get(f)) != null ? c : null;
          (o.get(f) !== d || p === g) && (e.delete(s), a++, !l && ((u = i.get(f)) != null ? u : null) === g && p !== g && (p === null ? i.delete(f) : i.set(f, p))), !l && !e.deleted && bi(
            i,
            /** @type {ContentFormat} */
            d
          );
          break;
        }
      }
    }
    e = /** @type {Item} */
    e.right;
  }
  return a;
}, z0 = (s, e) => {
  for (; e && e.right && (e.right.deleted || !e.right.countable); )
    e = e.right;
  const t = /* @__PURE__ */ new Set();
  for (; e && (e.deleted || !e.countable); ) {
    if (!e.deleted && e.content.constructor === Fe) {
      const n = (
        /** @type {ContentFormat} */
        e.content.key
      );
      t.has(n) ? e.delete(s) : t.add(n);
    }
    e = e.left;
  }
}, V0 = (s) => {
  let e = 0;
  return he(
    /** @type {Doc} */
    s.doc,
    (t) => {
      let n = (
        /** @type {Item} */
        s._start
      ), i = s._start, r = Tt();
      const o = Ga(r);
      for (; i; ) {
        if (i.deleted === !1)
          switch (i.content.constructor) {
            case Fe:
              bi(
                o,
                /** @type {ContentFormat} */
                i.content
              );
              break;
            default:
              e += gd(t, n, i, r, o), r = Ga(o), n = i;
              break;
          }
        i = i.right;
      }
    }
  ), e;
}, H0 = (s) => {
  const e = /* @__PURE__ */ new Set(), t = s.doc;
  for (const [n, i] of s.afterState.entries()) {
    const r = s.beforeState.get(n) || 0;
    i !== r && Zu(
      s,
      /** @type {Array<Item|GC>} */
      t.store.clients.get(n),
      r,
      i,
      (o) => {
        !o.deleted && /** @type {Item} */
        o.content.constructor === Fe && o.constructor !== St && e.add(
          /** @type {any} */
          o.parent
        );
      }
    );
  }
  he(t, (n) => {
    qs(s, s.deleteSet, (i) => {
      if (i instanceof St || !/** @type {YText} */
      i.parent._hasFormatting || e.has(
        /** @type {YText} */
        i.parent
      ))
        return;
      const r = (
        /** @type {YText} */
        i.parent
      );
      i.content.constructor === Fe ? e.add(r) : z0(n, i);
    });
    for (const i of e)
      V0(i);
  });
}, rh = (s, e, t) => {
  const n = t, i = Ga(e.currentAttributes), r = e.right;
  for (; t > 0 && e.right !== null; ) {
    if (e.right.deleted === !1)
      switch (e.right.content.constructor) {
        case Kt:
        case Ss:
        case Yt:
          t < e.right.length && lt(s, K(e.right.id.client, e.right.id.clock + t)), t -= e.right.length, e.right.delete(s);
          break;
      }
    e.forward();
  }
  r && gd(s, r, e.right, i, e.currentAttributes);
  const o = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (e.left || e.right).parent
  );
  return o._searchMarker && Ki(o._searchMarker, e.index, -n + t), e;
};
class pd extends $o {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(e, t, n) {
    super(e, t), this.childListChanged = !1, this.keysChanged = /* @__PURE__ */ new Set(), n.forEach((i) => {
      i === null ? this.childListChanged = !0 : this.keysChanged.add(i);
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const e = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = e;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const e = (
        /** @type {Doc} */
        this.target.doc
      ), t = [];
      he(e, (n) => {
        var g, p, m;
        const i = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
        let o = this.target._start, a = null;
        const l = {};
        let c = "", u = 0, d = 0;
        const f = () => {
          if (a !== null) {
            let w = null;
            switch (a) {
              case "delete":
                d > 0 && (w = { delete: d }), d = 0;
                break;
              case "insert":
                (typeof c == "object" || c.length > 0) && (w = { insert: c }, i.size > 0 && (w.attributes = {}, i.forEach((v, y) => {
                  v !== null && (w.attributes[y] = v);
                }))), c = "";
                break;
              case "retain":
                u > 0 && (w = { retain: u }, E1(l) || (w.attributes = v1({}, l))), u = 0;
                break;
            }
            w && t.push(w), a = null;
          }
        };
        for (; o !== null; ) {
          switch (o.content.constructor) {
            case Kt:
            case Ss:
              this.adds(o) ? this.deletes(o) || (f(), a = "insert", c = o.content.getContent()[0], f()) : this.deletes(o) ? (a !== "delete" && (f(), a = "delete"), d += 1) : o.deleted || (a !== "retain" && (f(), a = "retain"), u += 1);
              break;
            case Yt:
              this.adds(o) ? this.deletes(o) || (a !== "insert" && (f(), a = "insert"), c += /** @type {ContentString} */
              o.content.str) : this.deletes(o) ? (a !== "delete" && (f(), a = "delete"), d += o.length) : o.deleted || (a !== "retain" && (f(), a = "retain"), u += o.length);
              break;
            case Fe: {
              const { key: w, value: v } = (
                /** @type {ContentFormat} */
                o.content
              );
              if (this.adds(o)) {
                if (!this.deletes(o)) {
                  const y = (g = i.get(w)) != null ? g : null;
                  kn(y, v) ? v !== null && o.delete(n) : (a === "retain" && f(), kn(v, (p = r.get(w)) != null ? p : null) ? delete l[w] : l[w] = v);
                }
              } else if (this.deletes(o)) {
                r.set(w, v);
                const y = (m = i.get(w)) != null ? m : null;
                kn(y, v) || (a === "retain" && f(), l[w] = y);
              } else if (!o.deleted) {
                r.set(w, v);
                const y = l[w];
                y !== void 0 && (kn(y, v) ? y !== null && o.delete(n) : (a === "retain" && f(), v === null ? delete l[w] : l[w] = v));
              }
              o.deleted || (a === "insert" && f(), bi(
                i,
                /** @type {ContentFormat} */
                o.content
              ));
              break;
            }
          }
          o = o.right;
        }
        for (f(); t.length > 0; ) {
          const w = t[t.length - 1];
          if (w.retain !== void 0 && w.attributes === void 0)
            t.pop();
          else
            break;
        }
      }), this._delta = t;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
}
class Js extends Ke {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(e) {
    super(), this._pending = e !== void 0 ? [() => this.insert(0, e)] : [], this._searchMarker = [], this._hasFormatting = !1;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(e, t) {
    super._integrate(e, t);
    try {
      this._pending.forEach((n) => n());
    } catch (n) {
      console.error(n);
    }
    this._pending = null;
  }
  _copy() {
    return new Js();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YText}
   */
  clone() {
    const e = new Js();
    return e.applyDelta(this.toDelta()), e;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, t) {
    super._callObserver(e, t);
    const n = new pd(this, e, t);
    Vo(this, e, n), !e.local && this._hasFormatting && (e._needFormattingCleanup = !0);
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    let e = "", t = this._start;
    for (; t !== null; )
      !t.deleted && t.countable && t.content.constructor === Yt && (e += /** @type {ContentString} */
      t.content.str), t = t.right;
    return e;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {any} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(e, { sanitize: t = !0 } = {}) {
    this.doc !== null ? he(this.doc, (n) => {
      const i = new tl(null, this._start, 0, /* @__PURE__ */ new Map());
      for (let r = 0; r < e.length; r++) {
        const o = e[r];
        if (o.insert !== void 0) {
          const a = !t && typeof o.insert == "string" && r === e.length - 1 && i.right === null && o.insert.slice(-1) === "\n" ? o.insert.slice(0, -1) : o.insert;
          (typeof a != "string" || a.length > 0) && Ea(n, this, i, a, o.attributes || {});
        } else
          o.retain !== void 0 ? ih(n, this, i, o.retain, o.attributes || {}) : o.delete !== void 0 && rh(n, i, o.delete);
      }
    }) : this._pending.push(() => this.applyDelta(e));
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(e, t, n) {
    const i = [], r = /* @__PURE__ */ new Map(), o = (
      /** @type {Doc} */
      this.doc
    );
    let a = "", l = this._start;
    function c() {
      if (a.length > 0) {
        const d = {};
        let f = !1;
        r.forEach((p, m) => {
          f = !0, d[m] = p;
        });
        const g = { insert: a };
        f && (g.attributes = d), i.push(g), a = "";
      }
    }
    const u = () => {
      for (; l !== null; ) {
        if (Ns(l, e) || t !== void 0 && Ns(l, t))
          switch (l.content.constructor) {
            case Yt: {
              const d = r.get("ychange");
              e !== void 0 && !Ns(l, e) ? (d === void 0 || d.user !== l.id.client || d.type !== "removed") && (c(), r.set("ychange", n ? n("removed", l.id) : { type: "removed" })) : t !== void 0 && !Ns(l, t) ? (d === void 0 || d.user !== l.id.client || d.type !== "added") && (c(), r.set("ychange", n ? n("added", l.id) : { type: "added" })) : d !== void 0 && (c(), r.delete("ychange")), a += /** @type {ContentString} */
              l.content.str;
              break;
            }
            case Kt:
            case Ss: {
              c();
              const d = {
                insert: l.content.getContent()[0]
              };
              if (r.size > 0) {
                const f = (
                  /** @type {Object<string,any>} */
                  {}
                );
                d.attributes = f, r.forEach((g, p) => {
                  f[p] = g;
                });
              }
              i.push(d);
              break;
            }
            case Fe:
              Ns(l, e) && (c(), bi(
                r,
                /** @type {ContentFormat} */
                l.content
              ));
              break;
          }
        l = l.right;
      }
      c();
    };
    return e || t ? he(o, (d) => {
      e && Qa(d, e), t && Qa(d, t), u();
    }, "cleanup") : u(), i;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(e, t, n) {
    if (t.length <= 0)
      return;
    const i = this.doc;
    i !== null ? he(i, (r) => {
      const o = Rr(r, this, e, !n);
      n || (n = {}, o.currentAttributes.forEach((a, l) => {
        n[l] = a;
      })), Ea(r, this, o, t, n);
    }) : this._pending.push(() => this.insert(e, t, n));
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(e, t, n) {
    const i = this.doc;
    i !== null ? he(i, (r) => {
      const o = Rr(r, this, e, !n);
      Ea(r, this, o, t, n || {});
    }) : this._pending.push(() => this.insertEmbed(e, t, n || {}));
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(e, t) {
    if (t === 0)
      return;
    const n = this.doc;
    n !== null ? he(n, (i) => {
      rh(i, Rr(i, this, e, !0), t);
    }) : this._pending.push(() => this.delete(e, t));
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(e, t, n) {
    if (t === 0)
      return;
    const i = this.doc;
    i !== null ? he(i, (r) => {
      const o = Rr(r, this, e, !1);
      o.right !== null && ih(r, this, o, t, n);
    }) : this._pending.push(() => this.format(e, t, n));
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(e) {
    this.doc !== null ? he(this.doc, (t) => {
      ho(t, this, e);
    }) : this._pending.push(() => this.removeAttribute(e));
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(e, t) {
    this.doc !== null ? he(this.doc, (n) => {
      Wl(n, this, e, t);
    }) : this._pending.push(() => this.setAttribute(e, t));
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(e) {
    return (
      /** @type {any} */
      Jl(this, e)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return cd(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(lm);
  }
}
const U0 = (s) => new Js();
class Sa {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(e, t = () => !0) {
    this._filter = t, this._root = e, this._currentNode = /** @type {Item} */
    e._start, this._firstCall = !0;
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let e = this._currentNode, t = e && e.content && /** @type {any} */
    e.content.type;
    if (e !== null && (!this._firstCall || e.deleted || !this._filter(t)))
      do
        if (t = /** @type {any} */
        e.content.type, !e.deleted && (t.constructor === Ys || t.constructor === ds) && t._start !== null)
          e = t._start;
        else
          for (; e !== null; )
            if (e.right !== null) {
              e = e.right;
              break;
            } else
              e.parent === this._root ? e = null : e = /** @type {AbstractType<any>} */
              e.parent._item;
      while (e !== null && (e.deleted || !this._filter(
        /** @type {ContentType} */
        e.content.type
      )));
    return this._firstCall = !1, e === null ? { value: void 0, done: !0 } : (this._currentNode = e, { value: (
      /** @type {any} */
      e.content.type
    ), done: !1 });
  }
}
class ds extends Ke {
  constructor() {
    super(), this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const e = this._first;
    return e ? e.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, t) {
    super._integrate(e, t), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  _copy() {
    return new ds();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlFragment}
   */
  clone() {
    const e = new ds();
    return e.insert(0, this.toArray().map((t) => t instanceof Ke ? t.clone() : t)), e;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(e) {
    return new Sa(this, e);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(e) {
    e = e.toUpperCase();
    const n = new Sa(this, (i) => i.nodeName && i.nodeName.toUpperCase() === e).next();
    return n.done ? null : n.value;
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(e) {
    return e = e.toUpperCase(), Ln(new Sa(this, (t) => t.nodeName && t.nodeName.toUpperCase() === e));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, t) {
    Vo(this, e, new W0(this, t, e));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return id(this, (e) => e.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, t = {}, n) {
    const i = e.createDocumentFragment();
    return n !== void 0 && n._createAssociation(i, this), Qi(this, (r) => {
      i.insertBefore(r.toDOM(e, t, n), null);
    }), i;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(e, t) {
    this.doc !== null ? he(this.doc, (n) => {
      ad(n, this, e, t);
    }) : this._prelimContent.splice(e, 0, ...t);
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(e, t) {
    if (this.doc !== null)
      he(this.doc, (n) => {
        const i = e && e instanceof Ke ? e._item : e;
        co(n, this, i, t);
      });
    else {
      const n = (
        /** @type {Array<any>} */
        this._prelimContent
      ), i = e === null ? 0 : n.findIndex((r) => r === e) + 1;
      if (i === 0 && e !== null)
        throw Dn("Reference item not found");
      n.splice(i, 0, ...t);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(e, t = 1) {
    this.doc !== null ? he(this.doc, (n) => {
      ld(n, this, e, t);
    }) : this._prelimContent.splice(e, t);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return sd(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(e) {
    this.insert(this.length, e);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
   */
  unshift(e) {
    this.insert(0, e);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(e) {
    return rd(this, e);
  }
  /**
   * Returns a portion of this YXmlFragment into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(e = 0, t = this.length) {
    return nd(this, e, t);
  }
  /**
   * Executes a provided function on once on every child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    Qi(this, e);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(hm);
  }
}
const q0 = (s) => new ds();
class Ys extends ds {
  constructor(e = "UNDEFINED") {
    super(), this.nodeName = e, this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, t) {
    super._integrate(e, t), /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((n, i) => {
      this.setAttribute(i, n);
    }), this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new Ys(this.nodeName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlElement<KV>}
   */
  clone() {
    const e = new Ys(this.nodeName), t = this.getAttributes();
    return C1(t, (n, i) => {
      typeof n == "string" && e.setAttribute(i, n);
    }), e.insert(0, this.toArray().map((n) => n instanceof Ke ? n.clone() : n)), e;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const e = this.getAttributes(), t = [], n = [];
    for (const a in e)
      n.push(a);
    n.sort();
    const i = n.length;
    for (let a = 0; a < i; a++) {
      const l = n[a];
      t.push(l + '="' + e[l] + '"');
    }
    const r = this.nodeName.toLocaleLowerCase(), o = t.length > 0 ? " " + t.join(" ") : "";
    return "<".concat(r).concat(o, ">").concat(super.toString(), "</").concat(r, ">");
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(e) {
    this.doc !== null ? he(this.doc, (t) => {
      ho(t, this, e);
    }) : this._prelimAttrs.delete(e);
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(e, t) {
    this.doc !== null ? he(this.doc, (n) => {
      Wl(n, this, e, t);
    }) : this._prelimAttrs.set(e, t);
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(e) {
    return (
      /** @type {any} */
      Jl(this, e)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(e) {
    return (
      /** @type {any} */
      hd(this, e)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(e) {
    return (
      /** @type {any} */
      e ? j0(this, e) : cd(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, t = {}, n) {
    const i = e.createElement(this.nodeName), r = this.getAttributes();
    for (const o in r) {
      const a = r[o];
      typeof a == "string" && i.setAttribute(o, a);
    }
    return Qi(this, (o) => {
      i.appendChild(o.toDOM(e, t, n));
    }), n !== void 0 && n._createAssociation(i, this), i;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(cm), e.writeKey(this.nodeName);
  }
}
const G0 = (s) => new Ys(s.readKey());
class W0 extends $o {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with wich the
   *                                  change was created.
   */
  constructor(e, t, n) {
    super(e, n), this.childListChanged = !1, this.attributesChanged = /* @__PURE__ */ new Set(), t.forEach((i) => {
      i === null ? this.childListChanged = !0 : this.attributesChanged.add(i);
    });
  }
}
class uo extends Ws {
  /**
   * @param {string} hookName nodeName of the Dom Node.
   */
  constructor(e) {
    super(), this.hookName = e;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   */
  _copy() {
    return new uo(this.hookName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlHook}
   */
  clone() {
    const e = new uo(this.hookName);
    return this.forEach((t, n) => {
      e.set(n, t);
    }), e;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, t = {}, n) {
    const i = t[this.hookName];
    let r;
    return i !== void 0 ? r = i.createDom(this) : r = document.createElement(this.hookName), r.setAttribute("data-yjs-hook", this.hookName), n !== void 0 && n._createAssociation(r, this), r;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(um), e.writeKey(this.hookName);
  }
}
const J0 = (s) => new uo(s.readKey());
class Qe extends Js {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  _copy() {
    return new Qe();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlText}
   */
  clone() {
    const e = new Qe();
    return e.applyDelta(this.toDelta()), e;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, t, n) {
    const i = e.createTextNode(this.toString());
    return n !== void 0 && n._createAssociation(i, this), i;
  }
  toString() {
    return this.toDelta().map((e) => {
      const t = [];
      for (const i in e.attributes) {
        const r = [];
        for (const o in e.attributes[i])
          r.push({ key: o, value: e.attributes[i][o] });
        r.sort((o, a) => o.key < a.key ? -1 : 1), t.push({ nodeName: i, attrs: r });
      }
      t.sort((i, r) => i.nodeName < r.nodeName ? -1 : 1);
      let n = "";
      for (let i = 0; i < t.length; i++) {
        const r = t[i];
        n += "<".concat(r.nodeName);
        for (let o = 0; o < r.attrs.length; o++) {
          const a = r.attrs[o];
          n += " ".concat(a.key, '="').concat(a.value, '"');
        }
        n += ">";
      }
      n += e.insert;
      for (let i = t.length - 1; i >= 0; i--)
        n += "</".concat(t[i].nodeName, ">");
      return n;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(dm);
  }
}
const Y0 = (s) => new Qe();
class Yl {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(e, t) {
    this.id = e, this.length = t;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw Gt();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} wether this merged with right
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(e, t, n) {
    throw Gt();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, t) {
    throw Gt();
  }
}
const X0 = 0;
class St extends Yl {
  get deleted() {
    return !0;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.constructor !== e.constructor ? !1 : (this.length += e.length, !0);
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, t) {
    t > 0 && (this.id.clock += t, this.length -= t), Xu(e.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeInfo(X0), e.writeLen(this.length - t);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, t) {
    return null;
  }
}
class yr {
  /**
   * @param {Uint8Array} content
   */
  constructor(e) {
    this.content = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new yr(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(e) {
    throw Gt();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
}
const Z0 = (s) => new yr(s.readBuf());
class er {
  /**
   * @param {number} len
   */
  constructor(e) {
    this.len = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new er(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(e) {
    const t = new er(this.len - e);
    return this.len = e, t;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.len += e.len, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
    Zi(e.deleteSet, t.id.client, t.id.clock, this.len), t.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeLen(this.len - t);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
}
const K0 = (s) => new er(s.readLen()), md = (s, e) => new yi({ guid: s, ...e, shouldLoad: e.shouldLoad || e.autoLoad || !1 });
class br {
  /**
   * @param {Doc} doc
   */
  constructor(e) {
    e._item && console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid."), this.doc = e;
    const t = {};
    this.opts = t, e.gc || (t.gc = !1), e.autoLoad && (t.autoLoad = !0), e.meta !== null && (t.meta = e.meta);
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new br(md(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(e) {
    throw Gt();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
    this.doc._item = t, e.subdocsAdded.add(this.doc), this.doc.shouldLoad && e.subdocsLoaded.add(this.doc);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
    e.subdocsAdded.has(this.doc) ? e.subdocsAdded.delete(this.doc) : e.subdocsRemoved.add(this.doc);
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeString(this.doc.guid), e.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
}
const Q0 = (s) => new br(md(s.readString(), s.readAny()));
class Ss {
  /**
   * @param {Object} embed
   */
  constructor(e) {
    this.embed = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new Ss(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(e) {
    throw Gt();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
}
const em = (s) => new Ss(s.readJSON());
class Fe {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(e, t) {
    this.key = e, this.value = t;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new Fe(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(e) {
    throw Gt();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(e, t) {
    const n = (
      /** @type {YText} */
      t.parent
    );
    n._searchMarker = null, n._hasFormatting = !0;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeKey(this.key), e.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
}
const tm = (s) => new Fe(s.readKey(), s.readJSON());
class fo {
  /**
   * @param {Array<any>} arr
   */
  constructor(e) {
    this.arr = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentJSON}
   */
  copy() {
    return new fo(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentJSON}
   */
  splice(e) {
    const t = new fo(this.arr.slice(e));
    return this.arr = this.arr.slice(0, e), t;
  }
  /**
   * @param {ContentJSON} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.arr = this.arr.concat(e.arr), !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    const n = this.arr.length;
    e.writeLen(n - t);
    for (let i = t; i < n; i++) {
      const r = this.arr[i];
      e.writeString(r === void 0 ? "undefined" : JSON.stringify(r));
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 2;
  }
}
const nm = (s) => {
  const e = s.readLen(), t = [];
  for (let n = 0; n < e; n++) {
    const i = s.readString();
    i === "undefined" ? t.push(void 0) : t.push(JSON.parse(i));
  }
  return new fo(t);
};
class fs {
  /**
   * @param {Array<any>} arr
   */
  constructor(e) {
    this.arr = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new fs(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(e) {
    const t = new fs(this.arr.slice(e));
    return this.arr = this.arr.slice(0, e), t;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.arr = this.arr.concat(e.arr), !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    const n = this.arr.length;
    e.writeLen(n - t);
    for (let i = t; i < n; i++) {
      const r = this.arr[i];
      e.writeAny(r);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
}
const sm = (s) => {
  const e = s.readLen(), t = [];
  for (let n = 0; n < e; n++)
    t.push(s.readAny());
  return new fs(t);
};
class Yt {
  /**
   * @param {string} str
   */
  constructor(e) {
    this.str = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new Yt(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(e) {
    const t = new Yt(this.str.slice(e));
    this.str = this.str.slice(0, e);
    const n = this.str.charCodeAt(e - 1);
    return n >= 55296 && n <= 56319 && (this.str = this.str.slice(0, e - 1) + "�", t.str = "�" + t.str.slice(1)), t;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.str += e.str, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeString(t === 0 ? this.str : this.str.slice(t));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
}
const im = (s) => new Yt(s.readString()), rm = [
  B0,
  $0,
  U0,
  G0,
  q0,
  J0,
  Y0
], om = 0, am = 1, lm = 2, cm = 3, hm = 4, um = 5, dm = 6;
class Kt {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(e) {
    this.type = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new Kt(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(e) {
    throw Gt();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
    this.type._integrate(e.doc, t);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
    let t = this.type._start;
    for (; t !== null; )
      t.deleted ? t.id.clock < (e.beforeState.get(t.id.client) || 0) && e._mergeStructs.push(t) : t.delete(e), t = t.right;
    this.type._map.forEach((n) => {
      n.deleted ? n.id.clock < (e.beforeState.get(n.id.client) || 0) && e._mergeStructs.push(n) : n.delete(e);
    }), e.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
    let t = this.type._start;
    for (; t !== null; )
      t.gc(e, !0), t = t.right;
    this.type._start = null, this.type._map.forEach(
      /** @param {Item | null} item */
      (n) => {
        for (; n !== null; )
          n.gc(e, !0), n = n.left;
      }
    ), this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    this.type._write(e);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
}
const fm = (s) => new Kt(rm[s.readTypeRef()](s)), nl = (s, e) => {
  let t = e, n = 0, i;
  do
    n > 0 && (t = K(t.client, t.clock + n)), i = Rs(s, t), n = t.clock - i.id.clock, t = i.redone;
  while (t !== null && i instanceof fe);
  return {
    item: i,
    diff: n
  };
}, Xl = (s, e) => {
  for (; s !== null && s.keep !== e; )
    s.keep = e, s = /** @type {AbstractType<any>} */
    s.parent._item;
}, go = (s, e, t) => {
  const { client: n, clock: i } = e.id, r = new fe(
    K(n, i + t),
    e,
    K(n, i + t - 1),
    e.right,
    e.rightOrigin,
    e.parent,
    e.parentSub,
    e.content.splice(t)
  );
  return e.deleted && r.markDeleted(), e.keep && (r.keep = !0), e.redone !== null && (r.redone = K(e.redone.client, e.redone.clock + t)), e.right = r, r.right !== null && (r.right.left = r), s._mergeStructs.push(r), r.parentSub !== null && r.right === null && r.parent._map.set(r.parentSub, r), e.length = t, r;
}, oh = (s, e) => Fp(
  s,
  /** @param {StackItem} s */
  (t) => mr(t.deletions, e)
), wd = (s, e, t, n, i, r) => {
  const o = s.doc, a = o.store, l = o.clientID, c = e.redone;
  if (c !== null)
    return lt(s, c);
  let u = (
    /** @type {AbstractType<any>} */
    e.parent._item
  ), d = null, f;
  if (u !== null && u.deleted === !0) {
    if (u.redone === null && (!t.has(u) || wd(s, u, t, n, i, r) === null))
      return null;
    for (; u.redone !== null; )
      u = lt(s, u.redone);
  }
  const g = u === null ? (
    /** @type {AbstractType<any>} */
    e.parent
  ) : (
    /** @type {ContentType} */
    u.content.type
  );
  if (e.parentSub === null) {
    for (d = e.left, f = e; d !== null; ) {
      let v = d;
      for (; v !== null && /** @type {AbstractType<any>} */
      v.parent._item !== u; )
        v = v.redone === null ? null : lt(s, v.redone);
      if (v !== null && /** @type {AbstractType<any>} */
      v.parent._item === u) {
        d = v;
        break;
      }
      d = d.left;
    }
    for (; f !== null; ) {
      let v = f;
      for (; v !== null && /** @type {AbstractType<any>} */
      v.parent._item !== u; )
        v = v.redone === null ? null : lt(s, v.redone);
      if (v !== null && /** @type {AbstractType<any>} */
      v.parent._item === u) {
        f = v;
        break;
      }
      f = f.right;
    }
  } else if (f = null, e.right && !i) {
    for (d = e; d !== null && d.right !== null && (d.right.redone || mr(n, d.right.id) || oh(r.undoStack, d.right.id) || oh(r.redoStack, d.right.id)); )
      for (d = d.right; d.redone; )
        d = lt(s, d.redone);
    if (d && d.right !== null)
      return null;
  } else
    d = g._map.get(e.parentSub) || null;
  const p = _e(a, l), m = K(l, p), w = new fe(
    m,
    d,
    d && d.lastId,
    f,
    f && f.id,
    g,
    e.parentSub,
    e.content.copy()
  );
  return e.redone = m, Xl(w, !0), w.integrate(s, 0), w;
};
class fe extends Yl {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(e, t, n, i, r, o, a, l) {
    super(e, l.getLength()), this.origin = n, this.left = t, this.right = i, this.rightOrigin = r, this.parent = o, this.parentSub = a, this.redone = null, this.content = l, this.info = this.content.isCountable() ? Dc : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(e) {
    (this.info & ba) > 0 !== e && (this.info ^= ba);
  }
  get marker() {
    return (this.info & ba) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & Nc) > 0;
  }
  set keep(e) {
    this.keep !== e && (this.info ^= Nc);
  }
  get countable() {
    return (this.info & Dc) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & ya) > 0;
  }
  set deleted(e) {
    this.deleted !== e && (this.info ^= ya);
  }
  markDeleted() {
    this.info |= ya;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, t) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= _e(t, this.origin.client))
      return this.origin.client;
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= _e(t, this.rightOrigin.client))
      return this.rightOrigin.client;
    if (this.parent && this.parent.constructor === js && this.id.client !== this.parent.client && this.parent.clock >= _e(t, this.parent.client))
      return this.parent.client;
    if (this.origin && (this.left = Zc(e, t, this.origin), this.origin = this.left.lastId), this.rightOrigin && (this.right = lt(e, this.rightOrigin), this.rightOrigin = this.right.id), this.left && this.left.constructor === St || this.right && this.right.constructor === St)
      this.parent = null;
    else if (!this.parent)
      this.left && this.left.constructor === fe && (this.parent = this.left.parent, this.parentSub = this.left.parentSub), this.right && this.right.constructor === fe && (this.parent = this.right.parent, this.parentSub = this.right.parentSub);
    else if (this.parent.constructor === js) {
      const n = Rs(t, this.parent);
      n.constructor === St ? this.parent = null : this.parent = /** @type {ContentType} */
      n.content.type;
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, t) {
    if (t > 0 && (this.id.clock += t, this.left = Zc(e, e.doc.store, K(this.id.client, this.id.clock - 1)), this.origin = this.left.lastId, this.content = this.content.splice(t), this.length -= t), this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let n = this.left, i;
        if (n !== null)
          i = n.right;
        else if (this.parentSub !== null)
          for (i = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; i !== null && i.left !== null; )
            i = i.left;
        else
          i = /** @type {AbstractType<any>} */
          this.parent._start;
        const r = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set();
        for (; i !== null && i !== this.right; ) {
          if (o.add(i), r.add(i), Is(this.origin, i.origin)) {
            if (i.id.client < this.id.client)
              n = i, r.clear();
            else if (Is(this.rightOrigin, i.rightOrigin))
              break;
          } else if (i.origin !== null && o.has(Rs(e.doc.store, i.origin)))
            r.has(Rs(e.doc.store, i.origin)) || (n = i, r.clear());
          else
            break;
          i = i.right;
        }
        this.left = n;
      }
      if (this.left !== null) {
        const n = this.left.right;
        this.right = n, this.left.right = this;
      } else {
        let n;
        if (this.parentSub !== null)
          for (n = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; n !== null && n.left !== null; )
            n = n.left;
        else
          n = /** @type {AbstractType<any>} */
          this.parent._start, this.parent._start = this;
        this.right = n;
      }
      this.right !== null ? this.right.left = this : this.parentSub !== null && (this.parent._map.set(this.parentSub, this), this.left !== null && this.left.delete(e)), this.parentSub === null && this.countable && !this.deleted && (this.parent._length += this.length), Xu(e.doc.store, this), this.content.integrate(e, this), Qc(
        e,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      ), /** @type {AbstractType<any>} */
      (this.parent._item !== null && /** @type {AbstractType<any>} */
      this.parent._item.deleted || this.parentSub !== null && this.right !== null) && this.delete(e);
    } else
      new St(this.id, this.length).integrate(e, 0);
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let e = this.right;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let e = this.left;
    for (; e !== null && e.deleted; )
      e = e.left;
    return e;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : K(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(e) {
    if (this.constructor === e.constructor && Is(e.origin, this.lastId) && this.right === e && Is(this.rightOrigin, e.rightOrigin) && this.id.client === e.id.client && this.id.clock + this.length === e.id.clock && this.deleted === e.deleted && this.redone === null && e.redone === null && this.content.constructor === e.content.constructor && this.content.mergeWith(e.content)) {
      const t = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      return t && t.forEach((n) => {
        n.p === e && (n.p = this, !this.deleted && this.countable && (n.index -= this.length));
      }), e.keep && (this.keep = !0), this.right = e.right, this.right !== null && (this.right.left = this), this.length += e.length, !0;
    }
    return !1;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(e) {
    if (!this.deleted) {
      const t = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      this.countable && this.parentSub === null && (t._length -= this.length), this.markDeleted(), Zi(e.deleteSet, this.id.client, this.id.clock, this.length), Qc(e, t, this.parentSub), this.content.delete(e);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(e, t) {
    if (!this.deleted)
      throw _t();
    this.content.gc(e), t ? y0(e, this, new St(this.id, this.length)) : this.content = new er(this.length);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(e, t) {
    const n = t > 0 ? K(this.id.client, this.id.clock + t - 1) : this.origin, i = this.rightOrigin, r = this.parentSub, o = this.content.getRef() & Do | (n === null ? 0 : mt) | // origin is defined
    (i === null ? 0 : an) | // right origin is defined
    (r === null ? 0 : qi);
    if (e.writeInfo(o), n !== null && e.writeLeftID(n), i !== null && e.writeRightID(i), n === null && i === null) {
      const a = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (a._item !== void 0) {
        const l = a._item;
        if (l === null) {
          const c = qu(a);
          e.writeParentInfo(!0), e.writeString(c);
        } else
          e.writeParentInfo(!1), e.writeLeftID(l.id);
      } else
        a.constructor === String ? (e.writeParentInfo(!0), e.writeString(a)) : a.constructor === js ? (e.writeParentInfo(!1), e.writeLeftID(a)) : _t();
      r !== null && e.writeString(r);
    }
    this.content.write(e, t);
  }
}
const yd = (s, e) => gm[e & Do](s), gm = [
  () => {
    _t();
  },
  // GC is not ItemContent
  K0,
  // 1
  nm,
  // 2
  Z0,
  // 3
  im,
  // 4
  em,
  // 5
  tm,
  // 6
  fm,
  // 7
  sm,
  // 8
  Q0,
  // 9
  () => {
    _t();
  }
  // 10 - Skip is not ItemContent
], pm = 10;
class At extends Yl {
  get deleted() {
    return !0;
  }
  delete() {
  }
  /**
   * @param {Skip} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.constructor !== e.constructor ? !1 : (this.length += e.length, !0);
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, t) {
    _t();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeInfo(pm), te(e.restEncoder, this.length - t);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, t) {
    return null;
  }
}
const bd = (
  /** @type {any} */
  typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : {}
), vd = "__ $YJS$ __";
bd[vd] === !0 && console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
bd[vd] = !0;
function ah(s) {
  return Object.prototype.toString.call(s) === "[object Object]";
}
function lh(s) {
  if (!ah(s))
    return !1;
  const e = s.constructor;
  if (e === void 0)
    return !0;
  const t = e.prototype;
  return !(ah(t) === !1 || t.hasOwnProperty("isPrototypeOf") === !1);
}
function Zl(s, e) {
  for (const t in s) {
    const n = s[t], i = e[t];
    if (lh(n) && lh(i)) {
      if (!Zl(n, i))
        return !1;
    } else if (Array.isArray(n) && Array.isArray(i)) {
      if (n.length !== i.length)
        return !1;
      for (let r = 0; r < n.length; r++)
        if (n[r] !== i[r])
          return !1;
    } else if (n !== i)
      return !1;
  }
  for (const t in e)
    if (s[t] === void 0 && e[t] !== void 0)
      return !1;
  return !0;
}
function mm(s, ...e) {
  return Object.fromEntries(
    Object.entries(s).filter(([t]) => e.includes(t))
  );
}
function wm(s, ...e) {
  return Object.fromEntries(
    Object.entries(s).filter(([t]) => !e.includes(t))
  );
}
function ym(s) {
  return Object.fromEntries(
    Object.entries(s).filter(([, e]) => e !== null)
  );
}
function bm(s) {
  var t, n;
  const e = [];
  for (const i of s) {
    if (typeof i.insert == "string" && i.insert.length === 0)
      continue;
    const r = e[e.length - 1];
    if (!r || typeof r.insert != "string" || typeof i.insert != "string") {
      e.push(i);
      continue;
    }
    if (r.attributes === i.attributes || !r.attributes == !i.attributes && Zl((t = r.attributes) != null ? t : {}, (n = i.attributes) != null ? n : {})) {
      r.insert += i.insert;
      continue;
    }
    e.push(i);
  }
  return e;
}
function mn(s) {
  return bm(s.toDelta());
}
function xd({ insert: s }) {
  return typeof s == "string" ? s.length : 1;
}
function Cd(s) {
  return s.reduce((e, t) => e + xd(t), 0);
}
function Ed(s, e, t) {
  if (t < 1)
    return [];
  let n = 0;
  const i = [], r = e + t;
  for (let o = 0; o < s.length && !(n >= r); o++) {
    const a = s[o], l = xd(a);
    if (n + l <= e) {
      n += l;
      continue;
    }
    if (typeof a.insert != "string") {
      n += l, i.push(a);
      continue;
    }
    const c = Math.max(0, e - n), u = Math.min(
      l,
      l - (n + l - r)
    );
    i.push({
      ...a,
      insert: a.insert.slice(c, u)
    }), n += l;
  }
  return i;
}
function sn(s) {
  return wm(
    s,
    pe.isText(s) ? "text" : "children"
  );
}
function Sd(s) {
  const e = mn(s), t = e.length > 0 ? e.map(sl) : [{ text: "" }];
  return { ...s.getAttributes(), children: t };
}
function sl(s) {
  return typeof s.insert == "string" ? { ...s.attributes, text: s.insert } : Sd(s.insert);
}
function Ad(s) {
  return s.map((e) => pe.isText(e) ? { insert: e.text, attributes: sn(e) } : { insert: Md(e) });
}
function Md({
  children: s,
  ...e
}) {
  const t = new Qe();
  return Object.entries(e).forEach(([n, i]) => {
    t.setAttribute(n, i);
  }), t.applyDelta(Ad(s), { sanitize: !1 }), t;
}
function tr(s) {
  return s ? pe.isText(s) ? s.text.length : 1 : 0;
}
function vm(s, e) {
  return s.children.slice(0, e).reduce((t, n) => t + tr(n), 0);
}
function wt(s, e, t) {
  var d;
  if (t.length === 0)
    throw new Error("Path has to a have a length >= 1");
  if (pe.isText(e))
    throw new Error("Cannot descent into slate text");
  const [n, ...i] = t, r = vm(e, n), o = e.children[n], a = mn(s), l = tr(o), c = Ed(a, r, l);
  if (c.length > 1)
    throw new Error("Path doesn't match yText, yTarget spans multiple nodes");
  const u = (d = c[0]) == null ? void 0 : d.insert;
  if (i.length > 0) {
    if (!(u instanceof Qe))
      throw new Error(
        "Path doesn't match yText, cannot descent into non-yText"
      );
    return wt(u, o, i);
  }
  return {
    yParent: s,
    textRange: { start: r, end: r + l },
    yTarget: u instanceof Qe ? u : void 0,
    slateParent: e,
    slateTarget: o,
    targetDelta: c
  };
}
function Qn(s, e, t = {}) {
  const { assoc: n = 0, insert: i = !1 } = t;
  let r = 0, o = 0;
  for (let c = 0; c < s.children.length; c++) {
    const u = s.children[c], d = pe.isText(u) ? u.text.length : 1;
    d > 0 && (o = c);
    const f = r + d;
    if (d > 0 && (n >= 0 ? f > e : f >= e))
      return [c, e - r];
    r += d;
  }
  if (e > r + (i ? 1 : 0))
    throw new Error("yOffset out of bounds");
  if (i)
    return [s.children.length, 0];
  const a = s.children[o], l = pe.isText(a) ? a.text.length : 1;
  return [o, l];
}
function kd(s, e, t) {
  const n = [t];
  for (; n[0] !== s; ) {
    const { parent: r } = n[0];
    if (!r)
      throw new Error("yText isn't a descendant of root element");
    if (!(r instanceof Qe))
      throw new Error("Unexpected y parent type");
    n.unshift(r);
  }
  if (n.length < 2)
    return [];
  let i = e;
  return n.reduce((r, o, a) => {
    const l = n[a + 1];
    if (!l)
      return r;
    let c = 0;
    const u = mn(o);
    for (const f of u) {
      if (f.insert === l)
        break;
      c += typeof f.insert == "string" ? f.insert.length : 1;
    }
    if (pe.isText(i))
      throw new Error("Cannot descent into slate text");
    const [d] = Qn(i, c);
    return i = i.children[d], r.concat(d);
  }, []);
}
function Fs(s) {
  if (!s.doc)
    throw new Error("shared type isn't attached to a document");
}
const gs = "__slateYjsStoredPosition_";
function il(s, e, t) {
  const { yTarget: n, yParent: i, textRange: r } = wt(
    s,
    e,
    t.path
  );
  if (n)
    throw new Error(
      "Slate point points to a non-text element inside sharedRoot"
    );
  const o = r.start + t.offset;
  return Gu(
    i,
    o,
    o === r.end ? -1 : 0
  );
}
function xm(s, e, { type: t, index: n, assoc: i }) {
  if (!(t instanceof Qe))
    throw new Error("Absolute position points to a non-XMLText");
  const r = kd(s, e, t), o = xs.get(e, r);
  if (pe.isText(o))
    throw new Error(
      "Absolute position doesn't match slateRoot, cannot descent into text"
    );
  const [a, l] = Qn(o, n, {
    assoc: i
  }), c = o.children[a];
  return pe.isText(c) ? { path: [...r, a], offset: l } : null;
}
function rl(s, e, t) {
  if (!s.doc)
    throw new Error("sharedRoot isn't attach to a yDoc");
  const n = Ju(
    t,
    s.doc
  );
  return n && xm(s, e, n);
}
function Cm(s, e) {
  const t = s.getAttribute(gs + e);
  return t ? Wu(t) : null;
}
function Em(s) {
  return Object.fromEntries(
    Object.entries(s.getAttributes()).filter(([e]) => e.startsWith(gs)).map(([e, t]) => [
      e.slice(gs.length),
      u0(t)
    ])
  );
}
function Sm(s) {
  return Fs(s), Object.fromEntries(
    Object.entries(s.getAttributes()).filter(([e]) => e.startsWith(gs)).map(
      ([e, t]) => [
        e.slice(gs.length),
        Ju(
          Wu(t),
          s.doc
        )
      ]
    ).filter(([, e]) => e)
  );
}
function Am(s, e) {
  s.removeAttribute(gs + e);
}
function Pd(s, e, t) {
  s.setAttribute(
    gs + e,
    p0(t)
  );
}
function _d(s, e, t) {
  return Object.fromEntries(
    Object.entries(s).filter(([, n]) => n.type !== e ? !1 : t ? n.assoc >= 0 ? n.index >= t.start && n.index < t.end : n.index > t.start && n.index >= t.end : !0)
  );
}
function Od(s, e, t = "") {
  const n = {
    [t]: _d(s, e)
  };
  return mn(e).forEach(({ insert: r }, o) => {
    r instanceof Qe && Object.assign(
      n,
      Od(
        s,
        r,
        t ? "".concat(t, ".").concat(o) : o.toString()
      )
    );
  }), n;
}
function Kl(s, e, t, n = 0) {
  const i = Sm(s), r = {
    "": _d(i, e, {
      start: n,
      end: n + Cd(t)
    })
  };
  return t.forEach(({ insert: o }, a) => {
    o instanceof Qe && Object.assign(
      r,
      Od(i, o, a.toString())
    );
  }), r;
}
function Ho(s, e, t, n, i = 0, r = 0, o = "") {
  const a = t[o];
  a && Object.entries(a).forEach(([l, c]) => {
    Pd(
      s,
      l,
      Gu(
        e,
        c.index - r + i,
        c.assoc
      )
    );
  }), n.forEach(({ insert: l }, c) => {
    l instanceof Qe && Ho(
      s,
      l,
      t,
      mn(l),
      0,
      0,
      o ? "".concat(o, ".").concat(c) : c.toString()
    );
  });
}
function Kr(s, e, t) {
  return {
    anchor: il(s, e, t.anchor),
    focus: il(s, e, t.focus)
  };
}
function Td(s, e, t) {
  const n = rl(
    s,
    e,
    t.anchor
  );
  if (!n)
    return null;
  const i = rl(
    s,
    e,
    t.focus
  );
  return i ? { anchor: n, focus: i } : null;
}
function Mm(s, e, t) {
  const n = [];
  let i = t.reduce((r, o) => "retain" in o ? r + o.retain : "delete" in o ? r + o.delete : r, 0);
  return t.reverse().forEach((r) => {
    var o;
    if ("attributes" in r && "retain" in r) {
      const [a, l] = Qn(
        s,
        i - r.retain
      ), [c, u] = Qn(
        s,
        i,
        { assoc: -1 }
      );
      for (let d = c; d >= a; d--) {
        const f = s.children[d], g = [...e, d];
        if (!pe.isText(f))
          continue;
        const p = r.attributes, m = mm(
          s,
          ...Object.keys(r.attributes)
        );
        if (d === a || d === c) {
          const w = d === a ? l : 0, v = d === c ? u : f.text.length;
          if (v !== f.text.length && n.push({
            type: "split_node",
            path: g,
            position: v,
            properties: sn(f)
          }), w !== 0) {
            n.push({
              type: "split_node",
              path: g,
              position: w,
              properties: ym({
                ...sn(f),
                ...p
              })
            });
            continue;
          }
        }
        n.push({
          type: "set_node",
          newProperties: p,
          path: g,
          properties: m
        });
      }
    }
    if ("retain" in r && (i -= r.retain), "delete" in r) {
      const [a, l] = Qn(
        s,
        i - r.delete
      ), [c, u] = Qn(
        s,
        i,
        { assoc: -1 }
      );
      for (let d = u === 0 ? c - 1 : c; d >= a; d--) {
        const f = s.children[d], g = [...e, d];
        if (pe.isText(f) && (d === a || d === c)) {
          const p = d === a ? l : 0, m = d === c ? u : f.text.length;
          n.push({
            type: "remove_text",
            offset: p,
            text: f.text.slice(p, m),
            path: g
          }), i -= m - p;
          continue;
        }
        n.push({
          type: "remove_node",
          node: f,
          path: g
        }), i -= tr(f);
      }
      return;
    }
    if ("insert" in r) {
      const [a, l] = Qn(s, i, {
        insert: !0
      }), c = s.children[a], u = [...e, a];
      if (pe.isText(c)) {
        const d = n[n.length - 1], f = d != null && d.type === "insert_node" ? d.node : sn(c);
        let g = [];
        if (d != null && (d.type === "insert_node" || d.type === "insert_text" || d.type === "split_node" || d.type === "set_node") && (g = d.path), typeof r.insert == "string" && Zl((o = r.attributes) != null ? o : {}, f) && hs.equals(u, g))
          return n.push({
            type: "insert_text",
            offset: l,
            text: r.insert,
            path: u
          });
        const p = sl(r);
        return l === 0 ? n.push({
          type: "insert_node",
          path: u,
          node: p
        }) : (l < c.text.length && n.push({
          type: "split_node",
          path: u,
          position: l,
          properties: sn(c)
        }), n.push({
          type: "insert_node",
          path: hs.next(u),
          node: p
        }));
      }
      return n.push({
        type: "insert_node",
        path: u,
        node: sl(r)
      });
    }
  }), n;
}
function km(s, e, t) {
  const { target: n, changes: i } = t, r = t.delta;
  if (!(n instanceof Qe))
    throw new Error("Unexpected target node type");
  const o = [], a = kd(s, e, n), l = xs.get(e, a);
  if (pe.isText(l))
    throw new Error("Cannot apply yTextEvent to text node");
  const c = Array.from(i.keys.entries());
  if (a.length > 0 && c.length > 0) {
    const u = Object.fromEntries(
      c.map(([f, g]) => [
        f,
        g.action === "delete" ? null : n.getAttribute(f)
      ])
    ), d = Object.fromEntries(
      c.map(([f]) => [f, l[f]])
    );
    o.push({ type: "set_node", newProperties: u, properties: d, path: a });
  }
  return r.length > 0 && o.push(...Mm(l, a, r)), o;
}
function Pm(s, e, t) {
  if (t instanceof pd)
    return km(s, e, t);
  throw new Error("Unexpected Y event type");
}
function _m(s, e, t) {
  ne.withoutNormalizing(e, () => {
    t.forEach((n) => {
      Pm(s, e, n).forEach((i) => {
        e.apply(i);
      });
    });
  });
}
function Om(s, e, t) {
  const { yParent: n, textRange: i } = wt(s, e, t.path);
  if (pe.isText(t.node))
    return n.insert(
      i.start,
      t.node.text,
      sn(t.node)
    );
  n.insertEmbed(i.start, Md(t.node));
}
function Tm(s) {
  const e = new Qe(), t = s.getAttributes();
  return Object.entries(t).forEach(([n, i]) => {
    e.setAttribute(n, i);
  }), e.applyDelta(Uo(mn(s)), {
    sanitize: !1
  }), e;
}
function Uo(s) {
  return s.map((e) => typeof e.insert == "string" ? e : { ...e, insert: Tm(e.insert) });
}
function Lm(s, e, t) {
  const n = wt(s, e, t.path), i = wt(
    n.yParent,
    n.slateParent,
    hs.previous(t.path.slice(-1))
  );
  if (!n.yTarget != !i.yTarget)
    throw new Error("Cannot merge y text with y element");
  if (!i.yTarget || !n.yTarget) {
    const { yParent: u, textRange: d, slateTarget: f } = n;
    if (!f)
      throw new Error("Expected Slate target node for merge op.");
    const g = xs.get(e, hs.previous(t.path));
    if (!pe.isText(g))
      throw new Error("Path points to Y.Text but not a Slate text node.");
    const p = sn(f), m = sn(g), w = Object.keys(p).reduce((v, y) => y in m ? v : { ...v, [y]: null }, {});
    return u.format(d.start, d.end - d.start, {
      ...w,
      ...m
    });
  }
  const r = i.yTarget.length, o = mn(n.yTarget), a = Uo(o), l = Kl(
    s,
    n.yTarget,
    o,
    r
  ), c = [{ retain: r }, ...a];
  i.yTarget.applyDelta(c, {
    sanitize: !1
  }), n.yParent.delete(
    n.textRange.start,
    n.textRange.end - n.textRange.start
  ), Ho(
    s,
    i.yTarget,
    l,
    a,
    r
  );
}
function Nm(s, e, t) {
  const n = hs.parent(t.newPath), i = t.newPath[t.newPath.length - 1], r = xs.get(e, n);
  if (pe.isText(r))
    throw new Error("Cannot move slate node into text element");
  const o = [
    ...n,
    Math.min(i, r.children.length)
  ], a = wt(s, e, t.path), l = wt(s, e, o), c = Uo(a.targetDelta), u = Kl(
    s,
    a.yParent,
    a.targetDelta
  );
  a.yParent.delete(
    a.textRange.start,
    a.textRange.end - a.textRange.start
  );
  const d = Cd(mn(l.yParent)), f = Math.min(l.textRange.start, d), g = [{ retain: f }, ...c];
  l.yParent.applyDelta(g, { sanitize: !1 }), Ho(
    s,
    l.yParent,
    u,
    c,
    f,
    a.textRange.start
  );
}
function Dm(s, e, t) {
  const { yParent: n, textRange: i } = wt(
    s,
    e,
    t.path
  );
  n.delete(i.start, i.end - i.start);
}
function Im(s, e, t) {
  const { yTarget: n, textRange: i, yParent: r } = wt(
    s,
    e,
    t.path
  );
  if (n)
    return Object.entries(t.newProperties).forEach(([l, c]) => {
      if (c === null)
        return n.removeAttribute(l);
      n.setAttribute(l, c);
    }), Object.entries(t.properties).forEach(([l]) => {
      t.newProperties.hasOwnProperty(l) || n.removeAttribute(l);
    });
  const a = { ...Object.fromEntries(
    Object.keys(t.properties).map((l) => [l, null])
  ), ...t.newProperties };
  r.format(
    i.start,
    i.end - i.start,
    a
  );
}
function jm(s, e, t) {
  const n = wt(s, e, t.path);
  if (!n.slateTarget)
    throw new Error("Y target without corresponding slate node");
  if (!n.yTarget) {
    if (!pe.isText(n.slateTarget))
      throw new Error("Mismatch node type between y target and slate node");
    const d = {};
    return n.targetDelta.forEach((f) => {
      f.attributes && Object.keys(f.attributes).forEach((g) => {
        d[g] = null;
      });
    }), n.yParent.format(
      n.textRange.start,
      n.textRange.end - n.textRange.start,
      { ...d, ...t.properties }
    );
  }
  if (pe.isText(n.slateTarget))
    throw new Error("Mismatch node type between y target and slate node");
  const i = wt(n.yTarget, n.slateTarget, [
    t.position
  ]), r = n.slateTarget.children.slice(0, t.position).reduce((d, f) => d + tr(f), 0), o = n.slateTarget.children.reduce(
    (d, f) => d + tr(f),
    0
  ), a = Ed(
    mn(n.yTarget),
    r,
    o - r
  ), l = Uo(a), c = Kl(
    s,
    n.yTarget,
    a,
    r
  ), u = new Qe();
  u.applyDelta(l, {
    sanitize: !1
  }), Object.entries(t.properties).forEach(([d, f]) => {
    u.setAttribute(d, f);
  }), n.yTarget.delete(
    i.textRange.start,
    n.yTarget.length - i.textRange.start
  ), n.yParent.insertEmbed(n.textRange.end, u), Ho(
    s,
    u,
    c,
    l,
    0,
    r
  );
}
const Rm = {
  insert_node: Om,
  remove_node: Dm,
  set_node: Im,
  merge_node: Lm,
  move_node: Nm,
  split_node: jm
};
function Bm(s, e, t) {
  const { yParent: n, textRange: i } = wt(
    s,
    e,
    t.path
  ), r = xs.get(e, t.path);
  if (!pe.isText(r))
    throw new Error("Cannot insert text into non-text node");
  n.insert(
    i.start + t.offset,
    t.text,
    sn(r)
  );
}
function Fm(s, e, t) {
  const { yParent: n, textRange: i } = wt(
    s,
    e,
    t.path
  );
  n.delete(i.start + t.offset, t.text.length);
}
const $m = {
  insert_text: Bm,
  remove_text: Fm
}, zm = () => {
}, Vm = {
  ...$m,
  ...Rm,
  set_selection: zm
};
function Hm(s, e, t) {
  const n = Vm[t.type];
  if (!n)
    throw new Error("Unknown operation: ".concat(t.type));
  n(s, e, t);
}
const Um = Symbol("slate-yjs-operation"), qm = Symbol("slate-yjs-position-storage"), Aa = /* @__PURE__ */ new WeakMap(), ol = /* @__PURE__ */ new WeakMap(), al = /* @__PURE__ */ new WeakSet(), Ce = {
  isYjsEditor(s) {
    return ne.isEditor(s) && s.sharedRoot instanceof Qe && "localOrigin" in s && "positionStorageOrigin" in s && typeof s.applyRemoteEvents == "function" && typeof s.storeLocalChange == "function" && typeof s.flushLocalChanges == "function" && typeof s.isLocalOrigin == "function" && typeof s.connect == "function" && typeof s.disconnect == "function";
  },
  localChanges(s) {
    var e;
    return (e = ol.get(s)) != null ? e : [];
  },
  applyRemoteEvents(s, e, t) {
    s.applyRemoteEvents(e, t);
  },
  storeLocalChange(s, e) {
    s.storeLocalChange(e);
  },
  flushLocalChanges(s) {
    s.flushLocalChanges();
  },
  connected(s) {
    return al.has(s);
  },
  connect(s) {
    s.connect();
  },
  disconnect(s) {
    s.disconnect();
  },
  isLocal(s) {
    return s.isLocalOrigin(Ce.origin(s));
  },
  origin(s) {
    const e = Aa.get(s);
    return e !== void 0 ? e : s.localOrigin;
  },
  withOrigin(s, e, t) {
    const n = Ce.origin(s);
    Aa.set(s, e), t(), Aa.set(s, n);
  },
  storePosition(s, e, t) {
    var o;
    const { sharedRoot: n, positionStorageOrigin: i } = s;
    Fs(n);
    const r = il(n, s, t);
    (o = n.doc) == null || o.transact(() => {
      Pd(n, e, r);
    }, i);
  },
  removeStoredPosition(s, e) {
    var i;
    const { sharedRoot: t, positionStorageOrigin: n } = s;
    Fs(t), (i = t.doc) == null || i.transact(() => {
      Am(t, e);
    }, n);
  },
  position(s, e) {
    const t = Cm(s.sharedRoot, e);
    if (t)
      return rl(s.sharedRoot, s, t);
  },
  storedPositionsRelative(s) {
    return Em(s.sharedRoot);
  }
};
function Gm(s, e, t, {
  localOrigin: n,
  positionStorageOrigin: i,
  autoConnect: r = !1
} = {}) {
  const o = s;
  o.sharedRoot = e, o.editorWindow = t, o.localOrigin = n != null ? n : Um, o.positionStorageOrigin = i != null ? i : qm, o.applyRemoteEvents = (d, f) => {
    Ce.flushLocalChanges(o), ne.withoutNormalizing(o, () => {
      Ce.withOrigin(o, f, () => {
        _m(o.sharedRoot, o, d);
      });
    });
  }, o.isLocalOrigin = (d) => d === o.localOrigin;
  const a = (d, f) => {
    o.isLocalOrigin(f.origin) || Ce.applyRemoteEvents(o, d, f.origin);
  };
  let l = null;
  r && (l = setTimeout(() => {
    l = null, Ce.connect(o);
  })), o.connect = () => {
    if (Ce.connected(o))
      throw new Error("already connected");
    o.sharedRoot.observeDeep(a);
    const d = Sd(o.sharedRoot);
    o.children = d.children, al.add(o), ne.normalize(s, { force: !0 }), s.operations.length || s.onChange();
  }, o.disconnect = () => {
    l && clearTimeout(l), Ce.flushLocalChanges(o), o.sharedRoot.unobserveDeep(a), al.delete(o);
  }, o.storeLocalChange = (d) => {
    ol.set(o, [
      ...Ce.localChanges(o),
      { op: d, doc: s.children, origin: Ce.origin(o) }
    ]);
  }, o.flushLocalChanges = () => {
    Fs(o.sharedRoot);
    const d = Ce.localChanges(o);
    ol.delete(o);
    const f = [];
    d.forEach((g) => {
      const p = f[f.length - 1];
      if (p && p[0].origin === g.origin)
        return p.push(g);
      f.push([g]);
    }), f.forEach((g) => {
      var p;
      Fs(o.sharedRoot), (p = o.sharedRoot.doc) == null || p.transact(() => {
        g.forEach((m) => {
          Fs(o.sharedRoot), Hm(o.sharedRoot, { children: m.doc }, m.op);
        });
      }, g[0].origin);
    });
  };
  const { apply: c, onChange: u } = o;
  return o.apply = (d) => {
    Ce.connected(o) && Ce.isLocal(o) && Ce.storeLocalChange(o, d), c(d);
  }, o.onChange = () => {
    Ce.connected(o) && Ce.flushLocalChanges(o), u();
  }, o;
}
const ch = /* @__PURE__ */ new WeakMap(), Wm = Symbol(
  "slate-yjs-history-without-saving"
);
function Jm(s, {
  withoutSavingOrigin: e = Wm,
  trackedOrigins: t = /* @__PURE__ */ new Set([s.localOrigin]),
  ...n
} = {}) {
  const i = s, r = new E0(i.sharedRoot, {
    trackedOrigins: t,
    ...n
  });
  i.undoManager = r, i.withoutSavingOrigin = e;
  const { onChange: o, isLocalOrigin: a } = i;
  i.onChange = () => {
    o(), ch.set(
      i,
      i.selection && Kr(i.sharedRoot, i, i.selection)
    );
  }, i.isLocalOrigin = (g) => g === i.withoutSavingOrigin || a(g);
  const l = ({
    stackItem: g
  }) => {
    g.meta.set(
      "selection",
      i.selection && Kr(i.sharedRoot, i, i.selection)
    ), g.meta.set("selectionBefore", ch.get(i));
  }, c = ({
    stackItem: g
  }) => {
    g.meta.set(
      "selection",
      i.selection && Kr(i.sharedRoot, i, i.selection)
    );
  }, u = ({
    stackItem: g,
    type: p
  }) => {
    const m = p === "undo" ? i.undoManager.redoStack : i.undoManager.undoStack, w = m[m.length - 1];
    w && (w.meta.set("selection", g.meta.get("selectionBefore")), w.meta.set("selectionBefore", g.meta.get("selection")));
    const v = g.meta.get(
      "selectionBefore"
    );
    if (!v)
      return;
    const y = Td(
      i.sharedRoot,
      i,
      v
    );
    y && He.select(i, y);
  }, { connect: d, disconnect: f } = i;
  return i.connect = () => {
    d(), i.undoManager.on("stack-item-added", l), i.undoManager.on("stack-item-popped", u), i.undoManager.on("stack-item-updated", c);
  }, i.disconnect = () => {
    i.undoManager.off("stack-item-added", l), i.undoManager.off("stack-item-popped", u), i.undoManager.off("stack-item-updated", c), f();
  }, i.undo = () => {
    Ce.connected(i) && (Ce.flushLocalChanges(i), i.undoManager.undo());
  }, i.redo = () => {
    Ce.connected(i) && (Ce.flushLocalChanges(i), i.undoManager.redo());
  }, i;
}
const Qr = /* @__PURE__ */ new WeakMap(), Br = new fu(), Pn = {
  isCursorEditor(s) {
    return Ce.isYjsEditor(s) && s.awareness && typeof s.cursorDataField == "string" && typeof s.selectionStateField == "string" && typeof s.sendCursorPosition == "function" && typeof s.sendCursorData == "function";
  },
  sendCursorPosition(s, e = s.selection) {
    s.sendCursorPosition(e);
  },
  sendCursorData(s, e) {
    s.sendCursorData(e);
  },
  on(s, e, t) {
    var i;
    if (e !== "change")
      return;
    const n = (i = Qr.get(s)) != null ? i : /* @__PURE__ */ new Set();
    n.add(t), Qr.set(s, n);
  },
  off(s, e, t) {
    if (e !== "change")
      return;
    const n = Qr.get(s);
    n && n.delete(t);
  },
  cursorState(s, e) {
    var n;
    if (e === s.awareness.clientID || !Ce.connected(s))
      return null;
    const t = s.awareness.getStates().get(e);
    return t ? {
      relativeSelection: (n = t[s.selectionStateField]) != null ? n : null,
      data: t[s.cursorDataField],
      clientId: e
    } : null;
  },
  cursorStates(s) {
    return Ce.connected(s) ? Object.fromEntries(
      Array.from(s.awareness.getStates().entries(), ([e, t]) => e === s.awareness.clientID || !t ? null : [
        e,
        {
          relativeSelection: t[s.selectionStateField],
          data: t[s.cursorDataField]
        }
      ]).filter(Array.isArray)
    ) : {};
  },
  // TODO CursorEditor自定义事件处理器
  emitEvent(s, ...e) {
    Br.emit(s, ...e);
  },
  onEvent(s, e) {
    Br.on(s, e);
  },
  offEvent(s, e) {
    Br.off(s, e);
  },
  resetEvent() {
    Br.reset();
  }
};
function Ym(s, e, {
  cursorStateField: t = "selection",
  cursorDataField: n = "data",
  autoSend: i = !0,
  data: r
} = {}) {
  const o = s;
  o.awareness = e, o.cursorDataField = n, o.selectionStateField = t, o.sendCursorData = (u) => {
    o.awareness.setLocalStateField(o.cursorDataField, u);
  }, o.sendCursorPosition = (u) => {
    const d = o.awareness.getLocalState(), f = d == null ? void 0 : d[t];
    if (!u) {
      f && o.awareness.setLocalStateField(o.selectionStateField, null);
      return;
    }
    const { anchor: g, focus: p } = Kr(o.sharedRoot, o, u);
    (!f || !Xc(g, f) || !Xc(p, f)) && o.awareness.setLocalStateField(o.selectionStateField, { anchor: g, focus: p });
  };
  const a = (u) => {
    const d = Qr.get(o);
    if (!d)
      return;
    const f = o.awareness.clientID, g = {
      added: u.added.filter((p) => p !== f),
      removed: u.removed.filter((p) => p !== f),
      updated: u.updated.filter((p) => p !== f)
    };
    (g.added.length > 0 || g.removed.length > 0 || g.updated.length > 0) && d.forEach((p) => p(g));
  }, { connect: l, disconnect: c } = o;
  return o.connect = () => {
    if (l(), o.awareness.on("change", a), a({
      removed: [],
      added: Array.from(o.awareness.getStates().keys()),
      updated: []
    }), i) {
      r && Pn.sendCursorData(o, r);
      const { onChange: u } = o;
      o.onChange = () => {
        u(), Ce.connected(o) && (Pn.sendCursorPosition(o), Pn.emitEvent("updateCursor"));
      };
    }
  }, o.disconnect = () => {
    o.awareness.off("change", a), Pn.resetEvent(), a({
      removed: Array.from(o.awareness.getStates().keys()),
      added: [],
      updated: []
    }), c();
  }, o;
}
function Ld(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Ts(s) {
  const e = Ld(s);
  return new RegExp("(".concat(e, ").+?(").concat(e, ")$"));
}
function Ma(s) {
  const e = Ld(s);
  return new RegExp("^(".concat(e, ")$"));
}
function ka(s) {
  return (e, t) => {
    He.setNodes(e, { type: s }, {
      match: (n) => ne.isBlock(e, n),
      at: t
    });
  };
}
function Xm(s) {
  return (e, t) => {
    const n = ne.rangeRef(e, t);
    He.unwrapNodes(e, {
      at: t,
      match: (r) => ne.isInline(e, r),
      mode: "all",
      split: !0
    }), n.current && He.insertNodes(
      e,
      { text: " " },
      {
        match: pe.isText,
        at: ct.end(n.current),
        select: !0
      }
    );
    const i = n.unref();
    i && He.wrapNodes(e, { type: s, children: [] }, {
      at: i,
      split: !0
    });
  };
}
function ki(s) {
  return (e, t) => {
    He.insertNodes(
      e,
      { text: " " },
      {
        match: pe.isText,
        at: ct.end(t),
        select: !0
      }
    ), He.setNodes(
      e,
      { [s]: !0 },
      {
        match: pe.isText,
        at: t,
        split: !0
      }
    );
  };
}
const Zm = [
  { trigger: Ma("#"), apply: ka("heading-one") },
  { trigger: Ma("##"), apply: ka("heading-two") },
  { trigger: Ma(">"), apply: ka("block-quote") },
  { trigger: Ts("`"), apply: Xm("inline-code") },
  { trigger: Ts("**"), apply: ki("bold") },
  { trigger: Ts("__"), apply: ki("bold") },
  { trigger: Ts("*"), apply: ki("italic") },
  { trigger: Ts("_"), apply: ki("italic") },
  { trigger: Ts("~~"), apply: ki("strikethrough") }
];
function eo(s, e, t) {
  if (e.offset >= t)
    return { offset: e.offset - t, path: e.path };
  const n = ne.previous(s, {
    at: e.path,
    match: pe.isText
  });
  if (!n)
    return;
  const [i, r] = n;
  return eo(
    s,
    { offset: i.text.length, path: r },
    t - e.offset
  );
}
function Km(s) {
  const { deleteBackward: e, insertText: t, isInline: n, insertBreak: i } = s;
  return s.insertText = (r) => {
    const { selection: o } = s;
    if (r !== " " || !o || !ct.isCollapsed(o))
      return t(r);
    const { anchor: a } = o, l = ne.above(s, {
      match: (f) => ne.isBlock(s, f)
    }), c = l ? l[1] : [], u = { anchor: a, focus: ne.start(s, c) }, d = ne.string(s, u);
    for (const { trigger: f, apply: g } of Zm) {
      const p = f.exec(d);
      if (!p)
        continue;
      const [m, w, v] = p;
      ne.withoutNormalizing(s, () => {
        const y = a, b = v && eo(s, y, v.length), x = w && eo(s, y, m.length - w.length), C = eo(s, y, m.length);
        if (!y || !C)
          return;
        const A = ne.rangeRef(s, {
          anchor: C,
          focus: y
        });
        b && He.delete(s, {
          at: { anchor: b, focus: y }
        }), x && He.delete(s, {
          at: { anchor: C, focus: x }
        });
        const k = A.unref();
        k && g(s, k);
      });
      return;
    }
    t(r);
  }, s.insertBreak = () => {
    var a;
    const { selection: r } = s;
    if (we.getSelectedNodeByType(s, "layout")) {
      i();
      return;
    }
    if (r) {
      const l = ne.above(s, {
        match: (f) => ne.isBlock(s, f)
      }), c = l ? l[1] : [], u = ne.end(s, c), d = so.equals(
        u,
        ct.end(r)
      );
      if (He.splitNodes(s, { always: !0 }), d) {
        He.unwrapNodes(s, {
          match: (g) => ne.isInline(s, g),
          mode: "all"
        }), He.setNodes(s, { type: "paragraph" }, {
          match: (g) => ne.isBlock(s, g)
        });
        const f = (a = ne.marks(s)) != null ? a : {};
        He.unsetNodes(s, Object.keys(f), {
          match: pe.isText
        });
      }
    }
  }, s.deleteBackward = (...r) => {
    if (we.getSelectedNodeByType(s, "layout")) {
      e(...r);
      return;
    }
    const { selection: a } = s;
    if (a && ct.isCollapsed(a)) {
      const l = ne.above(s, {
        match: (c) => ne.isBlock(s, c)
      });
      if (l) {
        const [c, u] = l, d = ne.start(s, u);
        if (!ne.isEditor(c) && Ui.isElement(c) && c.type !== "paragraph" && so.equals(a.anchor, d)) {
          const f = {
            type: "paragraph"
          };
          He.setNodes(s, f);
          return;
        }
      }
      e(...r);
    }
  }, s.isInline = (r) => Ui.isElement(r) && r.type === "inline-code" || n(r), s;
}
function Qm(s) {
  const { normalizeNode: e } = s;
  return s.normalizeNode = (t) => {
    const [n] = t;
    if (!ne.isEditor(n) || n.children.length > 0)
      return e(t);
    const i = {
      type: "paragraph",
      children: [{ text: "" }]
    };
    He.insertNodes(s, i, { at: [0] });
  }, s;
}
class Xs {
  /**
   * 获取主题
   * @returns
   */
  static getThemeVar() {
    const e = document.documentElement;
    return e ? getComputedStyle(e).getPropertyValue("--ibiz-color-primary") : null;
  }
  /**
   * 是否包含中文字符
   * @param inputString
   * @returns
   */
  static isChineseCharacter(e) {
    return /[\u4e00-\u9fa5]/.test(e);
  }
  /**
   * 判断字符串是否同时存在英文和中文
   * @param str
   * @returns
   */
  static hasChineseAndEnglish(e) {
    return /[\u4e00-\u9fa5]+.*[a-zA-Z]+|[a-zA-Z]+.*[\u4e00-\u9fa5]+/.test(e);
  }
  /**
   * 字符串转16进制颜色
   * @param text
   * @returns
   */
  static stringToHexColor(e) {
    if (!e)
      return "";
    let t = 0;
    for (let l = 0; l < e.length; l++)
      if (this.isChineseCharacter(e))
        t = e.charCodeAt(l) + ((t << 5) - t), t = t & t;
      else {
        const c = e.charCodeAt(l);
        t += c.toString(16);
      }
    const n = String(t).substring(0, 6);
    let i = parseInt(n.substring(0, 2), 16), r = parseInt(n.substring(2, 4), 16), o = parseInt(n.substring(4, 6), 16);
    i < 0 && (i = 10), r < 0 && (r = 10), o < 0 && (o = 10);
    const a = "#".concat(i.toString(16).padStart(2, "0")).concat(r.toString(16).padStart(2, "0")).concat(o.toString(16).padStart(2, "0"));
    return a === "#FFFFFF" && this.getThemeVar() || a;
  }
  /**
   * 缩写名字
   * @param text
   * @returns
   */
  static avatarName(e) {
    if (e && e.toString().length < 2)
      return e;
    if (e && e.toString().length >= 2) {
      if (this.hasChineseAndEnglish(e)) {
        const r = e.split("").find((a) => /[a-zA-Z]/.test(a)) || "", o = e.split("").find((a) => /[\u4E00-\u9FA5]/.test(a)) || "";
        return "".concat(r).concat(o).toLowerCase();
      }
      return /[a-zA-Z]/.test(e) ? e.split("").filter((r) => /[a-zA-Z]/.test(r)).slice(0, 2).join("").toUpperCase() : /[\u4E00-\u9FA5]/.test(e) ? e.split("").filter((r) => /[\u4E00-\u9FA5]/.test(r)).slice(-2).join("") : e.replaceAll(" ", "").substring(0, 2);
    }
  }
  /**
   * 解析emoji表情
   *
   * @param {string} value
   * @return {*}  {string}
   */
  static getEmojiCustomHtml(e) {
    return e.replaceAll(/{"emoji":"(.+?)"}/g, (t, n) => {
      const i = decodeURIComponent(atob(n));
      return '<span class="emoji-tag">'.concat(i, "</span>");
    }).replaceAll(
      /<span data-w-e-type="emoji" class='emoji'>(.+?)<\/span>/g,
      (t, n) => {
        const i = decodeURIComponent(atob(n));
        return "<span data-w-e-type=\"emoji\" class='emoji'>".concat(i, "</span>");
      }
    );
  }
}
function e2(s, e) {
  const t = Math.round(Math.min(Math.max(e, 0), 1) * 255);
  return s + t.toString(16).toUpperCase();
}
function t2(s) {
  return {
    color: Xs.stringToHexColor(s),
    name: "".concat(s)
  };
}
const n2 = globalThis.Text, Nd = (s) => {
  var e, t;
  return (t = (e = s == null ? void 0 : s.ownerDocument) == null ? void 0 : e.defaultView) != null ? t : null;
}, s2 = (s) => {
  const e = Nd(s);
  return !!e && s instanceof e.Node;
}, hh = (s) => s2(s) && s.nodeType === 1;
function uh(s, e) {
  var l;
  const [t] = ne.node(s, e.path), n = s.toDOMNode(t);
  let i;
  ne.void(s, { at: e }) && (e = { path: e.path, offset: 0 });
  const r = "[data-slate-string], [data-slate-zero-width]", o = Array.from(n.querySelectorAll(r));
  let a = 0;
  for (let c = 0; c < o.length; c++) {
    const u = o[c], d = u.childNodes[0];
    if (d == null || d.textContent == null)
      continue;
    const { length: f } = d.textContent, g = u.getAttribute("data-slate-length"), p = g == null ? f : parseInt(g, 10), m = a + p, w = o[c + 1];
    if (e.offset === m && (w != null && w.hasAttribute("data-slate-mark-placeholder"))) {
      const v = w.childNodes[0];
      i = [
        v instanceof n2 ? v : w,
        (l = w.textContent) != null && l.startsWith("\uFEFF") ? 1 : 0
      ];
      break;
    }
    if (e.offset <= m) {
      const v = Math.min(f, Math.max(0, e.offset - a));
      i = [d, v];
      break;
    }
    a = m;
  }
  if (!i)
    throw new Error(
      "Cannot resolve a DOM point from Slate point: ".concat(JSON.stringify(e))
    );
  return i;
}
function i2(s, e) {
  const { anchor: t, focus: n } = e, i = ct.isBackward(e), r = uh(s, t), o = ct.isCollapsed(e) ? r : uh(s, n), l = s.editorWindow.document.createRange(), [c, u] = i ? o : r, [d, f] = i ? r : o, p = !!(hh(c) ? c : c.parentElement).getAttribute("data-slate-zero-width"), w = !!(hh(d) ? d : d.parentElement).getAttribute("data-slate-zero-width");
  return l.setStart(c, p ? 1 : u), l.setEnd(d, w ? 1 : f), l;
}
function r2(s, e) {
  try {
    return i2(s, e);
  } catch (t) {
    return null;
  }
}
const dh = /* @__PURE__ */ new WeakMap();
function fh(s, e) {
  if (!e.relativeSelection || !s)
    return null;
  let t = dh.get(s.children);
  t || (t = /* @__PURE__ */ new WeakMap(), dh.set(s.children, t));
  let n = t.get(e);
  if (n === void 0)
    try {
      n = Td(
        s.sharedRoot,
        s,
        e.relativeSelection
      ), t.set(e, n);
    } catch (i) {
      return null;
    }
  return n;
}
function o2(s, e, { yOffset: t, xOffset: n, shouldGenerateOverlay: i }) {
  const [r, o] = ct.edges(e), a = r2(s, e);
  if (!a)
    return {
      caretPosition: null,
      selectionRects: []
    };
  const l = [], c = ne.nodes(s, {
    at: e,
    match: (f, g) => pe.isText(f) && (!i || i(f, g))
  });
  let u = null;
  const d = ct.isBackward(e);
  for (const [f, g] of c) {
    const p = s.toDOMNode(f), m = hs.equals(g, r.path), w = hs.equals(g, o.path);
    let v = null;
    if (m || w) {
      const b = document.createRange();
      b.selectNode(p), m && b.setStart(a.startContainer, a.startOffset), w && b.setEnd(a.endContainer, a.endOffset), v = b.getClientRects();
    } else
      v = p.getClientRects();
    const y = d ? m : w;
    for (let b = 0; b < v.length; b++) {
      const x = v.item(b);
      if (!x)
        continue;
      const C = y && (d ? b === 0 : b === v.length - 1), A = x.top - t, k = x.left - n;
      C && (u = {
        height: "".concat(x.height, "px"),
        top: "".concat(A, "px"),
        left: "".concat(k + (d || ct.isCollapsed(e) ? 0 : x.width), "px")
      }), l.push({
        width: "".concat(x.width, "px"),
        height: "".concat(x.height, "px"),
        top: "".concat(A, "px"),
        left: "".concat(k, "px")
      });
    }
  }
  return {
    selectionRects: l,
    caretPosition: u
  };
}
const a2 = /* @__PURE__ */ ye({
  name: "CursorCaret",
  props: {
    data: {
      type: Object,
      required: !0
    },
    caretPosition: Object
  },
  setup(s) {
    const e = me("cursor-caret"), t = qe(() => ({
      ...s.caretPosition,
      background: s.data.color
    })), n = qe(() => ({
      transform: "translateY(-100%)",
      background: s.data.color
    }));
    return {
      ns: e,
      caretStyle: t,
      labelStyle: n
    };
  },
  render() {
    return S("div", {
      style: this.caretStyle,
      class: this.ns.b()
    }, [S("div", {
      class: this.ns.e("text"),
      style: this.labelStyle
    }, [this.data.name])]);
  }
});
const l2 = /* @__PURE__ */ ye({
  name: "CursorSelection",
  props: {
    data: Object,
    selectionRects: Array,
    caretPosition: Object
  },
  setup(s) {
    const e = me("cursor-selection"), t = qe(() => ({
      backgroundColor: e2(s.data.color, 0.5)
    }));
    return {
      ns: e,
      selectionStyle: t
    };
  },
  render() {
    var s;
    return this.data ? S(rp, null, [(s = this.selectionRects) == null ? void 0 : s.map((e, t) => S("div", {
      style: {
        ...this.selectionStyle,
        ...e
      },
      class: this.ns.b(),
      key: t
    }, null)), this.caretPosition && S(a2, {
      caretPosition: this.caretPosition,
      data: this.data
    }, null)]) : null;
  }
});
function c2(s, e) {
  let t = null;
  fn(() => {
    s.value && (t = new ResizeObserver(() => {
      e();
    }), t.observe(s.value));
  }), fr(() => {
    t && s.value && t.unobserve(s.value);
  });
}
const gh = Object.freeze([]);
function h2(s) {
  var u;
  const { slateYjs: e, containerRef: t, shouldGenerateOverlay: n } = s, i = "refreshOnResize" in s && (u = s.refreshOnResize) != null ? u : !0, r = /* @__PURE__ */ new Map(), o = L({}), a = () => {
    var w, v, y;
    if (t && !t.value || !e.yjsEditor)
      return;
    const d = (w = t == null ? void 0 : t.value) == null ? void 0 : w.getBoundingClientRect(), f = (v = d == null ? void 0 : d.x) != null ? v : 0, g = (y = d == null ? void 0 : d.y) != null ? y : 0;
    let p = Object.keys(o.value).length !== Object.keys(e.cursorStates).length;
    const m = Object.fromEntries(
      Object.entries(e.cursorStates).map(([b, x]) => {
        const C = x.relativeSelection && fh(e.yjsEditor, x);
        if (!C)
          return [b, gh];
        const A = r.get(C);
        if (A)
          return [b, A];
        const k = o2(
          e.yjsEditor,
          C,
          {
            xOffset: f,
            yOffset: g,
            shouldGenerateOverlay: n
          }
        );
        return p = !0, r.set(C, k), [b, k];
      })
    );
    p && (o.value = m);
  }, l = () => {
    r.clear(), a();
  };
  return i && c2(t, l), Pn.onEvent("updateCursor", Ll(a, 0)), Be(
    () => e.cursorStates,
    () => a(),
    { deep: !0, immediate: !0 }
  ), {
    overlayData: qe(() => Object.entries(e.cursorStates).map(([d, f]) => {
      var m, w;
      const g = f.relativeSelection && fh(e.yjsEditor, f), p = o.value[d];
      return {
        ...f,
        range: g,
        caretPosition: (m = p == null ? void 0 : p.caretPosition) != null ? m : null,
        selectionRects: (w = p == null ? void 0 : p.selectionRects) != null ? w : gh
      };
    })),
    refresh: l
  };
}
const u2 = /* @__PURE__ */ ye({
  name: "CursorOverlay",
  props: {
    slateYjs: {
      type: Object,
      required: !0
    }
  },
  setup(s) {
    const e = me("cursor-overlay"), t = L(), {
      overlayData: n
    } = h2({
      slateYjs: s.slateYjs,
      containerRef: t
    });
    return {
      ns: e,
      overlayData: n,
      containerRef: t
    };
  },
  render() {
    var s, e;
    return S("div", {
      class: this.ns.b(),
      ref: "containerRef"
    }, [(e = (s = this.$slots).default) == null ? void 0 : e.call(s), this.overlayData.map((t) => S(l2, op({
      key: t.clientId
    }, t), null))]);
  }
});
class d2 {
  /**
   * Creates an instance of CollaborateService.
   * @author tony001
   * @date 2024-08-06 11:08:59
   * @param {string} id
   * @param {string} mqttTopic
   * @param {string} token
   * @param {string} appId
   */
  constructor(e, t, n, i) {
    /**
     * 发送消息
     *
     * @author tony001
     * @date 2024-08-06 11:08:00
     * @protected
     */
    E(this, "collaborateUrl", "/portal/collaborate");
    /**
     * 连接状态
     *
     * @author tony001
     * @date 2024-08-06 11:08:20
     * @protected
     * @type {number}
     */
    E(this, "readyState");
    /**
     * 事件对象
     *
     * @author tony001
     * @date 2024-08-05 19:08:09
     */
    E(this, "evt", new fu());
    /**
     * mqtt 连接实例
     *
     * @author tony001
     * @date 2024-08-05 19:08:52
     * @type {MqttClient}
     */
    E(this, "client");
    /**
     * 连接选项
     *
     * @author tony001
     * @date 2024-08-05 19:08:06
     * @protected
     * @type {IClientOptions}
     */
    E(this, "options", {
      // 超时时间
      connectTimeout: 6e3,
      // 认证信息
      clientId: nt(),
      username: "",
      password: "",
      // 心跳时间
      keepalive: 60,
      clean: !0
    });
    this.id = e, this.mqttTopic = t, this.token = n, this.appId = i, this.options.username = t, this.options.password = n, this.readyState = 0;
  }
  /**
   * 发送消息
   *
   * @author tony001
   * @date 2024-08-06 11:08:40
   * @param {(string | ArrayBufferLike | Blob | ArrayBufferView)} data
   */
  send(e) {
    ibiz.net.post("".concat(this.collaborateUrl, "/ROOM/").concat(this.id), { data: e });
  }
  /**
   * mqtt 连接
   *
   * @author tony001
   * @date 2024-08-05 19:08:17
   * @return {*}  {Promise<void>}
   */
  async connect() {
    const e = await import("./mqtt.min-d765cb0e.js").then((i) => i.m), t = e.default ? e.default : e, { location: n } = window;
    this.client = t.connect(
      "ws://".concat(n.host).concat(ibiz.env.baseUrl, "/").concat(this.appId).concat(ibiz.env.mqttUrl),
      this.options
    ), this.client.on("connect", () => {
      this.client.subscribe(this.mqttTopic), this.readyState = 1, this.evt.emit("connect"), ibiz.log.debug("collaborate connect");
    }), this.client.on("error", (i) => {
      this.readyState = 3, this.evt.emit("error", i), ibiz.log.debug("collaborate error");
    }), this.client.on("message", (i, r) => {
      const o = JSON.parse(r.toString());
      o && o.data && o.data.data && o.data.data.data && this.evt.emit(
        "message",
        new Uint8Array(Object.values(o.data.data.data))
      ), ibiz.log.debug("collaborate message");
    }), this.client.on("reconnect", () => {
      this.readyState = 0, this.evt.emit("reconnect");
    }), this.client.on("close", () => {
      this.readyState = 3, this.evt.emit("close"), ibiz.log.debug("collaborate close");
    });
  }
  /**
   * 结束 mqtt 连接
   *
   * @author tony001
   * @date 2024-08-05 19:08:02
   */
  close() {
    var e;
    (e = this.client) == null || e.end(), this.evt.reset();
  }
}
const $s = () => /* @__PURE__ */ new Map(), Dd = (s, e, t) => {
  let n = s.get(e);
  return n === void 0 && s.set(e, n = t()), n;
}, f2 = String.fromCharCode, g2 = (s) => s.toLowerCase(), p2 = /^\s*/g, m2 = (s) => s.replace(p2, ""), w2 = /([A-Z])/g, ph = (s, e) => m2(s.replace(w2, (t) => "".concat(e).concat(g2(t)))), y2 = (s) => {
  const e = unescape(encodeURIComponent(s)), t = e.length, n = new Uint8Array(t);
  for (let i = 0; i < t; i++)
    n[i] = /** @type {number} */
    e.codePointAt(i);
  return n;
}, qo = (
  /** @type {TextEncoder} */
  typeof TextEncoder < "u" ? new TextEncoder() : null
), b2 = (s) => qo.encode(s), v2 = qo ? b2 : y2;
let Di = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
Di && Di.decode(new Uint8Array()).length === 1 && (Di = null);
const mh = (s) => s === void 0 ? null : s;
class x2 {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(e, t) {
    this.map.set(e, t);
  }
  /**
   * @param {string} key
   */
  getItem(e) {
    return this.map.get(e);
  }
}
let Id = new x2(), jd = !0;
try {
  typeof localStorage < "u" && (Id = localStorage, jd = !1);
} catch (s) {
}
const Rd = Id, C2 = (s) => jd || addEventListener(
  "storage",
  /** @type {any} */
  s
), nr = typeof process < "u" && process.release && /node|io\.js/.test(process.release.name), Bd = typeof window < "u" && !nr;
let Ut;
const E2 = () => {
  if (Ut === void 0)
    if (nr) {
      Ut = $s();
      const s = process.argv;
      let e = null;
      for (let t = 0; t < s.length; t++) {
        const n = s[t];
        n[0] === "-" ? (e !== null && Ut.set(e, ""), e = n) : e !== null && (Ut.set(e, n), e = null);
      }
      e !== null && Ut.set(e, "");
    } else
      typeof location == "object" ? (Ut = $s(), (location.search || "?").slice(1).split("&").forEach((s) => {
        if (s.length !== 0) {
          const [e, t] = s.split("=");
          Ut.set("--".concat(ph(e, "-")), t), Ut.set("-".concat(ph(e, "-")), t);
        }
      })) : Ut = $s();
  return Ut;
}, S2 = (s) => E2().has(s), A2 = (s) => mh(nr ? process.env[s.toUpperCase()] : Rd.getItem(s)), M2 = (s) => S2("--" + s) || A2(s) !== null;
M2("production");
const Fd = Math.floor, $d = (s, e) => s < e ? s : e, k2 = (s, e) => s > e ? s : e, P2 = Math.pow, zd = 128, to = 127, _2 = Number.MAX_SAFE_INTEGER;
class O2 {
  constructor() {
    this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = [];
  }
}
const xt = () => new O2(), Ql = (s) => {
  let e = s.cpos;
  for (let t = 0; t < s.bufs.length; t++)
    e += s.bufs[t].length;
  return e;
}, pt = (s) => {
  const e = new Uint8Array(Ql(s));
  let t = 0;
  for (let n = 0; n < s.bufs.length; n++) {
    const i = s.bufs[n];
    e.set(i, t), t += i.length;
  }
  return e.set(Ud(s.cbuf.buffer, 0, s.cpos), t), e;
}, po = (s, e) => {
  const t = s.cbuf.length;
  s.cpos === t && (s.bufs.push(s.cbuf), s.cbuf = new Uint8Array(t * 2), s.cpos = 0), s.cbuf[s.cpos++] = e;
}, Pe = (s, e) => {
  for (; e > to; )
    po(s, zd | to & e), e = Fd(e / 128);
  po(s, to & e);
}, ll = new Uint8Array(3e4), T2 = ll.length / 3, L2 = (s, e) => {
  if (e.length < T2) {
    const t = qo.encodeInto(e, ll).written || 0;
    Pe(s, t);
    for (let n = 0; n < t; n++)
      po(s, ll[n]);
  } else
    ln(s, v2(e));
}, N2 = (s, e) => {
  const t = unescape(encodeURIComponent(e)), n = t.length;
  Pe(s, n);
  for (let i = 0; i < n; i++)
    po(
      s,
      /** @type {number} */
      t.codePointAt(i)
    );
}, D2 = qo ? L2 : N2, I2 = (s, e) => {
  const t = s.cbuf.length, n = s.cpos, i = $d(t - n, e.length), r = e.length - i;
  s.cbuf.set(e.subarray(0, i), n), s.cpos += i, r > 0 && (s.bufs.push(s.cbuf), s.cbuf = new Uint8Array(k2(t * 2, r)), s.cbuf.set(e.subarray(i)), s.cpos = r);
}, ln = (s, e) => {
  Pe(s, e.byteLength), I2(s, e);
};
class j2 {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(e) {
    this.arr = e, this.pos = 0;
  }
}
const Vd = (s) => new j2(s), R2 = (s, e) => {
  const t = Ud(s.arr.buffer, s.pos + s.arr.byteOffset, e);
  return s.pos += e, t;
}, Go = (s) => R2(s, Tn(s)), wh = (s) => s.arr[s.pos++], Tn = (s) => {
  let e = 0, t = 1;
  for (; ; ) {
    const n = s.arr[s.pos++];
    if (e = e + (n & to) * t, t *= 128, n < zd)
      return e;
    if (e > _2)
      throw new Error("Integer out of range!");
  }
}, B2 = (s) => {
  let e = Tn(s);
  if (e === 0)
    return "";
  {
    let t = String.fromCodePoint(wh(s));
    if (--e < 100)
      for (; e--; )
        t += String.fromCodePoint(wh(s));
    else
      for (; e > 0; ) {
        const n = e < 1e4 ? e : 1e4, i = s.arr.subarray(s.pos, s.pos + n);
        s.pos += n, t += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          i
        ), e -= n;
      }
    return decodeURIComponent(escape(t));
  }
}, F2 = (s) => (
  /** @type any */
  Di.decode(Go(s))
), Hd = Di ? F2 : B2, $2 = (s) => new Uint8Array(s), Ud = (s, e, t) => new Uint8Array(s, e, t), z2 = (s) => new Uint8Array(s), V2 = (s) => {
  let e = "";
  for (let t = 0; t < s.byteLength; t++)
    e += f2(s[t]);
  return btoa(e);
}, H2 = (s) => Buffer.from(s.buffer, s.byteOffset, s.byteLength).toString("base64"), U2 = (s) => {
  const e = atob(s), t = $2(e.length);
  for (let n = 0; n < e.length; n++)
    t[n] = e.charCodeAt(n);
  return t;
}, q2 = (s) => {
  const e = Buffer.from(s, "base64");
  return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
}, G2 = Bd ? V2 : H2, W2 = Bd ? U2 : q2, J2 = /* @__PURE__ */ new Map();
class Y2 {
  /**
   * @param {string} room
   */
  constructor(e) {
    this.room = e, this.onmessage = null, C2((t) => t.key === e && this.onmessage !== null && this.onmessage({ data: W2(t.newValue || "") }));
  }
  /**
   * @param {ArrayBuffer} buf
   */
  postMessage(e) {
    Rd.setItem(this.room, G2(z2(e)));
  }
}
const X2 = typeof BroadcastChannel > "u" ? Y2 : BroadcastChannel, ec = (s) => Dd(J2, s, () => {
  const e = /* @__PURE__ */ new Set(), t = new X2(s);
  return t.onmessage = (n) => e.forEach((i) => i(n.data, "broadcastchannel")), {
    bc: t,
    subs: e
  };
}), Z2 = (s, e) => ec(s).subs.add(e), K2 = (s, e) => ec(s).subs.delete(e), Ds = (s, e, t = null) => {
  const n = ec(s);
  n.bc.postMessage(e), n.subs.forEach((i) => i(e, t));
}, ps = Date.now, qd = 0, tc = 1, Gd = 2, cl = (s, e) => {
  Pe(s, qd);
  const t = c0(e);
  ln(s, t);
}, Wd = (s, e, t) => {
  Pe(s, tc), ln(s, r0(e, t));
}, Q2 = (s, e, t) => Wd(e, t, Go(s)), Jd = (s, e, t) => {
  try {
    n0(e, Go(s), t);
  } catch (n) {
    console.error("Caught error while handling a Yjs update", n);
  }
}, e4 = (s, e) => {
  Pe(s, Gd), ln(s, e);
}, t4 = Jd, n4 = (s, e, t, n) => {
  const i = Tn(s);
  switch (i) {
    case qd:
      Q2(s, e, t);
      break;
    case tc:
      Jd(s, t, n);
      break;
    case Gd:
      t4(s, t, n);
      break;
    default:
      throw new Error("Unknown message type");
  }
  return i;
}, s4 = 0, i4 = (s, e, t) => {
  switch (Tn(s)) {
    case s4:
      t(e, Hd(s));
  }
}, r4 = () => /* @__PURE__ */ new Set(), o4 = Array.from;
class Yd {
  constructor() {
    this._observers = $s();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(e, t) {
    Dd(this._observers, e, r4).add(t);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(e, t) {
    const n = (...i) => {
      this.off(e, n), t(...i);
    };
    this.on(e, n);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(e, t) {
    const n = this._observers.get(e);
    n !== void 0 && (n.delete(t), n.size === 0 && this._observers.delete(e));
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(e, t) {
    return o4((this._observers.get(e) || $s()).values()).forEach((n) => n(...t));
  }
  destroy() {
    this._observers = $s();
  }
}
const a4 = Object.keys, l4 = (s, e) => {
  const t = [];
  for (const n in s)
    t.push(e(s[n], n));
  return t;
}, yh = (s) => a4(s).length, c4 = (s, e) => Object.prototype.hasOwnProperty.call(s, e), h4 = (s, e) => s === e, Ii = (s, e) => {
  if (s == null || e == null)
    return h4(s, e);
  if (s.constructor !== e.constructor)
    return !1;
  if (s === e)
    return !0;
  switch (s.constructor) {
    case ArrayBuffer:
      s = new Uint8Array(s), e = new Uint8Array(e);
    case Uint8Array: {
      if (s.byteLength !== e.byteLength)
        return !1;
      for (let t = 0; t < s.length; t++)
        if (s[t] !== e[t])
          return !1;
      break;
    }
    case Set: {
      if (s.size !== e.size)
        return !1;
      for (const t of s)
        if (!e.has(t))
          return !1;
      break;
    }
    case Map: {
      if (s.size !== e.size)
        return !1;
      for (const t of s.keys())
        if (!e.has(t) || !Ii(s.get(t), e.get(t)))
          return !1;
      break;
    }
    case Object:
      if (yh(s) !== yh(e))
        return !1;
      for (const t in s)
        if (!c4(s, t) || !Ii(s[t], e[t]))
          return !1;
      break;
    case Array:
      if (s.length !== e.length)
        return !1;
      for (let t = 0; t < s.length; t++)
        if (!Ii(s[t], e[t]))
          return !1;
      break;
    default:
      return !1;
  }
  return !0;
}, Pa = 3e4;
class u4 extends Yd {
  /**
   * @param {Y.Doc} doc
   */
  constructor(e) {
    super(), this.doc = e, this.clientID = e.clientID, this.states = /* @__PURE__ */ new Map(), this.meta = /* @__PURE__ */ new Map(), this._checkInterval = /** @type {any} */
    setInterval(() => {
      const t = ps();
      this.getLocalState() !== null && Pa / 2 <= t - /** @type {{lastUpdated:number}} */
      this.meta.get(this.clientID).lastUpdated && this.setLocalState(this.getLocalState());
      const n = [];
      this.meta.forEach((i, r) => {
        r !== this.clientID && Pa <= t - i.lastUpdated && this.states.has(r) && n.push(r);
      }), n.length > 0 && nc(this, n, "timeout");
    }, Fd(Pa / 10)), e.on("destroy", () => {
      this.destroy();
    }), this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]), this.setLocalState(null), super.destroy(), clearInterval(this._checkInterval);
  }
  /**
   * @return {Object<string,any>|null}
   */
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState(e) {
    const t = this.clientID, n = this.meta.get(t), i = n === void 0 ? 0 : n.clock + 1, r = this.states.get(t);
    e === null ? this.states.delete(t) : this.states.set(t, e), this.meta.set(t, {
      clock: i,
      lastUpdated: ps()
    });
    const o = [], a = [], l = [], c = [];
    e === null ? c.push(t) : r == null ? e != null && o.push(t) : (a.push(t), Ii(r, e) || l.push(t)), (o.length > 0 || l.length > 0 || c.length > 0) && this.emit("change", [{ added: o, updated: l, removed: c }, "local"]), this.emit("update", [{ added: o, updated: a, removed: c }, "local"]);
  }
  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField(e, t) {
    const n = this.getLocalState();
    n !== null && this.setLocalState({
      ...n,
      [e]: t
    });
  }
  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates() {
    return this.states;
  }
}
const nc = (s, e, t) => {
  const n = [];
  for (let i = 0; i < e.length; i++) {
    const r = e[i];
    if (s.states.has(r)) {
      if (s.states.delete(r), r === s.clientID) {
        const o = (
          /** @type {MetaClientState} */
          s.meta.get(r)
        );
        s.meta.set(r, {
          clock: o.clock + 1,
          lastUpdated: ps()
        });
      }
      n.push(r);
    }
  }
  n.length > 0 && (s.emit("change", [{ added: [], updated: [], removed: n }, t]), s.emit("update", [{ added: [], updated: [], removed: n }, t]));
}, ji = (s, e, t = s.states) => {
  const n = e.length, i = xt();
  Pe(i, n);
  for (let r = 0; r < n; r++) {
    const o = e[r], a = t.get(o) || null, l = (
      /** @type {MetaClientState} */
      s.meta.get(o).clock
    );
    Pe(i, o), Pe(i, l), D2(i, JSON.stringify(a));
  }
  return pt(i);
}, d4 = (s, e, t) => {
  const n = Vd(e), i = ps(), r = [], o = [], a = [], l = [], c = Tn(n);
  for (let u = 0; u < c; u++) {
    const d = Tn(n);
    let f = Tn(n);
    const g = JSON.parse(Hd(n)), p = s.meta.get(d), m = s.states.get(d), w = p === void 0 ? 0 : p.clock;
    (w < f || w === f && g === null && s.states.has(d)) && (g === null ? d === s.clientID && s.getLocalState() != null ? f++ : s.states.delete(d) : s.states.set(d, g), s.meta.set(d, {
      clock: f,
      lastUpdated: i
    }), p === void 0 && g !== null ? r.push(d) : p !== void 0 && g === null ? l.push(d) : g !== null && (Ii(g, m) || a.push(d), o.push(d)));
  }
  (r.length > 0 || a.length > 0 || l.length > 0) && s.emit("change", [{
    added: r,
    updated: a,
    removed: l
  }, t]), (r.length > 0 || o.length > 0 || l.length > 0) && s.emit("update", [{
    added: r,
    updated: o,
    removed: l
  }, t]);
}, f4 = (s) => l4(s, (e, t) => "".concat(encodeURIComponent(t), "=").concat(encodeURIComponent(e))).join("&"), ts = 0, Xd = 3, zs = 1, g4 = 2, vr = [];
vr[ts] = (s, e, t, n, i) => {
  Pe(s, ts);
  const r = n4(
    e,
    s,
    t.doc,
    t
  );
  n && r === tc && !t.synced && (t.synced = !0);
};
vr[Xd] = (s, e, t, n, i) => {
  Pe(s, zs), ln(
    s,
    ji(
      t.awareness,
      Array.from(t.awareness.getStates().keys())
    )
  );
};
vr[zs] = (s, e, t, n, i) => {
  d4(
    t.awareness,
    Go(e),
    t
  );
};
vr[g4] = (s, e, t, n, i) => {
  i4(
    e,
    t.doc,
    (r, o) => p4(t, o)
  );
};
const bh = 3e4, p4 = (s, e) => console.warn("Permission denied to access ".concat(s.url, ".\n").concat(e)), Zd = (s, e, t) => {
  const n = Vd(e), i = xt(), r = Tn(n), o = s.messageHandlers[r];
  return /** @type {any} */ o ? o(i, n, s, t, r) : console.error("Unable to compute message"), i;
}, Kd = (s) => {
  if (s.shouldConnect && s.ws === null) {
    const e = s._WS;
    s.ws = e, s.wsconnecting = !0, s.wsconnected = !1, s.synced = !1, e.evt.on("message", (t) => {
      s.wsLastMessageReceived = ps();
      const n = Zd(s, t, !0);
      Ql(n) > 1 && e.send(pt(n));
    }), e.evt.on("error", (t) => {
      s.emit("connection-error", [t, s]);
    }), e.evt.on("close", (t) => {
      s.emit("connection-close", [t, s]), s.ws = null, s.wsconnecting = !1, s.wsconnected ? (s.wsconnected = !1, s.synced = !1, nc(
        s.awareness,
        Array.from(s.awareness.getStates().keys()).filter(
          (n) => n !== s.doc.clientID
        ),
        s
      ), s.emit("status", [
        {
          status: "disconnected"
        }
      ])) : s.wsUnsuccessfulReconnects++, setTimeout(
        Kd,
        $d(
          P2(2, s.wsUnsuccessfulReconnects) * 100,
          s.maxBackoffTime
        ),
        s
      );
    }), e.evt.on("connect", () => {
      s.wsLastMessageReceived = ps(), s.wsconnecting = !1, s.wsconnected = !0, s.wsUnsuccessfulReconnects = 0, s.emit("status", [
        {
          status: "connected"
        }
      ]);
      const t = xt();
      if (Pe(t, ts), cl(t, s.doc), e.send(pt(t)), s.awareness.getLocalState() !== null) {
        const n = xt();
        Pe(n, zs), ln(
          n,
          ji(s.awareness, [
            s.doc.clientID
          ])
        ), e.send(pt(n));
      }
    }), s.emit("status", [
      {
        status: "connecting"
      }
    ]);
  }
}, _a = (s, e) => {
  const t = s.ws;
  s.wsconnected && t && t.readyState === 1 && t.send(e), s.bcconnected && Ds(s.bcChannel, e, s);
};
class m4 extends Yd {
  /**
   * @param {string} serverUrl
   * @param {string} roomname
   * @param {Y.Doc} doc
   * @param {object} opts
   * @param {boolean} [opts.connect]
   * @param {awarenessProtocol.Awareness} [opts.awareness]
   * @param {Object<string,string>} [opts.params] specify url parameters
   * @param {Array<string>} [opts.protocols] specify websocket protocols
   * @param {typeof Object} [opts.WebSocketPolyfill] Optionall provide a Object polyfill
   * @param {number} [opts.resyncInterval] Request server state every `resyncInterval` milliseconds
   * @param {number} [opts.maxBackoffTime] Maximum amount of time to wait before trying to reconnect (we try to reconnect using exponential backoff)
   * @param {boolean} [opts.disableBc] Disable cross-tab BroadcastChannel communication
   */
  constructor(e, t, n, {
    connect: i = !0,
    awareness: r = new u4(n),
    params: o = {},
    protocols: a = [],
    WebSocketPolyfill: l,
    resyncInterval: c = -1,
    maxBackoffTime: u = 2500,
    disableBc: d = !1
  } = {}) {
    for (super(); e[e.length - 1] === "/"; )
      e = e.slice(0, e.length - 1);
    this.serverUrl = e, this.bcChannel = e + "/" + t, this.maxBackoffTime = u, this.params = o, this.protocols = a, this.roomname = t, this.doc = n, this._WS = l, this.awareness = r, this.wsconnected = !1, this.wsconnecting = !1, this.bcconnected = !1, this.disableBc = d, this.wsUnsuccessfulReconnects = 0, this.messageHandlers = vr.slice(), this._synced = !1, this.ws = null, this.wsLastMessageReceived = 0, this.shouldConnect = i, this._resyncInterval = 0, c > 0 && (this._resyncInterval = /** @type {any} */
    setInterval(() => {
      if (this.ws && this.ws.readyState === 1) {
        const f = xt();
        Pe(f, ts), cl(f, n), this.ws.send(pt(f));
      }
    }, c)), this._bcSubscriber = (f, g) => {
      if (g !== this) {
        const p = Zd(this, new Uint8Array(f), !1);
        Ql(p) > 1 && Ds(this.bcChannel, pt(p), this);
      }
    }, this._updateHandler = (f, g) => {
      if (g !== this) {
        const p = xt();
        Pe(p, ts), e4(p, f), _a(this, pt(p));
      }
    }, this.doc.on("update", this._updateHandler), this._awarenessUpdateHandler = ({ added: f, updated: g, removed: p }, m) => {
      const w = f.concat(g).concat(p), v = xt();
      Pe(v, zs), ln(
        v,
        ji(r, w)
      ), _a(this, pt(v));
    }, this._exitHandler = () => {
      nc(
        this.awareness,
        [n.clientID],
        "app closed"
      );
    }, nr && typeof process < "u" && process.on("exit", this._exitHandler), r.on("update", this._awarenessUpdateHandler), this._checkInterval = /** @type {any} */
    setInterval(() => {
      this.wsconnected && bh < ps() - this.wsLastMessageReceived && this.ws.close();
    }, bh / 10), i && this.connect();
  }
  get url() {
    const e = f4(this.params);
    return this.serverUrl + "/" + this.roomname + (e.length === 0 ? "" : "?" + e);
  }
  /**
   * @type {boolean}
   */
  get synced() {
    return this._synced;
  }
  set synced(e) {
    this._synced !== e && (this._synced = e, this.emit("synced", [e]), this.emit("sync", [e]));
  }
  destroy() {
    this._resyncInterval !== 0 && clearInterval(this._resyncInterval), clearInterval(this._checkInterval), this.disconnect(), nr && typeof process < "u" && process.off("exit", this._exitHandler), this.awareness.off("update", this._awarenessUpdateHandler), this.doc.off("update", this._updateHandler), super.destroy();
  }
  connectBc() {
    if (this.disableBc)
      return;
    this.bcconnected || (Z2(this.bcChannel, this._bcSubscriber), this.bcconnected = !0);
    const e = xt();
    Pe(e, ts), cl(e, this.doc), Ds(this.bcChannel, pt(e), this);
    const t = xt();
    Pe(t, ts), Wd(t, this.doc), Ds(this.bcChannel, pt(t), this);
    const n = xt();
    Pe(n, Xd), Ds(
      this.bcChannel,
      pt(n),
      this
    );
    const i = xt();
    Pe(i, zs), ln(
      i,
      ji(this.awareness, [
        this.doc.clientID
      ])
    ), Ds(
      this.bcChannel,
      pt(i),
      this
    );
  }
  disconnectBc() {
    const e = xt();
    Pe(e, zs), ln(
      e,
      ji(
        this.awareness,
        [this.doc.clientID],
        /* @__PURE__ */ new Map()
      )
    ), _a(this, pt(e)), this.bcconnected && (K2(this.bcChannel, this._bcSubscriber), this.bcconnected = !1);
  }
  disconnect() {
    this.shouldConnect = !1, this.disconnectBc(), this.ws !== null && this.ws.close();
  }
  connect() {
    this.shouldConnect = !0, !this.wsconnected && this.ws === null && (Kd(this), this.connectBc());
  }
}
class w4 {
  /**
   * Creates an instance of CollaborateRoom.
   * @author tony001
   * @date 2024-08-05 18:08:36
   * @param {string} id
   * @param {IData} doc
   */
  constructor(e, t, n, i) {
    /**
     * 唯一标识
     *
     * @author tony001
     * @date 2024-08-05 18:08:19
     * @type {string}
     */
    E(this, "id");
    /**
     * 房间名称
     *
     * @author tony001
     * @date 2024-08-06 10:08:25
     * @type {string}
     */
    E(this, "name");
    /**
     * 文档实例
     *
     * @author tony001
     * @date 2024-08-05 18:08:59
     * @type {Y.Doc}
     */
    E(this, "doc");
    /**
     * 上下文
     *
     * @author tony001
     * @date 2024-08-06 10:08:29
     * @type {IContext}
     */
    E(this, "context");
    /**
     * 视图参数
     *
     * @author tony001
     * @date 2024-08-06 10:08:34
     * @type {IParams}
     */
    E(this, "params");
    /**
     * 连接提供者
     *
     * @author tony001
     * @date 2024-08-05 18:08:04
     * @type {*}
     */
    E(this, "connectionProvider");
    this.context = e, this.params = t, this.id = n, this.doc = i;
    const r = ibiz.appData.mqtttopic.split("/");
    this.name = "/".concat(r[1], "/collaborate/ROOM/").concat(this.id);
  }
  /**
   * 创建当前实例
   *
   * @author tony001
   * @date 2024-08-06 10:08:20
   * @return {*}  {Promise<void>}
   */
  async created() {
    const t = ibiz.hub.getApp(this.context.srfappid).model.appId || ibiz.env.appId, n = "ws://".concat(window.location.host).concat(ibiz.env.baseUrl, "/").concat(t).concat(ibiz.env.mqttUrl), i = new d2(
      this.id,
      this.name,
      bp(),
      t
    );
    await i.connect(), this.connectionProvider = new m4(
      n,
      this.name,
      this.doc,
      { WebSocketPolyfill: i, resyncInterval: 5e3 }
    );
  }
  /**
   * 销毁当前实例
   *
   * @author tony001
   * @date 2024-08-06 10:08:08
   * @return {*}  {Promise<void>}
   */
  async destroy() {
    var e;
    (e = this.connectionProvider) == null || e.destroy();
  }
}
class y4 {
  constructor() {
    /**
     * 协同房间缓存实例
     *
     * @author tony001
     * @date 2024-08-06 14:08:38
     * @protected
     * @type {Map<string, Map<string, CollaborateRoom>>}
     */
    E(this, "collaborateMap", /* @__PURE__ */ new Map());
  }
  /**
   * 获取应用标识
   *
   * @author tony001
   * @date 2024-08-06 14:08:27
   * @protected
   * @param {IContext} context
   * @return {*}  {string}
   */
  getAppId(e) {
    return ibiz.hub.getApp(e.srfappid).model.appId || ibiz.env.appId;
  }
  /**
   * 创建协同房间
   *
   * @author tony001
   * @date 2024-08-06 14:08:37
   * @param {IContext} context 上下文
   * @param {IParams} params 视图参数
   * @param {string} id 业务数据主键
   * @param {IData} doc 文档实例对象
   * @return {*}  {Promise<CollaborateRoom>}
   */
  async create(e, t, n, i) {
    const r = new w4(e, t, n, i);
    await r.created();
    const o = this.getAppId(e);
    return this.collaborateMap.has(o) || this.collaborateMap.set(o, /* @__PURE__ */ new Map()), this.collaborateMap.get(o).set(r.id, r), r;
  }
  /**
   * 获取协同房间
   *
   * @author tony001
   * @date 2024-08-06 10:08:17
   * @param {IContext} context 上下文
   * @param {IParams} params 视图参数
   * @param {string} id 业务数据主键
   * @return {*}  {Promise<CollaborateRoom>}
   */
  async get(e, t, n) {
    const i = this.getAppId(e);
    if (!this.collaborateMap.has(i))
      throw new Error(
        ibiz.i18n.t("runtime.utils.collaborateManager.invalidCollaborateRoom", {
          id: n
        })
      );
    const r = this.collaborateMap.get(i);
    if (r && r.has(n))
      return r.get(n);
    throw new Error(
      ibiz.i18n.t("runtime.utils.collaborateManager.invalidCollaborateRoom", {
        id: n
      })
    );
  }
  /**
   * 销毁协同房间
   *
   * @author tony001
   * @date 2024-08-06 10:08:08
   * @param {IContext} context 上下文
   * @param {IParams} params 视图参数
   * @param {string} id 业务数据主键
   * @return {*}  {Promise<void>}
   */
  async destroy(e, t, n) {
    const i = this.getAppId(e);
    if (this.collaborateMap.has(i)) {
      const r = this.collaborateMap.get(i);
      r && r.has(n) && (r.get(n).destroy(), r.delete(n));
    }
  }
}
class b4 {
  /**
   * Creates an instance of SlateYjs.
   * @memberof SlateYjs
   */
  constructor(e) {
    /**
     * Yjs 文档
     *
     * @private
     * @type {Y.Doc}
     * @memberof Yjs
     */
    E(this, "yDoc", new yi());
    /**
     * 协同编辑管理器
     *
     * @private
     * @memberof SlateYjs
     */
    E(this, "collaborateManager", new y4());
    /**
     * Yjs ws 适配器
     *
     * @type {WebsocketProvider | undefined}
     * @memberof Yjs
     */
    E(this, "wsProvider");
    /**
     * 是否初始化完成
     *
     * @private
     * @type {Ref<boolean>}
     * @memberof Yjs
     */
    E(this, "inited", L(!1));
    /**
     * yjs 编辑器实例
     *
     * @type {YjsEditor | undefined}
     * @memberof Yjs
     */
    E(this, "yjsEditor");
    /**
     * 光标状态信息
     *
     * @memberof Yjs
     */
    E(this, "cursorStates", lu({}));
    /**
     * 光标处理
     *
     * @private
     * @type {(RemoteCursorChangeEventListener | null)}
     * @memberof Yjs
     */
    E(this, "cursorHandler", null);
    this.enableRealtime = e, this.inited.value = !e;
  }
  /**
   * 初始化YJS 必须调用
   *
   * @param {ISlateYjsOption} opt
   * @return {*}  {Promise<void>}
   * @memberof Yjs
   */
  async initYjs(e) {
    var t;
    if (!this.inited.value) {
      const n = [...e.editor.children], i = this.yDoc.get("content", Qe), r = await this.collaborateManager.create(
        e.context,
        e.params,
        e.roomname,
        this.yDoc
      );
      this.wsProvider = r.connectionProvider, this.wsProvider.on("status", (o) => {
        o.status === "connected" && !this.inited.value && setTimeout(() => {
          this.inited.value = !0, !i.toJSON() && n.length > 0 && i.applyDelta(Ad(n));
        }, 1e3);
      }), this.yjsEditor = Km(
        Qm(
          Jm(
            Ym(
              Gm(e.editor, i, Nd((t = e.htmlRef) == null ? void 0 : t.$el), {
                autoConnect: !0
              }),
              this.wsProvider.awareness,
              {
                data: t2(e.context.srfusername)
              }
            )
          )
        )
      ), this.initCursorHandler();
    }
  }
  /**
   * 初始化光标处理
   *
   * @private
   * @memberof Yjs
   */
  initCursorHandler() {
    if (!this.cursorHandler && this.yjsEditor) {
      const e = /* @__PURE__ */ new Set();
      this.cursorHandler = (t) => {
        t.added.forEach((n) => e.add(n)), t.removed.forEach((n) => e.add(n)), t.updated.forEach((n) => e.add(n)), e.forEach((n) => {
          const i = Pn.cursorState(
            this.yjsEditor,
            n
          );
          i === null ? delete this.cursorStates[n.toString()] : this.cursorStates[n] = i;
        });
      }, Pn.on(
        this.yjsEditor,
        "change",
        this.cursorHandler
      );
    }
  }
  /**
   * 销毁
   *
   * @memberof Yjs
   */
  destroy() {
    var e, t;
    (e = this.yjsEditor) == null || e.disconnect(), this.wsProvider.disconnect(), this.cursorHandler && (Pn.off(
      this.yjsEditor,
      "change",
      this.cursorHandler
    ), this.cursorHandler = null), (t = this.yjsEditor) == null || t.destroy();
  }
}
const hl = /* @__PURE__ */ ye({
  name: "IBizHtmlCollapse",
  props: _l(),
  emits: ["change", "blur", "focus", "enter", "infoTextChange", "link", "itemClick"],
  setup(s, {
    emit: e
  }) {
    const t = me("html"), n = s.controller, i = L(), r = L({});
    let o = null, a = 0;
    const l = L(), c = au(), u = L(), d = L(), f = L(), g = L(""), p = L({
      Authorization: "Bearer ".concat(Ol(Tl.TOKEN))
    }), m = L(""), w = L(""), v = L(!0), y = L(!1), b = L(!1), x = L(!1), C = L(!1), A = L(!1), k = nt(), O = L(!0), P = L(!1), D = L(""), N = L(!1);
    let F;
    const ee = L([]), X = new b4(n.enableRealtime), _ = () => {
      var H;
      let B = s.data.srfuf === lp.CREATE ? "draft" : s.data.srfkey;
      (H = s.controller.params) != null && H.srfmarkopendatakey && (B = s.controller.params.srfmarkopendatakey), s.controller.collaborateKey && (B = s.controller.collaborateKey), X.initYjs({
        roomname: B,
        editor: c.value,
        context: n.context,
        params: n.params,
        htmlRef: u.value
      });
    }, I = n.model;
    I.editorParams && (I.editorParams.enableEdit && (y.value = !0, b.value = !0, v.value = n.toBoolean(I.editorParams.enableEdit) && !s.readonly && !s.disabled), I.editorParams.enableFullScreen && (x.value = n.toBoolean(I.editorParams.enableFullScreen)), I.editorParams.ISSHOWANCHOR && (A.value = n.toBoolean(I.editorParams.ISSHOWANCHOR))), s.readonly && (y.value = !1, b.value = !0), Be(() => s.data, (T) => {
      if (T) {
        const B = ibiz.util.file.calcFileUpDownUrl(n.context, n.params, T, n.editorParams);
        m.value = B.uploadUrl, w.value = B.downloadUrl;
      }
    }, {
      immediate: !0,
      deep: !0
    });
    const W = (T, B) => {
      if (B)
        return !0;
    }, oe = (T) => T;
    let re;
    const xe = async () => {
      var T;
      if (n.deService) {
        const B = await import("@ibiz-template-plugin/ai-chat"), H = B.chat || B.default.chat;
        re = H;
        const U = H.create({
          question: async (Ne) => {
            var Vt;
            const ze = nt(), Mi = new AbortController();
            return await ((Vt = n.deService) == null ? void 0 : Vt.aiChatSse((ot) => {
              if (ibiz.log.info("aiChatSse", ot), ot.actionstate === 20 && ot.actionresult)
                U.addMessage({
                  messageid: ze,
                  state: ot.actionstate,
                  type: "DEFAULT",
                  role: "ASSISTANT",
                  content: ot.actionresult
                });
              else if (ot.actionstate === 30 && ot.actionresult) {
                const np = JSON.parse(ot.actionresult), {
                  choices: ma
                } = np;
                ma && ma.length > 0 && U.replaceMessage({
                  messageid: ze,
                  state: ot.actionstate,
                  type: "DEFAULT",
                  role: "ASSISTANT",
                  content: ma[0].content || ""
                });
              } else
                ot.actionstate === 40 && U.replaceMessage({
                  messageid: ze,
                  state: ot.actionstate,
                  type: "ERROR",
                  role: "ASSISTANT",
                  content: ot.actionresult
                });
            }, Mi, n.context, {}, {
              messages: Ne
            })), U.addMessage({
              messageid: ze,
              state: 10,
              type: "DEFAULT",
              role: "ASSISTANT",
              content: ""
            }), !0;
          },
          action: (Ne, ze) => {
            Ne === "backfill" && (y.value ? g.value = ze.content : e("change", ze.content), N.value = !0);
          },
          closed: () => {
            c.value && c.value.focus(!0);
          }
        }), je = await ((T = n.deService) == null ? void 0 : T.aiChatHistory(n.context, {}));
        je.data && Array.isArray(je.data) && je.data.forEach((Ne) => {
          const ze = {
            messageid: nt(),
            state: 30,
            type: "DEFAULT",
            role: Ne.role,
            content: Ne.content
          };
          U.addMessage(ze);
        });
      }
    }, ce = {
      toolbarKeys: Ip
    };
    n.chatCompletion && (ce.insertKeys = {
      index: 60,
      keys: ["|", "aichart"]
    }), n.insertKeys.length > 0 && ce.toolbarKeys && n.insertKeys.forEach((T) => {
      T.keys && T.keys.forEach((B, H) => {
        ce.toolbarKeys.includes(B) || ce.toolbarKeys.splice(T.index + H, 0, B);
      });
    });
    const bn = {
      placeholder: n.placeHolder,
      readOnly: y.value ? b.value : s.readonly,
      MENU_CONF: {
        // 图片上传
        uploadImage: {
          // 上传地址
          server: m.value,
          // form-data fieldName ，默认值 'wangeditor-uploaded-image'
          fieldName: "file",
          // 单个文件的最大体积限制，默认为 2M
          maxFileSize: 10 * 1024 * 1024,
          // 10M
          // 最多可上传几个文件，默认为 100
          maxNumberOfFiles: 10,
          // 选择文件时的类型限制，默认为 ['image/*'] 。如不想限制，则设置为 []
          allowedFileTypes: [],
          // 自定义增加 http  header
          headers: p.value,
          // 跨域是否传递 cookie ，默认为 false
          withCredentials: !0,
          // 上传之前触发
          onBeforeUpload(T) {
            return T;
          },
          // 上传进度的回调函数
          onProgress(T) {
            console.log("progress", T);
          },
          // 单个文件上传成功之后
          onSuccess(T, B) {
            console.log("".concat(T.name, " 上传成功"), B);
          },
          // 单个文件上传失败
          onFailed(T, B) {
            console.log("".concat(T.name, " 上传失败"), B);
          },
          // 上传错误，或者触发 timeout 超时
          onError(T, B, H) {
            console.log("".concat(T.name, " 上传出错"), B, H);
          },
          // 自定义插入图片
          async customInsert(T, B) {
            const H = w.value.replace("%fileId%", T.id), U = T.filename;
            B(H, U, "");
          }
        },
        // 插入链接
        insertLink: {
          checkLink: W,
          // 也支持 async 函数
          parseLinkUrl: oe
          // 也支持 async 函数
        },
        // 更新链接
        editLink: {
          checkLink: W,
          // 也支持 async 函数
          parseLinkUrl: oe
          // 也支持 async 函数
        }
      },
      hoverbarKeys: {
        link: {
          menuKeys: ["editLink", "unLink", "customViewLink"]
        }
      }
    };
    Lo(() => {
      const T = c.value;
      T != null && (n.enableRealtime ? X.destroy() : T.destroy());
    });
    const bt = async (T) => {
      if (n.maxHeight) {
        const B = T.getEditableContainer();
        P.value = B.offsetHeight > n.maxHeight;
      }
    }, ut = async (T) => {
      const B = T.src;
      if (b.value)
        Ft(B);
      else {
        const H = ne.nodes(c.value, {
          match: (U) => !!(Ui.isElement(U) && U.type === "image"),
          universal: !0
        });
        if (H)
          for (const U of H) {
            const [je] = U;
            je.type === "image" && B.endsWith(je.src) && Ft(je.src);
          }
      }
    }, Ft = async (T) => {
      if (D.value = T, ee.value = [T], await Ye(), d.value) {
        const {
          container: B
        } = d.value.$refs;
        B && B.children[0].click();
      }
    }, dt = (T) => {
      const B = T.getEditableContainer();
      B && B.querySelectorAll("img").forEach((U) => {
        U.onload = () => {
          bt(T);
        }, U.onclick = (je) => {
          const Ne = je.target;
          Ne && ut(Ne);
        };
      });
    }, st = (T) => {
      const B = T.getEditableContainer();
      if (B) {
        const H = B.querySelector("table");
        H && (H.onclick = (U) => {
          const Ne = B.clientWidth - 310, ze = B.querySelector(".w-e-hover-bar.w-e-bar-show");
          ze && (ze.style.left = "".concat(Math.min(U.layerX, Ne), "px"), ze.style.top = "".concat(U.layerY + 20, "px"), ze.style.bottom = "auto");
        });
      }
    }, Jn = (T) => {
      if (d.value) {
        const {
          container: B
        } = d.value.$refs;
        if (B) {
          const H = B.querySelector(".el-image-viewer__wrapper");
          H == null || H[T]("keydown", Yn);
        }
      }
    }, Yn = async (T) => {
      (T.key === "Escape" || T.keyCode === 27) && (T.stopPropagation(), T.preventDefault(), await Ye(), Jn("removeEventListener"), ee.value = []);
    }, $t = async () => {
      await Ye(), Jn("addEventListener");
    }, ia = (T) => {
      n.handleClick(T), e("itemClick", T);
    }, ks = () => {
      let T = g.value;
      if (n.renderMode === "JSON") {
        const B = c.value;
        T = n.toJson(B.children);
      }
      s.value !== T && (e("change", T), n.evt.emit("onChange", {
        eventArg: T
      }));
    }, ra = Ll(ks, n.saveInterval), Xn = L(""), zt = L([]), it = [], kr = (T, B) => {
      const H = T.getBoundingClientRect(), U = B.getBoundingClientRect(), je = H.top - U.top, Ne = H.bottom - U.top, ze = H.left - U.left, Mi = H.right - U.left, Vt = U.height, ot = U.width;
      return je >= 0 && Ne <= Vt && ze >= 0 && Mi <= ot;
    }, Si = new IntersectionObserver((T) => {
      T.forEach((B) => {
        if (B.isIntersecting) {
          if (B.target && B.target.id) {
            const U = it[it.length - 1], je = it[0], Ne = zt.value.findIndex((Vt) => Vt.id === B.target.id), ze = zt.value.findIndex((Vt) => Vt.id === U), Mi = zt.value.findIndex((Vt) => Vt.id === je);
            Ne > ze && (it.push(B.target.id), Xn.value = it[it.length - 1]), Ne < Mi && (it.unshift(B.target.id), Xn.value = it[0]);
          }
        } else if (B.target && B.target.id) {
          const U = it.indexOf(B.target.id);
          U >= 0 && it.splice(U, 1);
        }
        if (it.length === 0)
          return;
        const H = document.getElementById(k);
        if (H) {
          const U = H.querySelector("#anchor_".concat(k, "_").concat(Xn.value));
          U && (kr(U, H) || U.scrollIntoView({
            behavior: "smooth",
            block: "nearest"
          }));
        }
      });
    }), Pr = async () => {
      if (Si.disconnect(), await Ye(), c.value) {
        const T = c.value.getEditableContainer();
        T && zt.value.forEach((B) => {
          const H = T.querySelector("#".concat(B.id));
          H && Si.observe(H);
        });
      }
    }, Ps = () => {
      if (zt.value = [], c.value) {
        const T = c.value.getEditableContainer();
        if (T) {
          const B = T.querySelectorAll("h1, h2, h3, h4, h5, h6");
          zt.value = Array.from(B).filter((H) => H.innerText.trim() !== "").map((H) => ({
            //  锚点id
            id: H.id,
            // 标题
            text: H.innerText.trim(),
            // 当前是几级标题
            level: Number(H.tagName.substring(1))
          }));
        }
      }
      Pr();
    }, oa = (T) => {
      c.value && c.value.scrollToElem(T);
    }, aa = () => S("div", {
      id: k,
      class: t.b("anchor-list"),
      style: {
        height: "".concat(n.maxHeight, "px")
      }
    }, [zt.value.map((T) => S("div", {
      id: "anchor_".concat(k, "_").concat(T.id),
      class: [t.be("anchor-list", "anchor-item"), t.is("selected", Xn.value === T.id), "level".concat(T.level)],
      onClick: () => oa(T.id),
      title: T.text
    }, [S("span", null, [T.text])]))]), Zn = async (T) => {
      c.value = T, await n.onCreated(c.value, s.data, ce);
      const B = n.parseNode(g.value);
      T.setHtml(B), _(), Ye(() => {
        Ps();
      });
      let H;
      T.on("modalOrPanelShow", (U) => {
        H = new bu(U, u.value);
      }), T.on("modalOrPanelHide", () => {
        H && H.destroy();
      }), T.on("aiClick", () => {
        xe();
      });
    }, Kn = (T) => {
      bt(T), dt(T), st(T), !y.value && T.isFocused() && (n.emitMode === "AUTOMATIC" ? ra() : ks()), Ye(() => {
        Ps();
      });
    }, _r = (T) => {
    }, Or = (T) => {
      e("focus"), n.evt.emit("onFocus", {
        eventArg: s.value
      });
    }, _s = (T) => {
      e("blur"), n.evt.emit("onBlur", {
        eventArg: s.value
      });
    }, Tr = (T, B) => {
      alert("【自定义提示】".concat(B, " - ").concat(T));
    }, Lr = (T, B, H) => {
      H(!0);
    }, la = (T) => {
      const B = c.value;
      B != null && B.insertText(T);
    }, ca = () => {
      c.value != null;
    }, vn = () => {
      const T = c.value;
      T != null && T.disable();
    }, Os = () => {
      const T = c.value;
      T != null && T.enable();
    }, ha = () => {
      vp(0, () => {
        if (i.value && l.value) {
          const T = i.value.$el.offsetHeight;
          o = new ResizeObserver((B) => {
            const {
              height: H
            } = B[0].contentRect;
            if (H !== a) {
              const U = {
                height: "".concat(T - B[0].contentRect.height, "px")
              };
              r.value = t.cssVarBlock(U), a = H;
            }
          }), o.observe(l.value.selector);
        }
      });
    }, ua = () => {
      var T, B;
      if (s.value) {
        const H = s.value.indexOf("</p>");
        if (H >= 0) {
          const U = (T = c.value.selection.anchor) == null ? void 0 : T.offset, je = (B = c.value.selection.anchor) == null ? void 0 : B.path;
          U === 0 && je.length > 0 && je[0] === 0 && c.value.move(H - 3);
        }
      }
    }, Ai = () => {
      if (b.value = !b.value, !b.value)
        Os(), c.value.focus(), ua(), O.value = !0;
      else {
        if (u.value) {
          const {
            box: T
          } = u.value.$refs;
          T.scroll(0, 0);
        }
        vn();
      }
    }, da = () => S("div", {
      class: t.be("message", "message-content")
    }, [S("p", null, [at("确定要取消编辑吗？")]), S("p", {
      class: t.bem("message", "message-content", "message-tip")
    }, [at("取消编辑将无法保存修改的内容，且不能找回。")])]), fa = () => {
      s.value !== g.value ? gu({
        title: "确认取消",
        type: "warning",
        customClass: t.b("message"),
        message: da(),
        showCancelButton: !0,
        cancelButtonClass: t.be("message", "message-cancel"),
        confirmButtonClass: t.be("message", "message-comfire")
      }).then(() => {
        if (s.value) {
          const T = n.parseNode(s.value);
          g.value = T;
        } else
          g.value = "";
        Ai();
      }).catch(() => {
        c.value.focus();
      }) : Ai();
    }, ga = () => {
      b.value = !0, c.value.disable(), n.renderMode !== "JSON" && e("change", g.value), C.value && (C.value = !1);
    }, pa = () => y.value && n.emitMode !== "AUTOMATIC" ? S("div", {
      class: [t.b("footer"), {
        [t.b("footer-dialog")]: C.value
      }]
    }, [S("div", {
      class: t.be("footer", "cancel"),
      onClick: () => fa()
    }, [at("取消")]), S("div", {
      class: t.be("footer", "save"),
      onClick: () => ga()
    }, [at("保存")])]) : null, j = () => {
      C.value = !C.value, O.value = !C.value, Ye(() => {
        b.value ? vn() : (Os(), c.value.focus());
      });
    }, z = () => x.value ? C.value ? S("i", {
      class: "fa fa-compress",
      "aria-hidden": "true",
      title: "缩小",
      onClick: () => j()
    }, null) : S("i", {
      class: "fa fa-expand",
      "aria-hidden": "true",
      title: "放大",
      onClick: () => j()
    }, null) : null, q = () => y.value || x.value ? S("div", {
      class: t.b("custom-toolbar")
    }, [y.value && v.value && b.value ? S("i", {
      class: "fa fa-edit",
      "aria-hidden": "true",
      title: "编辑",
      onClick: () => Ai()
    }, null) : null, z()]) : null, ae = () => P.value ? O.value ? S("div", {
      class: t.e("toggle"),
      onClick: () => {
        O.value = !O.value;
      }
    }, [at("展开更多 "), S(Ee("ion-icon"), {
      name: "arrow-down-outline"
    }, null)]) : S("div", {
      class: t.e("toggle"),
      onClick: () => {
        O.value = !O.value;
      }
    }, [at("收起更多 "), S(Ee("ion-icon"), {
      name: "arrow-up-outline"
    }, null)]) : null, ke = () => {
      const T = {
        ...r.value
      };
      return O.value && n.maxHeight && Object.assign(T, {
        maxHeight: "".concat(n.maxHeight, "px")
      }), gi(S(u2, {
        ref: "htmlContent",
        style: T,
        slateYjs: X,
        "element-loading-text": "数据同步中...",
        class: [t.b("content"), t.is("readonly", b.value)]
      }, {
        default: () => [S(du, {
          ref: "toolbarRef",
          editor: c.value,
          "default-config": ce,
          mode: "default",
          class: t.b("toolbar")
        }, null), S(uu, {
          ref: "htmlRef",
          class: t.b("editor"),
          modelValue: g.value,
          "onUpdate:modelValue": (B) => g.value = B,
          "default-config": bn,
          mode: "default",
          onClick: ia,
          onOnCreated: Zn,
          onOnChange: Kn,
          onOnDestroyed: _r,
          onOnFocus: Or,
          onOnBlur: _s,
          oncustomAlert: Tr,
          oncustomPaste: Lr
        }, null)]
      }), [[Vi("loading"), !X.inited.value]]);
    }, rt = () => S(Ee("el-image"), {
      class: t.e("preview"),
      ref: "previewRef",
      "zoom-rate": 1.1,
      src: D.value,
      "preview-src-list": ee.value,
      "hide-on-click-modal": !0,
      onShow: $t,
      fit: "cover"
    }, null);
    return fn(() => {
      f.value && (F = fp(f, async () => {
        c.value && c.value.emit("clickOutside");
      })), ha(), Be(() => s.value, (T, B) => {
        if (T !== B && (typeof s.value == "string" || T == null) && (T == null ? g.value = "" : n.renderMode === "JSON" ? g.value = n.jsonToHtml(T) : g.value = T, N.value && (c.value && Ye(() => {
          c.value.focus(!0);
        }), N.value = !1), T)) {
          const H = n.parseNode(T);
          g.value = H;
        }
        Ye(() => {
          c.value && Ps();
        });
      }, {
        immediate: !0
      }), Be(() => s.disabled, (T, B) => {
        T !== B && (T === !0 ? vn() : Os());
      }, {
        immediate: !0
      });
    }), fr(() => {
      o && o.disconnect(), F && F.stop && F.stop(), re && re.close();
    }), {
      c: n,
      ns: t,
      editorRef: c,
      previewRef: d,
      containerRef: f,
      htmlRef: u,
      mode: "default",
      valueHtml: g,
      toolbarConfig: ce,
      editorConfig: bn,
      handleCreated: Zn,
      handleChange: Kn,
      handleDestroyed: _r,
      handleFocus: Or,
      handleBlur: _s,
      customAlert: Tr,
      customPaste: Lr,
      insertText: la,
      printHtml: ca,
      disable: vn,
      enable: Os,
      renderHeaserToolbar: q,
      renderEditorContent: ke,
      renderToggle: ae,
      renderFooter: pa,
      htmlContent: i,
      hasEnableEdit: y,
      cssVars: r,
      toolbarRef: l,
      isFullScreen: C,
      readonlyState: b,
      collapse: O,
      isShowAnchor: A,
      changeFullScreenState: j,
      renderPreview: rt,
      renderAnchor: aa
    };
  },
  render() {
    return this.isFullScreen ? S(Ee("el-dialog"), {
      modelValue: this.isFullScreen,
      "onUpdate:modelValue": (s) => this.isFullScreen = s,
      width: "80%",
      top: "10vh",
      class: [this.ns.b("dialog-full-screen")],
      onClose: () => this.changeFullScreenState()
    }, {
      default: () => [S("div", {
        ref: "containerRef",
        class: [this.ns.b(), this.ns.b("collapse"), {
          [this.ns.b("editor-readonly")]: this.readonlyState
        }]
      }, [this.renderHeaserToolbar(), this.renderEditorContent(), this.hasEnableEdit && !this.readonlyState ? this.renderFooter() : null])]
    }) : S("div", {
      ref: "containerRef",
      class: [this.ns.b(), this.ns.is("allow-collapse", !0), {
        [this.ns.b("editor-readonly")]: this.readonlyState
      }]
    }, [this.renderHeaserToolbar(), this.isShowAnchor ? S("div", {
      class: this.ns.b("anchor-editor-container"),
      style: {
        height: "".concat(this.c.maxHeight, "px")
      }
    }, [this.renderEditorContent(), this.renderAnchor()]) : this.renderEditorContent(), this.readonlyState ? this.renderToggle() : null, this.hasEnableEdit && !this.readonlyState ? this.renderFooter() : null, this.renderPreview()]);
  }
});
const Oa = /* @__PURE__ */ ye({
  name: "HtmlComment",
  props: _l(),
  emits: {
    ...gp(),
    /** 点击事件 */
    click: (s, e) => !0
  },
  setup(s, {
    emit: e
  }) {
    const t = me("html-comment"), n = s.controller, i = L(), r = L(), o = L(!1), a = () => {
      n.collapsed.value = !1, e("focus");
    }, l = (p) => {
      e("change", p), p && n.collapsed.value && (n.collapsed.value = !1);
    }, c = () => {
      if (e("blur"), s.value)
        return null;
      n.collapsed.value = !0;
    }, u = (p) => {
      p.stopPropagation(), p.preventDefault();
      const {
        nodeName: m,
        dataset: w
      } = p.target;
      if (m && m === "MENTION-ELEM") {
        const v = w.value || "", y = JSON.parse(v);
        e("click", p, {
          data: y
        });
      }
    }, d = () => {
      o.value = !0;
    }, f = (p) => /^https?:|^http?:|^data:image|(\.png$|\.svg|\.jpg|\.png|\.gif|\.psd|\.tif|\.bmp|\.jpeg)$/.test(p);
    return {
      ns: t,
      c: n,
      comment: i,
      editorRef: r,
      onChange: l,
      onFocus: a,
      onBlur: c,
      onClick: u,
      renderAvatar: () => {
        if (n.userAvatar && !o.value) {
          let w = "";
          if (f(n.userAvatar))
            w = n.userAvatar;
          else {
            let v = [];
            try {
              v = JSON.parse(n.userAvatar);
            } catch (b) {
              console.error("解析头像数据失败", b);
            }
            if (v.length === 0)
              return null;
            const {
              downloadUrl: y
            } = ibiz.util.file.calcFileUpDownUrl(n.context, n.params, s.data, n.editorParams);
            w = y.replace("%fileId%", v[0].id);
          }
          return S("div", {
            class: t.e("avatar-name")
          }, [S("img", {
            src: w,
            alt: "",
            onError: d
          }, null)]);
        }
        const p = Xs.stringToHexColor(n.context.srfusername), m = Xs.avatarName(n.context.srfusername);
        return n.context.srfusername ? S("div", {
          class: t.e("avatar-name"),
          style: "background: ".concat(p, ";")
        }, [m]) : S(Ee("el-avatar"), {
          class: t.e("avatar"),
          src: "./assets/images/user-avatar.png"
        }, null);
      }
    };
  },
  render() {
    if (this.c.mode === "default")
      return S(hl, {
        controller: this.c,
        data: this.data,
        value: this.value,
        readonly: this.readonly,
        onChange: this.onChange,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onItemClick: this.onClick
      }, null);
    const s = {
      height: "".concat((this.c.collapsed.value ? this.c.minHeight : this.c.maxHeight) - 16, "px")
    }, e = this.ns.cssVarBlock(s);
    return S("div", {
      ref: "comment",
      class: [this.ns.b(), this.ns.is("collapse", this.c.collapsed.value), this.ns.is("has-file", this.c.hasFile.value)],
      style: e
    }, [this.renderAvatar(), S(oo, {
      controller: this.c,
      data: this.data,
      value: this.value,
      onChange: this.onChange,
      onFocus: this.onFocus,
      onBlur: this.onBlur,
      onItemClick: this.onClick
    }, null)]);
  }
});
function vh(s, e, t, n, i) {
  const r = e === void 0 ? void 0 : e.key;
  return { sel: s, data: e, children: t, text: n, elm: i, key: r };
}
const xh = Array.isArray;
function Ta(s) {
  return typeof s == "string" || typeof s == "number" || s instanceof String || s instanceof Number;
}
function Qd(s, e, t) {
  if (s.ns = "http://www.w3.org/2000/svg", t !== "foreignObject" && e !== void 0)
    for (let n = 0; n < e.length; ++n) {
      const i = e[n];
      if (typeof i == "string")
        continue;
      const r = i.data;
      r !== void 0 && Qd(r, i.children, i.sel);
    }
}
function wn(s, e, t) {
  let n = {}, i, r, o;
  if (t !== void 0 ? (e !== null && (n = e), xh(t) ? i = t : Ta(t) ? r = t.toString() : t && t.sel && (i = [t])) : e != null && (xh(e) ? i = e : Ta(e) ? r = e.toString() : e && e.sel ? i = [e] : n = e), i !== void 0)
    for (o = 0; o < i.length; ++o)
      Ta(i[o]) && (i[o] = vh(void 0, void 0, void 0, i[o], void 0));
  return s[0] === "s" && s[1] === "v" && s[2] === "g" && (s.length === 3 || s[3] === "." || s[3] === "#") && Qd(n, i, s), vh(s, n, i, r, void 0);
}
function v4(s) {
  const { script: e = "", data: t = {} } = s, n = Dt.execScriptFn({ data: t }, e, {
    singleRowReturn: !0,
    isAsync: !1
  });
  return "".concat(n);
}
const x4 = {
  type: "attachments",
  elemToHtml: v4
};
function C4(s) {
  const e = decodeURIComponent(s.getAttribute("data-value") || ""), t = JSON.parse(e);
  return {
    type: "attachments",
    script: t.script,
    data: t,
    children: [{ text: "" }]
  };
}
const E4 = {
  selector: 'span[data-w-e-type="attachments"]',
  parseElemHtml: C4
};
function S4(s) {
  const { data: e = {} } = s, t = {
    name: "".concat(e.name),
    id: e.id
  };
  return wn(
    "mention-elem",
    {
      dataset: { value: JSON.stringify(t) },
      props: {
        contentEditable: !1
        // 不可编辑
      }
    },
    []
  );
}
const A4 = {
  type: "attachments",
  renderElem: S4
};
class M4 {
  constructor() {
    E(this, "title", "本地文件");
    E(this, "tag", "button");
    E(this, "iconSvg", '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36px" height="36px" viewBox="0 0 36 36" version="1.1">\n    <title>附件</title>\n    <g id="附件" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <g id="icon">\n            <rect id="矩形" stroke="#EEEEEE" fill="#FFFFFF" x="0.5" y="0.5" width="35" height="35" rx="4"/>\n            <g id="编组-28" transform="translate(2.997929, 8.001508)">\n                <path d="M13.9611058,12.6330155 C13.9611058,14.5460163 12.4108408,16.0968098 10.498492,16.0968098 C8.58614322,16.0968098 7.03587822,14.5460163 7.03590808,12.6393438 L7.03590808,12.6393438 L6.98338468,7.07669061 C6.97992133,6.70644889 7.27712693,6.40347538 7.64724246,6.39998034 C8.017358,6.39648531 8.32022824,6.69379224 8.32372209,7.06403396 L8.32372209,7.06403396 L8.37624485,12.6330155 C8.37624485,13.8054998 9.32640727,14.7559862 10.498492,14.7559862 C11.6705768,14.7559862 12.6207392,13.8054998 12.6207392,12.6330155 L12.6207392,12.6330155 L12.6207392,6.46506253 C12.6207392,4.69957562 11.0562006,3.24725012 9.10227678,3.24725012 C7.148353,3.24725012 5.58381437,4.69957562 5.58381437,6.46506253 L5.58381437,6.46506253 L5.58381437,12.8655397 C5.58381437,15.5621365 7.78332719,17.7497339 10.498492,17.7497339 C13.2136568,17.7497339 15.4131697,15.5621365 15.4131697,12.8655397 L15.4131697,12.8655397 L15.4131697,7.10001026 C15.4131697,6.72975204 15.713221,6.42959845 16.083353,6.42959845 C16.453485,6.42959845 16.7535363,6.72975204 16.7535363,7.10001026 L16.7535363,7.10001026 L16.7535363,12.8655397 C16.7535363,16.3043913 13.9521943,19.0905575 10.498492,19.0905575 C7.04478976,19.0905575 4.24344774,16.3043913 4.24344774,12.8655397 L4.24344774,12.8655397 L4.24344774,6.46506253 C4.24344774,3.93573556 6.42955024,1.90642651 9.10227678,1.90642651 C11.7750033,1.90642651 13.9611058,3.93573556 13.9611058,6.46506253 L13.9611058,6.46506253 Z" id="形状结合" fill="#DDDDDD" transform="translate(10.498492, 10.498492) rotate(-315.000000) translate(-10.498492, -10.498492) "/>\n                <path d="M21.6662931,9.87797441 L24.6096402,9.87797441 C24.9410111,9.87797441 25.2096402,10.1466036 25.2096402,10.4779744 C25.2096402,10.8093453 24.9410111,11.0779744 24.6096402,11.0779744 L21.6662931,11.0779744 C21.3349223,11.0779744 21.0662931,10.8093453 21.0662931,10.4779744 C21.0662931,10.1466036 21.3349223,9.87797441 21.6662931,9.87797441 Z" id="矩形备份-74" fill="#73D897"/>\n                <path d="M21.6662931,4.29120933 L27.4020707,4.29120933 C27.7334415,4.29120933 28.0020707,4.55983848 28.0020707,4.89120933 C28.0020707,5.22258018 27.7334415,5.49120933 27.4020707,5.49120933 L21.6662931,5.49120933 C21.3349223,5.49120933 21.0662931,5.22258018 21.0662931,4.89120933 C21.0662931,4.55983848 21.3349223,4.29120933 21.6662931,4.29120933 Z" id="矩形备份-75" fill="#6698FF"/>\n                <path d="M21.6662931,15.4647395 L27.4020707,15.4647395 C27.7334415,15.4647395 28.0020707,15.7333686 28.0020707,16.0647395 C28.0020707,16.3961103 27.7334415,16.6647395 27.4020707,16.6647395 L21.6662931,16.6647395 C21.3349223,16.6647395 21.0662931,16.3961103 21.0662931,16.0647395 C21.0662931,15.7333686 21.3349223,15.4647395 21.6662931,15.4647395 Z" id="矩形备份-77" fill="#FF7575"/>\n            </g>\n        </g>\n    </g>\n</svg>');
  }
  // 菜单是否需要激活（如选中加粗文本，“加粗”菜单会激活），用不到则返回 false
  isActive(e) {
    return !1;
  }
  // 获取菜单执行时的 value ，用不到则返回空 字符串或 false
  getValue(e) {
    return "";
  }
  // 菜单是否需要禁用（如选中 H1 ，“引用”菜单被禁用），用不到则返回 false
  isDisabled(e) {
    return !1;
  }
  // 点击菜单时触发的函数
  exec(e, t) {
    e.emit("attachmentClick");
  }
}
const k4 = {
  key: "attachments",
  factory() {
    return new M4();
  }
}, P4 = {
  renderElems: [A4],
  elemsToHtml: [x4],
  parseElemsHtml: [E4],
  menus: [k4]
};
class _4 {
  /**
   * Creates an instance of AttachmentsController.
   * @param {IData} option
   * @memberof AttachmentsController
   */
  constructor() {
    /**
     * 模型
     *
     * @type {IEditor}
     * @memberof AttachmentsController
     */
    E(this, "model");
    /**
     * 上下文
     *
     * @type {IContext}
     */
    E(this, "context");
    /**
     * 视图参数
     *
     * @type {IParams}
     */
    E(this, "params");
    /**
     * 表单数据
     *
     * @type {IData}
     * @memberof AttachmentsController
     */
    E(this, "data", {});
    /**
     * 编辑器示例
     *
     * @type {IDomEditor}
     * @memberof AttachmentsController
     */
    E(this, "editor");
    /**
     * @description 富文本控制器
     * @type {HtmlCommentController}
     * @memberof AttachmentsController
     */
    E(this, "htmlController");
    /**
     * 编辑器参数
     *
     * @type {IData}
     * @memberof AttachmentsController
     */
    E(this, "editorParams");
    /**
     * 用户数据
     *
     * @type {IData[]}
     * @memberof AttachmentsController
     */
    E(this, "items", []);
    /**
     * 编辑器事件
     *
     * @type {ControllerEvent<commentEvent>}
     * @memberof AttachmentsController
     */
    E(this, "evt");
    /**
     * 是否正在执行
     *
     * @private
     * @type {boolean}
     * @memberof AttachmentsController
     */
    E(this, "execting", !1);
    /**
     * @description 额外属性值
     * @memberof AttachmentsController
     */
    E(this, "fileFieldValue", "");
    this.registerNode();
  }
  registerNode() {
    window.attachmentsIsRegiter || (ht.registerModule(P4), window.attachmentsIsRegiter = !0);
  }
  /**
   * 初始化
   *
   * @param {IDomEditor} editor
   * @memberof AttachmentsController
   */
  async init(e, t) {
    if (this.model = t.model, this.context = t.context, this.params = t.params, this.evt = t.evt, this.data = t.data, this.editor = e, this.editorParams = this.model.editorParams, this.htmlController = t.controller, this.editorParams) {
      const { EXTFIELDVALUE: n } = this.editorParams;
      if (n) {
        const r = n.split(";").map((o) => {
          const [a, l] = o.split(":");
          return { name: a, value: l };
        }).find((o) => o.name === "file");
        r && (this.fileFieldValue = r.value);
      }
    }
    e.on("attachmentClick", () => {
      this.fileUpload();
    });
  }
  /**
   * 控制器销毁
   *
   * @memberof AttachmentsController
   */
  onDestroyed() {
  }
  /**
   * 插入节点
   *
   * @param {IDomEditor} editor
   * @memberof AttachmentsController
   */
  insertNode(e) {
  }
  /**
   * 解析mention节点
   *
   * @param {string} value
   * @return {*}
   * @memberof AttachmentsController
   */
  parseNode(e) {
    return e;
  }
  async fileUpload() {
    if (!this.fileFieldValue) {
      ibiz.message.warning("请先配置本地文件额外属性");
      return;
    }
    const e = await ibiz.util.file.chooseFileAndUpload(
      this.context,
      this.params,
      this.data
    ), t = this.htmlController.parent, n = this.data[this.fileFieldValue] || "[]", i = JSON.parse(n), r = e.map((a) => ({ name: a.name, id: a.id }));
    i.push(...r);
    const o = JSON.stringify(i);
    t.setDataValue(o, this.fileFieldValue), this.evt.emit("fileChange", {
      value: o
    }), this.editor.blur();
  }
}
function O4(s) {
  const { script: e = "", data: t = {} } = s, n = Dt.execScriptFn({ data: t }, e, {
    singleRowReturn: !0,
    isAsync: !1
  });
  return "".concat(n);
}
const T4 = {
  type: "codesnippet",
  elemToHtml: O4
};
function L4(s) {
  const e = decodeURIComponent(s.getAttribute("data-value") || ""), t = JSON.parse(e);
  return {
    type: "codesnippet",
    script: t.script,
    data: t,
    children: [{ text: "" }]
  };
}
const N4 = {
  selector: 'span[data-w-e-type="codesnippet"]',
  parseElemHtml: L4
};
function D4(s) {
  const { data: e = {} } = s, t = {
    name: "".concat(e.name),
    id: e.id
  };
  return wn(
    "mention-elem",
    {
      dataset: { value: JSON.stringify(t) },
      props: {
        contentEditable: !1
        // 不可编辑
      }
    },
    []
  );
}
const I4 = {
  type: "CodeSnippet",
  renderElem: D4
};
class j4 {
  constructor() {
    E(this, "title", "代码段");
    E(this, "tag", "button");
    E(this, "iconSvg", '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36px" height="36px" viewBox="0 0 36 36" version="1.1">\n  <title>代码段</title>\n  <g id="代码段" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n      <g id="icon备份">\n          <rect id="矩形" stroke="#EEEEEE" fill="#FFFFFF" x="0.5" y="0.5" width="35" height="35" rx="4"/>\n          <path d="M24.6642225,18.8794824 L27.6075695,18.8794824 C27.9389404,18.8794824 28.2075695,19.1481115 28.2075695,19.4794824 C28.2075695,19.8108532 27.9389404,20.0794824 27.6075695,20.0794824 L24.6642225,20.0794824 C24.3328516,20.0794824 24.0642225,19.8108532 24.0642225,19.4794824 C24.0642225,19.1481115 24.3328516,18.8794824 24.6642225,18.8794824 Z" id="矩形备份-74" fill="#73D897"/>\n          <path d="M24.6642225,13.2927173 L30.4,13.2927173 C30.7313708,13.2927173 31,13.5613465 31,13.8927173 C31,14.2240882 30.7313708,14.4927173 30.4,14.4927173 L24.6642225,14.4927173 C24.3328516,14.4927173 24.0642225,14.2240882 24.0642225,13.8927173 C24.0642225,13.5613465 24.3328516,13.2927173 24.6642225,13.2927173 Z" id="矩形备份-75" fill="#6698FF"/>\n          <path d="M24.6642225,24.4662475 L30.4,24.4662475 C30.7313708,24.4662475 31,24.7348766 31,25.0662475 C31,25.3976183 30.7313708,25.6662475 30.4,25.6662475 L24.6642225,25.6662475 C24.3328516,25.6662475 24.0642225,25.3976183 24.0642225,25.0662475 C24.0642225,24.7348766 24.3328516,24.4662475 24.6642225,24.4662475 Z" id="矩形备份-77" fill="#FF7575"/>\n          <g id="1.Base基础/1.icon图标/11.editor/header-1" transform="translate(5.000000, 11.000000)" fill="#DDDDDD">\n              <path d="M4.68266589,2.39258039 L1.51032474,7.44797324 L5.01586095,12.7216272 L4.05994646,13.3212428 L0.126424153,7.40475416 L3.68603474,1.72997946 L4.68266589,2.39258039 Z M11.3173341,12.6697762 L14.4896753,7.61438339 L10.984139,2.34072939 L11.9400535,1.7411138 L15.8735758,7.65760247 L12.3139653,13.3323772 L11.3173341,12.6697762 Z M8.86596086,1.31248434 L10.0376294,1.55020137 L7.19605832,13.6243456 L6.0243898,13.3866286 L8.86596086,1.31248434 Z" id="形状结合"/>\n          </g>\n      </g>\n  </g>\n</svg>');
  }
  // 菜单是否需要激活（如选中加粗文本，“加粗”菜单会激活），用不到则返回 false
  isActive(e) {
    return !1;
  }
  // 获取菜单执行时的 value ，用不到则返回空 字符串或 false
  getValue(e) {
    return "";
  }
  // 菜单是否需要禁用（如选中 H1 ，“引用”菜单被禁用），用不到则返回 false
  isDisabled(e) {
    return !1;
  }
  // 点击菜单时触发的函数
  exec(e, t) {
    throw new io("暂未支持上传代码段！");
  }
}
const R4 = {
  key: "codesnippet",
  factory() {
    return new j4();
  }
}, B4 = {
  renderElems: [I4],
  elemsToHtml: [T4],
  parseElemsHtml: [N4],
  menus: [R4]
};
class F4 {
  /**
   * Creates an instance of CodeSnippetController.
   * @param {IData} option
   * @memberof CodeSnippetController
   */
  constructor() {
    /**
     * 模型
     *
     * @type {IEditor}
     * @memberof CodeSnippetController
     */
    E(this, "model");
    /**
     * 上下文
     *
     * @type {IContext}
     */
    E(this, "context");
    /**
     * 视图参数
     *
     * @type {IParams}
     */
    E(this, "params");
    /**
     * 表单数据
     *
     * @type {IData}
     * @memberof CodeSnippetController
     */
    E(this, "data", {});
    /**
     * 编辑器示例
     *
     * @type {IDomEditor}
     * @memberof CodeSnippetController
     */
    E(this, "editor");
    /**
     * 编辑器参数
     *
     * @type {IData}
     * @memberof CodeSnippetController
     */
    E(this, "editorParams");
    /**
     * 用户数据
     *
     * @type {IData[]}
     * @memberof CodeSnippetController
     */
    E(this, "items", []);
    /**
     * 编辑器事件
     *
     * @type {ControllerEvent<commentEvent>}
     * @memberof CodeSnippetController
     */
    E(this, "evt");
    /**
     * 是否正在执行
     *
     * @private
     * @type {boolean}
     * @memberof CodeSnippetController
     */
    E(this, "execting", !1);
    this.registerNode();
  }
  registerNode() {
    window.codesnippetIsRegiter || (ht.registerModule(B4), window.codesnippetIsRegiter = !0);
  }
  /**
   * 初始化
   *
   * @param {IDomEditor} editor
   * @memberof CodeSnippetController
   */
  async init(e, t) {
    this.model = t.model, this.context = t.context, this.params = t.params, this.evt = t.evt, this.data = t.data, this.editor = e, this.editorParams = this.model.editorParams;
  }
  /**
   * 控制器销毁
   *
   * @memberof CodeSnippetController
   */
  onDestroyed() {
  }
  /**
   * 插入节点
   *
   * @param {IDomEditor} editor
   * @memberof CodeSnippetController
   */
  insertNode(e) {
  }
  /**
   * 解析mention节点
   *
   * @param {string} value
   * @return {*}
   * @memberof CodeSnippetController
   */
  parseNode(e) {
    return e;
  }
}
function $4(s) {
  const { script: e = "", data: t = {} } = s, n = Dt.execScriptFn({ data: t }, e, {
    singleRowReturn: !0,
    isAsync: !1
  });
  return "".concat(n);
}
const z4 = {
  type: "marker",
  elemToHtml: $4
};
function V4(s) {
  const e = decodeURIComponent(s.getAttribute("data-value") || ""), t = JSON.parse(e);
  return {
    type: "marker",
    script: t.script,
    data: t,
    children: [{ text: "" }]
  };
}
const H4 = {
  selector: 'span[data-w-e-type="marker"]',
  parseElemHtml: V4
};
function U4(s) {
  const { data: e = {} } = s;
  return wn(
    "mention-elem",
    {
      dataset: { value: JSON.stringify(e) },
      props: {
        contentEditable: !1
        // 不可编辑
      }
    },
    []
  );
}
const q4 = {
  type: "marker",
  renderElem: U4
};
let G4 = class {
  constructor() {
    E(this, "title", "提及项");
    E(this, "tag", "button");
    E(this, "iconSvg", '<svg t="1706259772097" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6854" width="200" height="200"><path d="M929.28 625.664l-234.496 0.512 24.064-229.888 210.432-0.512c20.992 0 38.4-17.408 38.4-38.4s-17.408-38.4-38.4-38.4H727.04l29.184-275.456c2.048-20.992-13.312-39.936-34.304-41.984-20.992-2.048-39.936 13.312-41.984 34.304L650.24 318.976l-232.448 0.512 29.184-275.456c2.048-20.992-13.312-39.936-34.304-41.984-20.992-2.048-39.936 13.312-41.984 34.304l-29.696 283.648-246.272 0.512c-20.992 0-38.4 17.408-38.4 38.4s17.408 38.4 38.4 38.4l238.08-0.512-24.064 229.888-214.016 0.512c-20.992 0-38.4 17.408-38.4 38.4s17.408 38.4 38.4 38.4l205.824-0.512-29.184 276.992c-2.048 20.992 13.312 39.936 34.304 41.984h4.096c19.456 0 35.84-14.848 37.888-34.304l30.208-285.184 232.448-0.512-29.184 277.504c-2.048 20.992 13.312 39.936 34.304 41.984h4.096c19.456 0 35.84-14.848 38.4-34.304l30.208-285.184 242.688-0.512c20.992 0 38.4-17.408 38.4-38.4-1.536-20.992-18.944-37.888-39.936-37.888z m-544.256 0.512l24.064-229.888 232.448-0.512-24.064 229.888-232.448 0.512z" fill="#979797" p-id="6855"></path></svg>');
  }
  // 菜单是否需要激活（如选中加粗文本，“加粗”菜单会激活），用不到则返回 false
  isActive(e) {
    return !1;
  }
  // 获取菜单执行时的 value ，用不到则返回空 字符串或 false
  getValue(e) {
    return "";
  }
  // 菜单是否需要禁用（如选中 H1 ，“引用”菜单被禁用），用不到则返回 false
  isDisabled(e) {
    return !1;
  }
  // 点击菜单时触发的函数
  exec(e, t) {
    e.insertText("#");
  }
};
const W4 = {
  key: "marker",
  factory() {
    return new G4();
  }
}, J4 = {
  renderElems: [q4],
  elemsToHtml: [z4],
  parseElemsHtml: [H4],
  menus: [W4]
};
const Y4 = /* @__PURE__ */ ye({
  name: "MenTion",
  props: {
    controller: {
      type: Object,
      required: !0
    },
    modal: {
      type: Object
    }
  },
  setup(s) {
    const e = me("mention"), t = s.controller, n = L(!1), i = L([]);
    let r = Pt;
    const o = L({}), a = L(0), l = L(""), c = L([]), u = (C) => {
      const {
        eventArg: A
      } = C;
      if (A) {
        l.value || (l.value = A), l.value.length > A.length && t.overlay && t.execting && (l.value = "", t.overlay.dismiss());
        const k = A.match(new RegExp("(?<=\\@)([^\\@&^{]*?)(?=\\<)", "g")) || [];
        t.execting && (k.length === 0 && (l.value = "", t.overlay.dismiss()), t.query = k.pop() || "", t.query && /\s$/.test(t.query) ? (l.value = "", t.overlay.dismiss()) : t.query && m({
          isInitialLoad: !0
        }));
      } else
        t.overlay && t.execting && (l.value = "", t.overlay.dismiss());
    }, d = () => {
      t.evt && t.evt.on("onChange", u);
    }, f = (C = {}) => {
      n.value = !0, t.getUsers(C).then((A) => {
        (A.status !== 200 || !A.data) && (n.value = !1), A.headers["x-total"] && (a.value = Number(A.headers["x-total"])), C.isLoadMore === !0 ? i.value.push(...t.toUIData(A.data)) : (i.value = t.toUIData(A.data), i.value.length > 0 && (o.value = i.value[0])), n.value = !1;
      }).catch(() => {
        n.value = !1;
      });
    }, g = () => {
      f({
        isLoadMore: !0
      });
    }, p = qe(() => i.value.length >= a.value || n.value || a.value <= t.size), m = pu(f, 300, {
      leading: !0
    });
    d(), f({
      isInitialLoad: !0
    });
    const w = (C) => {
      var k;
      let A = i.value.findIndex((O) => O.id === o.value.id);
      switch (C) {
        case "up":
          A--, (A === -1 || A === -2) && (A = i.value.length - 1), o.value = i.value[A];
          break;
        case "down":
          A++, A === i.value.length && (A = 0), o.value = i.value[A];
          break;
        case "enter":
          i.value.length > 0 ? v(o.value) : (l.value = "", (k = s.modal) == null || k.dismiss({
            ok: !1,
            data: []
          }));
          break;
      }
    }, v = (C) => {
      var A;
      if (s.modal) {
        const k = {
          ok: !0,
          data: [C]
        };
        l.value = "", (A = s.modal) == null || A.dismiss(k);
      }
    }, y = (C) => {
      if (!C)
        return null;
      const A = JSON.parse(C);
      if (A.length === 0)
        return null;
      const {
        downloadUrl: k
      } = ibiz.util.file.calcFileUpDownUrl(t.context, t.params, t.editorParams);
      return k.replace("%fileId%", A[0].id);
    }, b = (C) => {
      c.value.push(C);
    }, x = (C) => {
      const A = C.name, k = Xs.stringToHexColor(A), O = Xs.avatarName(A), P = C.title;
      let D = "";
      if (t.operatorMap.has(C.id)) {
        const N = t.operatorMap.get(C.id);
        N.data.iconurl && (D = y(N.data.iconurl) || "");
      }
      return S("div", {
        class: [e.e("item"), e.is("active", C.id === o.value.id)],
        onClick: () => v(C)
      }, [S("div", {
        class: e.e("avatar"),
        style: "background: ".concat(k, ";")
      }, [D && !c.value.includes(D) ? S("img", {
        src: D,
        onError: () => b(D)
      }, null) : O]), S("div", {
        class: e.e("name"),
        title: A
      }, [A]), P && S("div", {
        class: e.e("title-label")
      }, [P])]);
    };
    return fn(() => {
      r = pi(window, "keyup", (C) => {
        C.keyCode === 40 ? w("down") : C.keyCode === 38 ? w("up") : C.keyCode === 13 && w("enter");
      });
    }), Lo(() => {
      r !== Pt && r(), t.evt.off("onChange", u);
    }), {
      ns: e,
      items: i,
      loading: n,
      isLodeMoreDisabled: p,
      renderItem: x,
      loadMore: g
    };
  },
  render() {
    return gi(S("div", {
      "infinite-scroll-distance": 10,
      "infinite-scroll-disabled": this.isLodeMoreDisabled,
      "infinite-scroll-immediate": !1,
      class: this.ns.b()
    }, [this.items.map((s) => this.renderItem(s)), this.items.length === 0 && S(Ee("iBizNoData"), {
      text: "暂无用户数据"
    }, null)]), [[Vi("infinite-scroll"), () => this.loadMore()], [Vi("loading"), this.loading]]);
  }
});
const X4 = /* @__PURE__ */ ye({
  name: "Marker",
  props: {
    controller: {
      type: Object,
      required: !0
    },
    modal: {
      type: Object
    }
  },
  setup(s) {
    const e = me("marker"), t = s.controller, n = L(!1), i = L([]);
    let r = Pt;
    const o = L({}), a = L(0), l = L(""), c = (b) => {
      const {
        eventArg: x
      } = b;
      if (x) {
        l.value || (l.value = x), l.value.length > x.length && t.overlay && t.execting && (l.value = "", t.overlay.dismiss());
        const C = /<svg((.|[\t\r\f\n\s])+?)<\/svg>/g, k = x.replace(C, "").match(new RegExp("(?<=\\#)([^\\#&^{]*?)(?=\\<)", "g")) || [];
        t.execting && (k.length === 0 && (l.value = "", t.overlay.dismiss()), t.query = k.pop() || "", t.query && /\s$/.test(t.query) ? (l.value = "", t.overlay.dismiss()) : t.query && p({
          isInitialLoad: !0
        }));
      } else
        t.overlay && t.execting && (l.value = "", t.overlay.dismiss());
    }, u = () => {
      t.evt && t.evt.on("onChange", c);
    }, d = (b = {}) => {
      n.value = !0, t.load(b).then((x) => {
        (x.status !== 200 || !x.data) && (n.value = !1), x.headers["x-total"] && (a.value = Number(x.headers["x-total"])), b.isLoadMore === !0 ? i.value.push(...t.toUIData(x.data)) : (i.value = t.toUIData(x.data), i.value.length > 0 && (o.value = i.value[0])), n.value = !1;
      }).catch(() => {
        n.value = !1;
      });
    }, f = () => {
      d({
        isLoadMore: !0
      });
    }, g = qe(() => i.value.length >= a.value || n.value || a.value <= t.size), p = pu(d, 300, {
      leading: !0
    });
    u(), d({
      isInitialLoad: !0
    });
    const m = (b) => {
      var C;
      let x = i.value.findIndex((A) => A.id === o.value.id);
      switch (b) {
        case "up":
          x--, (x === -1 || x === -2) && (x = i.value.length - 1), o.value = i.value[x];
          break;
        case "down":
          x++, x === i.value.length && (x = 0), o.value = i.value[x];
          break;
        case "enter":
          i.value.length > 0 ? w(o.value) : (l.value = "", (C = s.modal) == null || C.dismiss({
            ok: !1,
            data: []
          }));
          break;
      }
    }, w = (b) => {
      var x;
      if (s.modal) {
        const C = {
          ok: !0,
          data: [b]
        };
        l.value = "", (x = s.modal) == null || x.dismiss(C);
      }
    }, v = (b, x) => {
      if (t.quoteCodelistMap.has(b)) {
        const C = t.quoteCodelistMap.get(b);
        return S(Ee("iBizCodeList"), {
          codeListItems: C.codeListItems,
          codeList: C.codeList,
          value: x
        }, null);
      }
      return x;
    }, y = (b) => S("div", {
      class: [e.e("item"), e.is("active", b.id === o.value.id)],
      onClick: () => w(b)
    }, [S("div", {
      class: e.e("type")
    }, [v("type", b.owner_subtype)]), S("div", {
      class: e.e("identifier")
    }, [v("identifier", b.identifier)]), S("div", {
      class: e.e("name"),
      title: b.name
    }, [v("name", b.name)])]);
    return fn(() => {
      r = pi(window, "keyup", (b) => {
        b.keyCode === 40 ? m("down") : b.keyCode === 38 ? m("up") : b.keyCode === 13 && m("enter");
      });
    }), Lo(() => {
      r !== Pt && r(), t.evt.off("onChange", c);
    }), {
      ns: e,
      items: i,
      loading: n,
      isLodeMoreDisabled: g,
      renderItem: y,
      loadMore: f
    };
  },
  render() {
    return gi(S("div", {
      "infinite-scroll-distance": 10,
      "infinite-scroll-disabled": this.isLodeMoreDisabled,
      "infinite-scroll-immediate": !1,
      class: this.ns.b()
    }, [this.items.map((s) => this.renderItem(s)), this.items.length === 0 && S(Ee("iBizNoData"), {
      text: "暂无数据"
    }, null)]), [[Vi("infinite-scroll"), () => this.loadMore()], [Vi("loading"), this.loading]]);
  }
});
const Z4 = /* @__PURE__ */ ye({
  name: "IBizHtmlEmoji",
  props: {
    modal: {
      type: Object,
      required: !0
    }
  },
  setup(s) {
    return {
      ns: me("html-emoji"),
      onSelect: (n) => {
        const i = {
          ok: !0,
          data: [{
            emoji: ro(n.data)
          }]
        };
        s.modal.dismiss(i);
      }
    };
  },
  render() {
    return S("div", {
      class: this.ns.b()
    }, [S(Ee("iBizEmojiSelect"), {
      dark: !0,
      continuousList: !0,
      onSelect: this.onSelect
    }, null)]);
  }
});
let en = class {
  constructor(e, t, n) {
    E(this, "name");
    E(this, "icon");
    E(this, "text");
    this.name = e, this.icon = t, this.text = n;
  }
  get label() {
    return this.name;
  }
};
class h {
  constructor(e, t, n) {
    E(this, "data");
    E(this, "category");
    E(this, "aliases");
    this.data = e, this.category = t, this.aliases = n;
  }
}
const K4 = [
  new h("😀", "peoples", ["grinning"]),
  new h("😃", "peoples", ["smiley"]),
  new h("😄", "peoples", ["smile"]),
  new h("😁", "peoples", ["grin"]),
  new h("😆", "peoples", ["laughing", "satisfied"]),
  new h("😅", "peoples", ["sweat_smile"]),
  new h("😂", "peoples", ["joy"]),
  new h("🤣", "peoples", ["rofl"]),
  new h("😌", "peoples", ["relaxed"]),
  new h("😊", "peoples", ["blush"]),
  new h("😇", "peoples", ["innocent"]),
  new h("🙂", "peoples", ["slightly_smiling_face"]),
  new h("🙃", "peoples", ["upside_down_face"]),
  new h("😉", "peoples", ["wink"]),
  new h("😌", "peoples", ["relieved"]),
  new h("😍", "peoples", ["heart_eyes"]),
  new h("😘", "peoples", ["kissing_heart"]),
  new h("😗", "peoples", ["kissing"]),
  new h("😙", "peoples", ["kissing_smiling_eyes"]),
  new h("😚", "peoples", ["kissing_closed_eyes"]),
  new h("😋", "peoples", ["yum"]),
  new h("😜", "peoples", ["stuck_out_tongue_winking_eye"]),
  new h("😝", "peoples", ["stuck_out_tongue_closed_eyes"]),
  new h("😛", "peoples", ["stuck_out_tongue"]),
  new h("🤑", "peoples", ["money_mouth_face"]),
  new h("🤗", "peoples", ["hugs"]),
  new h("🤓", "peoples", ["nerd_face"]),
  new h("😎", "peoples", ["sunglasses"]),
  new h("🤡", "peoples", ["clown_face"]),
  new h("🤠", "peoples", ["cowboy_hat_face"]),
  new h("😏", "peoples", ["smirk"]),
  new h("😒", "peoples", ["unamused"]),
  new h("😞", "peoples", ["disappointed"]),
  new h("😔", "peoples", ["pensive"]),
  new h("😟", "peoples", ["worried"]),
  new h("😕", "peoples", ["confused"]),
  new h("🙁", "peoples", ["slightly_frowning_face"]),
  new h("☹️", "peoples", ["frowning_face"]),
  new h("😣", "peoples", ["persevere"]),
  new h("😖", "peoples", ["confounded"]),
  new h("😫", "peoples", ["tired_face"]),
  new h("😩", "peoples", ["weary"]),
  new h("😤", "peoples", ["triumph"]),
  new h("😠", "peoples", ["angry"]),
  new h("😡", "peoples", ["rage", "pout"]),
  new h("😶", "peoples", ["no_mouth"]),
  new h("😐", "peoples", ["neutral_face"]),
  new h("😑", "peoples", ["expressionless"]),
  new h("😯", "peoples", ["hushed"]),
  new h("😦", "peoples", ["frowning"]),
  new h("😧", "peoples", ["anguished"]),
  new h("😮", "peoples", ["open_mouth"]),
  new h("😲", "peoples", ["astonished"]),
  new h("😵", "peoples", ["dizzy_face"]),
  new h("😳", "peoples", ["flushed"]),
  new h("😱", "peoples", ["scream"]),
  new h("😨", "peoples", ["fearful"]),
  new h("😰", "peoples", ["cold_sweat"]),
  new h("😢", "peoples", ["cry"]),
  new h("😥", "peoples", ["disappointed_relieved"]),
  new h("🤤", "peoples", ["drooling_face"]),
  new h("😭", "peoples", ["sob"]),
  new h("😓", "peoples", ["sweat"]),
  new h("😪", "peoples", ["sleepy"]),
  new h("😴", "peoples", ["sleeping"]),
  new h("🙄", "peoples", ["roll_eyes"]),
  new h("🤔", "peoples", ["thinking"]),
  new h("🤥", "peoples", ["lying_face"]),
  new h("😬", "peoples", ["grimacing"]),
  new h("🤐", "peoples", ["zipper_mouth_face"]),
  new h("🤢", "peoples", ["nauseated_face"]),
  new h("🤧", "peoples", ["sneezing_face"]),
  new h("😷", "peoples", ["mask"]),
  new h("🤒", "peoples", ["face_with_thermometer"]),
  new h("🤕", "peoples", ["face_with_head_bandage"]),
  new h("😈", "peoples", ["smiling_imp"]),
  new h("👿", "peoples", ["imp"]),
  new h("👹", "peoples", ["japanese_ogre"]),
  new h("👺", "peoples", ["japanese_goblin"]),
  new h("💩", "peoples", ["hankey", "poop", "shit"]),
  new h("👻", "peoples", ["ghost"]),
  new h("💀", "peoples", ["skull"]),
  new h("☠️", "peoples", ["skull_and_crossbones"]),
  new h("👽", "peoples", ["alien"]),
  new h("👾", "peoples", ["space_invader"]),
  new h("🤖", "peoples", ["robot"]),
  new h("🎃", "peoples", ["jack_o_lantern"]),
  new h("😺", "peoples", ["smiley_cat"]),
  new h("😸", "peoples", ["smile_cat"]),
  new h("😹", "peoples", ["joy_cat"]),
  new h("😻", "peoples", ["heart_eyes_cat"]),
  new h("😼", "peoples", ["smirk_cat"]),
  new h("😽", "peoples", ["kissing_cat"]),
  new h("🙀", "peoples", ["scream_cat"]),
  new h("😿", "peoples", ["crying_cat_face"]),
  new h("😾", "peoples", ["pouting_cat"]),
  new h("👐", "peoples", ["open_hands"]),
  new h("🙌", "peoples", ["raised_hands"]),
  new h("👏", "peoples", ["clap"]),
  new h("🙏", "peoples", ["pray"]),
  new h("🤝", "peoples", ["handshake"]),
  new h("👍", "peoples", ["+1", "thumbsup"]),
  new h("👎", "peoples", ["-1", "thumbsdown"]),
  new h("👊", "peoples", ["fist_oncoming", "facepunch", "punch"]),
  new h("✊", "peoples", ["fist_raised", "fist"]),
  new h("🤛", "peoples", ["fist_left"]),
  new h("🤜", "peoples", ["fist_right"]),
  new h("🤞", "peoples", ["crossed_fingers"]),
  new h("✌️", "peoples", ["v"]),
  new h("🤘", "peoples", ["metal"]),
  new h("👌", "peoples", ["ok_hand"]),
  new h("👈", "peoples", ["point_left"]),
  new h("👉", "peoples", ["point_right"]),
  new h("👆", "peoples", ["point_up_2"]),
  new h("👇", "peoples", ["point_down"]),
  new h("☝️", "peoples", ["point_up"]),
  new h("✋", "peoples", ["hand", "raised_hand"]),
  new h("🤚", "peoples", ["raised_back_of_hand"]),
  new h("🖐", "peoples", ["raised_hand_with_fingers_splayed"]),
  new h("🖖", "peoples", ["vulcan_salute"]),
  new h("👋", "peoples", ["wave"]),
  new h("🤙", "peoples", ["call_me_hand"]),
  new h("💪", "peoples", ["muscle"]),
  new h("🖕", "peoples", ["middle_finger", "fu"]),
  new h("✍️", "peoples", ["writing_hand"]),
  new h("🤳", "peoples", ["selfie"]),
  new h("💅", "peoples", ["nail_care"]),
  new h("💍", "peoples", ["ring"]),
  new h("💄", "peoples", ["lipstick"]),
  new h("💋", "peoples", ["kiss"]),
  new h("👄", "peoples", ["lips"]),
  new h("👅", "peoples", ["tongue"]),
  new h("👂", "peoples", ["ear"]),
  new h("👃", "peoples", ["nose"]),
  new h("👣", "peoples", ["footprints"]),
  new h("👁", "peoples", ["eye"]),
  new h("👀", "peoples", ["eyes"]),
  new h("🗣", "peoples", ["speaking_head"]),
  new h("👤", "peoples", ["bust_in_silhouette"]),
  new h("👥", "peoples", ["busts_in_silhouette"]),
  new h("👶", "peoples", ["baby"]),
  new h("👦", "peoples", ["boy"]),
  new h("👧", "peoples", ["girl"]),
  new h("👨", "peoples", ["man"]),
  new h("👩", "peoples", ["woman"]),
  new h("👱‍♀", "peoples", ["blonde_woman"]),
  new h("👱", "peoples", ["blonde_man", "person_with_blond_hair"]),
  new h("👴", "peoples", ["older_man"]),
  new h("👵", "peoples", ["older_woman"]),
  new h("👲", "peoples", ["man_with_gua_pi_mao"]),
  new h("👳‍♀", "peoples", ["woman_with_turban"]),
  new h("👳", "peoples", ["man_with_turban"]),
  new h("👮‍♀", "peoples", ["policewoman"]),
  new h("👮", "peoples", ["policeman", "cop"]),
  new h("👷‍♀", "peoples", ["construction_worker_woman"]),
  new h("👷", "peoples", [
    "construction_worker_man",
    "construction_worker"
  ]),
  new h("💂‍♀", "peoples", ["guardswoman"]),
  new h("💂", "peoples", ["guardsman"]),
  new h("👩‍⚕", "peoples", ["woman_health_worker"]),
  new h("👨‍⚕", "peoples", ["man_health_worker"]),
  new h("👩‍🌾", "peoples", ["woman_farmer"]),
  new h("👨‍🌾", "peoples", ["man_farmer"]),
  new h("👩‍🍳", "peoples", ["woman_cook"]),
  new h("👨‍🍳", "peoples", ["man_cook"]),
  new h("👩‍🎓", "peoples", ["woman_student"]),
  new h("👨‍🎓", "peoples", ["man_student"]),
  new h("👩‍🎤", "peoples", ["woman_singer"]),
  new h("👨‍🎤", "peoples", ["man_singer"]),
  new h("👩‍🏫", "peoples", ["woman_teacher"]),
  new h("👨‍🏫", "peoples", ["man_teacher"]),
  new h("👩‍🏭", "peoples", ["woman_factory_worker"]),
  new h("👨‍🏭", "peoples", ["man_factory_worker"]),
  new h("👩‍💻", "peoples", ["woman_technologist"]),
  new h("👨‍💻", "peoples", ["man_technologist"]),
  new h("👩‍💼", "peoples", ["woman_office_worker"]),
  new h("👨‍💼", "peoples", ["man_office_worker"]),
  new h("👩‍🔧", "peoples", ["woman_mechanic"]),
  new h("👨‍🔧", "peoples", ["man_mechanic"]),
  new h("👩‍🔬", "peoples", ["woman_scientist"]),
  new h("👨‍🔬", "peoples", ["man_scientist"]),
  new h("👩‍🎨", "peoples", ["woman_artist"]),
  new h("👨‍🎨", "peoples", ["man_artist"]),
  new h("👩‍🚒", "peoples", ["woman_firefighter"]),
  new h("👨‍🚒", "peoples", ["man_firefighter"]),
  new h("👩‍🚀", "peoples", ["woman_astronaut"]),
  new h("👨‍🚀", "peoples", ["man_astronaut"]),
  new h("🤶", "peoples", ["mrs_claus"]),
  new h("🎅", "peoples", ["santa"]),
  new h("👸", "peoples", ["princess"]),
  new h("🤴", "peoples", ["prince"]),
  new h("👰", "peoples", ["bride_with_veil"]),
  new h("🤵", "peoples", ["man_in_tuxedo"]),
  new h("👼", "peoples", ["angel"]),
  new h("🤰", "peoples", ["pregnant_woman"]),
  new h("🙇‍♀", "peoples", ["bowing_woman"]),
  new h("🙇", "peoples", ["bowing_man", "bow"]),
  new h("💁", "peoples", [
    "tipping_hand_woman",
    "information_desk_person",
    "sassy_woman"
  ]),
  new h("💁‍♂", "peoples", ["tipping_hand_man", "sassy_man"]),
  new h("🙅", "peoples", ["no_good_woman", "no_good", "ng_woman"]),
  new h("🙅‍♂", "peoples", ["no_good_man", "ng_man"]),
  new h("🙆", "peoples", ["ok_woman"]),
  new h("🙆‍♂", "peoples", ["ok_man"]),
  new h("🙋", "peoples", ["raising_hand_woman", "raising_hand"]),
  new h("🙋‍♂", "peoples", ["raising_hand_man"]),
  new h("🤦‍♀", "peoples", ["woman_facepalming"]),
  new h("🤦‍♂", "peoples", ["man_facepalming"]),
  new h("🤷‍♀", "peoples", ["woman_shrugging"]),
  new h("🤷‍♂", "peoples", ["man_shrugging"]),
  new h("🙎", "peoples", ["pouting_woman", "person_with_pouting_face"]),
  new h("🙎‍♂", "peoples", ["pouting_man"]),
  new h("🙍", "peoples", ["frowning_woman", "person_frowning"]),
  new h("🙍‍♂", "peoples", ["frowning_man"]),
  new h("💇", "peoples", ["haircut_woman", "haircut"]),
  new h("💇‍♂", "peoples", ["haircut_man"]),
  new h("💆", "peoples", ["massage_woman", "massage"]),
  new h("💆‍♂", "peoples", ["massage_man"]),
  new h("🕴", "peoples", ["business_suit_levitating"]),
  new h("💃", "peoples", ["dancer"]),
  new h("🕺", "peoples", ["man_dancing"]),
  new h("👯", "peoples", ["dancing_women", "dancers"]),
  new h("👯‍♂", "peoples", ["dancing_men"]),
  new h("🚶‍♀", "peoples", ["walking_woman"]),
  new h("🚶", "peoples", ["walking_man", "walking"]),
  new h("🏃‍♀", "peoples", ["running_woman"]),
  new h("🏃", "peoples", ["running_man", "runner", "running"]),
  new h("👫", "peoples", ["couple"]),
  new h("👭", "peoples", ["two_women_holding_hands"]),
  new h("👬", "peoples", ["two_men_holding_hands"]),
  new h("💑", "peoples", [
    "couple_with_heart_woman_man",
    "couple_with_heart"
  ]),
  new h("👩‍❤️‍👩", "peoples", ["couple_with_heart_woman_woman"]),
  new h("👨‍❤️‍👨", "peoples", ["couple_with_heart_man_man"]),
  new h("💏", "peoples", ["couplekiss_man_woman"]),
  new h("👩‍❤️‍💋‍👩", "peoples", ["couplekiss_woman_woman"]),
  new h("👨‍❤️‍💋‍👨", "peoples", ["couplekiss_man_man"]),
  new h("👪", "peoples", ["family_man_woman_boy", "family"]),
  new h("👨‍👩‍👧", "peoples", ["family_man_woman_girl"]),
  new h("👨‍👩‍👧‍👦", "peoples", ["family_man_woman_girl_boy"]),
  new h("👨‍👩‍👦‍👦", "peoples", ["family_man_woman_boy_boy"]),
  new h("👨‍👩‍👧‍👧", "peoples", ["family_man_woman_girl_girl"]),
  new h("👩‍👩‍👦", "peoples", ["family_woman_woman_boy"]),
  new h("👩‍👩‍👧", "peoples", ["family_woman_woman_girl"]),
  new h("👩‍👩‍👧‍👦", "peoples", ["family_woman_woman_girl_boy"]),
  new h("👩‍👩‍👦‍👦", "peoples", ["family_woman_woman_boy_boy"]),
  new h("👩‍👩‍👧‍👧", "peoples", ["family_woman_woman_girl_girl"]),
  new h("👨‍👨‍👦", "peoples", ["family_man_man_boy"]),
  new h("👨‍👨‍👧", "peoples", ["family_man_man_girl"]),
  new h("👨‍👨‍👧‍👦", "peoples", ["family_man_man_girl_boy"]),
  new h("👨‍👨‍👦‍👦", "peoples", ["family_man_man_boy_boy"]),
  new h("👨‍👨‍👧‍👧", "peoples", ["family_man_man_girl_girl"]),
  new h("👩‍👦", "peoples", ["family_woman_boy"]),
  new h("👩‍👧", "peoples", ["family_woman_girl"]),
  new h("👩‍👧‍👦", "peoples", ["family_woman_girl_boy"]),
  new h("👩‍👦‍👦", "peoples", ["family_woman_boy_boy"]),
  new h("👩‍👧‍👧", "peoples", ["family_woman_girl_girl"]),
  new h("👨‍👦", "peoples", ["family_man_boy"]),
  new h("👨‍👧", "peoples", ["family_man_girl"]),
  new h("👨‍👧‍👦", "peoples", ["family_man_girl_boy"]),
  new h("👨‍👦‍👦", "peoples", ["family_man_boy_boy"]),
  new h("👨‍👧‍👧", "peoples", ["family_man_girl_girl"]),
  new h("👚", "peoples", ["womans_clothes"]),
  new h("👕", "peoples", ["shirt", "tshirt"]),
  new h("👖", "peoples", ["jeans"]),
  new h("👔", "peoples", ["necktie"]),
  new h("👗", "peoples", ["dress"]),
  new h("👙", "peoples", ["bikini"]),
  new h("👘", "peoples", ["kimono"]),
  new h("👠", "peoples", ["high_heel"]),
  new h("👡", "peoples", ["sandal"]),
  new h("👢", "peoples", ["boot"]),
  new h("👞", "peoples", ["mans_shoe", "shoe"]),
  new h("👟", "peoples", ["athletic_shoe"]),
  new h("👒", "peoples", ["womans_hat"]),
  new h("🎩", "peoples", ["tophat"]),
  new h("🎓", "peoples", ["mortar_board"]),
  new h("👑", "peoples", ["crown"]),
  new h("⛑", "peoples", ["rescue_worker_helmet"]),
  new h("🎒", "peoples", ["school_satchel"]),
  new h("👝", "peoples", ["pouch"]),
  new h("👛", "peoples", ["purse"]),
  new h("👜", "peoples", ["handbag"]),
  new h("💼", "peoples", ["briefcase"]),
  new h("👓", "peoples", ["eyeglasses"]),
  new h("🕶", "peoples", ["dark_sunglasses"]),
  new h("🌂", "peoples", ["closed_umbrella"]),
  new h("☂️", "peoples", ["open_umbrella"]),
  new h("🐶", "nature", ["dog"]),
  new h("🐱", "nature", ["cat"]),
  new h("🐭", "nature", ["mouse"]),
  new h("🐹", "nature", ["hamster"]),
  new h("🐰", "nature", ["rabbit"]),
  new h("🦊", "nature", ["fox_face"]),
  new h("🐻", "nature", ["bear"]),
  new h("🐼", "nature", ["panda_face"]),
  new h("🐨", "nature", ["koala"]),
  new h("🐯", "nature", ["tiger"]),
  new h("🦁", "nature", ["lion"]),
  new h("🐮", "nature", ["cow"]),
  new h("🐷", "nature", ["pig"]),
  new h("🐽", "nature", ["pig_nose"]),
  new h("🐸", "nature", ["frog"]),
  new h("🐵", "nature", ["monkey_face"]),
  new h("🙈", "nature", ["see_no_evil"]),
  new h("🙉", "nature", ["hear_no_evil"]),
  new h("🙊", "nature", ["speak_no_evil"]),
  new h("🐒", "nature", ["monkey"]),
  new h("🐔", "nature", ["chicken"]),
  new h("🐧", "nature", ["penguin"]),
  new h("🐦", "nature", ["bird"]),
  new h("🐤", "nature", ["baby_chick"]),
  new h("🐣", "nature", ["hatching_chick"]),
  new h("🐥", "nature", ["hatched_chick"]),
  new h("🦆", "nature", ["duck"]),
  new h("🦅", "nature", ["eagle"]),
  new h("🦉", "nature", ["owl"]),
  new h("🦇", "nature", ["bat"]),
  new h("🐺", "nature", ["wolf"]),
  new h("🐗", "nature", ["boar"]),
  new h("🐴", "nature", ["horse"]),
  new h("🦄", "nature", ["unicorn"]),
  new h("🐝", "nature", ["bee", "honeybee"]),
  new h("🐛", "nature", ["bug"]),
  new h("🦋", "nature", ["butterfly"]),
  new h("🐌", "nature", ["snail"]),
  new h("🐚", "nature", ["shell"]),
  new h("🐞", "nature", ["beetle"]),
  new h("🐜", "nature", ["ant"]),
  new h("🕷", "nature", ["spider"]),
  new h("🕸", "nature", ["spider_web"]),
  new h("🐢", "nature", ["turtle"]),
  new h("🐍", "nature", ["snake"]),
  new h("🦎", "nature", ["lizard"]),
  new h("🦂", "nature", ["scorpion"]),
  new h("🦀", "nature", ["crab"]),
  new h("🦑", "nature", ["squid"]),
  new h("🐙", "nature", ["octopus"]),
  new h("🦐", "nature", ["shrimp"]),
  new h("🐠", "nature", ["tropical_fish"]),
  new h("🐟", "nature", ["fish"]),
  new h("🐡", "nature", ["blowfish"]),
  new h("🐬", "nature", ["dolphin", "flipper"]),
  new h("🦈", "nature", ["shark"]),
  new h("🐳", "nature", ["whale"]),
  new h("🐋", "nature", ["whale2"]),
  new h("🐊", "nature", ["crocodile"]),
  new h("🐆", "nature", ["leopard"]),
  new h("🐅", "nature", ["tiger2"]),
  new h("🐃", "nature", ["water_buffalo"]),
  new h("🐂", "nature", ["ox"]),
  new h("🐄", "nature", ["cow2"]),
  new h("🦌", "nature", ["deer"]),
  new h("🐪", "nature", ["dromedary_camel"]),
  new h("🐫", "nature", ["camel"]),
  new h("🐘", "nature", ["elephant"]),
  new h("🦏", "nature", ["rhinoceros"]),
  new h("🦍", "nature", ["gorilla"]),
  new h("🐎", "nature", ["racehorse"]),
  new h("🐖", "nature", ["pig2"]),
  new h("🐐", "nature", ["goat"]),
  new h("🐏", "nature", ["ram"]),
  new h("🐑", "nature", ["sheep"]),
  new h("🐕", "nature", ["dog2"]),
  new h("🐩", "nature", ["poodle"]),
  new h("🐈", "nature", ["cat2"]),
  new h("🐓", "nature", ["rooster"]),
  new h("🦃", "nature", ["turkey"]),
  new h("🕊", "nature", ["dove"]),
  new h("🐇", "nature", ["rabbit2"]),
  new h("🐁", "nature", ["mouse2"]),
  new h("🐀", "nature", ["rat"]),
  new h("🐿", "nature", ["chipmunk"]),
  new h("🐾", "nature", ["feet", "paw_prints"]),
  new h("🐉", "nature", ["dragon"]),
  new h("🐲", "nature", ["dragon_face"]),
  new h("🌵", "nature", ["cactus"]),
  new h("🎄", "nature", ["christmas_tree"]),
  new h("🌲", "nature", ["evergreen_tree"]),
  new h("🌳", "nature", ["deciduous_tree"]),
  new h("🌴", "nature", ["palm_tree"]),
  new h("🌱", "nature", ["seedling"]),
  new h("🌿", "nature", ["herb"]),
  new h("☘️", "nature", ["shamrock"]),
  new h("🍀", "nature", ["four_leaf_clover"]),
  new h("🎍", "nature", ["bamboo"]),
  new h("🎋", "nature", ["tanabata_tree"]),
  new h("🍃", "nature", ["leaves"]),
  new h("🍂", "nature", ["fallen_leaf"]),
  new h("🍁", "nature", ["maple_leaf"]),
  new h("🍄", "nature", ["mushroom"]),
  new h("🌾", "nature", ["ear_of_rice"]),
  new h("💐", "nature", ["bouquet"]),
  new h("🌷", "nature", ["tulip"]),
  new h("🌹", "nature", ["rose"]),
  new h("🥀", "nature", ["wilted_flower"]),
  new h("🌻", "nature", ["sunflower"]),
  new h("🌼", "nature", ["blossom"]),
  new h("🌸", "nature", ["cherry_blossom"]),
  new h("🌺", "nature", ["hibiscus"]),
  new h("🌎", "nature", ["earth_americas"]),
  new h("🌍", "nature", ["earth_africa"]),
  new h("🌏", "nature", ["earth_asia"]),
  new h("🌕", "nature", ["full_moon"]),
  new h("🌖", "nature", ["waning_gibbous_moon"]),
  new h("🌗", "nature", ["last_quarter_moon"]),
  new h("🌘", "nature", ["waning_crescent_moon"]),
  new h("🌑", "nature", ["new_moon"]),
  new h("🌒", "nature", ["waxing_crescent_moon"]),
  new h("🌓", "nature", ["first_quarter_moon"]),
  new h("🌔", "nature", ["moon", "waxing_gibbous_moon"]),
  new h("🌚", "nature", ["new_moon_with_face"]),
  new h("🌝", "nature", ["full_moon_with_face"]),
  new h("🌞", "nature", ["sun_with_face"]),
  new h("🌛", "nature", ["first_quarter_moon_with_face"]),
  new h("🌜", "nature", ["last_quarter_moon_with_face"]),
  new h("🌙", "nature", ["crescent_moon"]),
  new h("💫", "nature", ["dizzy"]),
  new h("⭐️", "nature", ["star"]),
  new h("🌟", "nature", ["star2"]),
  new h("✨", "nature", ["sparkles"]),
  new h("⚡️", "nature", ["zap"]),
  new h("🔥", "nature", ["fire"]),
  new h("💥", "nature", ["boom", "collision"]),
  new h("☄", "nature", ["comet"]),
  new h("☀️", "nature", ["sunny"]),
  new h("🌤", "nature", ["sun_behind_small_cloud"]),
  new h("⛅️", "nature", ["partly_sunny"]),
  new h("🌥", "nature", ["sun_behind_large_cloud"]),
  new h("🌦", "nature", ["sun_behind_rain_cloud"]),
  new h("🌈", "nature", ["rainbow"]),
  new h("☁️", "nature", ["cloud"]),
  new h("🌧", "nature", ["cloud_with_rain"]),
  new h("⛈", "nature", ["cloud_with_lightning_and_rain"]),
  new h("🌩", "nature", ["cloud_with_lightning"]),
  new h("🌨", "nature", ["cloud_with_snow"]),
  new h("☃️", "nature", ["snowman_with_snow"]),
  new h("⛄️", "nature", ["snowman"]),
  new h("❄️", "nature", ["snowflake"]),
  new h("🌬", "nature", ["wind_face"]),
  new h("💨", "nature", ["dash"]),
  new h("🌪", "nature", ["tornado"]),
  new h("🌫", "nature", ["fog"]),
  new h("🌊", "nature", ["ocean"]),
  new h("💧", "nature", ["droplet"]),
  new h("💦", "nature", ["sweat_drops"]),
  new h("☔️", "nature", ["umbrella"]),
  new h("🍏", "foods", ["green_apple"]),
  new h("🍎", "foods", ["apple"]),
  new h("🍐", "foods", ["pear"]),
  new h("🍊", "foods", ["tangerine", "orange", "mandarin"]),
  new h("🍋", "foods", ["lemon"]),
  new h("🍌", "foods", ["banana"]),
  new h("🍉", "foods", ["watermelon"]),
  new h("🍇", "foods", ["grapes"]),
  new h("🍓", "foods", ["strawberry"]),
  new h("🍈", "foods", ["melon"]),
  new h("🍒", "foods", ["cherries"]),
  new h("🍑", "foods", ["peach"]),
  new h("🍍", "foods", ["pineapple"]),
  new h("🥝", "foods", ["kiwi_fruit"]),
  new h("🥑", "foods", ["avocado"]),
  new h("🍅", "foods", ["tomato"]),
  new h("🍆", "foods", ["eggplant"]),
  new h("🥒", "foods", ["cucumber"]),
  new h("🥕", "foods", ["carrot"]),
  new h("🌽", "foods", ["corn"]),
  new h("🌶", "foods", ["hot_pepper"]),
  new h("🥔", "foods", ["potato"]),
  new h("🍠", "foods", ["sweet_potato"]),
  new h("🌰", "foods", ["chestnut"]),
  new h("🥜", "foods", ["peanuts"]),
  new h("🍯", "foods", ["honey_pot"]),
  new h("🥐", "foods", ["croissant"]),
  new h("🍞", "foods", ["bread"]),
  new h("🥖", "foods", ["baguette_bread"]),
  new h("🧀", "foods", ["cheese"]),
  new h("🥚", "foods", ["egg"]),
  new h("🍳", "foods", ["fried_egg"]),
  new h("🥓", "foods", ["bacon"]),
  new h("🥞", "foods", ["pancakes"]),
  new h("🍤", "foods", ["fried_shrimp"]),
  new h("🍗", "foods", ["poultry_leg"]),
  new h("🍖", "foods", ["meat_on_bone"]),
  new h("🍕", "foods", ["pizza"]),
  new h("🌭", "foods", ["hotdog"]),
  new h("🍔", "foods", ["hamburger"]),
  new h("🍟", "foods", ["fries"]),
  new h("🥙", "foods", ["stuffed_flatbread"]),
  new h("🌮", "foods", ["taco"]),
  new h("🌯", "foods", ["burrito"]),
  new h("🥗", "foods", ["green_salad"]),
  new h("🥘", "foods", ["shallow_pan_of_food"]),
  new h("🍝", "foods", ["spaghetti"]),
  new h("🍜", "foods", ["ramen"]),
  new h("🍲", "foods", ["stew"]),
  new h("🍥", "foods", ["fish_cake"]),
  new h("🍣", "foods", ["sushi"]),
  new h("🍱", "foods", ["bento"]),
  new h("🍛", "foods", ["curry"]),
  new h("🍚", "foods", ["rice"]),
  new h("🍙", "foods", ["rice_ball"]),
  new h("🍘", "foods", ["rice_cracker"]),
  new h("🍢", "foods", ["oden"]),
  new h("🍡", "foods", ["dango"]),
  new h("🍧", "foods", ["shaved_ice"]),
  new h("🍨", "foods", ["ice_cream"]),
  new h("🍦", "foods", ["icecream"]),
  new h("🍰", "foods", ["cake"]),
  new h("🎂", "foods", ["birthday"]),
  new h("🍮", "foods", ["custard"]),
  new h("🍭", "foods", ["lollipop"]),
  new h("🍬", "foods", ["candy"]),
  new h("🍫", "foods", ["chocolate_bar"]),
  new h("🍿", "foods", ["popcorn"]),
  new h("🍩", "foods", ["doughnut"]),
  new h("🍪", "foods", ["cookie"]),
  new h("🥛", "foods", ["milk_glass"]),
  new h("🍼", "foods", ["baby_bottle"]),
  new h("☕️", "foods", ["coffee"]),
  new h("🍵", "foods", ["tea"]),
  new h("🍶", "foods", ["sake"]),
  new h("🍺", "foods", ["beer"]),
  new h("🍻", "foods", ["beers"]),
  new h("🥂", "foods", ["clinking_glasses"]),
  new h("🍷", "foods", ["wine_glass"]),
  new h("🥃", "foods", ["tumbler_glass"]),
  new h("🍸", "foods", ["cocktail"]),
  new h("🍹", "foods", ["tropical_drink"]),
  new h("🍾", "foods", ["champagne"]),
  new h("🥄", "foods", ["spoon"]),
  new h("🍴", "foods", ["fork_and_knife"]),
  new h("🍽", "foods", ["plate_with_cutlery"]),
  new h("⚽️", "activity", ["soccer"]),
  new h("🏀", "activity", ["basketball"]),
  new h("🏈", "activity", ["football"]),
  new h("⚾️", "activity", ["baseball"]),
  new h("🎾", "activity", ["tennis"]),
  new h("🏐", "activity", ["volleyball"]),
  new h("🏉", "activity", ["rugby_football"]),
  new h("🎱", "activity", ["8ball"]),
  new h("🏓", "activity", ["ping_pong"]),
  new h("🏸", "activity", ["badminton"]),
  new h("🥅", "activity", ["goal_net"]),
  new h("🏒", "activity", ["ice_hockey"]),
  new h("🏑", "activity", ["field_hockey"]),
  new h("🏏", "activity", ["cricket"]),
  new h("⛳️", "activity", ["golf"]),
  new h("🏹", "activity", ["bow_and_arrow"]),
  new h("🎣", "activity", ["fishing_pole_and_fish"]),
  new h("🥊", "activity", ["boxing_glove"]),
  new h("🥋", "activity", ["martial_arts_uniform"]),
  new h("⛸", "activity", ["ice_skate"]),
  new h("🎿", "activity", ["ski"]),
  new h("⛷", "activity", ["skier"]),
  new h("🏂", "activity", ["snowboarder"]),
  new h("🏋️‍♀️", "activity", ["weight_lifting_woman"]),
  new h("🏋", "activity", ["weight_lifting_man"]),
  new h("🤺", "activity", ["person_fencing"]),
  new h("🤼‍♀", "activity", ["women_wrestling"]),
  new h("🤼‍♂", "activity", ["men_wrestling"]),
  new h("🤸‍♀", "activity", ["woman_cartwheeling"]),
  new h("🤸‍♂", "activity", ["man_cartwheeling"]),
  new h("⛹️‍♀️", "activity", ["basketball_woman"]),
  new h("⛹", "activity", ["basketball_man"]),
  new h("🤾‍♀", "activity", ["woman_playing_handball"]),
  new h("🤾‍♂", "activity", ["man_playing_handball"]),
  new h("🏌️‍♀️", "activity", ["golfing_woman"]),
  new h("🏌", "activity", ["golfing_man"]),
  new h("🏄‍♀", "activity", ["surfing_woman"]),
  new h("🏄", "activity", ["surfing_man", "surfer"]),
  new h("🏊‍♀", "activity", ["swimming_woman"]),
  new h("🏊", "activity", ["swimming_man", "swimmer"]),
  new h("🤽‍♀", "activity", ["woman_playing_water_polo"]),
  new h("🤽‍♂", "activity", ["man_playing_water_polo"]),
  new h("🚣‍♀", "activity", ["rowing_woman"]),
  new h("🚣", "activity", ["rowing_man", "rowboat"]),
  new h("🏇", "activity", ["horse_racing"]),
  new h("🚴‍♀", "activity", ["biking_woman"]),
  new h("🚴", "activity", ["biking_man", "bicyclist"]),
  new h("🚵‍♀", "activity", ["mountain_biking_woman"]),
  new h("🚵", "activity", ["mountain_biking_man", "mountain_bicyclist"]),
  new h("🎽", "activity", ["running_shirt_with_sash"]),
  new h("🏅", "activity", ["medal_sports"]),
  new h("🎖", "activity", ["medal_military"]),
  new h("🥇", "activity", ["1st_place_medal"]),
  new h("🥈", "activity", ["2nd_place_medal"]),
  new h("🥉", "activity", ["3rd_place_medal"]),
  new h("🏆", "activity", ["trophy"]),
  new h("🏵", "activity", ["rosette"]),
  new h("🎗", "activity", ["reminder_ribbon"]),
  new h("🎫", "activity", ["ticket"]),
  new h("🎟", "activity", ["tickets"]),
  new h("🎪", "activity", ["circus_tent"]),
  new h("🤹‍♀", "activity", ["woman_juggling"]),
  new h("🤹‍♂", "activity", ["man_juggling"]),
  new h("🎭", "activity", ["performing_arts"]),
  new h("🎨", "activity", ["art"]),
  new h("🎬", "activity", ["clapper"]),
  new h("🎤", "activity", ["microphone"]),
  new h("🎧", "activity", ["headphones"]),
  new h("🎼", "activity", ["musical_score"]),
  new h("🎹", "activity", ["musical_keyboard"]),
  new h("🥁", "activity", ["drum"]),
  new h("🎷", "activity", ["saxophone"]),
  new h("🎺", "activity", ["trumpet"]),
  new h("🎸", "activity", ["guitar"]),
  new h("🎻", "activity", ["violin"]),
  new h("🎲", "activity", ["game_die"]),
  new h("🎯", "activity", ["dart"]),
  new h("🎳", "activity", ["bowling"]),
  new h("🎮", "activity", ["video_game"]),
  new h("🎰", "activity", ["slot_machine"]),
  new h("🚗", "places", ["car", "red_car"]),
  new h("🚕", "places", ["taxi"]),
  new h("🚙", "places", ["blue_car"]),
  new h("🚌", "places", ["bus"]),
  new h("🚎", "places", ["trolleybus"]),
  new h("🏎", "places", ["racing_car"]),
  new h("🚓", "places", ["police_car"]),
  new h("🚑", "places", ["ambulance"]),
  new h("🚒", "places", ["fire_engine"]),
  new h("🚐", "places", ["minibus"]),
  new h("🚚", "places", ["truck"]),
  new h("🚛", "places", ["articulated_lorry"]),
  new h("🚜", "places", ["tractor"]),
  new h("🛴", "places", ["kick_scooter"]),
  new h("🚲", "places", ["bike"]),
  new h("🛵", "places", ["motor_scooter"]),
  new h("🏍", "places", ["motorcycle"]),
  new h("🚨", "places", ["rotating_light"]),
  new h("🚔", "places", ["oncoming_police_car"]),
  new h("🚍", "places", ["oncoming_bus"]),
  new h("🚘", "places", ["oncoming_automobile"]),
  new h("🚖", "places", ["oncoming_taxi"]),
  new h("🚡", "places", ["aerial_tramway"]),
  new h("🚠", "places", ["mountain_cableway"]),
  new h("🚟", "places", ["suspension_railway"]),
  new h("🚃", "places", ["railway_car"]),
  new h("🚋", "places", ["train"]),
  new h("🚞", "places", ["mountain_railway"]),
  new h("🚝", "places", ["monorail"]),
  new h("🚄", "places", ["bullettrain_side"]),
  new h("🚅", "places", ["bullettrain_front"]),
  new h("🚈", "places", ["light_rail"]),
  new h("🚂", "places", ["steam_locomotive"]),
  new h("🚆", "places", ["train2"]),
  new h("🚇", "places", ["metro"]),
  new h("🚊", "places", ["tram"]),
  new h("🚉", "places", ["station"]),
  new h("🚁", "places", ["helicopter"]),
  new h("🛩", "places", ["small_airplane"]),
  new h("✈️", "places", ["airplane"]),
  new h("🛫", "places", ["flight_departure"]),
  new h("🛬", "places", ["flight_arrival"]),
  new h("🚀", "places", ["rocket"]),
  new h("🛰", "places", ["artificial_satellite"]),
  new h("💺", "places", ["seat"]),
  new h("🛶", "places", ["canoe"]),
  new h("⛵️", "places", ["boat", "sailboat"]),
  new h("🛥", "places", ["motor_boat"]),
  new h("🚤", "places", ["speedboat"]),
  new h("🛳", "places", ["passenger_ship"]),
  new h("⛴", "places", ["ferry"]),
  new h("🚢", "places", ["ship"]),
  new h("⚓️", "places", ["anchor"]),
  new h("🚧", "places", ["construction"]),
  new h("⛽️", "places", ["fuelpump"]),
  new h("🚏", "places", ["busstop"]),
  new h("🚦", "places", ["vertical_traffic_light"]),
  new h("🚥", "places", ["traffic_light"]),
  new h("🗺", "places", ["world_map"]),
  new h("🗿", "places", ["moyai"]),
  new h("🗽", "places", ["statue_of_liberty"]),
  new h("⛲️", "places", ["fountain"]),
  new h("🗼", "places", ["tokyo_tower"]),
  new h("🏰", "places", ["european_castle"]),
  new h("🏯", "places", ["japanese_castle"]),
  new h("🏟", "places", ["stadium"]),
  new h("🎡", "places", ["ferris_wheel"]),
  new h("🎢", "places", ["roller_coaster"]),
  new h("🎠", "places", ["carousel_horse"]),
  new h("⛱", "places", ["parasol_on_ground"]),
  new h("🏖", "places", ["beach_umbrella"]),
  new h("🏝", "places", ["desert_island"]),
  new h("⛰", "places", ["mountain"]),
  new h("🏔", "places", ["mountain_snow"]),
  new h("🗻", "places", ["mount_fuji"]),
  new h("🌋", "places", ["volcano"]),
  new h("🏜", "places", ["desert"]),
  new h("🏕", "places", ["camping"]),
  new h("⛺️", "places", ["tent"]),
  new h("🛤", "places", ["railway_track"]),
  new h("🛣", "places", ["motorway"]),
  new h("🏗", "places", ["building_construction"]),
  new h("🏭", "places", ["factory"]),
  new h("🏠", "places", ["house"]),
  new h("🏡", "places", ["house_with_garden"]),
  new h("🏘", "places", ["houses"]),
  new h("🏚", "places", ["derelict_house"]),
  new h("🏢", "places", ["office"]),
  new h("🏬", "places", ["department_store"]),
  new h("🏣", "places", ["post_office"]),
  new h("🏤", "places", ["european_post_office"]),
  new h("🏥", "places", ["hospital"]),
  new h("🏦", "places", ["bank"]),
  new h("🏨", "places", ["hotel"]),
  new h("🏪", "places", ["convenience_store"]),
  new h("🏫", "places", ["school"]),
  new h("🏩", "places", ["love_hotel"]),
  new h("💒", "places", ["wedding"]),
  new h("🏛", "places", ["classical_building"]),
  new h("⛪️", "places", ["church"]),
  new h("🕌", "places", ["mosque"]),
  new h("🕍", "places", ["synagogue"]),
  new h("🕋", "places", ["kaaba"]),
  new h("⛩", "places", ["shinto_shrine"]),
  new h("🗾", "places", ["japan"]),
  new h("🎑", "places", ["rice_scene"]),
  new h("🏞", "places", ["national_park"]),
  new h("🌅", "places", ["sunrise"]),
  new h("🌄", "places", ["sunrise_over_mountains"]),
  new h("🌠", "places", ["stars"]),
  new h("🎇", "places", ["sparkler"]),
  new h("🎆", "places", ["fireworks"]),
  new h("🌇", "places", ["city_sunrise"]),
  new h("🌆", "places", ["city_sunset"]),
  new h("🏙", "places", ["cityscape"]),
  new h("🌃", "places", ["night_with_stars"]),
  new h("🌌", "places", ["milky_way"]),
  new h("🌉", "places", ["bridge_at_night"]),
  new h("🌁", "places", ["foggy"]),
  new h("⌚️", "objects", ["watch"]),
  new h("📱", "objects", ["iphone"]),
  new h("📲", "objects", ["calling"]),
  new h("💻", "objects", ["computer"]),
  new h("⌨️", "objects", ["keyboard"]),
  new h("🖥", "objects", ["desktop_computer"]),
  new h("🖨", "objects", ["printer"]),
  new h("🖱", "objects", ["computer_mouse"]),
  new h("🖲", "objects", ["trackball"]),
  new h("🕹", "objects", ["joystick"]),
  new h("🗜", "objects", ["clamp"]),
  new h("💽", "objects", ["minidisc"]),
  new h("💾", "objects", ["floppy_disk"]),
  new h("💿", "objects", ["cd"]),
  new h("📀", "objects", ["dvd"]),
  new h("📼", "objects", ["vhs"]),
  new h("📷", "objects", ["camera"]),
  new h("📸", "objects", ["camera_flash"]),
  new h("📹", "objects", ["video_camera"]),
  new h("🎥", "objects", ["movie_camera"]),
  new h("📽", "objects", ["film_projector"]),
  new h("🎞", "objects", ["film_strip"]),
  new h("📞", "objects", ["telephone_receiver"]),
  new h("☎️", "objects", ["phone", "telephone"]),
  new h("📟", "objects", ["pager"]),
  new h("📠", "objects", ["fax"]),
  new h("📺", "objects", ["tv"]),
  new h("📻", "objects", ["radio"]),
  new h("🎙", "objects", ["studio_microphone"]),
  new h("🎚", "objects", ["level_slider"]),
  new h("🎛", "objects", ["control_knobs"]),
  new h("⏱", "objects", ["stopwatch"]),
  new h("⏲", "objects", ["timer_clock"]),
  new h("⏰", "objects", ["alarm_clock"]),
  new h("🕰", "objects", ["mantelpiece_clock"]),
  new h("⌛️", "objects", ["hourglass"]),
  new h("⏳", "objects", ["hourglass_flowing_sand"]),
  new h("📡", "objects", ["satellite"]),
  new h("🔋", "objects", ["battery"]),
  new h("🔌", "objects", ["electric_plug"]),
  new h("💡", "objects", ["bulb"]),
  new h("🔦", "objects", ["flashlight"]),
  new h("🕯", "objects", ["candle"]),
  new h("🗑", "objects", ["wastebasket"]),
  new h("🛢", "objects", ["oil_drum"]),
  new h("💸", "objects", ["money_with_wings"]),
  new h("💵", "objects", ["dollar"]),
  new h("💴", "objects", ["yen"]),
  new h("💶", "objects", ["euro"]),
  new h("💷", "objects", ["pound"]),
  new h("💰", "objects", ["moneybag"]),
  new h("💳", "objects", ["credit_card"]),
  new h("💎", "objects", ["gem"]),
  new h("⚖️", "objects", ["balance_scale"]),
  new h("🔧", "objects", ["wrench"]),
  new h("🔨", "objects", ["hammer"]),
  new h("⚒", "objects", ["hammer_and_pick"]),
  new h("🛠", "objects", ["hammer_and_wrench"]),
  new h("⛏", "objects", ["pick"]),
  new h("🔩", "objects", ["nut_and_bolt"]),
  new h("⚙️", "objects", ["gear"]),
  new h("⛓", "objects", ["chains"]),
  new h("🔫", "objects", ["gun"]),
  new h("💣", "objects", ["bomb"]),
  new h("🔪", "objects", ["hocho", "knife"]),
  new h("🗡", "objects", ["dagger"]),
  new h("⚔️", "objects", ["crossed_swords"]),
  new h("🛡", "objects", ["shield"]),
  new h("🚬", "objects", ["smoking"]),
  new h("⚰️", "objects", ["coffin"]),
  new h("⚱️", "objects", ["funeral_urn"]),
  new h("🏺", "objects", ["amphora"]),
  new h("🔮", "objects", ["crystal_ball"]),
  new h("📿", "objects", ["prayer_beads"]),
  new h("💈", "objects", ["barber"]),
  new h("⚗️", "objects", ["alembic"]),
  new h("🔭", "objects", ["telescope"]),
  new h("🔬", "objects", ["microscope"]),
  new h("🕳", "objects", ["hole"]),
  new h("💊", "objects", ["pill"]),
  new h("💉", "objects", ["syringe"]),
  new h("🌡", "objects", ["thermometer"]),
  new h("🚽", "objects", ["toilet"]),
  new h("🚰", "objects", ["potable_water"]),
  new h("🚿", "objects", ["shower"]),
  new h("🛁", "objects", ["bathtub"]),
  new h("🛀", "objects", ["bath"]),
  new h("🛎", "objects", ["bellhop_bell"]),
  new h("🔑", "objects", ["key"]),
  new h("🗝", "objects", ["old_key"]),
  new h("🚪", "objects", ["door"]),
  new h("🛋", "objects", ["couch_and_lamp"]),
  new h("🛏", "objects", ["bed"]),
  new h("🛌", "objects", ["sleeping_bed"]),
  new h("🖼", "objects", ["framed_picture"]),
  new h("🛍", "objects", ["shopping"]),
  new h("🛒", "objects", ["shopping_cart"]),
  new h("🎁", "objects", ["gift"]),
  new h("🎈", "objects", ["balloon"]),
  new h("🎏", "objects", ["flags"]),
  new h("🎀", "objects", ["ribbon"]),
  new h("🎊", "objects", ["confetti_ball"]),
  new h("🎉", "objects", ["tada"]),
  new h("🎎", "objects", ["dolls"]),
  new h("🏮", "objects", ["izakaya_lantern", "lantern"]),
  new h("🎐", "objects", ["wind_chime"]),
  new h("✉️", "objects", ["email", "envelope"]),
  new h("📩", "objects", ["envelope_with_arrow"]),
  new h("📨", "objects", ["incoming_envelope"]),
  new h("📧", "objects", ["e-mail"]),
  new h("💌", "objects", ["love_letter"]),
  new h("📥", "objects", ["inbox_tray"]),
  new h("📤", "objects", ["outbox_tray"]),
  new h("📦", "objects", ["package"]),
  new h("🏷", "objects", ["label"]),
  new h("📪", "objects", ["mailbox_closed"]),
  new h("📫", "objects", ["mailbox"]),
  new h("📬", "objects", ["mailbox_with_mail"]),
  new h("📭", "objects", ["mailbox_with_no_mail"]),
  new h("📮", "objects", ["postbox"]),
  new h("📯", "objects", ["postal_horn"]),
  new h("📜", "objects", ["scroll"]),
  new h("📃", "objects", ["page_with_curl"]),
  new h("📄", "objects", ["page_facing_up"]),
  new h("📑", "objects", ["bookmark_tabs"]),
  new h("📊", "objects", ["bar_chart"]),
  new h("📈", "objects", ["chart_with_upwards_trend"]),
  new h("📉", "objects", ["chart_with_downwards_trend"]),
  new h("🗒", "objects", ["spiral_notepad"]),
  new h("🗓", "objects", ["spiral_calendar"]),
  new h("📆", "objects", ["calendar"]),
  new h("📅", "objects", ["date"]),
  new h("📇", "objects", ["card_index"]),
  new h("🗃", "objects", ["card_file_box"]),
  new h("🗳", "objects", ["ballot_box"]),
  new h("🗄", "objects", ["file_cabinet"]),
  new h("📋", "objects", ["clipboard"]),
  new h("📁", "objects", ["file_folder"]),
  new h("📂", "objects", ["open_file_folder"]),
  new h("🗂", "objects", ["card_index_dividers"]),
  new h("🗞", "objects", ["newspaper_roll"]),
  new h("📰", "objects", ["newspaper"]),
  new h("📓", "objects", ["notebook"]),
  new h("📔", "objects", ["notebook_with_decorative_cover"]),
  new h("📒", "objects", ["ledger"]),
  new h("📕", "objects", ["closed_book"]),
  new h("📗", "objects", ["green_book"]),
  new h("📘", "objects", ["blue_book"]),
  new h("📙", "objects", ["orange_book"]),
  new h("📚", "objects", ["books"]),
  new h("📖", "objects", ["book", "open_book"]),
  new h("🔖", "objects", ["bookmark"]),
  new h("🔗", "objects", ["link"]),
  new h("📎", "objects", ["paperclip"]),
  new h("🖇", "objects", ["paperclips"]),
  new h("📐", "objects", ["triangular_ruler"]),
  new h("📏", "objects", ["straight_ruler"]),
  new h("📌", "objects", ["pushpin"]),
  new h("📍", "objects", ["round_pushpin"]),
  new h("✂️", "objects", ["scissors"]),
  new h("🖊", "objects", ["pen"]),
  new h("🖋", "objects", ["fountain_pen"]),
  new h("✒️", "objects", ["black_nib"]),
  new h("🖌", "objects", ["paintbrush"]),
  new h("🖍", "objects", ["crayon"]),
  new h("📝", "objects", ["memo", "pencil"]),
  new h("✏️", "objects", ["pencil2"]),
  new h("🔍", "objects", ["mag"]),
  new h("🔎", "objects", ["mag_right"]),
  new h("🔏", "objects", ["lock_with_ink_pen"]),
  new h("🔐", "objects", ["closed_lock_with_key"]),
  new h("🔒", "objects", ["lock"]),
  new h("🔓", "objects", ["unlock"]),
  new h("❤️", "symbols", ["heart"]),
  new h("💛", "symbols", ["yellow_heart"]),
  new h("💚", "symbols", ["green_heart"]),
  new h("💙", "symbols", ["blue_heart"]),
  new h("💜", "symbols", ["purple_heart"]),
  new h("🖤", "symbols", ["black_heart"]),
  new h("💔", "symbols", ["broken_heart"]),
  new h("❣️", "symbols", ["heavy_heart_exclamation"]),
  new h("💕", "symbols", ["two_hearts"]),
  new h("💞", "symbols", ["revolving_hearts"]),
  new h("💓", "symbols", ["heartbeat"]),
  new h("💗", "symbols", ["heartpulse"]),
  new h("💖", "symbols", ["sparkling_heart"]),
  new h("💘", "symbols", ["cupid"]),
  new h("💝", "symbols", ["gift_heart"]),
  new h("💟", "symbols", ["heart_decoration"]),
  new h("☮️", "symbols", ["peace_symbol"]),
  new h("✝️", "symbols", ["latin_cross"]),
  new h("☪️", "symbols", ["star_and_crescent"]),
  new h("🕉", "symbols", ["om"]),
  new h("☸️", "symbols", ["wheel_of_dharma"]),
  new h("✡️", "symbols", ["star_of_david"]),
  new h("🔯", "symbols", ["six_pointed_star"]),
  new h("🕎", "symbols", ["menorah"]),
  new h("☯️", "symbols", ["yin_yang"]),
  new h("☦️", "symbols", ["orthodox_cross"]),
  new h("🛐", "symbols", ["place_of_worship"]),
  new h("⛎", "symbols", ["ophiuchus"]),
  new h("♈️", "symbols", ["aries"]),
  new h("♉️", "symbols", ["taurus"]),
  new h("♊️", "symbols", ["gemini"]),
  new h("♋️", "symbols", ["cancer"]),
  new h("♌️", "symbols", ["leo"]),
  new h("♍️", "symbols", ["virgo"]),
  new h("♎️", "symbols", ["libra"]),
  new h("♏️", "symbols", ["scorpius"]),
  new h("♐️", "symbols", ["sagittarius"]),
  new h("♑️", "symbols", ["capricorn"]),
  new h("♒️", "symbols", ["aquarius"]),
  new h("♓️", "symbols", ["pisces"]),
  new h("🆔", "symbols", ["id"]),
  new h("⚛️", "symbols", ["atom_symbol"]),
  new h("🉑", "symbols", ["accept"]),
  new h("☢️", "symbols", ["radioactive"]),
  new h("☣️", "symbols", ["biohazard"]),
  new h("📴", "symbols", ["mobile_phone_off"]),
  new h("📳", "symbols", ["vibration_mode"]),
  new h("🈶", "symbols", ["u6709"]),
  new h("🈚️", "symbols", ["u7121"]),
  new h("🈸", "symbols", ["u7533"]),
  new h("🈺", "symbols", ["u55b6"]),
  new h("🈷️", "symbols", ["u6708"]),
  new h("✴️", "symbols", ["eight_pointed_black_star"]),
  new h("🆚", "symbols", ["vs"]),
  new h("💮", "symbols", ["white_flower"]),
  new h("🉐", "symbols", ["ideograph_advantage"]),
  new h("㊙️", "symbols", ["secret"]),
  new h("㊗️", "symbols", ["congratulations"]),
  new h("🈴", "symbols", ["u5408"]),
  new h("🈵", "symbols", ["u6e80"]),
  new h("🈹", "symbols", ["u5272"]),
  new h("🈲", "symbols", ["u7981"]),
  new h("🅰️", "symbols", ["a"]),
  new h("🅱️", "symbols", ["b"]),
  new h("🆎", "symbols", ["ab"]),
  new h("🆑", "symbols", ["cl"]),
  new h("🅾️", "symbols", ["o2"]),
  new h("🆘", "symbols", ["sos"]),
  new h("❌", "symbols", ["x"]),
  new h("⭕️", "symbols", ["o"]),
  new h("🛑", "symbols", ["stop_sign"]),
  new h("⛔️", "symbols", ["no_entry"]),
  new h("📛", "symbols", ["name_badge"]),
  new h("🚫", "symbols", ["no_entry_sign"]),
  new h("💯", "symbols", ["100"]),
  new h("💢", "symbols", ["anger"]),
  new h("♨️", "symbols", ["hotsprings"]),
  new h("🚷", "symbols", ["no_pedestrians"]),
  new h("🚯", "symbols", ["do_not_litter"]),
  new h("🚳", "symbols", ["no_bicycles"]),
  new h("🚱", "symbols", ["non-potable_water"]),
  new h("🔞", "symbols", ["underage"]),
  new h("📵", "symbols", ["no_mobile_phones"]),
  new h("🚭", "symbols", ["no_smoking"]),
  new h("❗️", "symbols", ["exclamation", "heavy_exclamation_mark"]),
  new h("❕", "symbols", ["grey_exclamation"]),
  new h("❓", "symbols", ["question"]),
  new h("❔", "symbols", ["grey_question"]),
  new h("‼️", "symbols", ["bangbang"]),
  new h("⁉️", "symbols", ["interrobang"]),
  new h("🔅", "symbols", ["low_brightness"]),
  new h("🔆", "symbols", ["high_brightness"]),
  new h("〽️", "symbols", ["part_alternation_mark"]),
  new h("⚠️", "symbols", ["warning"]),
  new h("🚸", "symbols", ["children_crossing"]),
  new h("🔱", "symbols", ["trident"]),
  new h("⚜️", "symbols", ["fleur_de_lis"]),
  new h("🔰", "symbols", ["beginner"]),
  new h("♻️", "symbols", ["recycle"]),
  new h("✅", "symbols", ["white_check_mark"]),
  new h("🈯️", "symbols", ["u6307"]),
  new h("💹", "symbols", ["chart"]),
  new h("❇️", "symbols", ["sparkle"]),
  new h("✳️", "symbols", ["eight_spoked_asterisk"]),
  new h("❎", "symbols", ["negative_squared_cross_mark"]),
  new h("🌐", "symbols", ["globe_with_meridians"]),
  new h("💠", "symbols", ["diamond_shape_with_a_dot_inside"]),
  new h("Ⓜ️", "symbols", ["m"]),
  new h("🌀", "symbols", ["cyclone"]),
  new h("💤", "symbols", ["zzz"]),
  new h("🏧", "symbols", ["atm"]),
  new h("🚾", "symbols", ["wc"]),
  new h("♿️", "symbols", ["wheelchair"]),
  new h("🅿️", "symbols", ["parking"]),
  new h("🈳", "symbols", ["u7a7a"]),
  new h("🈂️", "symbols", ["sa"]),
  new h("🛂", "symbols", ["passport_control"]),
  new h("🛃", "symbols", ["customs"]),
  new h("🛄", "symbols", ["baggage_claim"]),
  new h("🛅", "symbols", ["left_luggage"]),
  new h("🚹", "symbols", ["mens"]),
  new h("🚺", "symbols", ["womens"]),
  new h("🚼", "symbols", ["baby_symbol"]),
  new h("🚻", "symbols", ["restroom"]),
  new h("🚮", "symbols", ["put_litter_in_its_place"]),
  new h("🎦", "symbols", ["cinema"]),
  new h("📶", "symbols", ["signal_strength"]),
  new h("🈁", "symbols", ["koko"]),
  new h("🔣", "symbols", ["symbols"]),
  new h("ℹ️", "symbols", ["information_source"]),
  new h("🔤", "symbols", ["abc"]),
  new h("🔡", "symbols", ["abcd"]),
  new h("🔠", "symbols", ["capital_abcd"]),
  new h("🆖", "symbols", ["ng"]),
  new h("🆗", "symbols", ["ok"]),
  new h("🆙", "symbols", ["up"]),
  new h("🆒", "symbols", ["cool"]),
  new h("🆕", "symbols", ["new"]),
  new h("🆓", "symbols", ["free"]),
  new h("0️⃣", "symbols", ["zero"]),
  new h("1️⃣", "symbols", ["one"]),
  new h("2️⃣", "symbols", ["two"]),
  new h("3️⃣", "symbols", ["three"]),
  new h("4️⃣", "symbols", ["four"]),
  new h("5️⃣", "symbols", ["five"]),
  new h("6️⃣", "symbols", ["six"]),
  new h("7️⃣", "symbols", ["seven"]),
  new h("8️⃣", "symbols", ["eight"]),
  new h("9️⃣", "symbols", ["nine"]),
  new h("🔟", "symbols", ["keycap_ten"]),
  new h("🔢", "symbols", ["1234"]),
  new h("#️⃣", "symbols", ["hash"]),
  new h("*️⃣", "symbols", ["asterisk"]),
  new h("▶️", "symbols", ["arrow_forward"]),
  new h("⏸", "symbols", ["pause_button"]),
  new h("⏯", "symbols", ["play_or_pause_button"]),
  new h("⏹", "symbols", ["stop_button"]),
  new h("⏺", "symbols", ["record_button"]),
  new h("⏭", "symbols", ["next_track_button"]),
  new h("⏮", "symbols", ["previous_track_button"]),
  new h("⏩", "symbols", ["fast_forward"]),
  new h("⏪", "symbols", ["rewind"]),
  new h("⏫", "symbols", ["arrow_double_up"]),
  new h("⏬", "symbols", ["arrow_double_down"]),
  new h("◀️", "symbols", ["arrow_backward"]),
  new h("🔼", "symbols", ["arrow_up_small"]),
  new h("🔽", "symbols", ["arrow_down_small"]),
  new h("➡️", "symbols", ["arrow_right"]),
  new h("⬅️", "symbols", ["arrow_left"]),
  new h("⬆️", "symbols", ["arrow_up"]),
  new h("⬇️", "symbols", ["arrow_down"]),
  new h("↗️", "symbols", ["arrow_upper_right"]),
  new h("↘️", "symbols", ["arrow_lower_right"]),
  new h("↙️", "symbols", ["arrow_lower_left"]),
  new h("↖️", "symbols", ["arrow_upper_left"]),
  new h("↕️", "symbols", ["arrow_up_down"]),
  new h("↔️", "symbols", ["left_right_arrow"]),
  new h("↪️", "symbols", ["arrow_right_hook"]),
  new h("↩️", "symbols", ["leftwards_arrow_with_hook"]),
  new h("⤴️", "symbols", ["arrow_heading_up"]),
  new h("⤵️", "symbols", ["arrow_heading_down"]),
  new h("🔀", "symbols", ["twisted_rightwards_arrows"]),
  new h("🔁", "symbols", ["repeat"]),
  new h("🔂", "symbols", ["repeat_one"]),
  new h("🔄", "symbols", ["arrows_counterclockwise"]),
  new h("🔃", "symbols", ["arrows_clockwise"]),
  new h("🎵", "symbols", ["musical_note"]),
  new h("🎶", "symbols", ["notes"]),
  new h("➕", "symbols", ["heavy_plus_sign"]),
  new h("➖", "symbols", ["heavy_minus_sign"]),
  new h("➗", "symbols", ["heavy_division_sign"]),
  new h("✖️", "symbols", ["heavy_multiplication_x"]),
  new h("💲", "symbols", ["heavy_dollar_sign"]),
  new h("💱", "symbols", ["currency_exchange"]),
  new h("™️", "symbols", ["tm"]),
  new h("©️", "symbols", ["copyright"]),
  new h("®️", "symbols", ["registered"]),
  new h("〰️", "symbols", ["wavy_dash"]),
  new h("➰", "symbols", ["curly_loop"]),
  new h("➿", "symbols", ["loop"]),
  new h("🔚", "symbols", ["end"]),
  new h("🔙", "symbols", ["back"]),
  new h("🔛", "symbols", ["on"]),
  new h("🔝", "symbols", ["top"]),
  new h("🔜", "symbols", ["soon"]),
  new h("✔️", "symbols", ["heavy_check_mark"]),
  new h("☑️", "symbols", ["ballot_box_with_check"]),
  new h("🔘", "symbols", ["radio_button"]),
  new h("⚪️", "symbols", ["white_circle"]),
  new h("⚫️", "symbols", ["black_circle"]),
  new h("🔴", "symbols", ["red_circle"]),
  new h("🔵", "symbols", ["large_blue_circle"]),
  new h("🔺", "symbols", ["small_red_triangle"]),
  new h("🔻", "symbols", ["small_red_triangle_down"]),
  new h("🔸", "symbols", ["small_orange_diamond"]),
  new h("🔹", "symbols", ["small_blue_diamond"]),
  new h("🔶", "symbols", ["large_orange_diamond"]),
  new h("🔷", "symbols", ["large_blue_diamond"]),
  new h("🔳", "symbols", ["white_square_button"]),
  new h("🔲", "symbols", ["black_square_button"]),
  new h("▪️", "symbols", ["black_small_square"]),
  new h("▫️", "symbols", ["white_small_square"]),
  new h("◾️", "symbols", ["black_medium_small_square"]),
  new h("◽️", "symbols", ["white_medium_small_square"]),
  new h("◼️", "symbols", ["black_medium_square"]),
  new h("◻️", "symbols", ["white_medium_square"]),
  new h("⬛️", "symbols", ["black_large_square"]),
  new h("⬜️", "symbols", ["white_large_square"]),
  new h("🔈", "symbols", ["speaker"]),
  new h("🔇", "symbols", ["mute"]),
  new h("🔉", "symbols", ["sound"]),
  new h("🔊", "symbols", ["loud_sound"]),
  new h("🔔", "symbols", ["bell"]),
  new h("🔕", "symbols", ["no_bell"]),
  new h("📣", "symbols", ["mega"]),
  new h("📢", "symbols", ["loudspeaker"]),
  new h("👁‍🗨", "symbols", ["eye_speech_bubble"]),
  new h("💬", "symbols", ["speech_balloon"]),
  new h("💭", "symbols", ["thought_balloon"]),
  new h("🗯", "symbols", ["right_anger_bubble"]),
  new h("♠️", "symbols", ["spades"]),
  new h("♣️", "symbols", ["clubs"]),
  new h("♥️", "symbols", ["hearts"]),
  new h("♦️", "symbols", ["diamonds"]),
  new h("🃏", "symbols", ["black_joker"]),
  new h("🎴", "symbols", ["flower_playing_cards"]),
  new h("🀄️", "symbols", ["mahjong"]),
  new h("🕐", "symbols", ["clock1"]),
  new h("🕑", "symbols", ["clock2"]),
  new h("🕒", "symbols", ["clock3"]),
  new h("🕓", "symbols", ["clock4"]),
  new h("🕔", "symbols", ["clock5"]),
  new h("🕕", "symbols", ["clock6"]),
  new h("🕖", "symbols", ["clock7"]),
  new h("🕗", "symbols", ["clock8"]),
  new h("🕘", "symbols", ["clock9"]),
  new h("🕙", "symbols", ["clock10"]),
  new h("🕚", "symbols", ["clock11"]),
  new h("🕛", "symbols", ["clock12"]),
  new h("🕜", "symbols", ["clock130"]),
  new h("🕝", "symbols", ["clock230"]),
  new h("🕞", "symbols", ["clock330"]),
  new h("🕟", "symbols", ["clock430"]),
  new h("🕠", "symbols", ["clock530"]),
  new h("🕡", "symbols", ["clock630"]),
  new h("🕢", "symbols", ["clock730"]),
  new h("🕣", "symbols", ["clock830"]),
  new h("🕤", "symbols", ["clock930"]),
  new h("🕥", "symbols", ["clock1030"]),
  new h("🕦", "symbols", ["clock1130"]),
  new h("🕧", "symbols", ["clock1230"]),
  new h("🏳️", "flags", ["white_flag"]),
  new h("🏴", "flags", ["black_flag"]),
  new h("🏁", "flags", ["checkered_flag"]),
  new h("🚩", "flags", ["triangular_flag_on_post"]),
  new h("🏳️‍🌈", "flags", ["rainbow_flag"]),
  new h("🇦🇫", "flags", ["afghanistan"]),
  new h("🇦🇽", "flags", ["aland_islands"]),
  new h("🇦🇱", "flags", ["albania"]),
  new h("🇩🇿", "flags", ["algeria"]),
  new h("🇦🇸", "flags", ["american_samoa"]),
  new h("🇦🇩", "flags", ["andorra"]),
  new h("🇦🇴", "flags", ["angola"]),
  new h("🇦🇮", "flags", ["anguilla"]),
  new h("🇦🇶", "flags", ["antarctica"]),
  new h("🇦🇬", "flags", ["antigua_barbuda"]),
  new h("🇦🇷", "flags", ["argentina"]),
  new h("🇦🇲", "flags", ["armenia"]),
  new h("🇦🇼", "flags", ["aruba"]),
  new h("🇦🇺", "flags", ["australia"]),
  new h("🇦🇹", "flags", ["austria"]),
  new h("🇦🇿", "flags", ["azerbaijan"]),
  new h("🇧🇸", "flags", ["bahamas"]),
  new h("🇧🇭", "flags", ["bahrain"]),
  new h("🇧🇩", "flags", ["bangladesh"]),
  new h("🇧🇧", "flags", ["barbados"]),
  new h("🇧🇾", "flags", ["belarus"]),
  new h("🇧🇪", "flags", ["belgium"]),
  new h("🇧🇿", "flags", ["belize"]),
  new h("🇧🇯", "flags", ["benin"]),
  new h("🇧🇲", "flags", ["bermuda"]),
  new h("🇧🇹", "flags", ["bhutan"]),
  new h("🇧🇴", "flags", ["bolivia"]),
  new h("🇧🇶", "flags", ["caribbean_netherlands"]),
  new h("🇧🇦", "flags", ["bosnia_herzegovina"]),
  new h("🇧🇼", "flags", ["botswana"]),
  new h("🇧🇷", "flags", ["brazil"]),
  new h("🇮🇴", "flags", ["british_indian_ocean_territory"]),
  new h("🇻🇬", "flags", ["british_virgin_islands"]),
  new h("🇧🇳", "flags", ["brunei"]),
  new h("🇧🇬", "flags", ["bulgaria"]),
  new h("🇧🇫", "flags", ["burkina_faso"]),
  new h("🇧🇮", "flags", ["burundi"]),
  new h("🇨🇻", "flags", ["cape_verde"]),
  new h("🇰🇭", "flags", ["cambodia"]),
  new h("🇨🇲", "flags", ["cameroon"]),
  new h("🇨🇦", "flags", ["canada"]),
  new h("🇮🇨", "flags", ["canary_islands"]),
  new h("🇰🇾", "flags", ["cayman_islands"]),
  new h("🇨🇫", "flags", ["central_african_republic"]),
  new h("🇹🇩", "flags", ["chad"]),
  new h("🇨🇱", "flags", ["chile"]),
  new h("🇨🇳", "flags", ["cn"]),
  new h("🇨🇽", "flags", ["christmas_island"]),
  new h("🇨🇨", "flags", ["cocos_islands"]),
  new h("🇨🇴", "flags", ["colombia"]),
  new h("🇰🇲", "flags", ["comoros"]),
  new h("🇨🇬", "flags", ["congo_brazzaville"]),
  new h("🇨🇩", "flags", ["congo_kinshasa"]),
  new h("🇨🇰", "flags", ["cook_islands"]),
  new h("🇨🇷", "flags", ["costa_rica"]),
  new h("🇨🇮", "flags", ["cote_divoire"]),
  new h("🇭🇷", "flags", ["croatia"]),
  new h("🇨🇺", "flags", ["cuba"]),
  new h("🇨🇼", "flags", ["curacao"]),
  new h("🇨🇾", "flags", ["cyprus"]),
  new h("🇨🇿", "flags", ["czech_republic"]),
  new h("🇩🇰", "flags", ["denmark"]),
  new h("🇩🇯", "flags", ["djibouti"]),
  new h("🇩🇲", "flags", ["dominica"]),
  new h("🇩🇴", "flags", ["dominican_republic"]),
  new h("🇪🇨", "flags", ["ecuador"]),
  new h("🇪🇬", "flags", ["egypt"]),
  new h("🇸🇻", "flags", ["el_salvador"]),
  new h("🇬🇶", "flags", ["equatorial_guinea"]),
  new h("🇪🇷", "flags", ["eritrea"]),
  new h("🇪🇪", "flags", ["estonia"]),
  new h("🇪🇹", "flags", ["ethiopia"]),
  new h("🇪🇺", "flags", ["eu", "european_union"]),
  new h("🇫🇰", "flags", ["falkland_islands"]),
  new h("🇫🇴", "flags", ["faroe_islands"]),
  new h("🇫🇯", "flags", ["fiji"]),
  new h("🇫🇮", "flags", ["finland"]),
  new h("🇫🇷", "flags", ["fr"]),
  new h("🇬🇫", "flags", ["french_guiana"]),
  new h("🇵🇫", "flags", ["french_polynesia"]),
  new h("🇹🇫", "flags", ["french_southern_territories"]),
  new h("🇬🇦", "flags", ["gabon"]),
  new h("🇬🇲", "flags", ["gambia"]),
  new h("🇬🇪", "flags", ["georgia"]),
  new h("🇩🇪", "flags", ["de"]),
  new h("🇬🇭", "flags", ["ghana"]),
  new h("🇬🇮", "flags", ["gibraltar"]),
  new h("🇬🇷", "flags", ["greece"]),
  new h("🇬🇱", "flags", ["greenland"]),
  new h("🇬🇩", "flags", ["grenada"]),
  new h("🇬🇵", "flags", ["guadeloupe"]),
  new h("🇬🇺", "flags", ["guam"]),
  new h("🇬🇹", "flags", ["guatemala"]),
  new h("🇬🇬", "flags", ["guernsey"]),
  new h("🇬🇳", "flags", ["guinea"]),
  new h("🇬🇼", "flags", ["guinea_bissau"]),
  new h("🇬🇾", "flags", ["guyana"]),
  new h("🇭🇹", "flags", ["haiti"]),
  new h("🇭🇳", "flags", ["honduras"]),
  new h("🇭🇰", "flags", ["hong_kong"]),
  new h("🇭🇺", "flags", ["hungary"]),
  new h("🇮🇸", "flags", ["iceland"]),
  new h("🇮🇳", "flags", ["india"]),
  new h("🇮🇩", "flags", ["indonesia"]),
  new h("🇮🇷", "flags", ["iran"]),
  new h("🇮🇶", "flags", ["iraq"]),
  new h("🇮🇪", "flags", ["ireland"]),
  new h("🇮🇲", "flags", ["isle_of_man"]),
  new h("🇮🇱", "flags", ["israel"]),
  new h("🇮🇹", "flags", ["it"]),
  new h("🇯🇲", "flags", ["jamaica"]),
  new h("🇯🇵", "flags", ["jp"]),
  new h("🎌", "flags", ["crossed_flags"]),
  new h("🇯🇪", "flags", ["jersey"]),
  new h("🇯🇴", "flags", ["jordan"]),
  new h("🇰🇿", "flags", ["kazakhstan"]),
  new h("🇰🇪", "flags", ["kenya"]),
  new h("🇰🇮", "flags", ["kiribati"]),
  new h("🇽🇰", "flags", ["kosovo"]),
  new h("🇰🇼", "flags", ["kuwait"]),
  new h("🇰🇬", "flags", ["kyrgyzstan"]),
  new h("🇱🇦", "flags", ["laos"]),
  new h("🇱🇻", "flags", ["latvia"]),
  new h("🇱🇧", "flags", ["lebanon"]),
  new h("🇱🇸", "flags", ["lesotho"]),
  new h("🇱🇷", "flags", ["liberia"]),
  new h("🇱🇾", "flags", ["libya"]),
  new h("🇱🇮", "flags", ["liechtenstein"]),
  new h("🇱🇹", "flags", ["lithuania"]),
  new h("🇱🇺", "flags", ["luxembourg"]),
  new h("🇲🇴", "flags", ["macau"]),
  new h("🇲🇰", "flags", ["macedonia"]),
  new h("🇲🇬", "flags", ["madagascar"]),
  new h("🇲🇼", "flags", ["malawi"]),
  new h("🇲🇾", "flags", ["malaysia"]),
  new h("🇲🇻", "flags", ["maldives"]),
  new h("🇲🇱", "flags", ["mali"]),
  new h("🇲🇹", "flags", ["malta"]),
  new h("🇲🇭", "flags", ["marshall_islands"]),
  new h("🇲🇶", "flags", ["martinique"]),
  new h("🇲🇷", "flags", ["mauritania"]),
  new h("🇲🇺", "flags", ["mauritius"]),
  new h("🇾🇹", "flags", ["mayotte"]),
  new h("🇲🇽", "flags", ["mexico"]),
  new h("🇫🇲", "flags", ["micronesia"]),
  new h("🇲🇩", "flags", ["moldova"]),
  new h("🇲🇨", "flags", ["monaco"]),
  new h("🇲🇳", "flags", ["mongolia"]),
  new h("🇲🇪", "flags", ["montenegro"]),
  new h("🇲🇸", "flags", ["montserrat"]),
  new h("🇲🇦", "flags", ["morocco"]),
  new h("🇲🇿", "flags", ["mozambique"]),
  new h("🇲🇲", "flags", ["myanmar"]),
  new h("🇳🇦", "flags", ["namibia"]),
  new h("🇳🇷", "flags", ["nauru"]),
  new h("🇳🇵", "flags", ["nepal"]),
  new h("🇳🇱", "flags", ["netherlands"]),
  new h("🇳🇨", "flags", ["new_caledonia"]),
  new h("🇳🇿", "flags", ["new_zealand"]),
  new h("🇳🇮", "flags", ["nicaragua"]),
  new h("🇳🇪", "flags", ["niger"]),
  new h("🇳🇬", "flags", ["nigeria"]),
  new h("🇳🇺", "flags", ["niue"]),
  new h("🇳🇫", "flags", ["norfolk_island"]),
  new h("🇲🇵", "flags", ["northern_mariana_islands"]),
  new h("🇰🇵", "flags", ["north_korea"]),
  new h("🇳🇴", "flags", ["norway"]),
  new h("🇴🇲", "flags", ["oman"]),
  new h("🇵🇰", "flags", ["pakistan"]),
  new h("🇵🇼", "flags", ["palau"]),
  new h("🇵🇸", "flags", ["palestinian_territories"]),
  new h("🇵🇦", "flags", ["panama"]),
  new h("🇵🇬", "flags", ["papua_new_guinea"]),
  new h("🇵🇾", "flags", ["paraguay"]),
  new h("🇵🇪", "flags", ["peru"]),
  new h("🇵🇭", "flags", ["philippines"]),
  new h("🇵🇳", "flags", ["pitcairn_islands"]),
  new h("🇵🇱", "flags", ["poland"]),
  new h("🇵🇹", "flags", ["portugal"]),
  new h("🇵🇷", "flags", ["puerto_rico"]),
  new h("🇶🇦", "flags", ["qatar"]),
  new h("🇷🇪", "flags", ["reunion"]),
  new h("🇷🇴", "flags", ["romania"]),
  new h("🇷🇺", "flags", ["ru"]),
  new h("🇷🇼", "flags", ["rwanda"]),
  new h("🇧🇱", "flags", ["st_barthelemy"]),
  new h("🇸🇭", "flags", ["st_helena"]),
  new h("🇰🇳", "flags", ["st_kitts_nevis"]),
  new h("🇱🇨", "flags", ["st_lucia"]),
  new h("🇵🇲", "flags", ["st_pierre_miquelon"]),
  new h("🇻🇨", "flags", ["st_vincent_grenadines"]),
  new h("🇼🇸", "flags", ["samoa"]),
  new h("🇸🇲", "flags", ["san_marino"]),
  new h("🇸🇹", "flags", ["sao_tome_principe"]),
  new h("🇸🇦", "flags", ["saudi_arabia"]),
  new h("🇸🇳", "flags", ["senegal"]),
  new h("🇷🇸", "flags", ["serbia"]),
  new h("🇸🇨", "flags", ["seychelles"]),
  new h("🇸🇱", "flags", ["sierra_leone"]),
  new h("🇸🇬", "flags", ["singapore"]),
  new h("🇸🇽", "flags", ["sint_maarten"]),
  new h("🇸🇰", "flags", ["slovakia"]),
  new h("🇸🇮", "flags", ["slovenia"]),
  new h("🇸🇧", "flags", ["solomon_islands"]),
  new h("🇸🇴", "flags", ["somalia"]),
  new h("🇿🇦", "flags", ["south_africa"]),
  new h("🇬🇸", "flags", ["south_georgia_south_sandwich_islands"]),
  new h("🇰🇷", "flags", ["kr"]),
  new h("🇸🇸", "flags", ["south_sudan"]),
  new h("🇪🇸", "flags", ["es"]),
  new h("🇱🇰", "flags", ["sri_lanka"]),
  new h("🇸🇩", "flags", ["sudan"]),
  new h("🇸🇷", "flags", ["suriname"]),
  new h("🇸🇿", "flags", ["swaziland"]),
  new h("🇸🇪", "flags", ["sweden"]),
  new h("🇨🇭", "flags", ["switzerland"]),
  new h("🇸🇾", "flags", ["syria"]),
  new h("🇹🇼", "flags", ["taiwan"]),
  new h("🇹🇯", "flags", ["tajikistan"]),
  new h("🇹🇿", "flags", ["tanzania"]),
  new h("🇹🇭", "flags", ["thailand"]),
  new h("🇹🇱", "flags", ["timor_leste"]),
  new h("🇹🇬", "flags", ["togo"]),
  new h("🇹🇰", "flags", ["tokelau"]),
  new h("🇹🇴", "flags", ["tonga"]),
  new h("🇹🇹", "flags", ["trinidad_tobago"]),
  new h("🇹🇳", "flags", ["tunisia"]),
  new h("🇹🇷", "flags", ["tr"]),
  new h("🇹🇲", "flags", ["turkmenistan"]),
  new h("🇹🇨", "flags", ["turks_caicos_islands"]),
  new h("🇹🇻", "flags", ["tuvalu"]),
  new h("🇺🇬", "flags", ["uganda"]),
  new h("🇺🇦", "flags", ["ukraine"]),
  new h("🇦🇪", "flags", ["united_arab_emirates"]),
  new h("🇬🇧", "flags", ["gb", "uk"]),
  new h("🇺🇸", "flags", ["us"]),
  new h("🇻🇮", "flags", ["us_virgin_islands"]),
  new h("🇺🇾", "flags", ["uruguay"]),
  new h("🇺🇿", "flags", ["uzbekistan"]),
  new h("🇻🇺", "flags", ["vanuatu"]),
  new h("🇻🇦", "flags", ["vatican_city"]),
  new h("🇻🇪", "flags", ["venezuela"]),
  new h("🇻🇳", "flags", ["vietnam"]),
  new h("🇼🇫", "flags", ["wallis_futuna"]),
  new h("🇪🇭", "flags", ["western_sahara"]),
  new h("🇾🇪", "flags", ["yemen"]),
  new h("🇿🇲", "flags", ["zambia"]),
  new h("🇿🇼", "flags", ["zimbabwe"])
], tn = {
  activity: '\n    <svg width="1em" height="1em"\n      xmlns="http://www.w3.org/2000/svg" viewBox="0 0 303.6 303.6">\n      <path d="M291.503 11.6c-10.4-10.4-37.2-11.6-48.4-11.6-50.4 0-122.4 18.4-173.6 69.6-77.2 76.8-78.4 201.6-58.4 222 10.8 10.4 35.6 12 49.2 12 49.6 0 121.2-18.4 173.2-70 76.4-76.4 80.4-199.6 58-222zm-231.2 277.2c-24.4 0-36-4.8-38.8-7.6-5.2-5.2-8.4-24.4-6.8-49.6l57.2 56.8c-4 .4-8 .4-11.6.4zm162.8-66c-38.8 38.8-90.4 57.2-132.4 63.6l-74-73.6c6-42 24-94 63.2-133.2 38-38 88-56.4 130.8-62.8l75.6 75.6c-6 40.8-24.4 91.6-63.2 130.4zm65.2-148.8l-58.8-59.2c4.8-.4 9.2-.4 13.6-.4 24.4 0 35.6 4.8 38 7.2 5.6 5.6 9.2 25.6 7.2 52.4z"/>\n      <path d="M215.103 139.6l-20.8-20.8 13.2-13.2c2.8-2.8 2.8-7.6 0-10.4s-7.6-2.8-10.4 0l-13.2 13.6-20.8-20.8c-2.8-2.8-7.6-2.8-10.4 0-2.8 2.8-2.8 7.6 0 10.4l20.8 20.8-22 22-20.8-20.8c-2.8-2.8-7.6-2.8-10.4 0s-2.8 7.6 0 10.4l20.8 20.8-22 22-20.8-20.8c-2.8-2.8-7.6-2.8-10.4 0s-2.8 7.6 0 10.4l20.8 20.8-13.2 13.2c-2.8 2.8-2.8 7.6 0 10.4 1.6 1.6 3.2 2 5.2 2s3.6-.8 5.2-2l13.2-13.2 20.8 20.8c1.6 1.6 3.2 2 5.2 2s3.6-.8 5.2-2c2.8-2.8 2.8-7.6 0-10.4l-20.8-21.2 22-22 20.8 20.8c1.6 1.6 3.2 2 5.2 2s3.6-.8 5.2-2c2.8-2.8 2.8-7.6 0-10.4l-20.8-20.8 22-22 20.8 20.8c1.6 1.6 3.2 2 5.2 2s3.6-.8 5.2-2c2.8-2.8 2.8-7.6 0-10.4zM169.103 47.6c-1.2-4-5.2-6-9.2-4.8-3.2 1.2-80.8 25.6-110.4 98-1.6 4 0 8.4 4 9.6.8.4 2 .4 2.8.4 2.8 0 5.6-1.6 6.8-4.4 27.2-66 100.4-89.6 101.2-89.6 4-1.2 6-5.2 4.8-9.2z"/>\n    </svg>\n    ',
  flags: '\n    <svg width="1em" height="1em"\n      xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">\n      <path d="M472.928 34.72c-4.384-2.944-9.984-3.52-14.912-1.568-1.088.448-106.528 42.176-195.168.384C186.752-2.4 102.944 14.4 64 25.76V16c0-8.832-7.168-16-16-16S32 7.168 32 16v480c0 8.832 7.168 16 16 16s16-7.168 16-16V315.296c28.352-9.248 112.384-31.232 185.184 3.168 34.592 16.352 70.784 21.792 103.648 21.792 63.2 0 114.016-20.128 117.184-21.408 6.016-2.464 9.984-8.32 9.984-14.848V48c0-5.312-2.656-10.272-7.072-13.28zM448 292.672c-28.512 9.248-112.512 31.136-185.184-3.168C186.752 253.6 102.944 270.4 64 281.76V59.328c28.352-9.248 112.384-31.232 185.184 3.168 76 35.872 159.872 19.104 198.816 7.712v222.464z"/>\n    </svg>\n    ',
  foods: '\n    <svg width="1em" height="1em"\n      xmlns="http://www.w3.org/2000/svg" viewBox="0 0 511.999 511.999">\n      <path d="M413.949 155.583a10.153 10.153 0 0 0-3.24-2.16c-.61-.25-1.24-.44-1.87-.57-3.25-.66-6.701.41-9.03 2.73a10.093 10.093 0 0 0-2.93 7.07 10.098 10.098 0 0 0 1.69 5.56c.36.54.779 1.05 1.24 1.52 1.86 1.86 4.44 2.93 7.07 2.93.65 0 1.31-.07 1.96-.2.63-.13 1.26-.32 1.87-.57a10.146 10.146 0 0 0 3.24-2.16c.47-.47.88-.98 1.25-1.52a10.098 10.098 0 0 0 1.49-3.6 10.038 10.038 0 0 0-2.74-9.03zM115.289 385.873c-.12-.64-.32-1.27-.57-1.87-.25-.6-.55-1.18-.91-1.73-.37-.54-.79-1.06-1.25-1.52a9.57 9.57 0 0 0-1.52-1.24c-.54-.36-1.12-.67-1.72-.92-.61-.25-1.24-.44-1.88-.57a9.847 9.847 0 0 0-3.9 0c-.64.13-1.27.32-1.87.57-.61.25-1.19.56-1.73.92-.55.36-1.06.78-1.52 1.24-.46.46-.88.98-1.24 1.52-.36.55-.67 1.13-.92 1.73-.25.6-.45 1.23-.57 1.87-.13.651-.2 1.3-.2 1.96 0 .65.07 1.3.2 1.95.12.64.32 1.27.57 1.87.25.6.56 1.18.92 1.73.36.54.78 1.06 1.24 1.52.46.46.97.88 1.52 1.24.54.36 1.12.67 1.73.92.6.25 1.23.44 1.87.57s1.3.2 1.95.2c.65 0 1.31-.07 1.95-.2.64-.13 1.27-.32 1.88-.57.6-.25 1.18-.56 1.72-.92.55-.36 1.059-.78 1.52-1.24.46-.46.88-.98 1.25-1.52.36-.55.66-1.13.91-1.73.25-.6.45-1.23.57-1.87.13-.65.2-1.3.2-1.95 0-.66-.07-1.31-.2-1.96z"/>\n      <path d="M511.999 222.726c0-14.215-9.228-26.315-22.007-30.624-1.628-74.155-62.456-133.978-136.994-133.978H159.002c-74.538 0-135.366 59.823-136.994 133.978C9.228 196.411 0 208.51 0 222.726a32.076 32.076 0 0 0 3.847 15.203 44.931 44.931 0 0 0-.795 8.427v.708c0 14.06 6.519 26.625 16.693 34.833-10.178 8.275-16.693 20.891-16.693 35.001 0 15.114 7.475 28.515 18.921 36.702v26.668c0 40.588 33.021 73.608 73.608 73.608h320.836c40.588 0 73.608-33.021 73.608-73.608V353.6c11.446-8.186 18.921-21.587 18.921-36.702 0-13.852-6.354-26.385-16.361-34.702 9.983-8.212 16.361-20.656 16.361-34.562v-.708c0-2.985-.294-5.944-.877-8.845a32.082 32.082 0 0 0 3.93-15.355zM44.033 173.229h322.441c5.523 0 10-4.477 10-10s-4.477-10-10-10H49.737c16.896-43.883 59.503-75.106 109.265-75.106h193.996c62.942 0 114.438 49.953 116.934 112.295H42.068c.234-5.848.9-11.588 1.965-17.189zM23.052 316.896c0-13.837 11.257-25.094 25.094-25.094h117.298l55.346 50.188H48.146c-13.837 0-25.094-11.256-25.094-25.094zm.976-62.945c.422.111.847.215 1.275.309 7.421 1.634 14.68 8.002 22.365 14.744a576.29 576.29 0 0 0 3.206 2.799h-3.081c-11.253-.001-20.774-7.551-23.765-17.852zm308.727 89.752l57.233-51.899 49.904.57-81.871 74.24-25.266-22.911zm7.861 34.126H295.12l17.467-15.839h10.563l17.466 15.839zm19.599-86.027l-82.499 74.811-82.499-74.811h164.998zm-59.529-20c.849-.842 1.677-1.675 2.49-2.493 9.531-9.587 17.059-17.16 32.89-17.16 15.832 0 23.359 7.573 32.89 17.162.812.817 1.64 1.65 2.489 2.491h-70.759zm-160.13 0a485.82 485.82 0 0 0 2.489-2.492c9.531-9.588 17.059-17.161 32.89-17.161 15.83 0 23.358 7.573 32.888 17.16.813.818 1.641 1.651 2.49 2.493h-70.757zm275.862 162.073H95.582c-29.56 0-53.608-24.049-53.608-53.608v-18.275h200.872l17.467 15.839H145.897c-5.523 0-10 4.477-10 10s4.477 10 10 10H467.07c-7.288 20.958-27.242 36.044-50.652 36.044zm53.608-56.046h-94.6l17.467-15.839h77.133v15.839zm-6.174-35.837h-48.906l54.624-49.533c11.135 2.604 19.376 12.665 19.376 24.439 0 13.836-11.257 25.094-25.094 25.094zm-2.728-70.19l.262-.227.101-.087.342-.298c.848-.738 1.682-1.469 2.501-2.187 4.105-3.601 8.089-7.095 12.04-9.819 3.446-2.375 6.868-4.164 10.326-4.925l.359-.081.04-.01.317-.076.065-.016a22.897 22.897 0 0 0 .42-.107l.196-.052a.374.374 0 0 0 .048-.012c-2.433 9.276-10.129 16.443-19.691 18.102a9.984 9.984 0 0 0-2.016-.205h-5.31zm21.271-37.073a40.746 40.746 0 0 0-4.536 1.281c-10.109 3.489-18.327 10.602-26.283 17.58l-.434.381c-9.178 8.052-17.923 15.723-29.033 17.834h-13.146c-11.249-1.93-17.833-8.552-25.823-16.591-10.213-10.275-22.923-23.062-47.074-23.062-24.15 0-36.86 12.786-47.074 23.06-7.992 8.04-14.576 14.663-25.829 16.593h-14.327c-11.253-1.93-17.837-8.553-25.829-16.593-10.213-10.274-22.923-23.06-47.072-23.06-24.151 0-36.861 12.787-47.074 23.062-7.991 8.039-14.574 14.661-25.824 16.591h-7.065c-14.134 0-24.325-8.939-35.113-18.404-9.248-8.112-18.81-16.501-31.252-19.241a12.237 12.237 0 0 1-7.025-4.453 10.027 10.027 0 0 0-1.153-1.252 12.234 12.234 0 0 1-1.428-5.727c-.001-6.788 5.52-12.309 12.307-12.309h447.384c6.787 0 12.308 5.521 12.308 12.308 0 5.729-4.039 10.776-9.605 12.002z"/>\n    </svg>\n    ',
  frequently: '\n    <svg\n      xmlns="http://www.w3.org/2000/svg" viewBox="0 0 219.15 219.15" width="1em" height="1em">\n      <path d="M109.575 0C49.156 0 .001 49.155.001 109.574c0 60.42 49.154 109.576 109.573 109.576 60.42 0 109.574-49.156 109.574-109.576C219.149 49.155 169.995 0 109.575 0zm0 204.15c-52.148 0-94.573-42.427-94.573-94.576C15.001 57.426 57.427 15 109.575 15c52.148 0 94.574 42.426 94.574 94.574 0 52.15-42.426 94.576-94.574 94.576z"/>\n      <path d="M166.112 108.111h-52.051V51.249a7.5 7.5 0 0 0-15 0v64.362a7.5 7.5 0 0 0 7.5 7.5h59.551a7.5 7.5 0 0 0 0-15z"/>\n    </svg>\n    ',
  nature: '\n    <svg\n      xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="1em" height="1em">\n      <path d="M490.815 3.784C480.082 5.7 227.049 51.632 148.477 130.203c-39.153 39.153-64.259 87.884-70.694 137.218-5.881 45.081 4.347 85.929 28.878 116.708L.001 490.789 21.212 512l106.657-106.657c33.094 26.378 75.092 34.302 116.711 28.874 49.334-6.435 98.065-31.541 137.218-70.695C460.368 284.951 506.3 31.918 508.216 21.185L511.999 0l-21.184 3.784zm-43.303 39.493L309.407 181.383l-7.544-98.076c46.386-15.873 97.819-29.415 145.649-40.03zm-174.919 50.64l8.877 115.402-78.119 78.119-11.816-153.606c19.947-13.468 47.183-26.875 81.058-39.915zm-109.281 64.119l12.103 157.338-47.36 47.36c-39.246-52.892-24.821-139.885 35.257-204.698zm57.113 247.849c-26.548-.001-51.267-7.176-71.161-21.938l47.363-47.363 157.32 12.102c-40.432 37.475-89.488 57.201-133.522 57.199zm157.743-85.421l-153.605-11.816 78.118-78.118 115.403 8.877c-13.04 33.876-26.448 61.111-39.916 81.057zm50.526-110.326l-98.076-7.544L468.725 64.485c-10.589 47.717-24.147 99.232-40.031 145.653z"/>\n    </svg>\n    ',
  objects: '\n    <svg\n      xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 792 792">\n      <path d="M425.512 741.214H365.58c-14.183 0-25.164 11.439-25.164 25.622S351.397 792 365.58 792h59.932c15.101 0 26.54-10.981 26.54-25.164s-11.44-25.622-26.54-25.622zM472.638 671.209H319.821c-14.183 0-26.081 10.98-26.081 25.163s11.898 25.164 26.081 25.164h152.817c14.183 0 25.164-10.981 25.164-25.164s-10.982-25.163-25.164-25.163zM639.188 138.634c-25.164-42.548-59.181-76.135-102.49-101.113C493.526 12.621 446.566 0 395.771 0 320.28 0 247.19 31.684 197.205 81.445c-49.761 49.527-81.904 121.24-81.904 196.282 0 33.861 7.779 68.629 22.879 103.866 15.1 35.228 38.565 78.614 70.005 130.396 7.448 12.269 15.764 31.205 25.623 56.271 12.104 30.757 22.87 51.713 31.566 63.602 5.027 6.872 11.899 10.063 20.596 10.063h228.766c9.605 0 16.359-4.188 21.504-11.898 6.754-10.132 13.987-27.516 22.42-51.693 8.951-25.691 16.838-43.982 23.329-55.364 30.571-53.587 54.446-99.747 70.464-137.717 16.018-37.979 24.246-74.124 24.246-107.526 0-49.878-12.347-96.545-37.511-139.093zm-35.696 232.437c-15.012 34.348-36.398 76.974-65.427 126.736-9.41 16.125-18.458 37.003-26.989 63.592-3.367 10.474-7.32 20.596-11.439 30.2H300.153c-6.862-11.439-12.26-25.837-18.761-42.089-12.718-31.801-23.338-52.621-30.2-64.061-28.824-48.043-49.868-87.39-64.051-118.957s-20.537-60.859-21.044-88.766c-2.235-121.718 106.13-228.991 229.674-226.941 41.631.693 80.527 10.063 115.765 30.659 35.227 20.586 63.134 48.043 83.729 82.812 20.586 34.768 31.108 72.748 31.108 113.47-.001 27.449-7.692 58.596-22.881 93.345z"/>\n    </svg>\n    ',
  peoples: '\n    <svg\n      xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 106.059 106.059">\n      <path d="M90.544 90.542c20.687-20.684 20.685-54.341.002-75.024-20.688-20.689-54.347-20.689-75.031-.006-20.688 20.687-20.686 54.346.002 75.034 20.682 20.684 54.341 20.684 75.027-.004zM21.302 21.3c17.494-17.493 45.959-17.495 63.457.002 17.494 17.494 17.492 45.963-.002 63.455-17.494 17.494-45.96 17.496-63.455.003-17.498-17.498-17.496-45.966 0-63.46zM27 69.865s-2.958-11.438 6.705-8.874c0 0 17.144 9.295 38.651 0 9.662-2.563 6.705 8.874 6.705 8.874C73.539 86.824 53.03 85.444 53.03 85.444S32.521 86.824 27 69.865zm6.24-31.194a6.202 6.202 0 1 1 12.399.001 6.202 6.202 0 0 1-12.399-.001zm28.117 0a6.202 6.202 0 1 1 12.403.001 6.202 6.202 0 0 1-12.403-.001z"/>\n    </svg>\n    ',
  places: '\n    <svg\n      xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 611.999 611.998">\n      <path d="M596.583 15.454C586.226 5.224 573.354.523 558.423.523c-15.597 0-31.901 4.906-49.452 14.599-17.296 9.551-32.851 20.574-46.458 32.524h-.665c-2.655 2.322-10.953 10.287-25.219 24.553-14.272 14.272-26.217 26.223-35.845 36.51L112.401 26.406c-6.896-1.968-12.928.014-17.593 4.645L46.687 78.839c-4.326 4.297-5.805 9.268-4.977 15.597.829 6.287 3.979 10.627 9.629 13.607L280.32 228.839 161.514 347.978l-95.91 3.32c-4.645.164-8.637 1.643-12.276 5.311L5.872 404.397c-4.312 4.34-6.641 9.289-5.643 16.262 1.657 6.967 5.31 11.611 11.618 13.602l117.142 48.787 48.787 117.148c2.421 5.812 6.634 9.621 13.607 11.279h3.313c4.977 0 9.296-1.658 12.942-5.311l47.456-47.457c3.653-3.645 5.494-7.965 5.643-12.275l3.32-95.91 118.807-118.807 121.128 228.99c2.988 5.643 7.32 8.793 13.607 9.621 6.329.836 11.271-1.316 15.597-5.643l47.456-47.457c4.978-4.977 6.945-10.697 4.978-17.586l-82.296-288.389 59.732-59.739c10.287-10.287 21.699-24.149 33.183-45.134 5.777-10.542 10.032-20.886 12.942-31.194 5.722-20.218 3.258-44.07-12.608-59.73zm-59.4 110.176l-67.039 67.372c-5.628 5.657-6.811 11.122-4.977 17.586l81.637 288.388-22.563 22.238L403.438 292.89c-2.98-5.643-7.299-8.963-12.941-9.621-6.301-1.331-11.611.325-16.263 4.977l-141.37 141.37c-2.987 2.986-4.644 6.973-5.643 11.949l-3.32 95.904-22.896 23.236-41.48-98.566c-1.331-4.645-4.553-8.184-9.629-10.287L51.338 411.03l23.229-22.895 95.578-3.654c5.643-.99 9.622-2.654 12.276-5.309l141.37-141.371c4.651-4.645 6.308-9.954 4.984-16.262-.666-5.643-3.986-9.954-9.629-12.942L90.829 87.47l22.231-22.238 288.389 81.637c6.464 1.833 11.951.666 17.587-4.977l28.545-28.539 26.217-25.884 11.278-11.285 1.331-.666c27.873-23.895 55.088-38.16 72.016-38.16 5.969 0 9.954 1.324 11.611 3.979 18.917 18.585-21.099 72.484-32.851 84.293z"/>\n    </svg>\n    ',
  symbols: '\n    <svg\n      xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 511.626 511.626">\n      <path d="M475.366 71.949c-24.175-23.606-57.575-35.404-100.215-35.404-11.8 0-23.843 2.046-36.117 6.136-12.279 4.093-23.702 9.615-34.256 16.562-10.568 6.945-19.65 13.467-27.269 19.556a263.828 263.828 0 0 0-21.696 19.414 264.184 264.184 0 0 0-21.698-19.414c-7.616-6.089-16.702-12.607-27.268-19.556-10.564-6.95-21.985-12.468-34.261-16.562-12.275-4.089-24.316-6.136-36.116-6.136-42.637 0-76.039 11.801-100.211 35.404C12.087 95.55 0 128.286 0 170.16c0 12.753 2.24 25.891 6.711 39.398 4.471 13.514 9.566 25.031 15.275 34.546 5.708 9.514 12.181 18.792 19.414 27.834 7.233 9.041 12.519 15.272 15.846 18.698 3.33 3.426 5.948 5.903 7.851 7.427L243.25 469.938c3.427 3.426 7.614 5.144 12.562 5.144s9.138-1.718 12.563-5.144l177.87-171.31c43.588-43.58 65.38-86.406 65.38-128.472.001-41.877-12.085-74.61-36.259-98.207zm-53.961 199.846L255.813 431.391 89.938 271.507C54.344 235.922 36.55 202.133 36.55 170.156c0-15.415 2.046-29.026 6.136-40.824 4.093-11.8 9.327-21.177 15.703-28.124 6.377-6.949 14.132-12.607 23.268-16.988 9.141-4.377 18.086-7.328 26.84-8.85 8.754-1.52 18.079-2.281 27.978-2.281 9.896 0 20.557 2.424 31.977 7.279 11.418 4.853 21.934 10.944 31.545 18.271 9.613 7.332 17.845 14.183 24.7 20.557 6.851 6.38 12.559 12.229 17.128 17.559 3.424 4.189 8.091 6.283 13.989 6.283 5.9 0 10.562-2.094 13.99-6.283 4.568-5.33 10.28-11.182 17.131-17.559 6.852-6.374 15.085-13.222 24.694-20.557 9.613-7.327 20.129-13.418 31.553-18.271 11.416-4.854 22.08-7.279 31.977-7.279s19.219.761 27.977 2.281c8.757 1.521 17.702 4.473 26.84 8.85 9.137 4.38 16.892 10.042 23.267 16.988 6.376 6.947 11.612 16.324 15.705 28.124 4.086 11.798 6.132 25.409 6.132 40.824-.002 31.977-17.89 65.86-53.675 101.639z"/>\n    </svg>\n    '
}, Q4 = () => [
  new en("frequently", tn.frequently, "常用"),
  new en("peoples", tn.peoples, "情绪"),
  new en("nature", tn.nature, "自然"),
  new en("foods", tn.foods, "食物与饮料"),
  new en("activity", tn.activity, "活动"),
  new en("objects", tn.objects, "对象"),
  new en("places", tn.places, "旅行与地方"),
  new en("symbols", tn.symbols, "符号"),
  new en("flags", tn.flags, "旗帜")
], ew = () => S("svg", {
  viewBox: "0 0 16 16",
  xmlns: "http://www.w3.org/2000/svg",
  height: "1em",
  width: "1em",
  focusable: "false"
}, [S("g", {
  "stroke-width": "1"
}, [S("path", {
  d: "M6.751 12.303A5.557 5.557 0 0 1 1.2 6.751C1.2 3.691 3.69 1.2 6.751 1.2a5.558 5.558 0 0 1 5.551 5.551 5.557 5.557 0 0 1-5.551 5.552M6.751 0a6.751 6.751 0 1 0 4.309 11.949l3.855 3.855a.6.6 0 1 0 .849-.849l-3.854-3.853A6.751 6.751 0 0 0 6.751 0"
}, null)])]);
const tw = /* @__PURE__ */ ye({
  name: "IBizCategories",
  props: {
    categories: {
      type: Array,
      required: !0,
      default: () => []
    },
    current: {
      type: String,
      required: !0
    }
  },
  emits: ["select"],
  setup(s, {
    emit: e
  }) {
    return {
      ns: me("emoji-categories"),
      onSelect: (i) => {
        e("select", i);
      }
    };
  },
  render() {
    return S("div", {
      class: this.ns.b()
    }, [this.categories.map((s) => S("div", {
      class: [this.ns.e("category"), this.ns.is("active", s.name === this.current)],
      onClick: () => this.onSelect(s)
    }, [S("span", {
      class: this.ns.em("category", "svg"),
      title: s.label,
      innerHTML: s.icon
    }, null)]))]);
  }
});
const nw = /* @__PURE__ */ ye({
  name: "IBizCategoryLabel",
  props: {
    name: {
      type: String,
      default: ""
    }
  },
  emits: ["select"],
  setup() {
    return {
      ns: me("emoji-category-label")
    };
  },
  render() {
    return S("div", {
      class: this.ns.b()
    }, [this.name]);
  }
});
const sw = /* @__PURE__ */ ye({
  name: "IBizEmojiItem",
  props: {
    emoji: {
      type: Object,
      required: !0,
      default: () => {
      }
    },
    size: {
      type: Number,
      required: !0
    },
    withBorder: {
      type: Boolean,
      required: !0
    }
  },
  emits: ["click"],
  setup(s, {
    emit: e
  }) {
    const t = me("emoji-item"), n = qe(() => ({
      fontSize: "".concat(s.size - 5, "px"),
      lineHeight: "".concat(s.size, "px"),
      height: "".concat(s.size, "px"),
      width: "".concat(s.size, "px")
    }));
    return {
      ns: t,
      styleSize: n,
      onClick: () => {
        e("click", s.emoji);
      }
    };
  },
  render() {
    return S("span", {
      class: [this.ns.b(), this.ns.is("border", this.withBorder)],
      style: this.styleSize,
      onClick: this.onClick,
      innerHTML: this.emoji.data
    }, null);
  }
});
const Ch = (s, e) => {
  const t = (n) => n.toLowerCase().includes(s);
  return e.aliases.some((n) => t(n));
}, iw = /* @__PURE__ */ ye({
  name: "IBizEmojiList",
  props: {
    data: {
      type: Object,
      required: !0
    },
    emojisByRow: {
      type: Number,
      required: !0
    },
    emojiWithBorder: {
      type: Boolean
    },
    emojiSize: {
      type: Number
    },
    filter: {
      type: String,
      default: ""
    },
    continuousList: {
      type: Boolean
    },
    category: {
      type: String,
      default: ""
    },
    categories: {
      type: Object,
      required: !0,
      default: () => {
      }
    },
    hasSearch: {
      type: Boolean
    }
  },
  emits: ["select", "data"],
  setup(s, {
    emit: e
  }) {
    const t = me("emoji-list"), n = L({}), i = L({}), r = qe(() => {
      let g = s.data[s.category];
      const p = s.filter.trim().toLowerCase();
      return p && (g = g.filter((m) => Ch(p, m))), g;
    }), o = qe(() => Object.keys(s.data)), a = (g, p) => {
      p && (i.value[g] = p);
    }, l = () => s.hasSearch ? 88 : 44, c = qe(() => {
      const g = 100 / s.emojisByRow;
      return {
        gridTemplateColumns: "repeat(".concat(s.emojisByRow, ", ").concat(g, "%)")
      };
    }), u = qe(() => {
      const g = {};
      Object.assign(g, s.data);
      const p = s.filter.trim().toLowerCase();
      return p && o.value.forEach((m) => {
        g[m] = s.data[m].filter((w) => Ch(p, w));
      }), g;
    }), d = (g) => {
      e("select", g);
    };
    return Be(() => s.data, () => {
      n.value.$el.scrollTop = 0;
    }), Be(() => s.category, (g) => {
      if (s.continuousList) {
        const p = i.value[g].$el;
        n.value.scrollTop = p.offsetTop - l();
      }
    }), {
      ns: t,
      emojisRef: n,
      gridDynamic: c,
      dataFiltered: r,
      dataFilteredByCategory: u,
      onSelect: d,
      setCategoryRef: a,
      renderGridEmojis: (g) => {
        const {
          emojis: p,
          style: m,
          size: w,
          withBorder: v
        } = g;
        return p && p.length > 0 ? S("div", {
          class: [t.m("grid-emojis")],
          style: m
        }, [p.map((y) => S(sw, {
          emoji: y,
          size: w,
          withBorder: v,
          onClick: () => d(y)
        }, null))]) : "";
      }
    };
  },
  render() {
    return S("div", {
      class: [this.ns.b()]
    }, [S("div", {
      ref: "emojisRef",
      class: [this.ns.e("container")]
    }, [this.continuousList ? Object.keys(this.dataFilteredByCategory).map((s) => {
      const e = this.dataFilteredByCategory[s], t = this.categories[s], n = t ? t.text : s;
      return S("div", null, [e.length ? S(nw, {
        name: n,
        ref: (i) => this.setCategoryRef(s, i)
      }, null) : "", this.renderGridEmojis({
        emojis: e,
        style: this.gridDynamic,
        size: this.emojiSize,
        withBorder: this.emojiWithBorder
      })]);
    }) : this.renderGridEmojis({
      emojis: this.dataFiltered || [],
      style: this.gridDynamic,
      size: this.emojiSize,
      withBorder: this.emojiWithBorder
    })])]);
  }
});
const rw = /* @__PURE__ */ ye({
  name: "IBizInputSearch",
  emits: ["update"],
  setup(s, {
    emit: e
  }) {
    const t = me("emoji-input-search"), n = L(""), i = () => {
      e("update", n.value);
    };
    return {
      ns: t,
      inputSearch: n,
      onSearch: i,
      handleKeyUp: (o) => {
        o && o.code === "Enter" && i();
      }
    };
  },
  render() {
    return S("div", {
      class: [this.ns.b()]
    }, [S("div", {
      class: this.ns.e("container"),
      onKeyup: this.handleKeyUp
    }, [S("div", {
      class: this.ns.em("container", "search"),
      onClick: this.onSearch
    }, [ew()]), gi(S("input", {
      class: this.ns.em("container", "input"),
      type: "text",
      "onUpdate:modelValue": (s) => this.inputSearch = s,
      placeholder: ibiz.i18n.t("app.search")
    }, null), [[Pl, this.inputSearch]])])]);
  }
});
const ow = /* @__PURE__ */ ye({
  name: "IBizEmojiSelectHtmlComment",
  props: {
    // 自定义表情符号数组，类型为IEmoji[]，必填项，默认值为emojisDefault
    customEmojis: {
      type: Array,
      required: !0,
      default: () => K4
    },
    // 自定义分类数组，类型为ICategory[]，必填项，默认值为categoriesDefault
    customCategories: {
      type: Array,
      required: !0,
      default: () => []
    },
    // 频繁使用表情符号的数量限制
    limitFrequently: {
      type: Number,
      default: 15
    },
    // 每行显示的表情符号数量
    emojisByRow: {
      type: Number,
      default: 8
    },
    // 是否使用连续列表显示表情符号
    continuousList: {
      type: Boolean,
      default: !1
    },
    // 表情符号的大小
    emojiSize: {
      type: Number,
      default: 27
    },
    // 表情符号是否带有边框
    emojiWithBorder: {
      type: Boolean,
      default: !0
    },
    // 是否显示搜索框
    showSearch: {
      type: Boolean,
      default: !0
    },
    // 是否显示分类
    showCategories: {
      type: Boolean,
      default: !0
    },
    // 是否使用深色模式
    dark: {
      type: Boolean,
      default: !1
    },
    // 初始选择的分类
    initialCategory: {
      type: String,
      default: "peoples"
    },
    // 需要排除的分类数组
    exceptCategories: {
      type: Array,
      default: () => []
    },
    // 需要排除的表情符号数组
    exceptEmojis: {
      type: Array,
      default: () => []
    }
  },
  emits: ["select", "changeCategory", "customEmojis"],
  setup(s, {
    emit: e
  }) {
    const t = me("emoji-select"), n = L([]), i = L([]), r = L("peoples"), o = L([]), a = L([]), l = L([]), c = L({}), u = L({}), d = L("");
    d.value = r.value;
    const f = L(""), g = i.value.map((k) => k.name);
    g.includes(r.value) || (r.value = g[0]);
    const p = async (k) => {
      f.value = k;
    }, m = qe(() => i.value.filter((k) => !o.value.includes(k))), w = (k) => {
      k.forEach((O) => {
        Object.assign(c.value, {
          [O.name]: O
        });
      });
    }, v = (k) => {
      Object.assign(u.value, {
        frequently: []
      }), k.filter((O) => !a.value.includes(O)).forEach((O) => {
        const P = O.category;
        u.value[P] || Object.assign(u.value, {
          [P]: []
        }), u.value[P].push(O);
      });
    }, y = async () => {
      const k = l.value || [];
      Object.assign(u.value, {
        frequently: k.map((O) => n.value[O])
      });
    }, b = (k) => {
      const O = k.map((P) => n.value.indexOf(P));
      l.value = O;
    }, x = async (k) => {
      const O = u.value.frequently, P = [.../* @__PURE__ */ new Set([k, ...O])];
      u.value.frequently = P.slice(0, s.limitFrequently), b(P);
    }, C = async (k) => {
      const O = u.value[k.name].length;
      d.value = k.name, O && e("changeCategory", k);
    }, A = async (k) => {
      await x(k), e("select", k);
    };
    return Be(() => s.customEmojis, (k) => {
      n.value = s.customEmojis, k && k.length && (u.value = {}, v(k));
    }, {
      immediate: !0,
      deep: !0
    }), Be(() => s.customCategories, (k) => {
      k && k.length > 0 ? i.value = k : i.value = Q4(), w(i.value);
    }, {
      immediate: !0,
      deep: !0
    }), Be(() => s.initialCategory, () => {
      r.value = s.initialCategory;
    }), Be(() => s.exceptCategories, () => {
      o.value = s.exceptCategories;
    }), Be(() => s.exceptEmojis, () => {
      a.value = s.exceptEmojis;
    }), fn(() => {
      v(n.value), y();
    }), fr(() => {
      u.value = {}, l.value = [];
    }), {
      ns: t,
      mapEmojis: u,
      filterEmoji: f,
      mapCategories: c,
      currentCategory: d,
      categoriesFiltered: m,
      onSearch: p,
      onSelectEmoji: A,
      changeCategory: C
    };
  },
  render() {
    return S("div", {
      class: [this.ns.b(), this.ns.is("dark", this.dark)]
    }, [this.showCategories && S(tw, {
      categories: this.categoriesFiltered,
      current: this.currentCategory,
      onSelect: this.changeCategory
    }, null), this.showSearch && S(rw, {
      onUpdate: this.onSearch
    }, null), S(iw, {
      data: this.mapEmojis,
      category: this.currentCategory,
      filter: this.filterEmoji,
      categories: this.mapCategories,
      emojiWithBorder: this.emojiWithBorder,
      emojiSize: this.emojiSize,
      emojisByRow: this.emojisByRow,
      continuousList: this.continuousList,
      hasSearch: this.showSearch,
      onSelect: this.onSelectEmoji
    }, null)]);
  }
});
class La {
  constructor(e, t, n) {
    E(this, "type");
    E(this, "icon");
    E(this, "text");
    this.type = e, this.icon = t, this.text = n;
  }
  get label() {
    return this.type;
  }
}
class xn {
  constructor(e, t, n, i, r, o) {
    E(this, "type");
    E(this, "icon");
    E(this, "category");
    E(this, "text");
    E(this, "value");
    E(this, "isInline");
    this.type = e, this.icon = t, this.category = n, this.text = i, this.value = r, this.isInline = o === !0;
  }
}
const Cn = {
  layout: '<svg width="1em" height="1em" viewBox="0 0 28 28" version="1.1" xmlns="http://www.w3.org/2000/svg" fit="" preserveAspectRatio="xMidYMid meet" focusable="false"> <title>布局</title> <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <g id="icon"> <rect fill="#FFFFFF" x="0" y="0" width="28" height="28" rx="4"></rect> <path d="M24,0 C26.209139,0 28,1.790861 28,4 L28,24 C28,26.209139 26.209139,28 24,28 L4,28 C1.790861,28 0,26.209139 0,24 L0,4 C0,1.790861 1.790861,0 4,0 L24,0 Z M24,1 L4,1 C2.34314575,1 1,2.34314575 1,4 L1,24 C1,25.6568542 2.34314575,27 4,27 L24,27 C25.6568542,27 27,25.6568542 27,24 L27,4 C27,2.34314575 25.6568542,1 24,1 Z" id="矩形" fill="#EEEEEE" fill-rule="nonzero"></path> <g transform="translate(4.666667, 4.666667)"> <path d="M1.6,0 L6.95555556,0 C7.83921116,5.97197047e-17 8.55555556,0.7163444 8.55555556,1.6 L8.55555556,9.28888889 C8.55555556,10.1725445 7.83921116,10.8888889 6.95555556,10.8888889 L1.6,10.8888889 C0.7163444,10.8888889 1.082166e-16,10.1725445 0,9.28888889 L0,1.6 C-1.082166e-16,0.7163444 0.7163444,1.623249e-16 1.6,0 Z M11.6512821,0 L17.0068376,0 C17.8904932,5.97197047e-17 18.6068376,0.7163444 18.6068376,1.6 L18.6068376,9.28888889 C18.6068376,10.1725445 17.8904932,10.8888889 17.0068376,10.8888889 L11.6512821,10.8888889 C10.7676265,10.8888889 10.0512821,10.1725445 10.0512821,9.28888889 L10.0512821,1.6 C10.0512821,0.7163444 10.7676265,1.623249e-16 11.6512821,0 Z" id="形状结合" fill="#6698FF" opacity="0.300000012"></path> <path d="M0.466666667,17.8888889 L18.2,17.8888889 C18.4577329,17.8888889 18.6666667,18.0978227 18.6666667,18.3555556 C18.6666667,18.6132884 18.4577329,18.8222222 18.2,18.8222222 L0.466666667,18.8222222 C0.208933783,18.8222222 3.15631751e-17,18.6132884 0,18.3555556 C-3.15631751e-17,18.0978227 0.208933783,17.8888889 0.466666667,17.8888889 Z M0.466666667,14 L10.3025641,14 C10.560297,14 10.7692308,14.2089338 10.7692308,14.4666667 C10.7692308,14.7243995 10.560297,14.9333333 10.3025641,14.9333333 L0.466666667,14.9333333 C0.208933783,14.9333333 3.15631751e-17,14.7243995 0,14.4666667 C-3.15631751e-17,14.2089338 0.208933783,14 0.466666667,14 Z" id="形状结合" fill="#CACACA"></path> <path d="M4.2,4.82222222 L2.8,4.82222222 C2.54226712,4.82222222 2.33333333,4.61328844 2.33333333,4.35555556 C2.33333333,4.09782267 2.54226712,3.88888889 2.8,3.88888889 L4.2,3.88888889 C4.45773288,3.88888889 4.66666667,4.09782267 4.66666667,4.35555556 C4.66666667,4.61328844 4.45773288,4.82222222 4.2,4.82222222 Z M15.0888889,4.82222222 L12.9111111,4.82222222 C12.6533782,4.82222222 12.4444444,4.61328844 12.4444444,4.35555556 C12.4444444,4.09782267 12.6533782,3.88888889 12.9111111,3.88888889 L15.0888889,3.88888889 C15.3466218,3.88888889 15.5555556,4.09782267 15.5555556,4.35555556 C15.5555556,4.61328844 15.3466218,4.82222222 15.0888889,4.82222222 Z M5.75555556,7.93333333 L2.8,7.93333333 C2.54226712,7.93333333 2.33333333,7.72439955 2.33333333,7.46666667 C2.33333333,7.20893378 2.54226712,7 2.8,7 L5.75555556,7 C6.01328844,7 6.22222222,7.20893378 6.22222222,7.46666667 C6.22222222,7.72439955 6.01328844,7.93333333 5.75555556,7.93333333 Z M15.8666667,7.93333333 L12.9111111,7.93333333 C12.6533782,7.93333333 12.4444444,7.72439955 12.4444444,7.46666667 C12.4444444,7.20893378 12.6533782,7 12.9111111,7 L15.8666667,7 C16.1243995,7 16.3333333,7.20893378 16.3333333,7.46666667 C16.3333333,7.72439955 16.1243995,7.93333333 15.8666667,7.93333333 Z" id="形状结合" fill="#6698FF"></path> </g> </g> </g> </svg>',
  date: "<svg width='1em' height='1em' viewBox='0 0 28 28' version='1.1' xmlns='http://www.w3.org/2000/svg'> <title>日期</title> <g stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'> <g> <rect fill='#FFFFFF' x='0' y='0' width='28' height='28' rx='4'></rect> <path d='M24,0 C26.209139,0 28,1.790861 28,4 L28,24 C28,26.209139 26.209139,28 24,28 L4,28 C1.790861,28 0,26.209139 0,24 L0,4 C0,1.790861 1.790861,0 4,0 L24,0 Z M24,1 L4,1 C2.34314575,1 1,2.34314575 1,4 L1,24 C1,25.6568542 2.34314575,27 4,27 L24,27 C25.6568542,27 27,25.6568542 27,24 L27,4 C27,2.34314575 25.6568542,1 24,1 Z' fill='#EEEEEE' fill-rule='nonzero' ></path> <g transform='translate(4.666667, 4.666667)'> <path d='M18.2666667,6.62222222 L18.2666667,17.1111111 C18.2666667,17.430209 18.1373267,17.7190979 17.9282123,17.9282123 C17.7190979,18.1373267 17.430209,18.2666667 17.1111111,18.2666667 L1.55555556,18.2666667 C1.2364577,18.2666667 0.947568811,18.1373267 0.738454386,17.9282123 C0.529339961,17.7190979 0.4,17.430209 0.4,17.1111111 L0.4,6.62222222 L18.2666667,6.62222222 Z M18.1333333,6.75555556 L0.509112478,6.75555556 L1.17926226,18.1481019 L18.1333333,17.4960222 L18.1333333,6.75555556 Z M17.0666667,1.95555556 C17.3980375,1.95555556 17.6980375,2.08987013 17.9151948,2.30702742 C18.1323521,2.52418471 18.2666667,2.82418471 18.2666667,3.15555556 L18.2666667,5.80985059 L0.4,5.80985059 L0.4,3.15555556 C0.4,2.82418471 0.534314575,2.52418471 0.751471863,2.30702742 C0.96862915,2.08987013 1.26862915,1.95555556 1.6,1.95555556 Z' stroke='#EEEEEE' stroke-width='0.8' fill='#EEEEEE' ></path> <rect fill='#DDDDDD' x='3.88888889' y='0' width='1.55555556' height='3.88888889' rx='0.777777778' ></rect> <rect fill='#DDDDDD' x='13.2222222' y='0' width='1.55555556' height='3.88888889' rx='0.777777778' ></rect> <path d='M2.8,10.1111111 L4.2,10.1111111 C4.45773288,10.1111111 4.66666667,10.3200449 4.66666667,10.5777778 C4.66666667,10.8355107 4.45773288,11.0444444 4.2,11.0444444 L2.8,11.0444444 C2.54226712,11.0444444 2.33333333,10.8355107 2.33333333,10.5777778 C2.33333333,10.3200449 2.54226712,10.1111111 2.8,10.1111111 Z M2.8,14 L4.2,14 C4.45773288,14 4.66666667,14.2089338 4.66666667,14.4666667 C4.66666667,14.7243995 4.45773288,14.9333333 4.2,14.9333333 L2.8,14.9333333 C2.54226712,14.9333333 2.33333333,14.7243995 2.33333333,14.4666667 C2.33333333,14.2089338 2.54226712,14 2.8,14 Z M6.68888889,10.1111111 L8.08888889,10.1111111 C8.34662177,10.1111111 8.55555556,10.3200449 8.55555556,10.5777778 C8.55555556,10.8355107 8.34662177,11.0444444 8.08888889,11.0444444 L6.68888889,11.0444444 C6.43115601,11.0444444 6.22222222,10.8355107 6.22222222,10.5777778 C6.22222222,10.3200449 6.43115601,10.1111111 6.68888889,10.1111111 Z M14.4666667,14 L15.8666667,14 C16.1243995,14 16.3333333,14.2089338 16.3333333,14.4666667 C16.3333333,14.7243995 16.1243995,14.9333333 15.8666667,14.9333333 L14.4666667,14.9333333 C14.2089338,14.9333333 14,14.7243995 14,14.4666667 C14,14.2089338 14.2089338,14 14.4666667,14 Z' fill='#CACACA' ></path> <path d='M6.68888889,14 L11.9777778,14 C12.2355107,14 12.4444444,14.2089338 12.4444444,14.4666667 C12.4444444,14.7243995 12.2355107,14.9333333 11.9777778,14.9333333 L6.68888889,14.9333333 C6.43115601,14.9333333 6.22222222,14.7243995 6.22222222,14.4666667 C6.22222222,14.2089338 6.43115601,14 6.68888889,14 Z' fill='#FF7575' ></path> <path d='M10.5777778,10.1111111 L15.8666667,10.1111111 C16.1243995,10.1111111 16.3333333,10.3200449 16.3333333,10.5777778 C16.3333333,10.8355107 16.1243995,11.0444444 15.8666667,11.0444444 L10.5777778,11.0444444 C10.3200449,11.0444444 10.1111111,10.8355107 10.1111111,10.5777778 C10.1111111,10.3200449 10.3200449,10.1111111 10.5777778,10.1111111 Z' fill='#6698FF' ></path> </g> </g> </g></svg>",
  label: "<svg width='1em' height='1em' viewBox='0 0 28 28' version='1.1' xmlns='http://www.w3.org/2000/svg'> <title>标签</title> <g stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'> <g> <rect fill='#FFFFFF' x='0' y='0' width='28' height='28' rx='4'></rect> <path d='M24,0 C26.209139,0 28,1.790861 28,4 L28,24 C28,26.209139 26.209139,28 24,28 L4,28 C1.790861,28 0,26.209139 0,24 L0,4 C0,1.790861 1.790861,0 4,0 L24,0 Z M24,1 L4,1 C2.34314575,1 1,2.34314575 1,4 L1,24 C1,25.6568542 2.34314575,27 4,27 L24,27 C25.6568542,27 27,25.6568542 27,24 L27,4 C27,2.34314575 25.6568542,1 24,1 Z' fill='#EEEEEE' fill-rule='nonzero' ></path> <g transform='translate(3.888889, 6.222222)'> <rect fill='#EEEEEE' x='0' y='0' width='9.33333333' height='3.88888889' rx='1.94444444' ></rect> <rect fill='#F6C659' opacity='0.300000012' x='0' y='6.22222222' width='9.33333333' height='3.88888889' rx='1.94444444' ></rect> <rect fill='#D287F8' opacity='0.300000012' x='0' y='12.4444444' width='9.33333333' height='3.88888889' rx='1.94444444' ></rect> <rect fill='#FF7575' opacity='0.300000012' x='10.8888889' y='0' width='9.33333333' height='3.88888889' rx='1.94444444' ></rect> <rect fill='#73D897' opacity='0.300000012' x='10.8888889' y='6.22222222' width='9.33333333' height='3.88888889' rx='1.94444444' ></rect> <rect fill='#56ABFB' opacity='0.300000012' x='10.8888889' y='12.4444444' width='9.33333333' height='3.88888889' rx='1.94444444' ></rect> <path d='M7.77777778,2.02222222 C7.77777778,2.27995511 7.56884399,2.48888889 7.31111111,2.48888889 L2.02222222,2.48888889 C1.76448934,2.48888889 1.55555556,2.27995511 1.55555556,2.02222222 C1.55555556,1.76448934 1.76448934,1.55555556 2.02222222,1.55555556 L7.31111111,1.55555556 C7.56884399,1.55555556 7.77777778,1.76448934 7.77777778,2.02222222 Z' fill='#CACACA' fill-rule='nonzero' ></path> <path d='M7.77777778,8.24444444 C7.77777778,8.50217733 7.56884399,8.71111111 7.31111111,8.71111111 L2.02222222,8.71111111 C1.76448934,8.71111111 1.55555556,8.50217733 1.55555556,8.24444444 C1.55555556,7.98671156 1.76448934,7.77777778 2.02222222,7.77777778 L7.31111111,7.77777778 C7.56884399,7.77777778 7.77777778,7.98671156 7.77777778,8.24444444 Z' fill='#FFCD5D' fill-rule='nonzero' ></path> <path d='M7.77777778,14.4666667 C7.77777778,14.7243995 7.56884399,14.9333333 7.31111111,14.9333333 L2.02222222,14.9333333 C1.76448934,14.9333333 1.55555556,14.7243995 1.55555556,14.4666667 C1.55555556,14.2089338 1.76448934,14 2.02222222,14 L7.31111111,14 C7.56884399,14 7.77777778,14.2089338 7.77777778,14.4666667 Z' fill='#D287F8' fill-rule='nonzero' ></path> <path d='M18.6666667,2.02222222 C18.6666667,2.27995511 18.4577329,2.48888889 18.2,2.48888889 L12.9111111,2.48888889 C12.6533782,2.48888889 12.4444444,2.27995511 12.4444444,2.02222222 C12.4444444,1.76448934 12.6533782,1.55555556 12.9111111,1.55555556 L18.2,1.55555556 C18.4577329,1.55555556 18.6666667,1.76448934 18.6666667,2.02222222 Z' fill='#FF7575' fill-rule='nonzero' ></path> <path d='M18.6666667,8.24444444 C18.6666667,8.50217733 18.4577329,8.71111111 18.2,8.71111111 L12.9111111,8.71111111 C12.6533782,8.71111111 12.4444444,8.50217733 12.4444444,8.24444444 C12.4444444,7.98671156 12.6533782,7.77777778 12.9111111,7.77777778 L18.2,7.77777778 C18.4577329,7.77777778 18.6666667,7.98671156 18.6666667,8.24444444 Z' fill='#73D897' fill-rule='nonzero' ></path> <path d='M18.6666667,14.4666667 C18.6666667,14.7243995 18.4577329,14.9333333 18.2,14.9333333 L12.9111111,14.9333333 C12.6533782,14.9333333 12.4444444,14.7243995 12.4444444,14.4666667 C12.4444444,14.2089338 12.6533782,14 12.9111111,14 L18.2,14 C18.4577329,14 18.6666667,14.2089338 18.6666667,14.4666667 Z' fill='#56ABFB' fill-rule='nonzero' ></path> </g> </g> </g></svg>",
  promptBox: "<svg width='1em' height='1em' viewBox='0 0 28 28' version='1.1' xmlns='http://www.w3.org/2000/svg'> <title>提示框</title> <defs> <rec x='1' y='1' width='26' height='26' rx='4'></rect> </defs> <g stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'> <g > <rect fill='#FFFFFF' x='0' y='0' width='28' height='28' rx='3.2' ></rect> <path d='M24.8,0 C26.5673112,0 28,1.4326888 28,3.2 L28,24.8 C28,26.5673112 26.5673112,28 24.8,28 L3.2,28 C1.4326888,28 0,26.5673112 0,24.8 L0,3.2 C0,1.4326888 1.4326888,0 3.2,0 L24.8,0 Z M24.8,1 L3.2,1 C1.98497355,1 1,1.98497355 1,3.2 L1,24.8 C1,26.0150264 1.98497355,27 3.2,27 L24.8,27 C26.0150264,27 27,26.0150264 27,24.8 L27,3.2 C27,1.98497355 26.0150264,1 24.8,1 Z' fill='#EEEEEE' fill-rule='nonzero' ></path> <mask fill='white'> <use xlink:href='#path-1'></use> </mask> <use fill='#FFFFFF' xlink:href='#path-1'></use> <g mask='url(#mask-2)'> <g transform='translate(4.666667, 7.000000)'> <rect fill='#5DCFFF' opacity='0.200000003' x='0' y='0' width='33.4444444' height='14' rx='1.6' ></rect> <path d='M12.9111111,8.55555556 L15.8666667,8.55555556 C16.1243995,8.55555556 16.3333333,8.76448934 16.3333333,9.02222222 C16.3333333,9.27995511 16.1243995,9.48888889 15.8666667,9.48888889 L12.9111111,9.48888889 C12.6533782,9.48888889 12.4444444,9.27995511 12.4444444,9.02222222 C12.4444444,8.76448934 12.6533782,8.55555556 12.9111111,8.55555556 Z M12.9111111,4.66666667 L23.6444444,4.66666667 C23.9021773,4.66666667 24.1111111,4.87560045 24.1111111,5.13333333 C24.1111111,5.39106622 23.9021773,5.6 23.6444444,5.6 L12.9111111,5.6 C12.6533782,5.6 12.4444444,5.39106622 12.4444444,5.13333333 C12.4444444,4.87560045 12.6533782,4.66666667 12.9111111,4.66666667 Z' fill='#5DCFFF' ></path> <g stroke-width='1' fill='none' transform='translate(3.111111, 3.888889)' > <pat  d='M3.11111111,-8.8817842e-16 C4.82222222,-8.8817842e-16 6.22222222,1.4 6.22222222,3.11111111 C6.22222222,4.82222222 4.82222222,6.22222222 3.11111111,6.22222222 C1.4,6.22222222 0,4.82222222 0,3.11111111 C0,1.4 1.4,-8.8817842e-16 3.11111111,-8.8817842e-16 Z M2.85139179,2.72012729 L2.83967627,4.6768138 L3.3841145,4.6794151 L3.39583002,2.72272859 L2.85139179,2.72012729 Z M2.87813929,1.54282507 L2.87038639,2.32474454 L3.50268048,2.33249744 L3.51043338,1.55057797 L2.87813929,1.54282507 Z'  fill='#5DCFFF' ></path> </g> </g> </g> </g> </g></svg>",
  mindMap: '<svg width="1em" height="1em" viewBox="0 0 28 28" version="1.1" xmlns="http://www.w3.org/2000/svg" fit="" preserveAspectRatio="xMidYMid meet" focusable="false"> <title>思维导图</title> <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <g id="icon"> <rect fill="#FFFFFF" x="0" y="0" width="28" height="28" rx="4"></rect> <path d="M24,0 C26.209139,0 28,1.790861 28,4 L28,24 C28,26.209139 26.209139,28 24,28 L4,28 C1.790861,28 0,26.209139 0,24 L0,4 C0,1.790861 1.790861,0 4,0 L24,0 Z M24,1 L4,1 C2.34314575,1 1,2.34314575 1,4 L1,24 C1,25.6568542 2.34314575,27 4,27 L24,27 C25.6568542,27 27,25.6568542 27,24 L27,4 C27,2.34314575 25.6568542,1 24,1 Z" fill="#EEEEEE" fill-rule="nonzero"></path> <g id="编组-26" transform="translate(3.888889, 5.833333)"> <rect id="矩形" fill="#CACACA" x="7" y="7.77777778" width="5.44444444" height="1"></rect> <path d="M12.4444444,14.7777778 L11.3222222,14.7777778 C10.4385666,14.7777778 9.72222222,14.0614334 9.72222222,13.1777778 L9.72222222,3.15555556 C9.72222222,2.27189996 10.4385666,1.55555556 11.3222222,1.55555556 L12.4444444,1.55555556 L12.4444444,1.55555556" stroke="#CACACA" stroke-width="0.96"></path> <path d="M13.2444444,0 L18.6444444,0 C19.0862722,2.00237164e-16 19.4444444,0.3581722 19.4444444,0.8 L19.4444444,2.31111111 C19.4444444,2.75293891 19.0862722,3.11111111 18.6444444,3.11111111 L13.2444444,3.11111111 C12.8026166,3.11111111 12.4444444,2.75293891 12.4444444,2.31111111 L12.4444444,0.8 C12.4444444,0.3581722 12.8026166,-2.98598523e-17 13.2444444,0 Z" id="矩形备份-68" fill="#6698FF" opacity="0.300000012"></path> <rect fill="#73D897" opacity="0.300000012" x="12.4444444" y="6.61111111" width="7" height="3.11111111" rx="0.8"></rect> <path d="M13.2444444,13.2222222 L18.6444444,13.2222222 C19.0862722,13.2222222 19.4444444,13.5803944 19.4444444,14.0222222 L19.4444444,15.5333333 C19.4444444,15.9751611 19.0862722,16.3333333 18.6444444,16.3333333 L13.2444444,16.3333333 C12.8026166,16.3333333 12.4444444,15.9751611 12.4444444,15.5333333 L12.4444444,14.0222222 C12.4444444,13.5803944 12.8026166,13.2222222 13.2444444,13.2222222 Z" fill="#FF7575" opacity="0.300000012"></path> <path d="M17.8888889,1.64666667 C17.8888889,1.91176335 17.6739856,2.12666667 17.4088889,2.12666667 L14.48,2.12666667 C14.2149033,2.12666667 14,1.91176335 14,1.64666667 C14,1.38156999 14.2149033,1.16666667 14.48,1.16666667 L17.4088889,1.16666667 C17.6739856,1.16666667 17.8888889,1.38156999 17.8888889,1.64666667 Z" id="直线-7备份-6" fill="#6698FF" fill-rule="nonzero"></path> <path d="M17.8888889,8.25777778 C17.8888889,8.52287446 17.6739856,8.73777778 17.4088889,8.73777778 L14.48,8.73777778 C14.2149033,8.73777778 14,8.52287446 14,8.25777778 C14,7.9926811 14.2149033,7.77777778 14.48,7.77777778 L17.4088889,7.77777778 C17.6739856,7.77777778 17.8888889,7.9926811 17.8888889,8.25777778 Z" id="直线-7备份-7" fill="#73D897" fill-rule="nonzero"></path> <path d="M17.8888889,14.8688889 C17.8888889,15.1339856 17.6739856,15.3488889 17.4088889,15.3488889 L14.48,15.3488889 C14.2149033,15.3488889 14,15.1339856 14,14.8688889 C14,14.6037922 14.2149033,14.3888889 14.48,14.3888889 L17.4088889,14.3888889 C17.6739856,14.3888889 17.8888889,14.6037922 17.8888889,14.8688889 Z" id="直线-7备份-8" fill="#FF7575" fill-rule="nonzero"></path> <path d="M1.6,5.44444444 L5.4,5.44444444 C6.2836556,5.44444444 7,6.16078884 7,7.04444444 L7,9.28888889 C7,10.1725445 6.2836556,10.8888889 5.4,10.8888889 L1.6,10.8888889 C0.7163444,10.8888889 3.30261205e-16,10.1725445 0,9.28888889 L0,7.04444444 C1.13828005e-16,6.16078884 0.7163444,5.44444444 1.6,5.44444444 Z" fill="#EEEEEE"></path> </g> </g> </g> </svg>',
  audio: '<svg width="1em" height="1em" viewBox="0 0 28 28" version="1.1" xmlns="http://www.w3.org/2000/svg" fit="" preserveAspectRatio="xMidYMid meet" focusable="false"> <title>音频</title> <g id="音频" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <g id="icon"> <rect fill="#FFFFFF" x="0" y="0" width="28" height="28" rx="4"></rect> <path d="M24,0 C26.209139,0 28,1.790861 28,4 L28,24 C28,26.209139 26.209139,28 24,28 L4,28 C1.790861,28 0,26.209139 0,24 L0,4 C0,1.790861 1.790861,0 4,0 L24,0 Z M24,1 L4,1 C2.34314575,1 1,2.34314575 1,4 L1,24 C1,25.6568542 2.34314575,27 4,27 L24,27 C25.6568542,27 27,25.6568542 27,24 L27,4 C27,2.34314575 25.6568542,1 24,1 Z" id="矩形" fill="#EEEEEE" fill-rule="nonzero"></path> <g transform="translate(4.666667, 7.000000)"> <ellipse fill="#CACACA" cx="9.33333333" cy="7" rx="2.33333333" ry="3.11111111"></ellipse> <path d="M2.69356086,9.2803178 L0.690789474,9.2803178 C0.309276809,9.2803178 0,8.97105135 0,8.58952833 L0,5.35862792 C0,4.9771049 0.309276809,4.66783845 0.690789474,4.66783845 L2.69356086,4.66783845 C2.69356086,4.66783845 2.69356086,9.2803178 2.69356086,9.2803178 Z" id="路径" fill="#DDDDDD"></path> <path d="M9.24122807,0 L9.24122807,14 C6.82346491,14 2.69356086,9.2803178 2.69356086,9.2803178 L2.69356086,4.66783845 C2.69356086,4.66783845 6.82346491,0 9.24122807,0 Z" id="路径" fill="#F5F5F5"></path> <path d="M14.4666667,6.67859506 L16.7559366,6.67859506 C17.0136695,6.67859506 17.2226033,6.88752885 17.2226033,7.14526173 C17.2226033,7.40299461 17.0136695,7.6119284 16.7559366,7.6119284 L14.4666667,7.6119284 C14.2089338,7.6119284 14,7.40299461 14,7.14526173 C14,6.88752885 14.2089338,6.67859506 14.4666667,6.67859506 Z" id="矩形备份-74" fill="#73D897"></path> <path d="M14.4666667,2.33333333 L18.927827,2.33333333 C19.1855599,2.33333333 19.3944936,2.54226712 19.3944936,2.8 C19.3944936,3.05773288 19.1855599,3.26666667 18.927827,3.26666667 L14.4666667,3.26666667 C14.2089338,3.26666667 14,3.05773288 14,2.8 C14,2.54226712 14.2089338,2.33333333 14.4666667,2.33333333 Z" id="矩形备份-75" fill="#6698FF"></path> <path d="M14.4666667,11.0238568 L18.927827,11.0238568 C19.1855599,11.0238568 19.3944936,11.2327906 19.3944936,11.4905235 C19.3944936,11.7482563 19.1855599,11.9571901 18.927827,11.9571901 L14.4666667,11.9571901 C14.2089338,11.9571901 14,11.7482563 14,11.4905235 C14,11.2327906 14.2089338,11.0238568 14.4666667,11.0238568 Z" id="矩形备份-77" fill="#FF7575"></path> </g> </g> </g> </svg>',
  formula: '<svg width="1em" height="1em" viewBox="0 0 28 28" version="1.1" xmlns="http://www.w3.org/2000/svg" fit="" preserveAspectRatio="xMidYMid meet" focusable="false"> <title>公式</title> <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <g id="icon"> <rect fill="#FFFFFF" x="0" y="0" width="28" height="28" rx="4"></rect> <path d="M24,0 C26.209139,0 28,1.790861 28,4 L28,24 C28,26.209139 26.209139,28 24,28 L4,28 C1.790861,28 0,26.209139 0,24 L0,4 C0,1.790861 1.790861,0 4,0 L24,0 Z M24,1 L4,1 C2.34314575,1 1,2.34314575 1,4 L1,24 C1,25.6568542 2.34314575,27 4,27 L24,27 C25.6568542,27 27,25.6568542 27,24 L27,4 C27,2.34314575 25.6568542,1 24,1 Z" id="矩形" fill="#EEEEEE" fill-rule="nonzero"></path> <g transform="translate(6.222222, 6.222222)"> <path d="M0.466666667,16.3333333 L8.08888889,16.3333333 C8.34662177,16.3333333 8.55555556,16.5422671 8.55555556,16.8 C8.55555556,17.0577329 8.34662177,17.2666667 8.08888889,17.2666667 L0.466666667,17.2666667 C0.208933783,17.2666667 3.15631751e-17,17.0577329 0,16.8 C-3.15631751e-17,16.5422671 0.208933783,16.3333333 0.466666667,16.3333333 Z M0.466666667,13.2222222 L15.0888889,13.2222222 C15.3466218,13.2222222 15.5555556,13.431156 15.5555556,13.6888889 C15.5555556,13.9466218 15.3466218,14.1555556 15.0888889,14.1555556 L0.466666667,14.1555556 C0.208933783,14.1555556 3.15631751e-17,13.9466218 0,13.6888889 C-3.15631751e-17,13.431156 0.208933783,13.2222222 0.466666667,13.2222222 Z" id="形状结合" fill="#CACACA"></path> <path d="M7.29125451,0 C7.38377228,0 7.47325862,0.03098981 7.54722121,0.0875155065 L7.59958726,0.13461254 L8.32633451,0.900605806 C8.49662199,1.08008919 8.49662199,1.37108926 8.32633451,1.55057265 C8.17496787,1.71011343 7.94000374,1.72784019 7.77005987,1.60375291 L7.70966902,1.55057265 L7.11011022,0.919191919 L2.20294226,0.919191919 L5.86172644,4.73057214 C6.01309309,4.89011292 6.0299116,5.13776566 5.91218199,5.31688688 L5.86172644,5.38053898 L1.48925255,9.19191919 L7.21088891,9.19191919 L7.81117445,8.56053847 C7.9625411,8.40099768 8.19750523,8.38327092 8.3674491,8.5073582 L8.42783995,8.56053847 C8.57920659,8.72007925 8.59602511,8.96773199 8.4782955,9.14685321 L8.42783995,9.21050531 L7.70109269,9.97649857 C7.63567275,10.0454513 7.55160597,10.0902317 7.46138469,10.1053857 L7.39275995,10.1111111 L0.436922523,10.1111111 C0.0727247798,10.1111111 -0.121029049,9.67600851 0.0825161905,9.38305589 L0.128589776,9.32653173 L4.93638527,5.05555556 L0.841552739,0.784579379 C0.584026044,0.513145656 0.738922096,0.0610784438 1.07938574,0.00563033025 L1.14988549,0 L7.29125451,0 Z M13.4123521,6.36326594 C13.4835613,6.26668286 13.5653385,6.17894359 13.6560525,6.10179832 C13.7739326,6.14537625 13.9131899,6.18895419 14.0738245,6.23253213 C14.2338105,6.27601914 14.3985524,6.29798932 14.5639737,6.29789904 C14.8254058,6.30337896 15.0782142,6.20113169 15.2666735,6.0136951 C15.4633399,5.81548898 15.5681255,5.53943359 15.5543498,5.25581792 C15.5625234,5.03769835 15.4836884,4.82568311 15.3363022,4.66941046 C15.1932921,4.51889384 14.9960721,4.43684042 14.7920992,4.44299465 C14.5276073,4.44184652 14.2723055,4.54325127 14.076573,4.72719859 C13.79695,5.00734436 13.5561581,5.32614942 13.3610468,5.67454506 C13.305466,5.76927971 13.2388913,5.87854033 13.1613225,6.00232694 L12.7001548,6.55130253 C12.6378555,6.27846675 12.57464,5.99994689 12.5059275,5.71290091 C12.085407,3.96315198 10.6900851,4.30787901 10.2805586,4.48219077 C9.8389663,4.67166006 9.9571518,5.09512393 10.194439,4.98333705 C10.4166026,4.85295335 10.6857788,4.84072112 10.9181474,4.95044941 C11.1505161,5.0601777 11.3178523,5.27853825 11.3680485,5.53753473 C11.5668567,6.24899193 11.7134433,6.89792426 11.8508683,7.46822683 C11.7478048,7.62153899 11.403818,8.05305748 11.2859293,8.19448666 C11.2112337,8.28582736 11.1304112,8.37161645 11.0440613,8.45121756 C10.9090794,8.40069241 10.7652412,8.35427244 10.6125468,8.31195763 C10.4564339,8.269741 10.2956695,8.2487227 10.1343078,8.24943276 C9.87263241,8.24411775 9.61959814,8.34632312 9.43069178,8.5336367 C9.23123516,8.73520831 9.1254105,9.01585021 9.14026694,9.30382938 C9.13218953,9.51704512 9.20928522,9.72430908 9.35345807,9.87697219 C9.49763092,10.0296353 9.69618572,10.1142547 9.90251761,10.1109686 C10.1692308,10.1154591 10.427396,10.0136988 10.6235408,9.82676463 C10.8971525,9.54472709 11.1359499,9.22875305 11.3344861,8.88604959 C11.4206058,8.747737 11.4862644,8.64037107 11.531462,8.56395179 C11.5736056,8.49195346 11.876521,8.09631754 11.9690538,7.95232088 C12.0491926,8.58451479 12.347946,9.16533971 12.8100948,9.58744088 C13.5199368,9.89948674 14.0990436,10.1179285 14.7536202,9.69603082 C15.044045,9.52456111 14.9478475,9.16078006 14.7536202,9.22804166 C14.4839818,9.40974328 13.8958539,9.57918911 13.646555,9.36871093 C13.1802062,8.68324372 12.8921623,7.88528807 12.8100948,7.05150147 C12.9469091,6.85319028 13.3048553,6.49778914 13.4123521,6.36326594 Z" id="形状结合" fill="#666666" fill-rule="nonzero"></path> </g> </g> </g> </svg>',
  files: '<svg width="1em" height="1em" viewBox="0 0 28 28" version="1.1" xmlns="http://www.w3.org/2000/svg" fit=""> <title>本地文件</title> <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <g id="icon"> <rect fill="#FFFFFF" x="0" y="0" width="28" height="28" rx="4"></rect> <path d="M24,0 C26.209139,0 28,1.790861 28,4 L28,24 C28,26.209139 26.209139,28 24,28 L4,28 C1.790861,28 0,26.209139 0,24 L0,4 C0,1.790861 1.790861,0 4,0 L24,0 Z M24,1 L4,1 C2.34314575,1 1,2.34314575 1,4 L1,24 C1,25.6568542 2.34314575,27 4,27 L24,27 C25.6568542,27 27,25.6568542 27,24 L27,4 C27,2.34314575 25.6568542,1 24,1 Z" id="矩形" fill="#EEEEEE" fill-rule="nonzero"></path> <g transform="translate(2.331723, 6.223395)"> <path d="M10.8586379,9.82567869 C10.8586379,11.3135682 9.65287619,12.519741 8.16549379,12.519741 C6.6781114,12.519741 5.47234973,11.3135682 5.47237295,9.83060072 L5.43152142,5.5040927 C5.4288277,5.21612692 5.65998761,4.98048085 5.94785525,4.97776249 C6.23572289,4.97504413 6.47128863,5.20628285 6.47400607,5.49424863 L6.51485711,9.82567869 C6.51485711,10.737611 7.25387232,11.4768781 8.16549379,11.4768781 C9.07711526,11.4768781 9.81613048,10.737611 9.81613048,9.82567869 L9.81613048,5.02838197 C9.81613048,3.65522549 8.5992671,2.52563899 7.0795486,2.52563899 C5.55983011,2.52563899 4.34296673,3.65522549 4.34296673,5.02838197 L4.34296673,10.0065309 C4.34296673,12.103884 6.05369893,13.8053486 8.16549379,13.8053486 C10.2772887,13.8053486 11.9880209,12.103884 11.9880209,10.0065309 L11.9880209,5.5222302 C11.9880209,5.23425158 12.2213941,5.00079879 12.5092745,5.00079879 C12.797155,5.00079879 13.0305282,5.23425158 13.0305282,5.5222302 L13.0305282,10.0065309 C13.0305282,12.6811932 10.8517067,14.8482114 8.16549379,14.8482114 C5.47928093,14.8482114 3.30045935,12.6811932 3.30045935,10.0065309 L3.30045935,5.02838197 C3.30045935,3.06112766 5.0007613,1.48277617 7.0795486,1.48277617 C9.15833591,1.48277617 10.8586379,3.06112766 10.8586379,5.02838197 Z" id="形状结合" fill="#DDDDDD" transform="translate(8.165494, 8.165494) rotate(-315.000000) translate(-8.165494, -8.165494) "></path> <path d="M16.8515613,7.68286899 L19.1408313,7.68286899 C19.3985642,7.68286899 19.6074979,7.89180277 19.6074979,8.14953566 C19.6074979,8.40726854 19.3985642,8.61620232 19.1408313,8.61620232 L16.8515613,8.61620232 C16.5938284,8.61620232 16.3848947,8.40726854 16.3848947,8.14953566 C16.3848947,7.89180277 16.5938284,7.68286899 16.8515613,7.68286899 Z" id="矩形备份-74" fill="#73D897"></path> <path d="M16.8515613,3.33760726 L21.3127216,3.33760726 C21.5704545,3.33760726 21.7793883,3.54654104 21.7793883,3.80427393 C21.7793883,4.06200681 21.5704545,4.27094059 21.3127216,4.27094059 L16.8515613,4.27094059 C16.5938284,4.27094059 16.3848947,4.06200681 16.3848947,3.80427393 C16.3848947,3.54654104 16.5938284,3.33760726 16.8515613,3.33760726 Z" id="矩形备份-75" fill="#6698FF"></path> <path d="M16.8515613,12.0281307 L21.3127216,12.0281307 C21.5704545,12.0281307 21.7793883,12.2370645 21.7793883,12.4947974 C21.7793883,12.7525303 21.5704545,12.9614641 21.3127216,12.9614641 L16.8515613,12.9614641 C16.5938284,12.9614641 16.3848947,12.7525303 16.3848947,12.4947974 C16.3848947,12.2370645 16.5938284,12.0281307 16.8515613,12.0281307 Z" id="矩形备份-77" fill="#FF7575"></path> </g> </g> </g></svg>'
}, aw = () => [
  new La("base", "", "基础"),
  new La("graph", "", "图形"),
  new La("file", "", "文件")
], ef = () => [
  new xn("layout", Cn.layout, "base", "布局", "", !1),
  new xn(
    "date",
    Cn.date,
    "base",
    "日期",
    qa().format("YYYY-MM-DD"),
    !0
  ),
  new xn("label", Cn.label, "base", "标签", "", !0),
  new xn("prompt-box", Cn.promptBox, "base", "提示框", "", !1),
  new xn("formula", Cn.formula, "base", "LaTex 公式", "", !0),
  new xn("mind-map", Cn.mindMap, "graph", "思维导图", "", !1),
  new xn("files", Cn.files, "file", "本地文件", "", !0),
  new xn("audio", Cn.audio, "file", "本地音频", "", !1)
];
const lw = (s, e) => e.text.toLowerCase().includes(s), cw = /* @__PURE__ */ ye({
  name: "IBizInsertItemList",
  props: {
    data: {
      type: Object,
      required: !0
    },
    filter: {
      type: String,
      default: ""
    },
    categories: {
      type: Object,
      required: !0,
      default: () => {
      }
    },
    hasSearch: {
      type: Boolean
    }
  },
  emits: ["select", "data"],
  setup(s, {
    emit: e
  }) {
    const t = me("insert-item-list"), n = L({}), i = qe(() => Object.keys(s.data)), r = qe(() => {
      const c = {};
      Object.assign(c, s.data);
      const u = s.filter.trim().toLowerCase();
      return u && i.value.forEach((d) => {
        c[d] = s.data[d].filter((f) => lw(u, f));
      }), c;
    }), o = (c) => {
      e("select", c);
    }, a = (c) => {
      const {
        icon: u,
        text: d
      } = c;
      return S("div", {
        class: [t.e("insert-item")],
        onClick: () => o(c)
      }, [u ? S("div", {
        class: t.em("insert-item", "icon"),
        innerHTML: u
      }, null) : "", S("div", {
        class: t.em("insert-item", "text")
      }, [d])]);
    };
    return {
      ns: t,
      InsertItemsRef: n,
      dataFilteredByCategory: r,
      onSelect: o,
      renderListInsertItems: (c) => {
        const {
          insertSelect: u,
          style: d
        } = c;
        return u && u.length > 0 ? S("div", {
          class: [t.e("list-insert-items")],
          style: d
        }, [u.map((f) => a(f))]) : "";
      }
    };
  },
  render() {
    return S("div", {
      class: [this.ns.b()]
    }, [S("div", {
      ref: "InsertItemsRef",
      class: [this.ns.e("container")]
    }, [Object.keys(this.dataFilteredByCategory).map((s) => {
      const e = this.dataFilteredByCategory[s], t = this.categories[s], n = t ? t.text : s;
      return S("div", null, [e.length ? S("div", {
        class: this.ns.e("label")
      }, [n]) : "", this.renderListInsertItems({
        insertSelect: e
      })]);
    })])]);
  }
});
function hw(s) {
  const e = L([]), t = {
    "audio/*": "音频"
    // 可以根据需求继续添加其他类型
  }, n = (b) => {
    const x = t[b] || "";
    return "点击上传".concat(x, "文件");
  }, i = L({
    Authorization: "Bearer ".concat(Ol(Tl.TOKEN))
  }), r = L(""), o = L(""), a = {
    count: 0,
    cacheFiles: []
    // iview上传过程中不能改default-file-list,所以需要缓存
  }, l = qe(() => a.count);
  if (s.context && s.actionParams) {
    const b = ibiz.util.file.calcFileUpDownUrl(
      s.context,
      s.viewParams,
      {},
      s.actionParams
    );
    r.value = b.uploadUrl, o.value = b.downloadUrl;
  }
  const c = () => {
    const b = a.cacheFiles, x = b.length > 0 ? b : null;
    a.cacheFiles = [], s.modal.dismiss({ ok: !0, data: x });
  }, u = (b) => {
    const x = b.size / 1024 / 1024;
    return s.size && x > s.size ? (ibiz.message.error(
      "".concat(ibiz.i18n.t("editor.upload.fileSizeErr"), " ").concat(s.size, "MB!")
    ), !1) : (a.count += 1, !0);
  }, d = (b, x) => {
    var C;
    b && (a.cacheFiles.push({
      id: b.fileid,
      name: b.filename,
      ext: b.ext,
      folder: b.folder,
      size: b.size,
      type: ((C = x.raw) == null ? void 0 : C.type) || "",
      url: b.rul || o.value.replace("%fileId%", b.fileid)
    }), a.count -= 1);
  }, f = (...b) => {
    const x = b[0];
    throw a.count -= 1, new xp({
      response: { data: JSON.parse(x.message), status: x.status }
    });
  }, g = (b) => {
    if (s.disabled)
      return;
    if (a.count === 0) {
      const C = a.cacheFiles.findIndex(
        (A) => b.response && A.id === b.response.id
      );
      C !== -1 && a.cacheFiles.splice(C, 1);
    }
    const x = e.value.findIndex((C) => C.id === b.id);
    x !== -1 && e.value.splice(x, 1);
  }, p = L(), m = (b) => {
    p.value && p.value.handleRemove(b);
  }, w = qe(() => s.multiple ? 9999 : 1);
  return {
    uploadUrl: r,
    headers: i,
    files: e,
    limit: w,
    filesCount: l,
    uploadRef: p,
    onError: f,
    onRemove: g,
    onItemRemove: m,
    onSuccess: d,
    beforeUpload: u,
    onConfirm: () => {
      c();
    },
    onCancel: () => {
      a.cacheFiles = [], c();
    },
    getUploadMessage: n
  };
}
const uw = S("svg", {
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "9641",
  width: "1em",
  height: "1em"
}, [S("path", {
  d: "M852.537678 966.322357c7.542461 0 14.818718-3.016984 20.142807-8.341075s8.341075-12.600347 8.341075-20.142807V262.033969c0-6.743847-2.395841-13.22149-6.743848-18.368111L725.469393 67.793414c-5.412825-6.388908-13.39896-10.115771-21.740034-10.115771h-532.231543c-7.542461 0-14.818718 3.016984-20.142807 8.341075s-8.341075 12.600347-8.341075 20.142807v851.67695c0 7.542461 3.016984 14.818718 8.341075 20.142807s12.600347 8.341075 20.142807 8.341075h681.039862z",
  fill: "#CA223D",
  "p-id": "9642"
}, null), S("path", {
  d: "M881.02156 265.228423v-3.194454c0-6.743847-2.395841-13.22149-6.743848-18.368111L725.469393 67.793414c-5.412825-6.388908-13.39896-10.115771-21.740034-10.115771h-1.331023v207.55078h178.623224z",
  opacity: ".15",
  "p-id": "9643"
}, null), S("path", {
  d: "M359.083258 657.52513c-10.293241 0-16.14974-4.614211-19.432929-9.494627-10.027036-15.262392 2.040901-40.640555 14.197574-52.442288 6.300173-6.033969 25.023224-21.562565 65.131369-37.889775 8.07487-19.07799 15.97227-40.55182 23.071057-62.469324 11.801733-36.647487 18.989255-74.271057 22.982323-100.447834-8.696014-16.061005-34.162912-65.042634-34.162912-83.676949 0-10.470711 2.307106-18.989255 7.010052-25.200693 4.880416-6.566378 11.979203-10.204506 20.054073-10.204507 9.228423 0 18.456846 4.702946 25.466898 12.955286 7.098787 8.25234 11.00312 19.255459 11.003119 30.702253 0 17.569497-2.307106 44.012478-6.300173 71.254073 17.392028 31.323397 36.292548 59.984749 52.087348 78.885269 15.617331 18.634315 34.340381 35.493934 55.902946 50.223917 37.97851-3.283189 82.878336-4.348007 99.205546 2.218371 20.852686 8.429809 24.40208 22.272444 20.763952 32.476949-6.388908 17.924437-34.87279 27.951473-58.742461 20.586482-9.760832-3.016984-35.493934-12.067938-66.994801-32.47695-26.176776 2.484575-53.240901 6.388908-78.619064 11.358059-27.507799 5.32409-53.063432 12.422877-76.045754 21.030156-19.521664 44.278683-37.357366 70.10052-53.152166 76.755633-9.583362 4.259272-17.303293 5.856499-23.425997 5.856499z m-0.976083-22.272444c1.419757 0.17747 6.033969 0.266205 15.883536-3.904332 5.945234-2.484575 16.948354-15.351127 30.968457-42.947661-21.917504 11.00312-32.388215 20.054073-35.582669 23.159792-7.808666 7.453726-12.067938 19.699133-11.269324 23.692201z m271.794801-95.478683c15.97227 8.07487 28.128943 12.245407 33.985442 14.108839 14.996187 4.614211 29.105026-2.57331 31.145927-6.388908-0.621144-0.798614-2.57331-2.662045-7.986135-4.880416-5.235355-2.129636-24.490815-4.170537-57.145234-2.839515z m-181.728943 6.477643l-0.443674 1.064818c18.72305-6.033969 38.777123-11.091854 59.807279-15.173656 17.480763-3.371924 35.848873-6.300173 54.128249-8.607279l-0.709878-0.532409 2.129636-0.17747c-14.818718-11.979203-28.128943-25.023224-39.841941-39.043328-14.996187-17.835702-29.193761-39.487002-40.37435-57.943847l-0.17747 1.153553-0.532409-0.887349c-4.348007 22.893588-10.559445 49.691508-18.989255 76.045754-4.880416 15.173657-10.204506 30.258579-15.706066 44.456153l0.709879-0.35494z m9.849567-248.368804c-0.887348 0-1.508492 0.17747-2.307106 1.242288-0.798614 1.064818-2.57331 4.259272-2.57331 11.890468 0 4.525477 5.50156 20.586482 17.037088 44.722357 1.419757-14.108839 2.129636-26.709185 2.129636-36.381283 0-13.842634-9.494627-21.47383-14.286308-21.47383z",
  fill: "#FFFFFF",
  "p-id": "9644"
}, null), S("path", {
  d: "M404.808319 775.25851h17.125823l1.419757 8.252339h0.532409c6.655113-5.679029 14.996187-10.293241 23.514732-10.293241 19.699133 0 31.323397 16.14974 31.323397 40.640555 0 27.330329-16.415945 43.213865-33.896707 43.213865-7.010052 0-13.665165-3.105719-19.787869-8.696014l0.532409 13.132755v24.224611h-20.763951v-110.47487z m52.442288 38.954592c0-15.262392-4.880416-23.692201-15.794801-23.692201-5.412825 0-10.293241 2.75078-15.794801 8.25234v35.05026c5.14662 4.436742 10.293241 5.945234 14.552513 5.945234 9.583362 0.088735 17.037088-8.163605 17.037089-25.555633zM492.034662 815.366655c0-26.088042 16.238475-42.060312 33.453033-42.060312 8.962218 0 14.552513 3.460659 20.231542 8.696014l-0.887348-12.511612v-28.128943h20.941421v113.758059h-16.948353l-1.685962-8.252339h-0.443674c-5.856499 5.679029-13.842634 10.293241-22.094974 10.293241-19.787868-0.088735-32.565685-15.706066-32.565685-41.794108z m52.885962 16.238475v-35.05026c-4.880416-4.436742-9.849567-5.945234-14.818718-5.945234-8.962218 0-16.504679 8.518544-16.504679 24.490815 0 16.504679 5.945234 24.757019 16.504679 24.757019 5.50156 0 10.204506-2.307106 14.818718-8.25234zM630.993414 757.600277c-2.75078-0.976083-5.856499-1.685962-8.429809-1.685962-6.300173 0-9.672097 3.726863-9.672097 12.511612v6.832583h14.996187v16.504679h-14.996187v63.356672h-20.941421v-63.267937h-10.648181v-15.528596l10.648181-0.887349v-6.566378c0-16.682149 7.719931-29.459965 27.774003-29.459965 6.122704 0 11.535529 1.419757 15.084922 2.839515l-3.815598 15.351126z",
  fill: "#FFFFFF",
  "p-id": "9645"
}, null)]), dw = S("svg", {
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "11602",
  width: "1em",
  height: "1em"
}, [S("path", {
  d: "M146.879977 0A52.335992 52.335992 0 0 0 95.999985 51.167992v921.647856a49.039992 49.039992 0 0 0 15.279998 35.791994A49.839992 49.839992 0 0 0 146.863977 1023.99984h746.287883a48.559992 48.559992 0 0 0 35.567995-15.359998A50.719992 50.719992 0 0 0 943.999853 972.815848V290.015955L655.679898 0H146.847977h0.016z",
  fill: "#3662EC",
  "p-id": "11603"
}, null), S("path", {
  d: "M943.999853 287.999955H706.84789A52.127992 52.127992 0 0 1 655.999898 237.199963V0l287.951955 287.999955H943.999853z",
  fill: "#FFFFFF",
  "fill-opacity": ".7",
  "p-id": "11604"
}, null), S("path", {
  d: "M336.831947 751.999883h45.823993v-152.575977h51.711992V561.279912h-148.991977v38.143994h51.455992V751.999883z m102.399984 0h48.639993l16.383997-37.119995c4.351999-9.983998 8.703999-19.967997 13.055998-31.743995h1.024c5.119999 11.775998 9.471999 21.759997 14.079998 31.743995L550.079914 751.999883h50.943992l-52.479992-95.999985 49.151993-94.719986h-48.383993l-13.823998 34.303995c-3.839999 8.959999-7.935999 18.943997-12.287998 31.231995h-1.024c-5.375999-12.287998-9.471999-22.271997-13.823997-31.231995l-15.359998-34.303995h-50.943992l49.407992 92.671986L439.231931 751.999883z m217.855966 0h45.823993v-152.575977h51.711992V561.279912h-148.991977v38.143994h51.455992V751.999883z",
  fill: "#FFFFFF",
  "p-id": "11605"
}, null)]), fw = S("svg", {
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "17449",
  width: "1em",
  height: "1em"
}, [S("path", {
  d: "M947.2 216.064l-192.256-204.8A38.144 38.144 0 0 0 728.064 0h-614.4a40.192 40.192 0 0 0-38.912 41.472v941.056A40.192 40.192 0 0 0 113.664 1024H921.6a40.192 40.192 0 0 0 38.912-41.472V245.504A42.752 42.752 0 0 0 947.2 216.064zM652.8 768l-137.216-203.008L378.624 768h-95.488l184.576-264.704L295.424 256h95.488l124.672 185.088L640 256h95.488L563.2 503.04 748.032 768z",
  fill: "#25C273",
  "p-id": "17450"
}, null)]), gw = S("svg", {
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "19451",
  width: "1em",
  height: "1em"
}, [S("path", {
  d: "M854.6 288.7c6 6 9.4 14.1 9.4 22.6V928c0 17.7-14.3 32-32 32H192c-17.7 0-32-14.3-32-32V96c0-17.7 14.3-32 32-32h424.7c8.5 0 16.7 3.4 22.7 9.4l215.2 215.3zM790.2 326L602 137.8V326h188.2zM296 136v64h64v-64h-64z m64 64v64h64v-64h-64z m-64 64v64h64v-64h-64z m64 64v64h64v-64h-64z m-64 64v64h64v-64h-64z m64 64v64h64v-64h-64z m-64 64v64h64v-64h-64z m0 64v160h128V584H296z m48 48h32v64h-32v-64z",
  fill: "#515151",
  "p-id": "19452"
}, null)]), pw = S("svg", {
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "26339",
  width: "1em",
  height: "1em"
}, [S("path", {
  d: "M794.574 930.64h-562.47c-24.262 0-44-19.738-44-44V142.99c0-24.262 19.738-44 44-44h344.009v64H252.104v703.65h522.471V345h64v541.64c-0.001 24.261-19.739 44-44.001 44z",
  fill: "",
  "p-id": "26340"
}, null), S("path", {
  d: "M619 301.79h220v64H619z",
  fill: "",
  "p-id": "26341"
}, null), S("path", {
  d: "M618 98.228h64v266.078h-64z",
  fill: "",
  "p-id": "26342"
}, null), S("path", {
  d: "M632.307 136.573l51.007-38.649 155.153 204.764-51.008 38.649zM916.137 779.999H110.146c-6.6 0-12-5.4-12-12V493.127c0-6.6 5.4-12 12-12h805.991c6.6 0 12 5.4 12 12v274.872c0 6.6-5.4 12-12 12z",
  fill: "",
  "p-id": "26343"
}, null), S("path", {
  d: "M266.631 551.092h47.454c52.831 0 85.559 24.867 85.559 77.998 0 52.918-32.728 79.271-83.688 79.271h-49.324V551.092z m45.35 131.978c32.26 0 52.363-15.727 52.363-53.98 0-38.467-20.104-52.92-52.363-52.92h-10.753v106.9h10.753zM436.581 629.09c0-51.219 31.559-80.973 77.376-80.973s77.376 29.967 77.376 80.973-31.559 82.246-77.376 82.246-77.376-31.24-77.376-82.246z m119.453 0c0-33.793-16.363-53.982-42.077-53.982s-42.077 20.189-42.077 53.982c0 33.578 16.363 55.043 42.077 55.043s42.077-21.465 42.077-55.043zM628.271 630.365c0-51.857 36.701-82.248 80.415-82.248 21.975 0 39.507 9.564 50.728 20.189l-18.234 19.979c-8.649-7.652-18.701-13.178-31.792-13.178-26.182 0-45.817 20.402-45.817 54.193 0 34.217 17.766 54.832 45.116 54.832 14.728 0 26.416-6.375 35.767-15.514l18.233 19.553c-14.26 15.088-32.728 23.164-55.169 23.164-43.714 0.001-79.247-28.478-79.247-80.97z",
  fill: "#FFFFFF",
  "p-id": "26344"
}, null)]), mw = S("svg", {
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "27355",
  width: "1em",
  height: "1em"
}, [S("path", {
  d: "M170.65984 42.65984l682.65984 0q53.00224 0 90.50112 37.49888t37.49888 90.50112l0 682.65984q0 53.00224-37.49888 90.50112t-90.50112 37.49888l-682.65984 0q-53.00224 0-90.50112-37.49888t-37.49888-90.50112l0-682.65984q0-53.00224 37.49888-90.50112t90.50112-37.49888zM896 742.99392l-213.34016-213.34016-366.32576 366.32576 537.00608 0q17.67424 0 30.16704-12.4928t12.4928-30.16704l0-110.32576zM853.34016 128l-682.65984 0q-17.67424 0-30.16704 12.4928t-12.4928 30.16704l0 682.65984q0 17.67424 12.4928 30.16704t30.16704 12.4928l25.00608 0 486.99392-486.99392 213.34016 213.34016 0-451.66592q0-17.67424-12.4928-30.16704t-30.16704-12.4928zM341.34016 213.34016q53.00224 0 90.50112 37.49888t37.49888 90.50112-37.49888 90.50112-90.50112 37.49888-90.50112-37.49888-37.49888-90.50112 37.49888-90.50112 90.50112-37.49888zM341.34016 298.65984q-17.67424 0-30.16704 12.4928t-12.4928 30.16704 12.4928 30.16704 30.16704 12.4928 30.16704-12.4928 12.4928-30.16704-12.4928-30.16704-30.16704-12.4928z",
  fill: "#444444",
  "p-id": "27356"
}, null)]), ww = S("svg", {
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "28365",
  width: "1em",
  height: "1em"
}, [S("path", {
  d: "M622.95253333 327.29173333l0.02133334-224.4384H176.6688V921.14133333h670.72853333V327.29173333H622.95253333z m5.1552 195.20533334c-9.32266667-19.97866667-28.90666667-28.61866667-46.624-30.93866667-17.4432-2.34346667-33.1712 1.17973333-44.7872 3.58826667v153.4144c1.2448 22.29866667-12.25066667 46.25066667-36.144 60.04693333-31.80586667 18.3552-70.0032 11.75253333-85.3056-14.752-15.3024-26.5088-1.92213333-62.88 29.8848-81.2416 24.368-14.0736 52.48853333-13.49013333 71.18826667-0.53013333V489.48266667l-0.12053333-0.0544 0.12053333-0.2784V442.35733333c0-5.64266667 4.57066667-10.30613333 10.208-10.31146666a10.18026667 10.18026667 0 0 1 9.16266667 5.86026666c16.0512 13.97013333 31.22346667 19.11466667 48.1472 25.62453334 13.45173333 5.19466667 25.44 13.16693333 32.98666666 24.08533333 7.73333333 10.6656 11.0208 24.26346667 11.328 34.9568l-0.0448-0.07573333z",
  fill: "#2C2C2C",
  "p-id": "28366"
}, null), S("path", {
  d: "M833.74933333 293.94026667L656.82346667 119.28533333l0.28373333 174.65386667z",
  fill: "#2C2C2C",
  "p-id": "28367"
}, null)]), yw = S("svg", {
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "30241",
  width: "1em",
  height: "1em"
}, [S("path", {
  d: "M838.85646561 290.47900106L659.12225186 113.05176719l0.28823703 177.42615027z",
  fill: "#2C2C2C",
  "p-id": "30242"
}, null), S("path", {
  d: "M624.71368465 324.35985608l0.02167197-228.00091428H171.34608254V927.63564021h681.37501799V324.35985608H624.71368465z m13.17655027 250.27210159c-0.75418413 2.25821799-3.01240211 3.76658624-5.27062011 5.27603809L437.46255238 699.71166138c-7.53425608 5.2771217-18.08633227 3.01240211-23.35695238-5.27062011a20.12783068 20.12783068 0 0 1-2.25821799-9.04370794V446.53985186c0-9.79897566 7.53425608-17.33323175 17.33214815-17.33323175 3.01240211 0 6.02480424 0.75526773 9.04262433 2.26471957l194.4082963 119.8090836c7.51800211 4.51535238 10.53040424 15.06201059 5.25978413 23.35153439z",
  fill: "#2C2C2C",
  "p-id": "30243"
}, null)]), bw = S("svg", {
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "31313",
  width: "1em",
  height: "1em"
}, [S("path", {
  d: "M112 16h736v992H112z",
  fill: "#EDF2F9",
  "p-id": "31314"
}, null), S("path", {
  d: "M480 576a128 128 0 1 0 0 256 128 128 0 0 0 0-256z m0 192a64 64 0 1 1 0-128 64 64 0 0 1 0 128z",
  fill: "#C2CDDC",
  "p-id": "31315"
}, null), S("path", {
  d: "M480 784c44.192 0 80-35.808 80-80s-35.808-80-80-80-80 35.808-80 80 35.808 80 80 80z m0-128a48 48 0 1 1 0 96 48 48 0 0 1 0-96z m-176 80h36.016a144.208 144.208 0 0 0 18.576 44.16l-25.664 25.664a15.984 15.984 0 0 0 0 22.624l22.624 22.624a15.984 15.984 0 0 0 22.624 0l25.536-25.536a141.92 141.92 0 0 0 44.304 18.768V880a16 16 0 0 0 16 16h32a16 16 0 0 0 16-16v-35.68a141.92 141.92 0 0 0 44.304-18.768l25.536 25.536a15.984 15.984 0 0 0 22.624 0l22.624-22.624a15.984 15.984 0 0 0 0-22.624l-25.664-25.664a143.824 143.824 0 0 0 18.576-44.16H656a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16h-36.016a144.208 144.208 0 0 0-18.576-44.16l25.664-25.664a15.984 15.984 0 0 0 0-22.624l-22.624-22.624a15.984 15.984 0 0 0-22.624 0l-25.536 25.536a142.288 142.288 0 0 0-44.304-18.768V528a16 16 0 0 0-16-16h-32a16 16 0 0 0-16 16v35.68a142.288 142.288 0 0 0-44.304 18.768l-25.536-25.536a15.984 15.984 0 0 0-22.624 0l-22.624 22.624a15.984 15.984 0 0 0 0 22.624l25.664 25.664a143.824 143.824 0 0 0-18.576 44.16H304a16 16 0 0 0-16 16v32A16 16 0 0 0 304 736z m176-144a112 112 0 1 1 0 224 112 112 0 0 1 0-224zM896 128h-32V32a32 32 0 0 0-32-32H128a32 32 0 0 0-32 32v960a32 32 0 0 0 32 32h704a32 32 0 0 0 32-32V416h32a32 32 0 0 0 32-32V160a32 32 0 0 0-32-32z m-64 0H448a32 32 0 0 0-32 32v224a32 32 0 0 0 32 32h384v576H128V32h704v96z",
  fill: "#8592A5",
  "p-id": "31316"
}, null), S("path", {
  d: "M603.952 214.112v20.8h-47.824v27.2h36.624v20h-36.624v27.76h47.824v20.8h-75.04v-116.56h75.04zM648.032 270.752l-36.08-56.64h27.04a8.48 8.48 0 0 1 3.872 0.688 5.824 5.824 0 0 1 2.192 2.288l23.216 39.28a13.376 13.376 0 0 1 0.912-2c0.336-0.64 0.736-1.312 1.152-2l20.336-34.896c1.328-2.24 3.136-3.36 5.44-3.36h25.92l-36.56 55.44 37.376 61.12h-27.056a6.688 6.688 0 0 1-4.272-1.28 10.016 10.016 0 0 1-2.608-3.024l-23.344-40.816a15.84 15.84 0 0 1-1.456 3.04l-21.76 37.76a11.008 11.008 0 0 1-2.56 3.008 6.016 6.016 0 0 1-4 1.312h-25.264l37.504-59.92zM808.288 214.112v20.8h-47.84v27.2h36.624v20h-36.624v27.76h47.84v20.8h-75.04v-116.56h75.04z",
  fill: "#FFFFFF",
  "p-id": "31317"
}, null)]), vw = S("svg", {
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "21634",
  width: "1em",
  height: "1em"
}, [S("path", {
  d: "M640 42.688H170.688A42.688 42.688 0 0 0 128 85.376v853.312c0 23.616 19.072 42.688 42.688 42.688h682.688a42.688 42.688 0 0 0 42.752-42.688v-640c-100.16-99.968-156.16-156.096-256.128-256zM499.2 853.312a42.688 42.688 0 1 1 0-85.376 42.688 42.688 0 0 1 0 85.376z m88-239.36c-26.496 13.568-42.688 23.936-48.384 31.168-9.6 11.072-18.304 27.2-18.24 37.568q0.128 10.88 0 42.688h-51.2v-42.688c0-36.16 8.704-48.512 17.408-62.912 7.68-11.072 19.008-21.504 33.984-31.104 33.856-19.264 54.208-31.744 61.504-37.568 22.208-18.816 33.28-41.92 33.28-69.376 0-38.656-17.344-65.6-52.032-81.024a125.632 125.632 0 0 0-51.328-10.112c-49.216 0-83.392 22.72-102.72 68.032l-9.344 28.16c-1.024 3.904-1.728 8.192-2.24 12.992l-56.384-12.288c11.072-69.376 45.12-115.008 102.016-136.704a194.56 194.56 0 0 1 72.96-12.992c54.016 0 96.896 16.384 128.704 49.216l15.232 18.112c13.952 21.696 21.504 46.976 22.4 75.904-0.128 54.848-32 99.2-95.616 132.992zM640 298.752V128l170.688 170.688H640z",
  fill: "#515151",
  "p-id": "21635"
}, null)]);
function tf(s) {
  switch (s) {
    case "text/csv":
    case "text/plain":
      return dw;
    case "application/pdf":
      return uw;
    case "application/msword":
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
      return pw;
    case "image/jpeg":
    case "image/png":
    case "image/gif":
      return mw;
    case "audio/mpeg":
    case "audio/wav":
    case "audio/ogg":
      return ww;
    case "video/mp4":
    case "video/x-msvideo":
    case "video/x-matroska":
      return yw;
    case "application/zip":
    case "application/x-rar-compressed":
      return gw;
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
    case "application/vnd.ms-excel":
      return fw;
    case "application/x-msdownload":
    case "application/x-apple-diskimage":
      return bw;
    default:
      return vw;
  }
}
const nf = /* @__PURE__ */ ye({
  name: "UploadCustom",
  props: {
    modal: {
      type: Object,
      required: !0
    },
    context: {
      type: Object,
      default: () => {
      }
    },
    viewParams: {
      type: Object,
      default: () => {
      }
    },
    actionParams: {
      type: Object,
      default: () => {
      }
    },
    accept: {
      type: String,
      default: ""
    }
  },
  setup(s) {
    const e = me("upload-custom"), {
      uploadUrl: t,
      headers: n,
      files: i,
      limit: r,
      uploadRef: o,
      getUploadMessage: a,
      onError: l,
      onRemove: c,
      onItemRemove: u,
      onSuccess: d,
      beforeUpload: f,
      onConfirm: g,
      onCancel: p
    } = hw({
      ...s,
      multiple: !0
    });
    return {
      ns: e,
      files: i,
      limit: r,
      uploadUrl: t,
      headers: n,
      uploadRef: o,
      getUploadMessage: a,
      onError: l,
      onRemove: c,
      onItemRemove: u,
      onSuccess: d,
      beforeUpload: f,
      onConfirm: g,
      onCancel: p
    };
  },
  render() {
    return S("div", {
      class: [this.ns.b()]
    }, [S("div", {
      class: [this.ns.e("center")]
    }, [S(Ee("el-upload"), {
      class: [this.ns.em("center", "upload")],
      ref: "uploadRef",
      modelValue: this.files,
      "onUpdate:modelValue": (s) => this.files = s,
      action: this.uploadUrl,
      headers: this.headers,
      limit: this.limit,
      multiple: !0,
      accept: this.accept,
      drag: !0,
      "auto-upload": !0,
      "before-upload": this.beforeUpload,
      onSuccess: this.onSuccess,
      onError: this.onError,
      onRemove: this.onRemove
    }, {
      default: () => S("div", {
        class: this.ns.e("message")
      }, [S("span", {
        class: this.ns.em("message", "icon")
      }, [S("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024",
        width: "1em",
        height: "1em"
      }, [S("path", {
        fill: "currentColor",
        d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
      }, null)])]), S("span", {
        class: this.ns.em("message", "caption")
      }, [this.getUploadMessage(this.accept)])]),
      file: ({
        file: s
      }) => {
        var e, t, n;
        return [S("div", {
          class: "el-upload-list__item-info"
        }, [S("a", {
          class: "el-upload-list__item-name"
        }, [S("i", {
          class: "el-icon el-icon--document"
        }, [tf(((e = s.raw) == null ? void 0 : e.type) || "")]), S("span", {
          class: "el-upload-list__item-file-name",
          title: (t = s.raw) == null ? void 0 : t.name
        }, [(n = s.raw) == null ? void 0 : n.name])]), s.status === "uploading" && S(Ee("el-progress"), {
          type: "line",
          "stroke-width": "2",
          percentage: Number(s.percentage),
          style: "margin-top: 0.5rem"
        }, null), S("label", {
          class: "el-upload-list__item-status-label"
        }, [S("i", {
          class: "el-icon el-icon--upload-success el-icon--circle-check"
        }, [S("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [S("path", {
          fill: "currentColor",
          d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
        }, null), S("path", {
          fill: "currentColor",
          d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
        }, null)])])]), S("i", {
          class: "el-icon el-icon--close",
          onClick: () => this.onItemRemove(s)
        }, [S("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [S("path", {
          fill: "currentColor",
          d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
        }, null)])])])];
      }
    })]), S("div", {
      class: [this.ns.e("bottom")]
    }, [S(Ee("el-button"), {
      onClick: this.onCancel
    }, {
      default: () => [at("取消")]
    }), S(Ee("el-button"), {
      onClick: this.onConfirm
    }, {
      default: () => [at("确认")]
    })])]);
  }
}), xw = /* @__PURE__ */ ye({
  name: "IBizHtmlInsertSelect",
  props: {
    modal: {
      type: Object,
      required: !0
    },
    context: {
      type: Object,
      default: () => {
      }
    },
    viewParams: {
      type: Object,
      default: () => {
      }
    },
    actionParams: {
      type: Object,
      default: () => {
      }
    }
  },
  emits: ["select"],
  setup(s) {
    const e = me("html-insert-select"), t = L(""), n = L([]), i = L({}), r = L([]), o = L({}), a = (f) => {
      Object.assign(i.value, {
        frequently: []
      }), f.filter((g) => !r.value.includes(g)).forEach((g) => {
        const p = g.category;
        i.value[p] || Object.assign(i.value, {
          [p]: []
        }), i.value[p].push(g);
      });
    }, l = (f) => {
      f.forEach((g) => {
        Object.assign(o.value, {
          [g.type]: g
        });
      });
    }, c = async (f) => {
      const g = f.type === "audio" ? "audio/*" : "", p = {
        ok: !0,
        data: []
      }, m = await ibiz.overlay.modal((w) => cs(nf, {
        modal: w,
        context: s.context,
        viewParams: s.viewParams,
        actionParams: s.actionParams,
        accept: g
      }), void 0, {
        width: "auto",
        height: "auto"
      });
      m.ok && m.data && m.data.length > 0 && m.data.forEach((w) => {
        var v;
        (v = p.data) == null || v.push({
          type: f.type,
          value: w,
          params: {
            isAdd: !0
          }
        });
      }), s.modal.dismiss(p);
    }, u = (f) => {
      const g = {
        ok: !0,
        data: [{
          type: f.type,
          value: f.value,
          params: {
            isAdd: !0
          }
        }]
      };
      s.modal.dismiss(g);
    }, d = async (f) => {
      switch (f.type) {
        case "audio":
        case "files":
          await c(f);
          break;
        default:
          u(f);
          break;
      }
    };
    return fn(() => {
      i.value = {}, a(ef()), n.value = aw(), l(n.value);
    }), {
      ns: e,
      mapInsertItems: i,
      mapCategories: o,
      searchVal: t,
      onSelectItem: d
    };
  },
  render() {
    const s = S("div", {
      class: [this.ns.b("search")]
    }, [S("div", {
      class: this.ns.be("search", "container")
    }, [S("div", {
      class: this.ns.bem("search", "container", "search")
    }, [S("svg", {
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      height: "1em",
      width: "1em",
      focusable: "false"
    }, [S("g", {
      "stroke-width": "1"
    }, [S("path", {
      d: "M6.751 12.303A5.557 5.557 0 0 1 1.2 6.751C1.2 3.691 3.69 1.2 6.751 1.2a5.558 5.558 0 0 1 5.551 5.551 5.557 5.557 0 0 1-5.551 5.552M6.751 0a6.751 6.751 0 1 0 4.309 11.949l3.855 3.855a.6.6 0 1 0 .849-.849l-3.854-3.853A6.751 6.751 0 0 0 6.751 0"
    }, null)])])]), gi(S("input", {
      class: this.ns.bem("search", "container", "input"),
      type: "text",
      "onUpdate:modelValue": (e) => this.searchVal = e,
      placeholder: ibiz.i18n.t("app.search")
    }, null), [[Pl, this.searchVal]])])]);
    return S("div", {
      class: this.ns.b()
    }, [s, S(cw, {
      data: this.mapInsertItems,
      filter: this.searchVal,
      categories: this.mapCategories,
      onSelect: this.onSelectItem
    }, null)]);
  }
});
/*! Element Plus v2.4.2 */
var Cw = {
  name: "zh-cn",
  el: {
    colorpicker: {
      confirm: "确定",
      clear: "清空"
    },
    datepicker: {
      now: "此刻",
      today: "今天",
      cancel: "取消",
      clear: "清空",
      confirm: "确定",
      selectDate: "选择日期",
      selectTime: "选择时间",
      startDate: "开始日期",
      startTime: "开始时间",
      endDate: "结束日期",
      endTime: "结束时间",
      prevYear: "前一年",
      nextYear: "后一年",
      prevMonth: "上个月",
      nextMonth: "下个月",
      year: "年",
      month1: "1 月",
      month2: "2 月",
      month3: "3 月",
      month4: "4 月",
      month5: "5 月",
      month6: "6 月",
      month7: "7 月",
      month8: "8 月",
      month9: "9 月",
      month10: "10 月",
      month11: "11 月",
      month12: "12 月",
      weeks: {
        sun: "日",
        mon: "一",
        tue: "二",
        wed: "三",
        thu: "四",
        fri: "五",
        sat: "六"
      },
      months: {
        jan: "一月",
        feb: "二月",
        mar: "三月",
        apr: "四月",
        may: "五月",
        jun: "六月",
        jul: "七月",
        aug: "八月",
        sep: "九月",
        oct: "十月",
        nov: "十一月",
        dec: "十二月"
      }
    },
    select: {
      loading: "加载中",
      noMatch: "无匹配数据",
      noData: "无数据",
      placeholder: "请选择"
    },
    cascader: {
      noMatch: "无匹配数据",
      loading: "加载中",
      placeholder: "请选择",
      noData: "暂无数据"
    },
    pagination: {
      goto: "前往",
      pagesize: "条/页",
      total: "共 {total} 条",
      pageClassifier: "页",
      page: "页",
      prev: "上一页",
      next: "下一页",
      currentPage: "第 {pager} 页",
      prevPages: "向前 {pager} 页",
      nextPages: "向后 {pager} 页",
      deprecationWarning: "你使用了一些已被废弃的用法，请参考 el-pagination 的官方文档"
    },
    messagebox: {
      title: "提示",
      confirm: "确定",
      cancel: "取消",
      error: "输入的数据不合法!"
    },
    upload: {
      deleteTip: "按 delete 键可删除",
      delete: "删除",
      preview: "查看图片",
      continue: "继续上传"
    },
    table: {
      emptyText: "暂无数据",
      confirmFilter: "筛选",
      resetFilter: "重置",
      clearFilter: "全部",
      sumText: "合计"
    },
    tree: {
      emptyText: "暂无数据"
    },
    transfer: {
      noMatch: "无匹配数据",
      noData: "无数据",
      titles: ["列表 1", "列表 2"],
      filterPlaceholder: "请输入搜索内容",
      noCheckedFormat: "共 {total} 项",
      hasCheckedFormat: "已选 {checked}/{total} 项"
    },
    image: {
      error: "加载失败"
    },
    pageHeader: {
      title: "返回"
    },
    popconfirm: {
      confirmButtonText: "确定",
      cancelButtonText: "取消"
    }
  }
};
const Vs = (s, e = {}, t = {}) => ibiz.overlay.createPopover(
  (n) => cs(s, { modal: n, ...t }),
  void 0,
  {
    width: "auto",
    height: "auto",
    noArrow: !0,
    autoClose: !0,
    placement: "bottom-start",
    ...e
  }
);
function As() {
  return {
    data: { type: Object, required: !0 },
    change: { type: Function, required: !0 },
    nodeKey: { type: String, default: "" },
    isFocus: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 }
  };
}
const Wo = (s) => {
  (document.getElementsByClassName(s) || []).forEach((t) => {
    t.remove();
  });
};
const Ew = /* @__PURE__ */ ye({
  name: "IBizDateSelect",
  props: As(),
  emits: ["change"],
  setup(s) {
    const e = me("date-select"), t = L(), n = L("");
    return s.data && (n.value = qa(s.data).format("YYYY-MM-DD")), s.isFocus && Be(t, (r) => {
      r && r.focus && r.focus();
    }), {
      ns: e,
      dateVal: n,
      dateRef: t,
      handleChange: (r) => {
        const o = qa(r).format("YYYY-MM-DD");
        n.value = o;
        let a = setTimeout(() => {
          s.change(o), clearTimeout(a), a = null;
        }, 200);
      }
    };
  },
  render() {
    return S("div", {
      class: [this.ns.b(), this.readonly ? this.ns.m("readonly") : ""]
    }, [S(Ee("el-date-picker"), {
      ref: "dateRef",
      "popper-class": [this.ns.e("popover"), "".concat(this.nodeKey)],
      modelValue: this.dateVal,
      "onUpdate:modelValue": (s) => this.dateVal = s,
      onChange: this.handleChange
    }, null)]);
  }
});
const Sw = /* @__PURE__ */ ye({
  name: "IBizLabelSelect",
  props: As(),
  setup(s) {
    const e = me("label-select"), t = (p) => p.replace(")", ",0.196)"), n = ["rgba(207, 207, 207)", "rgb(255, 117, 117)", "rgb(246, 198, 89)", "rgb(115, 216, 151)", "rgb(210, 135, 248)", "rgb(86, 171, 251)"], i = L(), r = L(), o = L(), a = lu({
      color: n[0],
      bgColor: t(n[0]),
      labelName: ""
    }), l = L("");
    s != null && s.data && (Object.assign(a, s == null ? void 0 : s.data), l.value = s == null ? void 0 : s.data.labelName), s.isFocus && Be(o, (p) => {
      p && p.click && p.click();
    });
    const c = () => {
      let p;
      l.value && (p = {
        color: a.color,
        bgColor: a.bgColor,
        labelName: l.value
      }), s.change(p, {
        isDelete: !l.value
      });
    };
    return {
      ns: e,
      curData: a,
      inputVal: l,
      inputRef: i,
      popoverRef: r,
      labelConfig: n,
      referenceRef: o,
      onInput: () => {
        a.labelName = l.value;
      },
      handleColorItemClick: (p) => {
        a.color = p, a.bgColor = t(p);
      },
      handleAfterEnter: () => {
        s.isFocus && i.value && i.value.focus();
      },
      handleAfterLeave: async () => {
        c();
      },
      calcAlpha: t
    };
  },
  render() {
    const s = S("div", {
      ref: "referenceRef",
      class: this.ns.e("reference"),
      style: {
        backgroundColor: "".concat(this.curData.bgColor),
        color: this.curData.color === this.labelConfig[0] ? "" : this.curData.color
      }
    }, [this.curData.labelName || "设置标签"]), e = S(Ee("el-popover"), {
      trigger: "click",
      ref: "popoverRef",
      width: "200px",
      "hide-after": 0,
      "popper-class": [this.ns.e("popover"), "".concat(this.nodeKey)],
      onAfterEnter: this.handleAfterEnter,
      onAfterLeave: this.handleAfterLeave
    }, {
      default: () => S("div", {
        class: this.ns.em("popover", "content")
      }, [gi(S("input", {
        ref: "inputRef",
        class: this.ns.em("popover", "input"),
        type: "text",
        "onUpdate:modelValue": (t) => this.inputVal = t,
        onInput: () => this.onInput(),
        placeholder: "输入标签名称"
      }, null), [[Pl, this.inputVal]]), S("div", {
        class: this.ns.em("popover", "color-box")
      }, [this.labelConfig.map((t, n) => S("div", {
        class: this.ns.em("popover", "color-item"),
        style: "background-color: ".concat(n === 0 ? this.calcAlpha(t) : t),
        onClick: () => this.handleColorItemClick(t)
      }, [t === this.curData.color ? S("svg", {
        viewBox: "0 0 16 16",
        xmlns: "http://www.w3.org/2000/svg",
        height: "1em",
        width: "1em"
      }, [S("g", {
        "stroke-width": "1",
        "fill-rule": "evenodd"
      }, [S("path", {
        d: "M13.993 3l1.364 1.364-9.311 9.31-.01-.01-.008.01L0 7.645l1.362-1.363 4.674 4.673L13.993 3z"
      }, null)])]) : ""]))])]),
      reference: () => s
    });
    return S("div", {
      class: [this.ns.b(), this.readonly ? this.ns.m("readonly") : ""]
    }, [this.readonly ? s : e]);
  }
});
const Aw = [
  "rgb(0, 0, 0)",
  "rgb(38, 38, 38)",
  "rgb(89, 89, 89)",
  "rgb(140, 140, 140)",
  "rgb(191, 191, 191)",
  "rgb(217, 217, 217)",
  "rgb(233, 233, 233)",
  "rgb(245, 245, 245)",
  "rgb(250, 250, 250)",
  "rgb(255, 255, 255)",
  // 10
  "rgb(225, 60, 57)",
  "rgb(231, 95, 51)",
  "rgb(235, 144, 58)",
  "rgb(245, 219, 77)",
  "rgb(114, 192, 64)",
  "rgb(89, 191, 192)",
  "rgb(66, 144, 247)",
  "rgb(54, 88, 226)",
  "rgb(106, 57, 201)",
  "rgb(216, 68, 147)",
  // 10
  "rgb(251, 233, 230)",
  "rgb(252, 237, 225)",
  "rgb(252, 239, 212)",
  "rgb(252, 251, 207)",
  "rgb(231, 246, 213)",
  "rgb(218, 244, 240)",
  "rgb(217, 237, 250)",
  "rgb(224, 232, 250)",
  "rgb(237, 225, 248)",
  "rgb(246, 226, 234)",
  // 10
  "rgb(255, 163, 158)",
  "rgb(255, 187, 150)",
  "rgb(255, 213, 145)",
  "rgb(255, 251, 143)",
  "rgb(183, 235, 143)",
  "rgb(135, 232, 222)",
  "rgb(145, 213, 255)",
  "rgb(173, 198, 255)",
  "rgb(211, 173, 247)",
  "rgb(255, 173, 210)",
  // 10
  "rgb(255, 77, 79)",
  "rgb(255, 122, 69)",
  "rgb(255, 169, 64)",
  "rgb(255, 236, 61)",
  "rgb(115, 209, 61)",
  "rgb(54, 207, 201)",
  "rgb(64, 169, 255)",
  "rgb(89, 126, 247)",
  "rgb(146, 84, 222)",
  "rgb(247, 89, 171)",
  // 10
  "rgb(207, 19, 34)",
  "rgb(212, 56, 13)",
  "rgb(212, 107, 8)",
  "rgb(212, 177, 6)",
  "rgb(56, 158, 13)",
  "rgb(8, 151, 156)",
  "rgb(9, 109, 217)",
  "rgb(29, 57, 196)",
  "rgb(83, 29, 171)",
  "rgb(196, 29, 127)",
  // 10
  "rgb(130, 0, 20)",
  "rgb(135, 20, 0)",
  "rgb(135, 56, 0)",
  "rgb(97, 71, 0)",
  "rgb(19, 82, 0)",
  "rgb(0, 71, 79)",
  "rgb(0, 58, 140)",
  "rgb(6, 17, 120)",
  "rgb(34, 7, 94)",
  "rgb(120, 6, 80)"
  // 10
], Mw = [
  {
    type: "success",
    text: "成功",
    color: "rgb(103,194,58,0.2)",
    icon: "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em' style='fill:rgb(103,194,58)'> <g stroke-width='1' fill-rule='evenodd'> <path d='M0 8c0-4.4 3.6-8 8-8s8 3.6 8 8-3.6 8-8 8-8-3.6-8-8zm7.097.758L5.199 6.905l-.978 1.001 2.9 2.833 4.563-4.685-1.003-.977-3.584 3.68z'></path> </g></svg>"
  },
  {
    type: "danger",
    text: "危险",
    color: "rgb(245,108,108,0.2)",
    icon: "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em' style='fill:rgb(245,108,108)'> <g stroke-width='1' fill-rule='evenodd'> <path d='M0 8c0-4.4 3.6-8 8-8s8 3.6 8 8-3.6 8-8 8-8-3.6-8-8zm9.005.021l1.777-1.793-.994-.986-1.769 1.784L6.28 5.27l-.995.985 1.75 1.767-1.766 1.782.995.985 1.756-1.772 1.702 1.718.995-.985L9.005 8.02z'></path> </g></svg>"
  },
  {
    type: "warning",
    text: "警告",
    color: "rgb(230,162,60,0.2)",
    icon: "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em' style='fill:rgb(230,162,60)'> <g stroke-width='1' fill-rule='evenodd'> <path d='M9.718 2.496l5.588 9.387a2 2 0 0 1-1.718 3.023H2.412a2 2 0 0 1-1.718-3.023L6.28 2.496a2 2 0 0 1 3.437 0zm-2.447 9.496v1.457h1.457v-1.457H7.271zm-.363-5.84l.363 4.384h1.457l.376-4.385H6.908z'></path> </g></svg>"
  },
  {
    type: "prompt",
    text: "提示",
    color: "rgb(64,158,255,0.2)",
    icon: "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em' style='fill:rgb(64,158,255)'> <g stroke-width='1' fill-rule='evenodd'> <path d='M0 8c0-4.4 3.6-8 8-8s8 3.6 8 8-3.6 8-8 8-8-3.6-8-8zm7.332-1.005l-.03 5.031 1.4.007L8.732 7l-1.4-.006zm0-3.052l-.03 1.732 1.4.006.03-1.731-1.4-.007z'></path> </g></svg>"
  },
  {
    type: "add-emoji",
    text: "添加表情",
    icon: "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em'> <g stroke-width='1' fill-rule='evenodd'> <path d='M14.727 7h1.211A8 8 0 1 1 11.206.668L10.795 1.8A6.8 6.8 0 1 0 14.727 7zm-.226-1h1.247-1.247zM5 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm6.97 1.5a4 4 0 0 1-7.94 0h1.215a2.8 2.8 0 0 0 5.51 0h1.214zM11 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm2.264-5.177V1.459h1.2v1.364h1.364v1.2h-1.364v1.363h-1.2V4.023H11.9v-1.2h1.364z'></path> </g></svg>"
  },
  {
    type: "delete-emoji",
    text: "删除表情",
    icon: "<svg viewBox='0 0 16 16' version='1.1' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em'> <g stroke-width='1' fill-rule='evenodd'> <path d='M1.90326777,1.07326956 L14.9701984,14.1861127 C15.2041017,14.4208379 15.2034355,14.8007363 14.9687103,15.0346396 C14.7339852,15.2685429 14.3540868,15.2678766 14.1201835,15.0331515 L1.05325285,1.9203083 C0.819349557,1.68558316 0.8200158,1.30568475 1.05474094,1.07178147 C1.28946608,0.837878178 1.66936449,0.838544422 1.90326777,1.07326956 Z M1.78392959,4.77808157 L2.68262793,5.6799605 C2.37220548,6.39042724 2.2,7.17510325 2.2,8 C2.2,11.2032515 4.79674845,13.8 8,13.8 C8.81790048,13.8 9.59625958,13.6307032 10.3019463,13.3252407 L11.199833,14.2274912 C10.2408005,14.7212594 9.15295194,15 8,15 C4.13400675,15 1,11.8659932 1,8 C1,6.83818849 1.28304083,5.7424847 1.78392959,4.77808157 Z M8,1 C11.8659932,1 15,4.13400675 15,8 C15,9.18355772 14.7062644,10.2985098 14.1877157,11.2759337 L13.2919736,10.3773191 C13.6183874,9.65183814 13.8,8.84712801 13.8,8 C13.8,4.79674845 11.2032515,2.2 8,2.2 C7.15989239,2.2 6.36150251,2.37861488 5.640734,2.69994102 L4.7450393,1.80120321 C5.71742699,1.28955298 6.82489914,1 8,1 Z'></path> </g></svg>"
  },
  {
    type: "separator",
    text: "|"
  },
  {
    type: "background-color",
    text: "背景色",
    icon: "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em'> <g stroke-width='1' fill-rule='evenodd'> <path d='M3.58 8.165l2.092 1.209L3.86 12.51l4.9.01.592-1.021 1.39.803 4.138-7.165L7.717 1 3.58 8.165zm1.639-.44L8.156 2.64l5.085 2.936-2.935 5.087-5.087-2.937z'></path> <path d='M1 15.064h11.997v-1.201H1z'></path> </g></svg>"
  },
  {
    type: "separator",
    text: "|"
  },
  {
    type: "delete",
    text: "删除",
    icon: "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em'> <g stroke-width='1' fill-rule='evenodd'> <path d='M4.002 3.403V1a1 1 0 0 1 1-1h6.003a1 1 0 0 1 1 1v2.403h3.396a.6.6 0 1 1 0 1.2h-1.395V15a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4.603H.6a.6.6 0 1 1 0-1.2h3.4zm8.804 1.205H3.2V14.8h9.605V4.608zM5.202 1.2v2.155h5.603V1.2H5.202zm.6 6.417a.6.6 0 0 1 1.201 0v4.758a.6.6 0 0 1-1.2 0V7.617zm3.202 0a.6.6 0 0 1 1.2 0v4.758a.6.6 0 0 1-1.2 0V7.617z'></path> </g></svg>"
  }
];
function kw() {
  return Aw;
}
function Pw() {
  return Mw;
}
const _w = /* @__PURE__ */ ye({
  name: "IBizPromptBoxSelect",
  props: As(),
  emits: ["change"],
  setup(s) {
    const e = me("prompt-box-select"), t = L(""), n = L(""), i = L(""), r = L(null), o = L(null), a = L(null), l = L(), c = L(), u = L([]), d = L([]);
    if (u.value = kw(), d.value = Pw(), t.value = d.value[0].color, n.value = d.value[0].icon, s.data) {
      const {
        color: P,
        icon: D,
        text: N
      } = s.data;
      t.value = P, n.value = Ha(D), i.value = N;
    }
    let f = new ResizeObserver(() => {
      var P;
      c.value && c.value.offsetWidth !== 0 && ((P = c.value) == null || P.click(), f = null);
    });
    s.isFocus && (Be(c, (P) => {
      P && P.click && f.observe(P);
    }), Be(l, (P) => {
      P && P.focus && P.focus();
    }));
    const g = () => {
      const P = {
        color: t.value,
        icon: ro(n.value),
        text: i.value
      };
      s.change(P);
    }, p = (P) => {
      var N;
      const D = {
        ok: !0,
        data: [{
          emoji: ro(P.data)
        }]
      };
      (N = o.value) == null || N.dismiss(D);
    }, m = (P) => {
      var D;
      (D = a.value) == null || D.dismiss({
        ok: !0,
        data: [P]
      });
    }, w = (P) => {
      var D;
      P.color && (t.value = P.color, n.value = P.icon), (D = l.value) == null || D.focus();
    }, v = (P) => S("div", {
      class: e.be("background-popover", "content")
    }, [S("ul", {
      class: e.be("background-popover", "list")
    }, [S("li", {
      class: e.be("background-popover", "list-item-clear"),
      onClick: () => m("")
    }, [S("svg", {
      viewBox: "0 0 1024 1024",
      width: "1em",
      height: "1em"
    }, [S("path", {
      d: "M236.8 128L896 787.2V128H236.8z m614.4 704L192 172.8V832h659.2zM192 64h704c38.4 0 64 25.6 64 64v704c0 38.4-25.6 64-64 64H192c-38.4 0-64-25.6-64-64V128c0-38.4 25.6-64 64-64z"
    }, null)]), at("清除背景色")]), P.map((D) => S("li", {
      class: e.be("background-popover", "list-item"),
      onClick: () => m(D)
    }, [S("div", {
      class: e.bem("background-popover", "list-item", "color-block"),
      style: {
        backgroundColor: D
      }
    }, null)]))])]), y = async (P) => {
      var F, ee;
      o.value || (o.value = Vs(ow, {}, {
        dark: !0,
        continuousList: !0,
        onSelect: p
      })), await o.value.present(P.target);
      const D = await o.value.onWillDismiss(), N = (F = D.data) == null ? void 0 : F[0];
      D.ok && N && (n.value = "".concat(Ha(N.emoji))), o.value = null, (ee = l.value) == null || ee.focus();
    }, b = async (P) => {
      var F, ee;
      a.value || (a.value = Vs(v(u.value))), await a.value.present(P.target);
      const D = await a.value.onWillDismiss(), N = (F = D.data) == null ? void 0 : F[0];
      D.ok && (t.value = "".concat(N)), a.value = null, (ee = l.value) == null || ee.focus();
    }, x = async () => {
      var P, D, N;
      await ((P = r.value) == null ? void 0 : P.dismiss()), await ((D = o.value) == null ? void 0 : D.dismiss()), await ((N = a.value) == null ? void 0 : N.dismiss()), s.change("", {
        isDelete: !0
      });
    }, C = () => {
      n.value = "";
    }, A = (P, D) => {
      var N;
      if (P.type !== "separator")
        switch ((N = l.value) == null || N.focus(), P.type) {
          case "add-emoji":
            y(D);
            break;
          case "background-color":
            b(D);
            break;
          case "delete":
            x();
            break;
          case "delete-emoji":
            C();
            break;
          default:
            w(P);
            break;
        }
    }, k = () => S("div", {
      class: e.be("popover", "content")
    }, [d.value.map((P) => S("div", {
      class: [e.be("popover", "tool-item"), e.be("popover", "tool-item-".concat(P.type)), e.is("activated", n.value === P.icon)],
      title: P.text,
      onClick: (D) => A(P, D)
    }, [S("div", {
      class: e.bem("popover", "tool-item", "content"),
      innerHTML: P.icon || P.text
    }, null)]))]);
    return {
      ns: e,
      curColor: t,
      curIcon: n,
      curText: i,
      inputRef: l,
      referenceRef: c,
      toolBars: d,
      handleToolItemClick: A,
      onOpenTopPopover: async () => {
        var P;
        (P = l.value) == null || P.focus(), r.value = Vs(k(), {
          placement: "top-start"
        }), await r.value.present(c.value), await r.value.onWillDismiss(), g(), r.value = null;
      }
    };
  },
  render() {
    return S("div", {
      class: [this.ns.b(), this.readonly ? this.ns.m("readonly") : ""]
    }, [S("div", {
      ref: "referenceRef",
      class: this.ns.e("reference"),
      style: {
        backgroundColor: this.curColor
      },
      onClick: this.onOpenTopPopover
    }, [this.curIcon ? S("div", {
      class: [this.ns.em("reference", "icon")],
      innerHTML: this.curIcon
    }, null) : "", S(Ee("el-input"), {
      ref: "inputRef",
      modelValue: this.curText,
      "onUpdate:modelValue": (s) => this.curText = s,
      type: "text",
      autofocus: !0
    }, null)])]);
  }
});
const Ow = new cu(import.meta.url);
class Jo {
  /**
   * @description 获取Luckysheet对象
   * @static
   * @return {*}  {*}
   * @memberof MathJax
   */
  static getMathJax() {
    return window.MathJax;
  }
  /**
   * 动态加载脚本
   *
   * @static
   * @return {*}
   * @memberof MathJax
   */
  static loadScript(e) {
    return new Promise((t, n) => {
      const i = document.createElement("script");
      i.src = e, i.onload = t, i.onerror = n, document.head.appendChild(i);
    });
  }
  /**
   * 配置全局 MathJax
   * @param {FnType} callback Mathjax 加载完成的回调
   */
  static initMathJax(e) {
    window.MathJax = {
      tex: {
        inlineMath: [["$", "$"]],
        processEnvironments: !0,
        processRefs: !0
      },
      options: {
        skipHtmlTags: ["noscript", "style", "textarea", "pre", "code"],
        ignoreHtmlClass: "tex2jax_ignore"
      },
      startup: {
        pageReady: () => e && e()
      },
      svg: {
        fontCache: "global"
      }
    };
  }
  /**
   * 手动渲染公式
   * @param {HTMLElement} el 需要触发渲染的节点
   * @returns Promise
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static renderFormula(e) {
    return !window.MathJax || !window.MathJax.typesetPromise ? Promise.reject() : (e && !Array.isArray(e) && (e = [e]), window.MathJax.typesetPromise(e));
  }
  /**
   * 加载MathJax
   *
   * @static
   * @return {*}
   * @memberof MathJax
   */
  static loadMathJax() {
    return new Promise((e, t) => {
      if (this.getMathJax())
        e();
      else {
        this.initMathJax();
        const i = [
          this.loadScript(
            // 插件中使用 resource.dir
            Ow.dir("assets/mathjax/plugins/js/tex-svg.js")
            // 模板中使用
            // '/assets/mathjax/plugins/js/tex-svg.js',
          )
        ];
        Promise.all(i).then(() => {
          e();
        }).catch(() => {
          ibiz.message.error(
            "加载mathJax静态资源失败,请确认静态资源是否存在！"
          ), t();
        });
      }
    });
  }
}
function Tw() {
}
const mo = '<p data-we-empty-p=""><br></p>', sf = "#ee7959", Lw = [
  "Control",
  "Escape",
  "Tab",
  "CapsLock",
  "Shift",
  "Meta",
  "Alt",
  "ArrowLeft",
  "ArrowUp",
  "ArrowDown",
  "ArrowRight",
  "Enter",
  "Backspace",
  "Delete",
  "Insert",
  "c",
  "v",
  "z"
], Nw = [" ", "{", "}"];
function Dw(s, e = 200) {
  let t = 0;
  return function(...n) {
    t && window.clearTimeout(t), t = window.setTimeout(() => {
      t = 0, s.call(this, ...n);
    }, e);
  };
}
function sc(s) {
  return Array.prototype.slice.call(s);
}
function Iw(s) {
  return '<span style="color: '.concat(sf, '">').concat(s !== " " ? s : "&nbsp;", "</span>");
}
function rf(s) {
  const e = /[A-Za-z0-9]+/g;
  return s = s.replace(
    e,
    (t) => '<span style="color: '.concat(sf, '">').concat(t, "</span>")
  ), "<span>".concat(s, "</span>&nbsp;");
}
function Vn(s) {
  return '<div class="me-menu-item"><span class="icon">$'.concat(s, "$</span></div>");
}
class jw {
  constructor() {
    E(this, "_ua");
    // 是否为旧版 Edge
    E(this, "isOldEdge");
    // 是否为 Firefox
    E(this, "isFirefox");
    this._ua = navigator.userAgent;
    const e = this._ua.match(/(Edge?)\/(\d+)/);
    this.isOldEdge = !!(e && e[1] === "Edge" && parseInt(e[2]) < 19), this.isFirefox = !!(/Firefox\/\d+/.test(this._ua) && !/Seamonkey\/\d+/.test(this._ua));
  }
  /** 是否为 IE */
  isIE() {
    return "ActiveXObject" in window;
  }
  /** 是否为 webkit */
  isWebkit() {
    return /webkit/i.test(this._ua);
  }
}
const Eh = new jw(), Fr = [];
function Rw(s) {
  const e = document.createElement("div");
  e.innerHTML = s;
  const t = e.children;
  return sc(t);
}
function Bw(s) {
  return s ? s instanceof HTMLCollection || s instanceof NodeList : !1;
}
function Fw(s) {
  const e = document.querySelectorAll(s);
  return sc(e);
}
function Sh(s) {
  let e = [];
  const t = [];
  return Array.isArray(s) ? e = s : e = s.split(";"), e.forEach((n) => {
    const i = n.split(":").map((r) => r.trim());
    i.length === 2 && t.push("".concat(i[0], ":").concat(i[1]));
  }), t;
}
class wo {
  // 通过 getNodeTop 获取顶级段落的时候，可以通过 prior 去回溯来源的子节点
  /**
   * 构造函数
   * @param selector 任一类型的选择器
   */
  constructor(e) {
    // 定义属性
    E(this, "selector");
    E(this, "length");
    E(this, "elems");
    E(this, "dataSource");
    E(this, "prior");
    if (this.elems = [], this.length = this.elems.length, this.dataSource = /* @__PURE__ */ new Map(), !e)
      return;
    if (e instanceof wo)
      return e;
    let t = [];
    const n = e instanceof Node ? e.nodeType : -1;
    if (this.selector = e, n === 1 || n === 9)
      t = [e];
    else if (Bw(e))
      t = sc(e);
    else if (e instanceof Array)
      t = e;
    else if (typeof e == "string") {
      const o = e.replace("/\n/mg", "").trim();
      o.indexOf("<") === 0 ? t = Rw(o) : t = Fw(o);
    }
    const i = t.length;
    if (!i)
      return this;
    let r = 0;
    for (; r < i; r++)
      this.elems.push(t[r]);
    this.length = i;
  }
  /**
   * 获取元素 id
   */
  get id() {
    return this.elems[0].id;
  }
  /**
   * 遍历所有元素，执行回调函数
   * @param fn 回调函数
   */
  forEach(e) {
    for (let t = 0; t < this.length; t++) {
      const n = this.elems[t];
      if (e.call(n, n, t) === !1)
        break;
    }
    return this;
  }
  /**
   * 克隆元素
   * @param deep 是否深度克隆
   */
  clone(e = !1) {
    const t = [];
    return this.elems.forEach((n) => {
      t.push(n.cloneNode(!!e));
    }), Y(t);
  }
  /**
   * 获取第几个元素
   * @param index index
   */
  get(e = 0) {
    const t = this.length;
    return e >= t && (e %= t), Y(this.elems[e]);
  }
  /**
   * 获取第一个元素
   */
  first() {
    return this.get(0);
  }
  /**
   * 获取最后一个元素
   */
  last() {
    const e = this.length;
    return this.get(e - 1);
  }
  on(e, t, n) {
    return e ? (typeof t == "function" && (n = t, t = ""), this.forEach((i) => {
      if (!t) {
        i.addEventListener(e, n);
        return;
      }
      const r = function(o) {
        const a = o.target;
        a.matches(t) && n.call(a, o);
      };
      i.addEventListener(e, r), Fr.push({
        elem: i,
        selector: t,
        fn: n,
        agentFn: r
      });
    })) : this;
  }
  off(e, t, n) {
    return e ? (typeof t == "function" && (n = t, t = ""), this.forEach(function(i) {
      if (t) {
        let r = -1;
        for (let o = 0; o < Fr.length; o++) {
          const a = Fr[o];
          if (a.selector === t && a.fn === n && a.elem === i) {
            r = o;
            break;
          }
        }
        if (r !== -1) {
          const { agentFn: o } = Fr.splice(r, 1)[0];
          i.removeEventListener(e, o);
        }
      } else
        i.removeEventListener(e, n);
    })) : this;
  }
  attr(e, t) {
    return t === void 0 ? this.elems[0].getAttribute(e) || "" : this.forEach(function(n) {
      n.setAttribute(e, t);
    });
  }
  /**
   * 删除 属性
   * @param key key
   */
  removeAttr(e) {
    this.forEach(function(t) {
      t.removeAttribute(e);
    });
  }
  /**
   * 添加 css class
   * @param className css class
   */
  addClass(e) {
    return e ? this.forEach(function(t) {
      if (t.className) {
        let n = t.className.split(/\s/);
        n = n.filter((i) => !!i.trim()), n.indexOf(e) < 0 && n.push(e), t.className = n.join(" ");
      } else
        t.className = e;
    }) : this;
  }
  /**
   * 添加 css class
   * @param className css class
   */
  removeClass(e) {
    return e ? this.forEach(function(t) {
      if (!t.className)
        return;
      let n = t.className.split(/\s/);
      n = n.filter((i) => (i = i.trim(), !(!i || i === e))), t.className = n.join(" ");
    }) : this;
  }
  /**
   * 是否有传入的 css class
   * @param className css class
   */
  hasClass(e) {
    if (!e)
      return !1;
    const t = this.elems[0];
    return t.className ? t.className.split(/\s/).includes(e) : !1;
  }
  /**
   * 修改 css
   * @param key css key
   * @param val css value
   */
  // css(key: string): string
  css(e, t) {
    let n;
    return t === "" ? n = "" : n = "".concat(e, ":").concat(t, ";"), this.forEach((i) => {
      const r = (i.getAttribute("style") || "").trim();
      if (r) {
        let o = Sh(r);
        o = o.map((a) => a.indexOf(e) === 0 ? n : a), n !== "" && o.indexOf(n) < 0 && o.push(n), n === "" && (o = Sh(o)), i.setAttribute("style", o.join("; "));
      } else
        i.setAttribute("style", n);
    });
  }
  /**
   * 封装 getBoundingClientRect
   */
  getBoundingClientRect() {
    return this.elems[0].getBoundingClientRect();
  }
  /**
   * 显示
   */
  show() {
    return this.css("display", "block");
  }
  /**
   * 隐藏
   */
  hide() {
    return this.css("display", "none");
  }
  /**
   * 获取子节点（只有 DOM 元素）
   */
  children() {
    const e = this.elems[0];
    return e ? Y(e.children) : null;
  }
  /**
   * 获取子节点（包括文本节点）
   */
  childNodes() {
    const e = this.elems[0];
    return e ? Y(e.childNodes) : null;
  }
  /**
   * 将子元素全部替换
   * @param $children 新的child节点
   */
  replaceChildAll(e) {
    const t = this.getNode(), n = this.elems[0];
    for (; n.hasChildNodes(); )
      t.firstChild && n.removeChild(t.firstChild);
    this.append(e);
  }
  /**
   * 增加子节点
   * @param $children 子节点
   */
  append(e) {
    return this.forEach((t) => {
      e.forEach(function(n) {
        t.appendChild(n);
      });
    });
  }
  /**
   * 移除当前节点
   */
  remove() {
    return this.forEach((e) => {
      if (e.remove)
        e.remove();
      else {
        const t = e.parentElement;
        t && t.removeChild(e);
      }
    });
  }
  /**
   * 当前元素，是否包含某个子元素
   * @param $child 子元素
   */
  isContain(e) {
    const t = this.elems[0], n = e.elems[0];
    return t.contains(n);
  }
  /**
   * 获取当前元素 nodeName
   */
  getNodeName() {
    return this.elems[0].nodeName;
  }
  /**
   * 根据元素位置获取元素节点（默认获取0位置的节点）
   * @param n 元素节点位置
   */
  getNode(e = 0) {
    return this.elems[e];
  }
  /**
   * 查询
   * @param selector css 选择器
   */
  find(e) {
    const t = this.elems[0];
    return Y(t.querySelectorAll(e));
  }
  text(e) {
    return e === void 0 ? this.elems[0].innerHTML.replace(/<[^>]+>/g, () => "") : this.forEach(function(t) {
      t.innerHTML = e;
    });
  }
  html(e) {
    const t = this.elems[0];
    return e === void 0 ? t.innerHTML : (t.innerHTML = e, this);
  }
  /**
   * 获取元素 value
   */
  val() {
    return this.elems[0].value.trim();
  }
  /**
   * focus 到当前元素
   */
  focus() {
    return this.forEach((e) => {
      e.focus();
    });
  }
  /**
   * 当前元素前一个兄弟节点
   */
  prev() {
    const e = this.elems[0];
    return Y(e.previousElementSibling);
  }
  /**
   * 当前元素后一个兄弟节点
   * 不包括文本节点、注释节点）
   */
  next() {
    const e = this.elems[0];
    return Y(e.nextElementSibling);
  }
  /**
   * 获取当前节点的下一个兄弟节点
   * 包括文本节点、注释节点即回车、换行、空格、文本等等）
   */
  getNextSibling() {
    const e = this.elems[0];
    return Y(e.nextSibling);
  }
  /**
   * 获取父元素
   */
  parent() {
    const e = this.elems[0];
    return Y(e.parentElement);
  }
  /**
   * 查找父元素，直到满足 selector 条件
   * @param selector css 选择器
   * @param curElem 从哪个元素开始查找，默认为当前元素
   */
  parentUntil(e, t) {
    const n = t || this.elems[0];
    if (n.nodeName === "BODY")
      return null;
    const i = n.parentElement;
    return i ? i.matches(e) ? Y(i) : this.parentUntil(e, i) : null;
  }
  /**
   * 判读是否相等
   * @param $elem 元素
   */
  equal(e) {
    return e instanceof wo ? this.elems[0] === e.elems[0] : e instanceof HTMLElement ? this.elems[0] === e : !1;
  }
  /**
   * 将该元素插入到某个元素前面
   * @param selector css 选择器
   */
  insertBefore(e) {
    const n = Y(e).elems[0];
    return n ? this.forEach((i) => {
      const r = n.parentNode;
      r == null || r.insertBefore(i, n);
    }) : this;
  }
  /**
   * 将该元素插入到selector元素后面
   * @param selector css 选择器
   */
  insertAfter(e) {
    const n = Y(e).elems[0], i = n && n.nextSibling;
    return n ? this.forEach(function(r) {
      const o = n.parentNode;
      i ? o.insertBefore(r, i) : o.appendChild(r);
    }) : this;
  }
  /**
   * 设置/获取 数据
   * @param key key
   * @param value value
   */
  data(e, t) {
    if (t === void 0)
      return this.dataSource.get(e);
    this.dataSource.set(e, t);
  }
  /**
   * 获取当前节点的顶级(段落)
   * @param editor 富文本实例
   */
  getNodeTop(e) {
    if (this.length < 1)
      return this;
    const t = this.parent();
    return e.$textLatexElem.equal(this) || e.$textLatexElem.equal(t) ? this : (t.prior = this, t.getNodeTop(e));
  }
  /**
   * 获取当前 节点 基与上一个拥有相对或者解决定位的父容器的位置
   * @param editor 富文本实例
   */
  getOffsetData() {
    const e = this.elems[0];
    return {
      top: e.offsetTop,
      left: e.offsetLeft,
      width: e.offsetWidth,
      height: e.offsetHeight,
      parent: e.offsetParent
    };
  }
  /**
   * 从上至下进行滚动
   * @param top 滚动的值
   */
  scrollTop(e) {
    this.elems[0].scrollTo({ top: e });
  }
  renderFormula() {
    return Jo.renderFormula(this.elems);
  }
}
function Y(...s) {
  return new wo(...s);
}
const $w = {
  width: 620,
  height: 272,
  menuHeight: 38,
  mathJaxUrl: "https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/mathjax/3.2.0/es5/tex-svg.min.js"
}, zw = {
  menus: [
    "presets",
    "operators",
    "greekLetters",
    "inequation",
    "AdvancedMath",
    "LinearAlgebra",
    "arrows",
    "Trigonometric"
  ],
  presets(s) {
    return [
      // 勾股定理
      {
        label: s("fe.pt"),
        value: "a^2+b^2=c^2"
      },
      // 双曲线
      {
        label: s("fe.h"),
        value: "\\frac{x^2}{a^2}-\\frac{y^2}{b^2}=1"
      },
      // 三角函数关系
      {
        label: s("fe.tfr"),
        value: "\\sin^2\\theta +\\cos^2\\theta = 1"
      },
      // 导数
      {
        label: s("fe.d"),
        value: "\\left( e^x \\right) ' = e^x"
      },
      // 牛莱公式
      {
        label: s("fe.nl"),
        value: "\\int_a^b f(x) dx = F(b) - F(a)"
      }
    ];
  },
  operators: [
    "+",
    "-",
    "\\pm",
    "\\mp",
    "\\times",
    "\\div",
    "\\ast",
    "\\cdot",
    "\\cap",
    "\\cup",
    "\\aleph",
    "\\Re",
    "\\top",
    "\\bot",
    "\\infty",
    "\\partial",
    "\\forall",
    "\\exists",
    "\\neg",
    "\\because",
    "\\therefore",
    "\\varnothing",
    "\\frac{b}{a}",
    "\\circ",
    "\\bullet",
    "\\prime",
    "\\triangle",
    "\\angle",
    "\\surd",
    "\\barwedge",
    "\\veebar",
    "\\odot",
    "\\oplus",
    "\\otimes",
    "\\oslash",
    "\\circledcirc",
    "\\boxdot",
    "\\bigtriangledown",
    "\\dagger",
    "\\diamond",
    "\\star",
    "\\triangleleft",
    "\\triangleright"
  ],
  greekLetters: [
    "\\alpha",
    "\\beta",
    "\\gamma",
    "\\delta",
    "\\epsilon",
    "\\zeta",
    "\\eta",
    "\\theta",
    "\\iota",
    "\\kappa",
    "\\lambda",
    "\\mu",
    "\\nu",
    "\\xi",
    "\\omicron",
    "\\pi",
    "\\rho",
    "\\sigma",
    "\\tau",
    "\\upsilon",
    "\\phi",
    "\\chi",
    "\\psi",
    "\\omega",
    "\\varepsilon",
    "\\vartheta",
    "\\varpi",
    "\\varrho",
    "\\varsigma",
    "\\varphi",
    "\\Gamma",
    "\\Delta",
    "\\Theta",
    "\\Lambda",
    "\\Xi",
    "\\Pi",
    "\\Sigma",
    "\\Upsilon",
    "\\Phi",
    "\\Psi",
    "\\Omega"
  ],
  inequation: [
    "=",
    "\\leq",
    "\\geq",
    "\\prec",
    "\\succ",
    "\\preceq",
    "\\succeq",
    "\\ll",
    "\\gg",
    "\\equiv",
    "\\sim",
    "\\simeq",
    "\\asymp",
    "\\approx",
    "\\ne",
    "\\subset",
    "\\supset",
    "\\subseteq",
    "\\supseteq",
    "\\nsubseteq",
    "\\nsupseteq",
    "\\in",
    "\\ni",
    "\\notin"
  ],
  AdvancedMath: [
    "x_{a}",
    "x^{b}",
    "x_{a}^{b}",
    "\\sqrt{x}",
    "\\sqrt[n]{x}",
    "\\bigcap_{a}^{b}",
    "\\bigcup_{a}^{b}",
    "\\prod_{a}^{b}",
    "\\coprod_{a}^{b}",
    "\\int_{a}^{b}",
    "\\oint_{a}^{b}",
    "\\sum_{a}^{b}{x}",
    "\\lim_{a  \\rightarrow b}{x}",
    "\\frac{dy}{dx}|_{t=0}",
    "\\vec{a}",
    "\\bar{a}",
    "\\tilde{a}",
    "\\dot{a}",
    "\\ddot{a}",
    "\\hat{a}",
    "\\overleftarrow{ab}",
    "\\overline{ab}",
    "\\overrightarrow{ab}",
    "\\underline{ab}",
    "\\overbrace{ab}",
    "\\underbrace{ab}"
  ],
  LinearAlgebra: [
    "A^{*}",
    "A^{T}",
    "A^{-1}",
    "\\left( x  \\right)",
    "\\left[ x  \\right]",
    "\\left \\{ x  \\right \\}",
    "\\left| x  \\right|",
    "\\begin{pmatrix}a&b\\\\c&d\\\\ \\end{pmatrix}",
    "\\begin{bmatrix}a&b\\\\c&d\\\\ \\end{bmatrix}",
    "\\begin{Bmatrix}a&b\\\\c&d\\\\ \\end{Bmatrix}",
    "\\begin{vmatrix}a&b\\\\c&d\\\\ \\end{vmatrix}"
  ],
  arrows: [
    "\\leftarrow",
    "\\rightarrow",
    "\\leftrightarrow",
    "\\Leftarrow",
    "\\Rightarrow",
    "\\Leftrightarrow",
    "\\uparrow",
    "\\downarrow",
    "\\updownarrow",
    "\\Uparrow",
    "\\Downarrow",
    "\\Updownarrow"
  ],
  trigonometric: [
    "\\sin \\theta",
    "\\cos \\theta",
    "\\tan \\theta",
    "\\csc \\theta",
    "\\sec \\theta",
    "\\cot \\theta",
    "\\arcsin \\theta",
    "\\arccos \\theta"
  ]
};
function Vw(s) {
  const {
    $editorRootElem: e,
    $toolbarElem: t,
    $textLatexElem: n,
    // $textSvgElem,
    config: i
  } = s;
  e.append(t);
  const r = Y("<div></div>");
  r.addClass("clearfix").css("width", "100%").css("height", "".concat(i.height - i.menuHeight, "px")).css("overflow", "hidden"), n.attr("contenteditable", "true").css("outline", "none"), r.append(n), e.css("width", "".concat(i.width, "px")).css("height", "".concat(i.height, "px")), e.append(r);
}
class Hw {
  constructor(e) {
    E(this, "editor");
    this.editor = e;
  }
  /**
   * 执行富文本操作的命令
   * @param value value
   */
  do(e) {
    const t = this.editor.selection;
    t.getRange() && (t.restoreSelection(), this.insertHtml(e), this.renderFormula(), t.saveRange(), t.restoreSelection());
  }
  /**
   * 公式编辑输入处理
   * @param text 插入的字符串
   * @param isSeparator 是否是定义的分隔符
   */
  insert(e, t) {
    if (t) {
      const r = this.editor.selection.getRange();
      if (r) {
        const o = r.startContainer;
        r.setStart(o, r.endOffset), r.setEnd(o, r.endOffset), r.deleteContents();
      }
      this.insertHtml(e === " " ? "&nbsp;" : e);
      return;
    }
    const n = Iw(e);
    this.do(n);
  }
  /**
   * 渲染数学公式
   */
  renderFormula() {
    const e = this.editor, t = e.latex.text();
    e.change(t);
  }
  /**
   * 插入 html 片段
   * @param html html字符串
   */
  insertHtml(e) {
    const t = this.editor, n = t.selection.getRange();
    if (n) {
      if (this.queryCommandSupported("insertHTML"))
        this.execCommand("insertHTML", e);
      else if (n.insertNode) {
        if (n.deleteContents(), Y(e).elems.length > 0)
          n.insertNode(Y(e).elems[0]);
        else {
          const i = document.createElement("p");
          i.appendChild(document.createTextNode(e)), n.insertNode(i);
        }
        t.selection.collapseRange();
      }
    }
  }
  /**
   * 执行 document.execCommand
   * @param name name
   * @param value value
   */
  execCommand(e, t) {
    document.execCommand(e, !1, t);
  }
  /**
   * 执行 document.queryCommandSupported
   * @param name name
   */
  queryCommandSupported(e) {
    return document.queryCommandSupported(e);
  }
}
class Uw {
  constructor(e) {
    E(this, "editor");
    E(this, "_currentRange", null);
    this.editor = e;
  }
  /**
   * 获取当前 range
   */
  getRange() {
    return this._currentRange;
  }
  /**
   * 保存选区范围
   * @param _range 选区范围
   */
  saveRange(e) {
    if (e) {
      this._currentRange = e;
      return;
    }
    const t = window.getSelection();
    if (t.rangeCount === 0)
      return;
    const n = t.getRangeAt(0), i = this.getSelectionContainerElem(n);
    if (!(i != null && i.length))
      return;
    const r = this.editor, o = r.$textLatexElem;
    if (o.isContain(i)) {
      if (o.elems[0] === i.elems[0] && o.html().trim() === mo) {
        const a = o.children(), l = a == null ? void 0 : a.last();
        r.selection.createRangeByElem(l, !0, !0), r.selection.restoreSelection();
      }
      this._currentRange = n;
    }
  }
  /**
   * 折叠选区范围
   * @param toStart true 开始位置，false 结束位置
   */
  collapseRange(e = !1) {
    const t = this._currentRange;
    t && t.collapse(e);
  }
  /**
   * 获取选区范围内的文字
   */
  getSelectionText() {
    const e = this._currentRange;
    return e ? e.toString() : "";
  }
  /**
   * 获取选区范围的 DOM 元素
   * @param range 选区范围
   */
  getSelectionContainerElem(e) {
    const t = e || this._currentRange;
    if (t) {
      const n = t.commonAncestorContainer;
      return Y(n.nodeType === 1 ? n : n.parentNode);
    }
  }
  /**
   * 选区范围开始的 DOM 元素
   * @param range 选区范围
   */
  getSelectionStartElem(e) {
    const t = e || this._currentRange;
    if (t) {
      const n = t.startContainer;
      return Y(n.nodeType === 1 ? n : n.parentNode);
    }
  }
  /**
   * 选区范围结束的 DOM 元素
   * @param range 选区范围
   */
  getSelectionEndElem(e) {
    const t = e || this._currentRange;
    if (t) {
      const n = t.endContainer;
      return Y(n.nodeType === 1 ? n : n.parentNode);
    }
  }
  /**
   * 选区是否为空（没有选择文字）
   */
  isSelectionEmpty() {
    const e = this._currentRange;
    return !!(e && e.startContainer && e.startContainer === e.endContainer && e.startOffset === e.endOffset);
  }
  /**
   * 恢复选区范围
   */
  restoreSelection() {
    const e = window.getSelection(), t = this._currentRange;
    e && t && (e.removeAllRanges(), e.addRange(t));
  }
  /**
   * 重新设置选区
   * @param startDom 选区开始的元素
   * @param endDom 选区结束的元素
   */
  createRangeByElems(e, t) {
    const n = window.getSelection ? window.getSelection() : document.getSelection();
    n == null || n.removeAllRanges();
    const i = document.createRange();
    i.setStart(e, 0), i.setEnd(t, t.childNodes.length || 1), this.saveRange(i), this.restoreSelection();
  }
  /**
   * 根据 DOM 元素设置选区
   * @param $elem DOM 元素
   * @param toStart true 开始位置，false 结束位置
   * @param isContent 是否选中 $elem 的内容
   */
  createRangeByElem(e, t, n) {
    if (!e.length)
      return;
    const i = e.elems[0], r = document.createRange();
    n ? r.selectNodeContents(i) : r.selectNode(i), t != null && (r.collapse(t), t || (this.saveRange(r), this.editor.selection.moveCursor(i))), this.saveRange(r);
  }
  /**
   * 获取 当前 选取范围的 顶级(段落) 元素
   * @param $editor
   */
  getSelectionRangeTopNodes() {
    var n, i;
    const e = (n = this.getSelectionStartElem()) == null ? void 0 : n.getNodeTop(this.editor), t = (i = this.getSelectionEndElem()) == null ? void 0 : i.getNodeTop(this.editor);
    return this.recordSelectionNodes(Y(e), Y(t));
  }
  /**
   * 移动光标位置,默认情况下在尾部
   * 有一个特殊情况是firefox下的文本节点会自动补充一个br元素，会导致自动换行
   * 所以默认情况下在firefox下的文本节点会自动移动到br前面
   * @param {Node} node 元素节点
   * @param {number} position 光标的位置
   */
  moveCursor(e, t) {
    var o;
    const n = this.getRange();
    let i = e.nodeType === 3 ? (o = e.nodeValue) == null ? void 0 : o.length : e.childNodes.length;
    (Eh.isFirefox || Eh.isIE()) && i !== 0 && (e.nodeType === 3 || e.childNodes[i - 1].nodeName === "BR") && (i -= 1);
    const r = t != null ? t : i;
    n && e && (n.setStart(e, r), n.setEnd(e, r), this.restoreSelection());
  }
  /**
   * 获取光标在当前选区的位置
   */
  getCursorPos() {
    const e = window.getSelection();
    return e == null ? void 0 : e.anchorOffset;
  }
  /**
   * 清除当前选区的Range,notice:不影响已保存的Range
   */
  clearWindowSelectionRange() {
    const e = window.getSelection();
    e && e.removeAllRanges();
  }
  /**
   * 记录节点 - 从选区开始节点开始 一直到匹配到选区结束节点为止
   * @param $node 节点
   */
  recordSelectionNodes(e, t) {
    const n = [];
    let i = !0;
    try {
      let r = e;
      const o = this.editor.$textLatexElem;
      for (; i; ) {
        const a = r == null ? void 0 : r.getNodeTop(this.editor);
        a.getNodeName() === "BODY" && (i = !1), a.length > 0 && (n.push(Y(r)), t != null && t.equal(a) || o.equal(a) ? i = !1 : r = a.getNextSibling());
      }
    } catch (r) {
      i = !1;
    }
    return n;
  }
  /**
   * 将当前 range 设置到 node 元素并初始化位置
   * 解决编辑器内容为空时，菜单不生效的问题
   * @param node 元素节点
   */
  setRangeToElem(e) {
    const t = this.getRange();
    t == null || t.setStart(e, 0), t == null || t.setEnd(e, 0);
  }
}
function ul(s, e) {
  const t = s.$textLatexElem, n = t.children();
  if (!n || !n.length) {
    t.append(Y(mo)), ul(s);
    return;
  }
  const i = n.last();
  if (e) {
    const r = i.html().toLowerCase(), o = i.getNodeName();
    if (r !== "<br>" && r !== "<br/>" || o !== "P") {
      t.append(Y(mo)), ul(s);
      return;
    }
  }
  s.selection.createRangeByElem(i, !1, !0), s.selection.restoreSelection();
}
let qw = class {
  constructor(e, t) {
    E(this, "key");
    E(this, "$elem");
    E(this, "editor");
    /** 菜单是否处于激活状态，如选中一段加粗文字时，bold 菜单要被激活（即高亮显示） */
    E(this, "_active");
    this.$elem = e, this.editor = t, this._active = !1, e.on("click", (n) => {
      n.stopPropagation(), t.selection.getRange() && (e.addClass("active"), this.clickHandler());
    });
  }
  /**
   * 菜单点击事件
   */
  clickHandler() {
  }
  /**
   * 激活菜单，高亮显示
   */
  active() {
    this._active = !0, this.$elem.addClass("me-active");
  }
  /**
   * 取消激活，不再高亮显示
   */
  unActive() {
    this._active = !1, this.$elem.removeClass("me-active");
  }
  /**
   * 是否处于激活状态
   */
  get isActive() {
    return this._active;
  }
};
const Gw = 38;
class Ww {
  constructor(e, t) {
    E(this, "menu");
    E(this, "conf");
    E(this, "$container");
    E(this, "rendered");
    E(this, "_show");
    E(this, "hideTimeoutId");
    this.hideTimeoutId = 0, this.menu = e, this.conf = t;
    const {
      height: n,
      menuHeight: i,
      zIndex: r = 0
    } = this.menu.editor.config, o = Y("<p>".concat(t.title, "</p>")).addClass("me-dp-title"), a = Y('<div class="me-droplist"></div>').append(o).css("z-index", r + 1), l = t.list || [], c = t.type || "block", u = t.clickHandler || Tw, d = Y(
      '<ul class="'.concat(c === "list" ? "me-list" : "me-block", '"></ul>')
    ).css("max-height", "".concat(n - i - Gw, "px")).css("overflow-y", "auto");
    l.forEach((f) => {
      const g = f.$elem, p = f.value, m = Y('<li class="me-item"></li>');
      g && (m.append(g), d.append(m), m.on("click", (w) => {
        u(p), w.stopPropagation(), this.hideTimeoutId = window.setTimeout(() => {
          this.hide();
        });
      }));
    }), a.append(d), a.on("mouseleave", () => {
      this.hideTimeoutId = window.setTimeout(() => {
        this.hide();
      });
    }), this.$container = a, this.rendered = !1, this._show = !1;
  }
  /**
   * 显示 DropList
   */
  show() {
    this.hideTimeoutId && clearTimeout(this.hideTimeoutId);
    const t = this.menu.$elem, n = this.$container;
    if (!this._show) {
      if (this.rendered)
        n.show();
      else {
        const i = this.conf.width || 232;
        n.css("width", "".concat(i, "px")), t.append(n), this.rendered = !0, t.renderFormula();
      }
      this._show = !0;
    }
  }
  /**
   * 隐藏 DropList
   */
  hide() {
    const e = this.$container;
    this._show && (e.hide(), this._show = !1);
  }
  get isShow() {
    return this._show;
  }
}
class Hn extends qw {
  constructor(t, n, i) {
    super(t, n);
    E(this, "dropList");
    const r = new Ww(this, i);
    this.dropList = r, t.on("mouseover", () => {
      n.selection.getRange() && (t.addClass("active"), r.show());
    }).on("mouseleave", () => {
      t.removeClass("active"), r.hideTimeoutId = window.setTimeout(() => {
        r.hide();
      });
    });
  }
  /**
   * 执行命令
   * @param value value
   */
  command(t) {
    var a;
    const n = this.editor, i = n.selection.isSelectionEmpty();
    if (!((a = n.selection.getSelectionContainerElem()) == null ? void 0 : a.elems[0]))
      return;
    const o = rf(t);
    n.cmd.do(o), i && (n.selection.collapseRange(), n.selection.restoreSelection());
  }
}
class Jw {
  constructor(e) {
    E(this, "itemList");
    this.itemList = e.map(({ label: t, value: n }) => ({
      $elem: Y('<p class="title">'.concat(t, "：</p><p>$ ").concat(n, " $</p>")),
      value: n
    }));
  }
  getItemList() {
    return this.itemList;
  }
}
class Yw extends Hn {
  constructor(e) {
    const t = Y(Vn("f_{(x)}")), n = new Jw(e.menusConfig.presets(e.t)), i = {
      width: 252,
      title: e.t("fe.p"),
      type: "list",
      list: n.getItemList(),
      clickHandler: (r) => {
        this.command(r);
      }
    };
    super(t, e, i);
  }
}
class Ms {
  constructor(e) {
    E(this, "itemList");
    this.itemList = e.map((t) => ({
      $elem: Y("<span>$".concat(t, "$</span>")),
      value: t
    }));
  }
  getItemList() {
    return this.itemList;
  }
}
class Xw extends Hn {
  constructor(e) {
    const t = Y(Vn("+")), n = new Ms(e.menusConfig.operators), i = {
      title: e.t("fe.o"),
      list: n.getItemList(),
      clickHandler: (r) => {
        this.command(r);
      }
    };
    super(t, e, i);
  }
}
class Zw extends Hn {
  constructor(e) {
    const t = Y(Vn("\\alpha")), n = new Ms(e.menusConfig.greekLetters), i = {
      title: e.t("fe.gl"),
      list: n.getItemList(),
      clickHandler: (r) => {
        this.command(r);
      }
    };
    super(t, e, i);
  }
}
class Kw extends Hn {
  constructor(e) {
    const t = Y(Vn("\\approx")), n = new Ms(e.menusConfig.inequation), i = {
      title: e.t("fe.i"),
      list: n.getItemList(),
      clickHandler: (r) => {
        this.command(r);
      }
    };
    super(t, e, i);
  }
}
class Qw extends Hn {
  constructor(e) {
    const t = Y(Vn("\\Sigma")), n = new Ms(e.menusConfig.AdvancedMath), i = {
      width: 244,
      title: e.t("fe.am"),
      list: n.getItemList(),
      clickHandler: (r) => {
        this.command(r);
      }
    };
    super(t, e, i);
  }
}
class e6 extends Hn {
  constructor(e) {
    const t = Y(Vn("\\left|x\\right|")), n = new Ms(e.menusConfig.LinearAlgebra), i = {
      width: 244,
      title: e.t("fe.lg"),
      list: n.getItemList(),
      clickHandler: (r) => {
        this.command(r);
      }
    };
    super(t, e, i);
  }
}
class t6 extends Hn {
  constructor(e) {
    const t = Y(Vn("\\rightarrow")), n = new Ms(e.menusConfig.arrows), i = {
      title: e.t("fe.a"),
      list: n.getItemList(),
      clickHandler: (r) => {
        this.command(r);
      }
    };
    super(t, e, i);
  }
}
class n6 extends Hn {
  constructor(e) {
    const t = Y(Vn("\\theta")), n = new Ms(e.menusConfig.trigonometric), i = {
      title: e.t("fe.t"),
      list: n.getItemList(),
      clickHandler: (r) => {
        this.command(r);
      }
    };
    super(t, e, i);
  }
}
const s6 = {
  presets: Yw,
  operators: Xw,
  greekLetters: Zw,
  inequation: Kw,
  AdvancedMath: Qw,
  LinearAlgebra: e6,
  arrows: t6,
  Trigonometric: n6
};
class i6 {
  constructor(e) {
    E(this, "editor");
    E(this, "menuList");
    E(this, "constructorList");
    this.editor = e, this.menuList = [], this.constructorList = s6;
  }
  /**
   * 自定义添加菜单
   * @param key 菜单 key ，和 editor.menusConfig.menus 对应
   * @param Menu 菜单构造函数
   */
  extend(e, t) {
    !t || typeof t != "function" || (this.constructorList[e] = t);
  }
  // 初始化菜单
  init() {
    this.editor.menusConfig.menus.forEach((t) => {
      const n = this.constructorList[t];
      this._initMenuList(t, n);
    }), this._addToToolbar();
  }
  /**
   * 创建 menu 实例，并放到 menuList 中
   * @param menuKey 菜单 key ，和 editor.menusConfig.menus 对应
   * @param MenuConstructor 菜单构造函数
   */
  _initMenuList(e, t) {
    if (typeof t == "function")
      if (this.menuList.some((n) => n.key === e))
        console.warn("Duplicate menu name:".concat(e));
      else {
        const n = new t(this.editor);
        n.key = e, this.menuList.push(n);
      }
  }
  // 添加到菜单栏
  _addToToolbar() {
    const { editor: e } = this, { $toolbarElem: t } = e;
    t.addClass("clearfix"), this.menuList.forEach((n) => {
      const { $elem: i } = n;
      i && t.append(i);
    });
  }
  /**
   * 获取菜单对象
   * @param 菜单名称 小写
   * @return Menus 菜单对象
   */
  menuFind(e) {
    const { menuList: t } = this;
    for (let n = 0, i = t.length; n < i; n++)
      if (t[n].key === e)
        return t[n];
    return t[0];
  }
}
class r6 {
  constructor(e) {
    E(this, "editor");
    this.editor = e;
  }
  /**
   * 初始化
   */
  init() {
    this._saveRange();
  }
  /**
   * 清空内容
   */
  clear() {
    this.editor.$textLatexElem.replaceChildAll(Y(mo));
  }
  /**
   * 设置/获取 text
   */
  text() {
    return this.editor.$textLatexElem.text().replace(/&nbsp;/g, " ");
  }
  /**
   * 每一步操作，都实时保存选区范围
   */
  _saveRange() {
    const e = this.editor, t = e.$textLatexElem, n = Y(document);
    function i() {
      e.selection.saveRange();
    }
    function r() {
      i(), e.cmd.renderFormula();
    }
    t.on("keyup", Dw(r));
    function o(u) {
      const d = u.key, f = u.ctrlKey && !Lw.includes(d), g = Nw.includes(d);
      (f || g) && (u.preventDefault(), i(), e.cmd.insert(d, g));
    }
    t.on("keydown", o);
    function a() {
      i(), t.off("click", a);
    }
    t.on("click", a);
    function l() {
      i(), n.off("mouseup", l);
    }
    function c() {
      n.on("mouseup", l), t.off("mouseleave", c);
    }
    t.on("mousedown", () => {
      t.on("mouseleave", c);
    }), t.on("mouseup", () => {
      t.off("mouseleave", c), setTimeout(() => {
        e.selection.getRange() && i();
      }, 0);
    });
  }
}
const o6 = {
  "fe.a": "箭头符号",
  "fe.am": "高数",
  "fe.lg": "线代",
  "fe.gl": "希腊字母",
  "fe.i": "不等式",
  "fe.o": "运算符",
  "fe.p": "预设公式",
  "fe.t": "三角函数",
  "fe.l": "资源加载中...",
  "fe.pt": "勾股定理",
  "fe.h": "双曲线",
  "fe.tfr": "三角函数关系",
  "fe.d": "导数",
  "fe.nl": "牛莱公式"
};
function a6(s) {
  return o6[s] || s;
}
class of {
  constructor() {
    E(this, "config");
    E(this, "menusConfig");
    E(this, "$editorRootElem");
    E(this, "$toolbarElem");
    E(this, "$textLatexElem");
    E(this, "$textSvgElem");
    E(this, "cmd");
    E(this, "selection");
    E(this, "menus");
    E(this, "latex");
    E(this, "t");
    this.config = $w, this.menusConfig = zw, this.$editorRootElem = Y('<div class="math-editor"></div>'), this.$toolbarElem = Y('<div class="me-menu"></div>'), this.$textLatexElem = Y('<div class="me-latex is-no-data"></div>'), this.$textSvgElem = Y('<div class="me-svg"></div>'), this.cmd = new Hw(this), this.selection = new Uw(this), this.menus = new i6(this), this.latex = new r6(this), this.t = a6;
  }
  /**
   * 创建编辑器 DOM
   * @param rootSelector 公式弹窗附属DOM selector
   * @param callback mathJax加载完成时执行
   */
  async create(e, t) {
    this.menus.init(), this.latex.init(), Vw(this);
    const n = Y(e);
    n.text(this.t("fe.l"));
    const i = () => {
      n.text("").append(this.$editorRootElem), this.initSelection(), this.$toolbarElem.renderFormula(), t && t();
    };
    Jo.loadMathJax().then(() => i());
  }
  /**
   * 二次编辑
   */
  append(e) {
    const t = rf(e);
    this.cmd.do(t);
  }
  /**
   * 值改变
   */
  change(e) {
    e ? this.$textLatexElem.removeClass("is-no-data") : this.$textLatexElem.addClass("is-no-data");
  }
  /**
   * 初始化选区
   */
  initSelection() {
    ul(this);
  }
  /**
   * 销毁编辑器 DOM
   */
  destroyDom() {
    this.$editorRootElem.remove();
  }
}
// 暴露 $
E(of, "$", Y);
Jo.loadMathJax();
const l6 = /* @__PURE__ */ ye({
  name: "IBizFormula",
  props: As(),
  setup(s) {
    const e = me("formula-elem"), t = L(), n = L(null), i = L(null), r = L(""), o = L(), a = L("");
    s.data && (a.value = s.data);
    const l = async () => {
      var A, k, O;
      await ((A = n.value) == null ? void 0 : A.dismiss()), await ((k = i.value) == null ? void 0 : k.dismiss()), await ((O = t.value) == null ? void 0 : O.destroyDom());
    }, c = () => {
      if (a.value) {
        const A = a.value.replace(/&nbsp;/g, " ").trim(), k = "$ ".concat(A, " $");
        o.value.innerHTML = k, Jo.renderFormula(o.value);
      } else
        o.value.innerHTML = "输入 LaTeX 公式";
    }, u = () => {
      var A;
      a.value && ((A = t.value) == null || A.append(a.value));
    }, d = () => {
      c(), t.value = new of(), t.value.config = {
        width: 570,
        height: 184,
        menuHeight: 40
      }, t.value.change = (A) => {
        A ? t.value.$textLatexElem.removeClass("is-no-data") : t.value.$textLatexElem.addClass("is-no-data"), a.value = A, c();
      };
    }, f = L([{
      type: "edit",
      text: "编辑",
      icon: '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fit="" height="1em" width="1em" preserveAspectRatio="xMidYMid meet" focusable="false"><g id="ajbaction/edit" stroke-width="1" fill-rule="evenodd"><path d="M2 8.34L10.71 0 15 4.17 6.538 13H2V8.34zm1.2.512V11.8h2.826l7.283-7.6-2.606-2.533L3.2 8.852zM0 16v-1.2h16V16H0z"></path></g></svg>'
    }, {
      type: "delete",
      text: "删除",
      icon: "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em'> <g stroke-width='1' fill-rule='evenodd'> <path d='M4.002 3.403V1a1 1 0 0 1 1-1h6.003a1 1 0 0 1 1 1v2.403h3.396a.6.6 0 1 1 0 1.2h-1.395V15a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4.603H.6a.6.6 0 1 1 0-1.2h3.4zm8.804 1.205H3.2V14.8h9.605V4.608zM5.202 1.2v2.155h5.603V1.2H5.202zm.6 6.417a.6.6 0 0 1 1.201 0v4.758a.6.6 0 0 1-1.2 0V7.617zm3.202 0a.6.6 0 0 1 1.2 0v4.758a.6.6 0 0 1-1.2 0V7.617z'></path> </g></svg>"
    }]), g = async () => {
      await l(), s.change("", {
        isDelete: !0
      });
    }, p = () => {
      var A;
      (A = i.value) == null || A.dismiss();
    }, m = () => S("div", {
      class: e.b("edit-popover")
    }, [S("div", {
      id: r.value,
      class: e.be("edit-popover", "editor")
    }, null), S("div", {
      class: e.be("edit-popover", "confirm"),
      onClick: p
    }, [S("button", {
      class: ["el-button el-button--default"]
    }, [at("确定")])])]), w = async () => {
      r.value = nt(), i.value || (i.value = Vs(m(), {
        placement: "top-start"
      })), await i.value.present(o.value), t.value.create(document.getElementById(r.value), u), await i.value.onWillDismiss(), s.change(a.value), t.value.destroyDom(), t.value = null, n.value = null;
    }, v = async (A) => {
      if (A.type !== "separator")
        switch (A.type) {
          case "edit":
            await n.value.dismiss(), w();
            break;
          case "delete":
            g();
            break;
        }
    }, y = () => S("div", {
      class: e.b("tool-popover")
    }, [f.value.map((A) => S("div", {
      class: [e.be("tool-popover", "item"), e.is(A.type, !0)],
      title: A.text,
      onClick: () => v(A)
    }, [S("div", {
      class: e.bem("popover", "item", "content"),
      innerHTML: A.icon || A.text
    }, null)]))]), b = async () => {
      n.value = Vs(y(), {
        placement: "top-start"
      }), await n.value.present(o.value), await n.value.onWillDismiss(), n.value = null;
    }, x = this;
    let C = new ResizeObserver(() => {
      o.value && o.value.offsetWidth !== 0 && (d.bind(x)(), s.isFocus && w(), C.disconnect(), C = null);
    });
    return Be(o, (A) => {
      A && A.click && C.observe(o.value);
    }), fr(() => {
      l();
    }), {
      ns: e,
      nodeRef: o,
      openNodeOverlay: b
    };
  },
  render() {
    return S("div", {
      ref: "nodeRef",
      class: [this.ns.b(), this.readonly ? this.ns.m("readonly") : ""],
      onClick: this.openNodeOverlay
    }, null);
  }
}), c6 = () => [
  {
    id: "1",
    type: "topic",
    shape: "mind-map",
    label: "思维导图",
    width: 120,
    height: 40,
    children: [
      {
        id: "1-1",
        type: "topic-child",
        shape: "mind-map",
        label: "新建节点",
        width: 120,
        height: 30
      },
      {
        id: "1-2",
        type: "topic-child",
        shape: "mind-map",
        label: "新建节点",
        width: 120,
        height: 30
      }
    ]
  }
], h6 = () => [
  {
    type: "panning",
    icon: '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fit="" height="1em" width="1em" preserveAspectRatio="xMidYMid meet" focusable="false"><g stroke-width="1" fill-rule="evenodd"><path d="M8.446.5c.628.01 1.101.34 1.416.843.035.056.067.112.096.167l.063.132.041-.018c.135-.056.282-.092.44-.106l.163-.008c.823 0 1.356.483 1.637 1.154.088.21.132.436.132.662l.002.479.08-.022c.096-.022.198-.036.304-.04l.163-.001c.63.024 1.082.338 1.326.82.143.282.19.551.19.772l-.107 6.715a3.688 3.688 0 0 1-.87 2.334 4.249 4.249 0 0 1-.364.377c-.695.637-1.403.894-1.968.94l-3.718-.02a3.014 3.014 0 0 1-.977-.333 3.486 3.486 0 0 1-.608-.398l-3.335-3.448a4.423 4.423 0 0 1-.597-.587c-.376-.443-.62-.9-.652-1.386a1.437 1.437 0 0 1 .28-.96c.242-.33.546-.547.892-.638.483-.128.952-.005 1.39.257.18.108.317.216.397.292l.352.318-.042-5.204.004-.131c.014-.228.065-.505.183-.792.251-.609.738-1.023 1.455-1.062a1.75 1.75 0 0 1 .623.073l.027.009c.021-.054.044-.108.07-.163l.085-.167C7.315.832 7.795.49 8.446.5zm-.02 1.2c-.158-.002-.263.072-.361.248-.025.044-.047.09-.064.13l-.052.126-.005.003-.001.954h.029V7.61h-1.2L6.77 3.338h-.027a.861.861 0 0 0-.044-.227l-.036-.092c-.074-.161-.166-.224-.386-.213-.208.012-.322.108-.41.321-.07.172-.096.36-.096.463l.064 7.935-2.417-2.19-.103-.075-.068-.043c-.187-.113-.355-.157-.466-.127-.072.019-.146.071-.231.188a.24.24 0 0 0-.05.172c.011.173.144.423.369.688.163.191.328.343.486.475l3.329 3.444c.026.02.063.047.109.077l.16.098.097.052c.209.11.412.183.506.201l3.584.017c.01 0 .022-.002.037-.005l.121-.028a2.606 2.606 0 0 0 1.048-.594c.09-.082.177-.172.26-.27.369-.433.576-.991.585-1.575l.108-6.702a.596.596 0 0 0-.061-.224c-.055-.107-.126-.156-.301-.163-.257-.01-.404.17-.462.454v2.132h-1.2V5.688h-.03l-.012-2.36a.513.513 0 0 0-.038-.2c-.114-.27-.276-.418-.531-.418-.208 0-.345.164-.413.403l.001 4.4h-1.2V3.288h-.037l-.028-.989-.025-.076a1.36 1.36 0 0 0-.07-.16l-.049-.084c-.116-.187-.245-.276-.417-.279z" id="arj形状结合"></path></g></svg>',
    text: "平移"
  },
  {
    type: "separator",
    text: "|"
  },
  {
    type: "delete",
    icon: '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fit="" height="1em" width="1em" preserveAspectRatio="xMidYMid meet" focusable="false"><g stroke-width="1" fill-rule="evenodd"><path d="M4.002 3.403V1a1 1 0 0 1 1-1h6.003a1 1 0 0 1 1 1v2.403h3.396a.6.6 0 1 1 0 1.2h-1.395V15a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4.603H.6a.6.6 0 1 1 0-1.2h3.4zm8.804 1.205H3.2V14.8h9.605V4.608zM5.202 1.2v2.155h5.603V1.2H5.202zm.6 6.417a.6.6 0 0 1 1.201 0v4.758a.6.6 0 0 1-1.2 0V7.617zm3.202 0a.6.6 0 0 1 1.2 0v4.758a.6.6 0 0 1-1.2 0V7.617z" id="azk删除"></path></g></svg>',
    text: "删除"
  }
];
typeof window == "object" && window.NodeList && !NodeList.prototype.forEach && (NodeList.prototype.forEach = Array.prototype.forEach);
typeof window < "u" && function(s) {
  s.forEach((e) => {
    Object.prototype.hasOwnProperty.call(e, "append") || Object.defineProperty(e, "append", {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value(...t) {
        const n = document.createDocumentFragment();
        t.forEach((i) => {
          const r = i instanceof Node;
          n.appendChild(r ? i : document.createTextNode(String(i)));
        }), this.appendChild(n);
      }
    });
  });
}([Element.prototype, Document.prototype, DocumentFragment.prototype]);
class hn {
  get disposed() {
    return this._disposed === !0;
  }
  dispose() {
    this._disposed = !0;
  }
}
(function(s) {
  function e() {
    return (t, n, i) => {
      const r = i.value, o = t.__proto__;
      i.value = function(...a) {
        this.disposed || (r.call(this, ...a), o.dispose.call(this));
      };
    };
  }
  s.dispose = e;
})(hn || (hn = {}));
class Ah {
  constructor() {
    this.isDisposed = !1, this.items = /* @__PURE__ */ new Set();
  }
  /**
   * Test whether the set has been disposed.
   */
  get disposed() {
    return this.isDisposed;
  }
  /**
   * Dispose of the set and the items it contains.
   *
   * #### Notes
   * Items are disposed in the order they are added to the set.
   */
  dispose() {
    this.isDisposed || (this.isDisposed = !0, this.items.forEach((e) => {
      e.dispose();
    }), this.items.clear());
  }
  /**
   * Test whether the set contains a specific item.
   *
   * @param item - The item of interest.
   *
   * @returns `true` if the set contains the item, `false` otherwise.
   */
  contains(e) {
    return this.items.has(e);
  }
  /**
   * Add a disposable item to the set.
   *
   * @param item - The item to add to the set.
   *
   * #### Notes
   * If the item is already contained in the set, this is a no-op.
   */
  add(e) {
    this.items.add(e);
  }
  /**
   * Remove a disposable item from the set.
   *
   * @param item - The item to remove from the set.
   *
   * #### Notes
   * If the item is not contained in the set, this is a no-op.
   */
  remove(e) {
    this.items.delete(e);
  }
  /**
   * Remove all items from the set.
   */
  clear() {
    this.items.clear();
  }
}
(function(s) {
  function e(t) {
    const n = new s();
    return t.forEach((i) => {
      n.add(i);
    }), n;
  }
  s.from = e;
})(Ah || (Ah = {}));
function af(s, e, t) {
  if (t)
    switch (t.length) {
      case 0:
        return s.call(e);
      case 1:
        return s.call(e, t[0]);
      case 2:
        return s.call(e, t[0], t[1]);
      case 3:
        return s.call(e, t[0], t[1], t[2]);
      case 4:
        return s.call(e, t[0], t[1], t[2], t[3]);
      case 5:
        return s.call(e, t[0], t[1], t[2], t[3], t[4]);
      case 6:
        return s.call(e, t[0], t[1], t[2], t[3], t[4], t[5]);
      default:
        return s.apply(e, t);
    }
  return s.call(e);
}
function J(s, e, ...t) {
  return af(s, e, t);
}
function u6(s) {
  return typeof s == "object" && s.then && typeof s.then == "function";
}
function Mh(s) {
  return s != null && (s instanceof Promise || u6(s));
}
function lf(...s) {
  const e = [];
  if (s.forEach((n) => {
    Array.isArray(n) ? e.push(...n) : e.push(n);
  }), e.some((n) => Mh(n))) {
    const n = e.map((i) => Mh(i) ? i : Promise.resolve(i !== !1));
    return Promise.all(n).then((i) => i.reduce((r, o) => o !== !1 && r, !0));
  }
  return e.every((n) => n !== !1);
}
function Na(s, e) {
  const t = [];
  for (let n = 0; n < s.length; n += 2) {
    const i = s[n], r = s[n + 1], o = Array.isArray(e) ? e : [e], a = af(i, r, o);
    t.push(a);
  }
  return lf(t);
}
class d6 {
  constructor() {
    this.listeners = {};
  }
  on(e, t, n) {
    return t == null ? this : (this.listeners[e] || (this.listeners[e] = []), this.listeners[e].push(t, n), this);
  }
  once(e, t, n) {
    const i = (...r) => (this.off(e, i), Na([t, n], r));
    return this.on(e, i, this);
  }
  off(e, t, n) {
    if (!(e || t || n))
      return this.listeners = {}, this;
    const i = this.listeners;
    return (e ? [e] : Object.keys(i)).forEach((o) => {
      const a = i[o];
      if (a) {
        if (!(t || n)) {
          delete i[o];
          return;
        }
        for (let l = a.length - 2; l >= 0; l -= 2)
          t && a[l] !== t || n && a[l + 1] !== n || a.splice(l, 2);
      }
    }), this;
  }
  trigger(e, ...t) {
    let n = !0;
    if (e !== "*") {
      const r = this.listeners[e];
      r != null && (n = Na([...r], t));
    }
    const i = this.listeners["*"];
    return i != null ? lf([
      n,
      Na([...i], [e, ...t])
    ]) : n;
  }
  emit(e, ...t) {
    return this.trigger(e, ...t);
  }
}
function f6(s, ...e) {
  e.forEach((t) => {
    Object.getOwnPropertyNames(t.prototype).forEach((n) => {
      n !== "constructor" && Object.defineProperty(s.prototype, n, Object.getOwnPropertyDescriptor(t.prototype, n));
    });
  });
}
const g6 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(s, e) {
  s.__proto__ = e;
} || function(s, e) {
  for (const t in e)
    Object.prototype.hasOwnProperty.call(e, t) && (s[t] = e[t]);
};
function p6(s, e) {
  g6(s, e);
  function t() {
    this.constructor = s;
  }
  s.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
class m6 {
}
const w6 = /^\s*class\s+/.test("".concat(m6)) || /^\s*class\s*\{/.test("".concat(class {
}));
function ic(s, e) {
  let t;
  return w6 ? t = class extends e {
  } : (t = function() {
    return e.apply(this, arguments);
  }, p6(t, e)), Object.defineProperty(t, "name", { value: s }), t;
}
function kh(s) {
  return s === "__proto__";
}
function rc(s, e, t = "/") {
  let n;
  const i = Array.isArray(e) ? e : e.split(t);
  if (i.length)
    for (n = s; i.length; ) {
      const r = i.shift();
      if (Object(n) === n && r && r in n)
        n = n[r];
      else
        return;
    }
  return n;
}
function vi(s, e, t, n = "/") {
  const i = Array.isArray(e) ? e : e.split(n), r = i.pop();
  if (r && !kh(r)) {
    let o = s;
    i.forEach((a) => {
      kh(a) || (o[a] == null && (o[a] = {}), o = o[a]);
    }), o[r] = t;
  }
  return s;
}
function Ph(s, e, t = "/") {
  const n = Array.isArray(e) ? e.slice() : e.split(t), i = n.pop();
  if (i)
    if (n.length > 0) {
      const r = rc(s, n);
      r && delete r[i];
    } else
      delete s[i];
  return s;
}
var y6 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class yt extends d6 {
  dispose() {
    this.off();
  }
}
y6([
  hn.dispose()
], yt.prototype, "dispose", null);
(function(s) {
  s.dispose = hn.dispose;
})(yt || (yt = {}));
f6(yt, hn);
const cf = (s) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = s(t));
}, hf = cf((s) => s.replace(/\B([A-Z])/g, "-$1").toLowerCase()), oc = cf((s) => Ep(No(s)).replace(/ /g, ""));
function Da(s) {
  let e = 2166136261, t = !1, n = s;
  for (let i = 0, r = n.length; i < r; i += 1) {
    let o = n.charCodeAt(i);
    o > 127 && !t && (n = unescape(encodeURIComponent(n)), o = n.charCodeAt(i), t = !0), e ^= o, e += (e << 1) + (e << 4) + (e << 7) + (e << 8) + (e << 24);
  }
  return e >>> 0;
}
function yo() {
  let s = "";
  const e = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
  for (let t = 0, n = e.length; t < n; t += 1) {
    const i = e[t], r = Math.random() * 16 | 0, o = i === "x" ? r : i === "y" ? r & 3 | 8 : i;
    s += o.toString(16);
  }
  return s;
}
function b6(s, e, t) {
  const n = Math.min(2, Math.floor(s.length * 0.34));
  let i = Math.floor(s.length * 0.4) + 1, r, o = !1;
  const a = s.toLowerCase();
  for (const l of e) {
    const c = t(l);
    if (c !== void 0 && Math.abs(c.length - a.length) <= n) {
      const u = c.toLowerCase();
      if (u === a) {
        if (c === s)
          continue;
        return l;
      }
      if (o || c.length < 3)
        continue;
      const d = v6(a, u, i - 1);
      if (d === void 0)
        continue;
      d < 3 ? (o = !0, r = l) : (i = d, r = l);
    }
  }
  return r;
}
function v6(s, e, t) {
  let n = new Array(e.length + 1), i = new Array(e.length + 1);
  const r = t + 1;
  for (let a = 0; a <= e.length; a += 1)
    n[a] = a;
  for (let a = 1; a <= s.length; a += 1) {
    const l = s.charCodeAt(a - 1), c = a > t ? a - t : 1, u = e.length > t + a ? t + a : e.length;
    i[0] = a;
    let d = a;
    for (let g = 1; g < c; g += 1)
      i[g] = r;
    for (let g = c; g <= u; g += 1) {
      const p = l === e.charCodeAt(g - 1) ? n[g - 1] : Math.min(
        /* delete */
        n[g] + 1,
        /* insert */
        i[g - 1] + 1,
        /* substitute */
        n[g - 1] + 2
      );
      i[g] = p, d = Math.min(d, p);
    }
    for (let g = u + 1; g <= e.length; g += 1)
      i[g] = r;
    if (d > t)
      return;
    const f = n;
    n = i, i = f;
  }
  const o = n[e.length];
  return o > t ? void 0 : o;
}
function un(s) {
  return typeof s == "string" && s.slice(-1) === "%";
}
function Lt(s, e) {
  if (s == null)
    return 0;
  let t;
  if (typeof s == "string") {
    if (t = parseFloat(s), un(s) && (t /= 100, Number.isFinite(t)))
      return t * e;
  } else
    t = s;
  return Number.isFinite(t) ? t > 0 && t < 1 ? t * e : t : 0;
}
function ms(s) {
  if (typeof s == "object") {
    let t = 0, n = 0, i = 0, r = 0;
    return s.vertical != null && Number.isFinite(s.vertical) && (n = r = s.vertical), s.horizontal != null && Number.isFinite(s.horizontal) && (i = t = s.horizontal), s.left != null && Number.isFinite(s.left) && (t = s.left), s.top != null && Number.isFinite(s.top) && (n = s.top), s.right != null && Number.isFinite(s.right) && (i = s.right), s.bottom != null && Number.isFinite(s.bottom) && (r = s.bottom), { top: n, right: i, bottom: r, left: t };
  }
  let e = 0;
  return s != null && Number.isFinite(s) && (e = s), { top: e, right: e, bottom: e, left: e };
}
let ac = !1, uf = !1, df = !1, ff = !1, gf = !1, pf = !1, mf = !1, wf = !1, yf = !1, bf = !1, vf = !1, xf = !1, Cf = !1, Ef = !1, Sf = !1, Af = !1;
if (typeof navigator == "object") {
  const s = navigator.userAgent;
  ac = s.indexOf("Macintosh") >= 0, uf = !!s.match(/(iPad|iPhone|iPod)/g), df = s.indexOf("Windows") >= 0, ff = s.indexOf("MSIE") >= 0, gf = !!s.match(/Trident\/7\./), pf = !!s.match(/Edge\//), mf = s.indexOf("Mozilla/") >= 0 && s.indexOf("MSIE") < 0 && s.indexOf("Edge/") < 0, yf = s.indexOf("Chrome/") >= 0 && s.indexOf("Edge/") < 0, bf = s.indexOf("Opera/") >= 0 || s.indexOf("OPR/") >= 0, vf = s.indexOf("Firefox/") >= 0, xf = s.indexOf("AppleWebKit/") >= 0 && s.indexOf("Chrome/") < 0 && s.indexOf("Edge/") < 0, typeof document == "object" && (Af = !document.createElementNS || "".concat(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")) !== "[object SVGForeignObjectElement]" || s.indexOf("Opera/") >= 0);
}
typeof window == "object" && (wf = window.chrome != null && window.chrome.app != null && window.chrome.app.runtime != null, Ef = window.PointerEvent != null && !ac);
if (typeof document == "object") {
  Cf = "ontouchstart" in document.documentElement;
  try {
    const s = Object.defineProperty({}, "passive", {
      get() {
        Sf = !0;
      }
    }), e = document.createElement("div");
    e.addEventListener && e.addEventListener("click", () => {
    }, s);
  } catch (s) {
  }
}
var In;
(function(s) {
  s.IS_MAC = ac, s.IS_IOS = uf, s.IS_WINDOWS = df, s.IS_IE = ff, s.IS_IE11 = gf, s.IS_EDGE = pf, s.IS_NETSCAPE = mf, s.IS_CHROME_APP = wf, s.IS_CHROME = yf, s.IS_OPERA = bf, s.IS_FIREFOX = vf, s.IS_SAFARI = xf, s.SUPPORT_TOUCH = Cf, s.SUPPORT_POINTER = Ef, s.SUPPORT_PASSIVE = Sf, s.NO_FOREIGNOBJECT = Af, s.SUPPORT_FOREIGNOBJECT = !s.NO_FOREIGNOBJECT;
})(In || (In = {}));
(function(s) {
  function e() {
    const r = window.module;
    return r != null && r.hot != null && r.hot.status != null ? r.hot.status() : "unkonwn";
  }
  s.getHMRStatus = e;
  function t() {
    return e() === "apply";
  }
  s.isApplyingHMR = t;
  const n = {
    select: "input",
    change: "input",
    submit: "form",
    reset: "form",
    error: "img",
    load: "img",
    abort: "img"
  };
  function i(r) {
    const o = document.createElement(n[r] || "div"), a = "on".concat(r);
    let l = a in o;
    return l || (o.setAttribute(a, "return;"), l = typeof o[a] == "function"), l;
  }
  s.isEventSupported = i;
})(In || (In = {}));
const lc = /[\t\r\n\f]/g, cc = /\S+/g, Zs = (s) => " ".concat(s, " ");
function Ks(s) {
  return s && s.getAttribute && s.getAttribute("class") || "";
}
function xr(s, e) {
  if (s == null || e == null)
    return !1;
  const t = Zs(Ks(s)), n = Zs(e);
  return s.nodeType === 1 ? t.replace(lc, " ").includes(n) : !1;
}
function ie(s, e) {
  if (!(s == null || e == null)) {
    if (typeof e == "function")
      return ie(s, e(Ks(s)));
    if (typeof e == "string" && s.nodeType === 1) {
      const t = e.match(cc) || [], n = Zs(Ks(s)).replace(lc, " ");
      let i = t.reduce((r, o) => r.indexOf(Zs(o)) < 0 ? "".concat(r).concat(o, " ") : r, n);
      i = i.trim(), n !== i && s.setAttribute("class", i);
    }
  }
}
function kt(s, e) {
  if (s != null) {
    if (typeof e == "function")
      return kt(s, e(Ks(s)));
    if ((!e || typeof e == "string") && s.nodeType === 1) {
      const t = (e || "").match(cc) || [], n = Zs(Ks(s)).replace(lc, " ");
      let i = t.reduce((r, o) => {
        const a = Zs(o);
        return r.indexOf(a) > -1 ? r.replace(a, " ") : r;
      }, n);
      i = e ? i.trim() : "", n !== i && s.setAttribute("class", i);
    }
  }
}
function Mf(s, e, t) {
  if (!(s == null || e == null)) {
    if (t != null && typeof e == "string") {
      t ? ie(s, e) : kt(s, e);
      return;
    }
    if (typeof e == "function")
      return Mf(s, e(Ks(s), t), t);
    typeof e == "string" && (e.match(cc) || []).forEach((i) => {
      xr(s, i) ? kt(s, i) : ie(s, i);
    });
  }
}
let _h = 0;
function x6() {
  return _h += 1, "v".concat(_h);
}
function hc(s) {
  return (s.id == null || s.id === "") && (s.id = x6()), s.id;
}
function jn(s) {
  return s == null ? !1 : typeof s.getScreenCTM == "function" && s instanceof SVGElement;
}
const Ue = {
  svg: "http://www.w3.org/2000/svg",
  xmlns: "http://www.w3.org/2000/xmlns/",
  xml: "http://www.w3.org/XML/1998/namespace",
  xlink: "http://www.w3.org/1999/xlink",
  xhtml: "http://www.w3.org/1999/xhtml"
}, Oh = "1.1";
function Th(s, e = document) {
  return e.createElement(s);
}
function uc(s, e = Ue.xhtml, t = document) {
  return t.createElementNS(e, s);
}
function Bt(s, e = document) {
  return uc(s, Ue.svg, e);
}
function bo(s) {
  if (s) {
    const t = '<svg xmlns="'.concat(Ue.svg, '" xmlns:xlink="').concat(Ue.xlink, '" version="').concat(Oh, '">').concat(s, "</svg>"), { documentElement: n } = C6(t, { async: !1 });
    return n;
  }
  const e = document.createElementNS(Ue.svg, "svg");
  return e.setAttributeNS(Ue.xmlns, "xmlns:xlink", Ue.xlink), e.setAttribute("version", Oh), e;
}
function C6(s, e = {}) {
  let t;
  try {
    const n = new DOMParser();
    if (e.async != null) {
      const i = n;
      i.async = e.async;
    }
    t = n.parseFromString(s, e.mimeType || "text/xml");
  } catch (n) {
    t = void 0;
  }
  if (!t || t.getElementsByTagName("parsererror").length)
    throw new Error("Invalid XML: ".concat(s));
  return t;
}
function E6(s, e = !0) {
  const t = s.nodeName;
  return e ? t.toLowerCase() : t.toUpperCase();
}
function dc(s) {
  let e = 0, t = s.previousSibling;
  for (; t; )
    t.nodeType === 1 && (e += 1), t = t.previousSibling;
  return e;
}
function S6(s, e) {
  return s.querySelectorAll(e);
}
function A6(s, e) {
  return s.querySelector(e);
}
function kf(s, e, t) {
  const n = s.ownerSVGElement;
  let i = s.parentNode;
  for (; i && i !== t && i !== n; ) {
    if (xr(i, e))
      return i;
    i = i.parentNode;
  }
  return null;
}
function Pf(s, e) {
  const t = e && e.parentNode;
  return s === t || !!(t && t.nodeType === 1 && s.compareDocumentPosition(t) & 16);
}
function Qs(s) {
  s && (Array.isArray(s) ? s : [s]).forEach((t) => {
    t.parentNode && t.parentNode.removeChild(t);
  });
}
function Cr(s) {
  for (; s.firstChild; )
    s.removeChild(s.firstChild);
}
function Er(s, e) {
  (Array.isArray(e) ? e : [e]).forEach((n) => {
    n != null && s.appendChild(n);
  });
}
function M6(s, e) {
  const t = s.firstChild;
  return t ? fc(t, e) : Er(s, e);
}
function fc(s, e) {
  const t = s.parentNode;
  t && (Array.isArray(e) ? e : [e]).forEach((i) => {
    i != null && t.insertBefore(i, s);
  });
}
function k6(s, e) {
  e != null && e.appendChild(s);
}
function Lh(s) {
  try {
    return s instanceof HTMLElement;
  } catch (e) {
    return typeof s == "object" && s.nodeType === 1 && typeof s.style == "object" && typeof s.ownerDocument == "object";
  }
}
const _f = [
  "viewBox",
  "attributeName",
  "attributeType",
  "repeatCount",
  "textLength",
  "lengthAdjust",
  "gradientUnits"
];
function P6(s, e) {
  return s.getAttribute(e);
}
function Of(s, e) {
  const t = Lf(e);
  t.ns ? s.hasAttributeNS(t.ns, t.local) && s.removeAttributeNS(t.ns, t.local) : s.hasAttribute(e) && s.removeAttribute(e);
}
function gc(s, e, t) {
  if (t == null)
    return Of(s, e);
  const n = Lf(e);
  n.ns && typeof t == "string" ? s.setAttributeNS(n.ns, e, t) : e === "id" ? s.id = "".concat(t) : s.setAttribute(e, "".concat(t));
}
function Tf(s, e) {
  Object.keys(e).forEach((t) => {
    gc(s, t, e[t]);
  });
}
function ge(s, e, t) {
  if (e == null) {
    const n = s.attributes, i = {};
    for (let r = 0; r < n.length; r += 1)
      i[n[r].name] = n[r].value;
    return i;
  }
  if (typeof e == "string" && t === void 0)
    return s.getAttribute(e);
  typeof e == "object" ? Tf(s, e) : gc(s, e, t);
}
function Lf(s) {
  if (s.indexOf(":") !== -1) {
    const e = s.split(":");
    return {
      ns: Ue[e[0]],
      local: e[1]
    };
  }
  return {
    ns: null,
    local: s
  };
}
function sr(s) {
  const e = {};
  return Object.keys(s).forEach((t) => {
    const n = _f.includes(t) ? t : hf(t);
    e[n] = s[t];
  }), e;
}
function $r(s) {
  const e = {};
  return s.split(";").forEach((n) => {
    const i = n.trim();
    if (i) {
      const r = i.split("=");
      r.length && (e[r[0].trim()] = r[1] ? r[1].trim() : "");
    }
  }), e;
}
function dl(s, e) {
  return Object.keys(e).forEach((t) => {
    if (t === "class")
      s[t] = s[t] ? "".concat(s[t], " ").concat(e[t]) : e[t];
    else if (t === "style") {
      const n = typeof s[t] == "object", i = typeof e[t] == "object";
      let r, o;
      n && i ? (r = s[t], o = e[t]) : n ? (r = s[t], o = $r(e[t])) : i ? (r = $r(s[t]), o = e[t]) : (r = $r(s[t]), o = $r(e[t])), s[t] = dl(r, o);
    } else
      s[t] = e[t];
  }), s;
}
function _6(s, e, t = {}) {
  const n = t.offset || 0, i = [], r = [];
  let o, a, l = null;
  for (let c = 0; c < s.length; c += 1) {
    o = r[c] = s[c];
    for (let u = 0, d = e.length; u < d; u += 1) {
      const f = e[u], g = f.start + n, p = f.end + n;
      c >= g && c < p && (typeof o == "string" ? o = r[c] = {
        t: s[c],
        attrs: f.attrs
      } : o.attrs = dl(dl({}, o.attrs), f.attrs), t.includeAnnotationIndices && (o.annotations == null && (o.annotations = []), o.annotations.push(u)));
    }
    a = r[c - 1], a ? Pi(o) && Pi(a) ? (l = l, JSON.stringify(o.attrs) === JSON.stringify(a.attrs) ? l.t += o.t : (i.push(l), l = o)) : Pi(o) || Pi(a) ? (l = l, i.push(l), l = o) : l = (l || "") + o : l = o;
  }
  return l != null && i.push(l), i;
}
function O6(s) {
  return s.replace(/ /g, " ");
}
var Nh;
(function(s) {
  function e(c) {
    const u = "data:";
    return c.substr(0, u.length) === u;
  }
  s.isDataUrl = e;
  function t(c, u) {
    if (!c || e(c)) {
      setTimeout(() => u(null, c));
      return;
    }
    const d = () => {
      u(new Error("Failed to load image: ".concat(c)));
    }, f = window.FileReader ? (
      // chrome, IE10+
      (p) => {
        if (p.status === 200) {
          const m = new FileReader();
          m.onload = (w) => {
            const v = w.target.result;
            u(null, v);
          }, m.onerror = d, m.readAsDataURL(p.response);
        } else
          d();
      }
    ) : (p) => {
      const m = (w) => {
        const y = [];
        for (let b = 0; b < w.length; b += 32768)
          y.push(String.fromCharCode.apply(null, w.subarray(b, b + 32768)));
        return y.join("");
      };
      if (p.status === 200) {
        let w = c.split(".").pop() || "png";
        w === "svg" && (w = "svg+xml");
        const v = "data:image/".concat(w, ";base64,"), y = new Uint8Array(p.response), b = v + btoa(m(y));
        u(null, b);
      } else
        d();
    }, g = new XMLHttpRequest();
    g.responseType = window.FileReader ? "blob" : "arraybuffer", g.open("GET", c, !0), g.addEventListener("error", d), g.addEventListener("load", () => f(g)), g.send();
  }
  s.imageToDataUri = t;
  function n(c) {
    let u = c.replace(/\s/g, "");
    u = decodeURIComponent(u);
    const d = u.indexOf(","), f = u.slice(0, d), g = f.split(":")[1].split(";")[0], p = u.slice(d + 1);
    let m;
    f.indexOf("base64") >= 0 ? m = atob(p) : m = unescape(encodeURIComponent(p));
    const w = new Uint8Array(m.length);
    for (let v = 0; v < m.length; v += 1)
      w[v] = m.charCodeAt(v);
    return new Blob([w], { type: g });
  }
  s.dataUriToBlob = n;
  function i(c, u) {
    const d = window.navigator.msSaveBlob;
    if (d)
      d(c, u);
    else {
      const f = window.URL.createObjectURL(c), g = document.createElement("a");
      g.href = f, g.download = u, document.body.appendChild(g), g.click(), document.body.removeChild(g), window.URL.revokeObjectURL(f);
    }
  }
  s.downloadBlob = i;
  function r(c, u) {
    const d = n(c);
    i(d, u);
  }
  s.downloadDataUri = r;
  function o(c) {
    const u = c.match(/<svg[^>]*viewBox\s*=\s*(["']?)(.+?)\1[^>]*>/i);
    return u && u[2] ? u[2].replace(/\s+/, " ").split(" ") : null;
  }
  function a(c) {
    const u = parseFloat(c);
    return Number.isNaN(u) ? null : u;
  }
  function l(c, u = {}) {
    let d = null;
    const f = (b) => (d == null && (d = o(c)), d != null ? a(d[b]) : null), g = (b) => {
      const x = c.match(b);
      return x && x[2] ? a(x[2]) : null;
    };
    let p = u.width;
    if (p == null && (p = g(/<svg[^>]*width\s*=\s*(["']?)(.+?)\1[^>]*>/i)), p == null && (p = f(2)), p == null)
      throw new Error("Can not parse width from svg string");
    let m = u.height;
    if (m == null && (m = g(/<svg[^>]*height\s*=\s*(["']?)(.+?)\1[^>]*>/i)), m == null && (m = f(3)), m == null)
      throw new Error("Can not parse height from svg string");
    const w = encodeURIComponent(c).replace(/'/g, "%27").replace(/"/g, "%22"), v = "data:image/svg+xml";
    return "".concat(v, ",").concat(w);
  }
  s.svgToDataUrl = l;
})(Nh || (Nh = {}));
let es;
const T6 = {
  px(s) {
    return s;
  },
  mm(s) {
    return es * s;
  },
  cm(s) {
    return es * s * 10;
  },
  in(s) {
    return es * s * 25.4;
  },
  pt(s) {
    return es * (25.4 * s / 72);
  },
  pc(s) {
    return es * (25.4 * s / 6);
  }
};
var Dh;
(function(s) {
  function e(n, i, r) {
    const o = document.createElement("div"), a = o.style;
    a.display = "inline-block", a.position = "absolute", a.left = "-15000px", a.top = "-15000px", a.width = n + (r || "px"), a.height = i + (r || "px"), document.body.appendChild(o);
    const l = o.getBoundingClientRect(), c = {
      width: l.width || 0,
      height: l.height || 0
    };
    return document.body.removeChild(o), c;
  }
  s.measure = e;
  function t(n, i) {
    es == null && (es = e("1", "1", "mm").width);
    const r = i ? T6[i] : null;
    return r ? r(n) : n;
  }
  s.toPx = t;
})(Dh || (Dh = {}));
const L6 = /-(.)/g;
function N6(s) {
  return s.replace(L6, (e, t) => t.toUpperCase());
}
const Ia = {}, Ih = ["webkit", "ms", "moz", "o"], Nf = typeof document < "u" ? document.createElement("div").style : {};
function D6(s) {
  for (let e = 0; e < Ih.length; e += 1) {
    const t = Ih[e] + s;
    if (t in Nf)
      return t;
  }
  return null;
}
function I6(s) {
  const e = N6(s);
  if (Ia[e] == null) {
    const t = e.charAt(0).toUpperCase() + e.slice(1);
    Ia[e] = e in Nf ? e : D6(t);
  }
  return Ia[e];
}
function jh(s, e) {
  const t = s.ownerDocument && s.ownerDocument.defaultView && s.ownerDocument.defaultView.opener ? s.ownerDocument.defaultView.getComputedStyle(s, null) : window.getComputedStyle(s, null);
  return t && e ? t.getPropertyValue(e) || t[e] : t;
}
const j6 = {
  animationIterationCount: !0,
  columnCount: !0,
  flexGrow: !0,
  flexShrink: !0,
  fontWeight: !0,
  gridArea: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnStart: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowStart: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  widows: !0,
  zIndex: !0
};
function R6(s) {
  return /^--/.test(s);
}
function B6(s, e, t) {
  const n = window.getComputedStyle(s, null);
  return t ? n.getPropertyValue(e) || void 0 : n[e] || s.style[e];
}
function F6(s, e) {
  return !j6[s] && typeof e == "number" ? "".concat(e, "px") : e;
}
function Sr(s, e, t) {
  if (typeof e == "string") {
    const n = R6(e);
    if (n || (e = I6(e)), t === void 0)
      return B6(s, e, n);
    n || (t = F6(e, t));
    const i = s.style;
    n ? i.setProperty(e, t) : i[e] = t;
    return;
  }
  for (const n in e)
    Sr(s, n, e[n]);
}
const vo = /* @__PURE__ */ new WeakMap();
function Rh(s, e) {
  const t = No(e), n = vo.get(s);
  if (n)
    return n[t];
}
function $6(s, e, t) {
  const n = No(e), i = vo.get(s);
  i ? i[n] = t : vo.set(s, {
    [n]: t
  });
}
function ws(s, e, t) {
  if (!e) {
    const n = {};
    return Object.keys(vo).forEach((i) => {
      n[i] = Rh(s, i);
    }), n;
  }
  if (typeof e == "string") {
    if (t === void 0)
      return Rh(s, e);
    $6(s, e, t);
    return;
  }
  for (const n in e)
    ws(s, n, e[n]);
}
class G {
  get [Symbol.toStringTag]() {
    return G.toStringTag;
  }
  get type() {
    return this.node.nodeName;
  }
  get id() {
    return this.node.id;
  }
  set id(e) {
    this.node.id = e;
  }
  constructor(e, t, n) {
    if (!e)
      throw new TypeError("Invalid element to create vector");
    let i;
    if (G.isVector(e))
      i = e.node;
    else if (typeof e == "string")
      if (e.toLowerCase() === "svg")
        i = bo();
      else if (e[0] === "<") {
        const r = bo(e);
        i = document.importNode(r.firstChild, !0);
      } else
        i = document.createElementNS(Ue.svg, e);
    else
      i = e;
    this.node = i, t && this.setAttributes(t), n && this.append(n);
  }
  transform(e, t) {
    return e == null ? ei(this.node) : (ei(this.node, e, t), this);
  }
  translate(e, t = 0, n = {}) {
    return e == null ? Fh(this.node) : (Fh(this.node, e, t, n), this);
  }
  rotate(e, t, n, i = {}) {
    return e == null ? pl(this.node) : (pl(this.node, e, t, n, i), this);
  }
  scale(e, t) {
    return e == null ? ml(this.node) : (ml(this.node, e, t), this);
  }
  /**
   * Returns an SVGMatrix that specifies the transformation necessary
   * to convert this coordinate system into `target` coordinate system.
   */
  getTransformToElement(e) {
    const t = G.toNode(e);
    return Bi(this.node, t);
  }
  removeAttribute(e) {
    return Of(this.node, e), this;
  }
  getAttribute(e) {
    return P6(this.node, e);
  }
  setAttribute(e, t) {
    return gc(this.node, e, t), this;
  }
  setAttributes(e) {
    return Tf(this.node, e), this;
  }
  attr(e, t) {
    return e == null ? ge(this.node) : typeof e == "string" && t === void 0 ? ge(this.node, e) : (typeof e == "object" ? ge(this.node, e) : ge(this.node, e, t), this);
  }
  svg() {
    return this.node instanceof SVGSVGElement ? this : G.create(this.node.ownerSVGElement);
  }
  defs() {
    const e = this.svg() || this, t = e.node.getElementsByTagName("defs")[0];
    return t ? G.create(t) : G.create("defs").appendTo(e);
  }
  text(e, t = {}) {
    return If(this.node, e, t), this;
  }
  tagName() {
    return E6(this.node);
  }
  clone() {
    return G.create(this.node.cloneNode(!0));
  }
  remove() {
    return Qs(this.node), this;
  }
  empty() {
    return Cr(this.node), this;
  }
  append(e) {
    return Er(this.node, G.toNodes(e)), this;
  }
  appendTo(e) {
    return k6(this.node, G.isVector(e) ? e.node : e), this;
  }
  prepend(e) {
    return M6(this.node, G.toNodes(e)), this;
  }
  before(e) {
    return fc(this.node, G.toNodes(e)), this;
  }
  replace(e) {
    return this.node.parentNode && this.node.parentNode.replaceChild(G.toNode(e), this.node), G.create(e);
  }
  first() {
    return this.node.firstChild ? G.create(this.node.firstChild) : null;
  }
  last() {
    return this.node.lastChild ? G.create(this.node.lastChild) : null;
  }
  get(e) {
    const t = this.node.childNodes[e];
    return t ? G.create(t) : null;
  }
  indexOf(e) {
    return Array.prototype.slice.call(this.node.childNodes).indexOf(G.toNode(e));
  }
  find(e) {
    const t = [], n = S6(this.node, e);
    if (n)
      for (let i = 0, r = n.length; i < r; i += 1)
        t.push(G.create(n[i]));
    return t;
  }
  findOne(e) {
    const t = A6(this.node, e);
    return t ? G.create(t) : null;
  }
  findParentByClass(e, t) {
    const n = kf(this.node, e, t);
    return n ? G.create(n) : null;
  }
  matches(e) {
    const t = this.node;
    this.node.matches;
    const n = t.matches || t.matchesSelector || t.msMatchesSelector || t.mozMatchesSelector || t.webkitMatchesSelector || t.oMatchesSelector || null;
    return n && n.call(t, e);
  }
  contains(e) {
    return Pf(this.node, G.isVector(e) ? e.node : e);
  }
  wrap(e) {
    const t = G.create(e), n = this.node.parentNode;
    return n != null && n.insertBefore(t.node, this.node), t.append(this);
  }
  parent(e) {
    let t = this;
    if (t.node.parentNode == null)
      return null;
    if (t = G.create(t.node.parentNode), e == null)
      return t;
    do
      if (typeof e == "string" ? t.matches(e) : t instanceof e)
        return t;
    while (t = G.create(t.node.parentNode));
    return t;
  }
  children() {
    const e = this.node.childNodes, t = [];
    for (let n = 0; n < e.length; n += 1)
      e[n].nodeType === 1 && t.push(G.create(e[n]));
    return t;
  }
  eachChild(e, t) {
    const n = this.children();
    for (let i = 0, r = n.length; i < r; i += 1)
      e.call(n[i], n[i], i, n), t && n[i].eachChild(e, t);
    return this;
  }
  index() {
    return dc(this.node);
  }
  hasClass(e) {
    return xr(this.node, e);
  }
  addClass(e) {
    return ie(this.node, e), this;
  }
  removeClass(e) {
    return kt(this.node, e), this;
  }
  toggleClass(e, t) {
    return Mf(this.node, e, t), this;
  }
  toLocalPoint(e, t) {
    return o3(this.node, e, t);
  }
  /**
   * Samples the underlying SVG element (it currently works only on
   * paths - where it is most useful anyway). Returns an array of objects
   * of the form `{ x: Number, y: Number, distance: Number }`. Each of these
   * objects represent a point on the path. This basically creates a discrete
   * representation of the path (which is possible a curve). The sampling
   * interval defines the accuracy of the sampling. In other words, we travel
   * from the beginning of the path to the end by interval distance (on the
   * path, not between the resulting points) and collect the discrete points
   * on the path. This is very useful in many situations. For example, SVG
   * does not provide a built-in mechanism to find intersections between two
   * paths. Using sampling, we can just generate bunch of points for each of
   * the path and find the closest ones from each set.
   */
  sample(e = 1) {
    return this.node instanceof SVGPathElement ? U6(this.node, e) : [];
  }
  toPath() {
    return G.create(Z6(this.node));
  }
  toPathData() {
    return Ff(this.node);
  }
}
(function(s) {
  s.toStringTag = "X6.".concat(s.name);
  function e(o) {
    if (o == null)
      return !1;
    if (o instanceof s)
      return !0;
    const a = o[Symbol.toStringTag], l = o;
    return (a == null || a === s.toStringTag) && l.node instanceof SVGElement && typeof l.sample == "function" && typeof l.toPath == "function";
  }
  s.isVector = e;
  function t(o, a, l) {
    return new s(o, a, l);
  }
  s.create = t;
  function n(o) {
    if (o[0] === "<") {
      const a = bo(o), l = [];
      for (let c = 0, u = a.childNodes.length; c < u; c += 1) {
        const d = a.childNodes[c];
        l.push(t(document.importNode(d, !0)));
      }
      return l;
    }
    return [t(o)];
  }
  s.createVectors = n;
  function i(o) {
    return e(o) ? o.node : o;
  }
  s.toNode = i;
  function r(o) {
    return Array.isArray(o) ? o.map((a) => i(a)) : [i(o)];
  }
  s.toNodes = r;
})(G || (G = {}));
function z6(s, e) {
  const t = G.create(e), n = G.create("textPath"), i = s.d;
  if (i && s["xlink:href"] === void 0) {
    const r = G.create("path").attr("d", i).appendTo(t.defs());
    n.attr("xlink:href", "#".concat(r.id));
  }
  return typeof s == "object" && n.attr(s), n.node;
}
function V6(s, e, t) {
  const n = t.eol, i = t.baseSize, r = t.lineHeight;
  let o = 0, a;
  const l = {}, c = e.length - 1;
  for (let u = 0; u <= c; u += 1) {
    let d = e[u], f = null;
    if (typeof d == "object") {
      const g = d.attrs, p = G.create("tspan", g);
      a = p.node;
      let m = d.t;
      n && u === c && (m += n), a.textContent = m;
      const w = g.class;
      w && p.addClass(w), t.includeAnnotationIndices && p.attr("annotations", d.annotations.join(",")), f = parseFloat(g["font-size"]), f === void 0 && (f = i), f && f > o && (o = f);
    } else
      n && u === c && (d += n), a = document.createTextNode(d || " "), i && i > o && (o = i);
    s.appendChild(a);
  }
  return o && (l.maxFontSize = o), r ? l.lineHeight = r : o && (l.lineHeight = o * 1.2), l;
}
const Df = /em$/;
function zr(s, e) {
  const t = parseFloat(s);
  return Df.test(s) ? t * e : t;
}
function H6(s, e, t, n) {
  if (!Array.isArray(e))
    return 0;
  const i = e.length;
  if (!i)
    return 0;
  let r = e[0];
  const o = zr(r.maxFontSize, t) || t;
  let a = 0;
  const l = zr(n, t);
  for (let d = 1; d < i; d += 1) {
    r = e[d];
    const f = zr(r.lineHeight, t) || l;
    a += f;
  }
  const c = zr(r.maxFontSize, t) || t;
  let u;
  switch (s) {
    case "middle":
      u = o / 2 - 0.15 * c - a / 2;
      break;
    case "bottom":
      u = -(0.25 * c) - a;
      break;
    case "top":
    default:
      u = 0.8 * o;
      break;
  }
  return u;
}
function If(s, e, t = {}) {
  e = O6(e);
  const n = t.eol;
  let i = t.textPath;
  const r = t.textVerticalAnchor, o = r === "middle" || r === "bottom" || r === "top";
  let a = t.x;
  a === void 0 && (a = s.getAttribute("x") || 0);
  const l = t.includeAnnotationIndices;
  let c = t.annotations;
  c && !Array.isArray(c) && (c = [c]);
  const u = t.lineHeight, d = u === "auto", f = d ? "1.5em" : u || "1em";
  let g = !0;
  const p = s.childNodes;
  if (p.length === 1) {
    const P = p[0];
    P && P.tagName.toUpperCase() === "TITLE" && (g = !1);
  }
  g && Cr(s), ge(s, {
    // Preserve spaces, do not consecutive spaces to get collapsed to one.
    "xml:space": "preserve",
    // An empty text gets rendered into the DOM in webkit-based browsers.
    // In order to unify this behaviour across all browsers
    // we rather hide the text element when it's empty.
    display: e || t.displayEmpty ? null : "none"
  });
  const m = ge(s, "font-size");
  let w = parseFloat(m);
  w || (w = 16, (o || c) && !m && ge(s, "font-size", "".concat(w)));
  let v;
  i ? (typeof i == "string" && (i = { d: i }), v = z6(i, s)) : v = document.createDocumentFragment();
  let y, b = 0, x;
  const C = e.split("\n"), A = [], k = C.length - 1;
  for (let P = 0; P <= k; P += 1) {
    y = f;
    let D = "v-line";
    const N = Bt("tspan");
    let F, ee = C[P];
    if (ee)
      if (c) {
        const X = _6(ee, c, {
          offset: -b,
          includeAnnotationIndices: l
        });
        F = V6(N, X, {
          eol: P !== k && n,
          baseSize: w,
          lineHeight: d ? null : f,
          includeAnnotationIndices: l
        });
        const _ = F.lineHeight;
        _ && d && P !== 0 && (y = _), P === 0 && (x = F.maxFontSize * 0.8);
      } else
        n && P !== k && (ee += n), N.textContent = ee;
    else {
      N.textContent = "-", D += " v-empty-line";
      const X = N.style;
      X.fillOpacity = 0, X.strokeOpacity = 0, c && (F = {});
    }
    F && A.push(F), P > 0 && N.setAttribute("dy", y), (P > 0 || i) && N.setAttribute("x", a), N.className.baseVal = D, v.appendChild(N), b += ee.length + 1;
  }
  if (o)
    if (c)
      y = H6(r, A, w, f);
    else if (r === "top")
      y = "0.8em";
    else {
      let P;
      switch (k > 0 ? (P = parseFloat(f) || 1, P *= k, Df.test(f) || (P /= w)) : P = 0, r) {
        case "middle":
          y = "".concat(0.3 - P / 2, "em");
          break;
        case "bottom":
          y = "".concat(-P - 0.3, "em");
          break;
      }
    }
  else
    r === 0 ? y = "0em" : r ? y = r : (y = 0, s.getAttribute("y") == null && s.setAttribute("y", "".concat(x || "0.8em")));
  v.firstChild.setAttribute("dy", y), s.appendChild(v);
}
function Ri(s, e = {}) {
  const t = document.createElement("canvas").getContext("2d");
  if (!s)
    return { width: 0 };
  const n = [], i = e["font-size"] ? "".concat(parseFloat(e["font-size"]), "px") : "14px";
  return n.push(e["font-style"] || "normal"), n.push(e["font-variant"] || "normal"), n.push(e["font-weight"] || 400), n.push(i), n.push(e["font-family"] || "sans-serif"), t.font = n.join(" "), t.measureText(s);
}
function Bh(s, e, t, n = {}) {
  if (e >= t)
    return [s, ""];
  const i = s.length, r = {};
  let o = Math.round(e / t * i - 1);
  for (o < 0 && (o = 0); o >= 0 && o < i; ) {
    const a = s.slice(0, o), l = r[a] || Ri(a, n).width, c = s.slice(0, o + 1), u = r[c] || Ri(c, n).width;
    if (r[a] = l, r[c] = u, l > e)
      o -= 1;
    else if (u <= e)
      o += 1;
    else
      break;
  }
  return [s.slice(0, o), s.slice(o)];
}
function jf(s, e, t = {}, n = {}) {
  const i = e.width, r = e.height, o = n.eol || "\n", a = t.fontSize || 14, l = t.lineHeight ? parseFloat(t.lineHeight) : Math.ceil(a * 1.4), c = Math.floor(r / l);
  if (s.indexOf(o) > -1) {
    const w = yo(), v = [];
    return s.split(o).map((y) => {
      const b = jf(y, Object.assign(Object.assign({}, e), { height: Number.MAX_SAFE_INTEGER }), t, Object.assign(Object.assign({}, n), { eol: w }));
      b && v.push(...b.split(w));
    }), v.slice(0, c).join(o);
  }
  const { width: u } = Ri(s, t);
  if (u < i)
    return s;
  const d = [];
  let f = s, g = u, p = n.ellipsis, m = 0;
  p && (typeof p != "string" && (p = "…"), m = Ri(p, t).width);
  for (let w = 0; w < c; w += 1)
    if (g > i)
      if (w === c - 1) {
        const [y] = Bh(f, i - m, g, t);
        d.push(p ? "".concat(y).concat(p) : y);
      } else {
        const [y, b] = Bh(f, i, g, t);
        d.push(y), f = b, g = Ri(f, t).width;
      }
    else {
      d.push(f);
      break;
    }
  return d.join(o);
}
const fl = 0.551784;
function Ze(s, e, t = NaN) {
  const n = s.getAttribute(e);
  if (n == null)
    return t;
  const i = parseFloat(n);
  return Number.isNaN(i) ? t : i;
}
function U6(s, e = 1) {
  const t = s.getTotalLength(), n = [];
  let i = 0, r;
  for (; i < t; )
    r = s.getPointAtLength(i), n.push({ distance: i, x: r.x, y: r.y }), i += e;
  return n;
}
function q6(s) {
  return [
    "M",
    Ze(s, "x1"),
    Ze(s, "y1"),
    "L",
    Ze(s, "x2"),
    Ze(s, "y2")
  ].join(" ");
}
function G6(s) {
  const e = xo(s);
  return e.length === 0 ? null : "".concat(Rf(e), " Z");
}
function W6(s) {
  const e = xo(s);
  return e.length === 0 ? null : Rf(e);
}
function Rf(s) {
  const e = s.map((t) => "".concat(t.x, " ").concat(t.y));
  return "M ".concat(e.join(" L"));
}
function xo(s) {
  const e = [], t = s.points;
  if (t)
    for (let n = 0, i = t.numberOfItems; n < i; n += 1)
      e.push(t.getItem(n));
  return e;
}
function J6(s) {
  const e = Ze(s, "cx", 0), t = Ze(s, "cy", 0), n = Ze(s, "r"), i = n * fl;
  return [
    "M",
    e,
    t - n,
    "C",
    e + i,
    t - n,
    e + n,
    t - i,
    e + n,
    t,
    "C",
    e + n,
    t + i,
    e + i,
    t + n,
    e,
    t + n,
    "C",
    e - i,
    t + n,
    e - n,
    t + i,
    e - n,
    t,
    "C",
    e - n,
    t - i,
    e - i,
    t - n,
    e,
    t - n,
    "Z"
  ].join(" ");
}
function Y6(s) {
  const e = Ze(s, "cx", 0), t = Ze(s, "cy", 0), n = Ze(s, "rx"), i = Ze(s, "ry") || n, r = n * fl, o = i * fl;
  return [
    "M",
    e,
    t - i,
    "C",
    e + r,
    t - i,
    e + n,
    t - o,
    e + n,
    t,
    "C",
    e + n,
    t + o,
    e + r,
    t + i,
    e,
    t + i,
    "C",
    e - r,
    t + i,
    e - n,
    t + o,
    e - n,
    t,
    "C",
    e - n,
    t - o,
    e - r,
    t - i,
    e,
    t - i,
    "Z"
  ].join(" ");
}
function X6(s) {
  return Bf({
    x: Ze(s, "x", 0),
    y: Ze(s, "y", 0),
    width: Ze(s, "width", 0),
    height: Ze(s, "height", 0),
    rx: Ze(s, "rx", 0),
    ry: Ze(s, "ry", 0)
  });
}
function Bf(s) {
  let e;
  const t = s.x, n = s.y, i = s.width, r = s.height, o = Math.min(s.rx || s["top-rx"] || 0, i / 2), a = Math.min(s.rx || s["bottom-rx"] || 0, i / 2), l = Math.min(s.ry || s["top-ry"] || 0, r / 2), c = Math.min(s.ry || s["bottom-ry"] || 0, r / 2);
  return o || a || l || c ? e = [
    "M",
    t,
    n + l,
    "v",
    r - l - c,
    "a",
    a,
    c,
    0,
    0,
    0,
    a,
    c,
    "h",
    i - 2 * a,
    "a",
    a,
    c,
    0,
    0,
    0,
    a,
    -c,
    "v",
    -(r - c - l),
    "a",
    o,
    l,
    0,
    0,
    0,
    -o,
    -l,
    "h",
    -(i - 2 * o),
    "a",
    o,
    l,
    0,
    0,
    0,
    -o,
    l,
    "Z"
  ] : e = ["M", t, n, "H", t + i, "V", n + r, "H", t, "V", n, "Z"], e.join(" ");
}
function Z6(s) {
  const e = Bt("path");
  ge(e, ge(s));
  const t = Ff(s);
  return t && e.setAttribute("d", t), e;
}
function Ff(s) {
  const e = s.tagName.toLowerCase();
  switch (e) {
    case "path":
      return s.getAttribute("d");
    case "line":
      return q6(s);
    case "polygon":
      return G6(s);
    case "polyline":
      return W6(s);
    case "ellipse":
      return Y6(s);
    case "circle":
      return J6(s);
    case "rect":
      return X6(s);
  }
  throw new Error('"'.concat(e, '" cannot be converted to svg path element.'));
}
const K6 = /(\w+)\(([^,)]+),?([^)]+)?\)/gi, $f = /[ ,]+/, Q6 = /^(\w+)\((.*)\)/;
function e3(s, e) {
  const n = Bt("svg").createSVGPoint();
  return n.x = s, n.y = e, n;
}
function We(s) {
  const t = Bt("svg").createSVGMatrix();
  if (s != null) {
    const n = s, i = t;
    for (const r in n)
      i[r] = n[r];
  }
  return t;
}
function _i(s) {
  const e = Bt("svg");
  return s != null ? (s instanceof DOMMatrix || (s = We(s)), e.createSVGTransformFromMatrix(s)) : e.createSVGTransform();
}
function ir(s) {
  let e = We();
  const t = s != null && s.match(K6);
  if (!t)
    return e;
  for (let n = 0, i = t.length; n < i; n += 1) {
    const o = t[n].match(Q6);
    if (o) {
      let a, l, c, u, d, f = We();
      const g = o[2].split($f);
      switch (o[1].toLowerCase()) {
        case "scale":
          a = parseFloat(g[0]), l = g[1] === void 0 ? a : parseFloat(g[1]), f = f.scaleNonUniform(a, l);
          break;
        case "translate":
          c = parseFloat(g[0]), u = parseFloat(g[1]), f = f.translate(c, u);
          break;
        case "rotate":
          d = parseFloat(g[0]), c = parseFloat(g[1]) || 0, u = parseFloat(g[2]) || 0, c !== 0 || u !== 0 ? f = f.translate(c, u).rotate(d).translate(-c, -u) : f = f.rotate(d);
          break;
        case "skewx":
          d = parseFloat(g[0]), f = f.skewX(d);
          break;
        case "skewy":
          d = parseFloat(g[0]), f = f.skewY(d);
          break;
        case "matrix":
          f.a = parseFloat(g[0]), f.b = parseFloat(g[1]), f.c = parseFloat(g[2]), f.d = parseFloat(g[3]), f.e = parseFloat(g[4]), f.f = parseFloat(g[5]);
          break;
        default:
          continue;
      }
      e = e.multiply(f);
    }
  }
  return e;
}
function xi(s) {
  const e = s || {}, t = e.a != null ? e.a : 1, n = e.b != null ? e.b : 0, i = e.c != null ? e.c : 0, r = e.d != null ? e.d : 1, o = e.e != null ? e.e : 0, a = e.f != null ? e.f : 0;
  return "matrix(".concat(t, ",").concat(n, ",").concat(i, ",").concat(r, ",").concat(o, ",").concat(a, ")");
}
function Yo(s) {
  let e, t, n;
  if (s) {
    const r = $f;
    if (s.trim().indexOf("matrix") >= 0) {
      const o = ir(s), a = t3(o);
      e = [a.translateX, a.translateY], t = [a.rotation], n = [a.scaleX, a.scaleY];
      const l = [];
      (e[0] !== 0 || e[1] !== 0) && l.push("translate(".concat(e.join(","), ")")), (n[0] !== 1 || n[1] !== 1) && l.push("scale(".concat(n.join(","), ")")), t[0] !== 0 && l.push("rotate(".concat(t[0], ")")), s = l.join(" ");
    } else {
      const o = s.match(/translate\((.*?)\)/);
      o && (e = o[1].split(r));
      const a = s.match(/rotate\((.*?)\)/);
      a && (t = a[1].split(r));
      const l = s.match(/scale\((.*?)\)/);
      l && (n = l[1].split(r));
    }
  }
  const i = n && n[0] ? parseFloat(n[0]) : 1;
  return {
    raw: s || "",
    translation: {
      tx: e && e[0] ? parseInt(e[0], 10) : 0,
      ty: e && e[1] ? parseInt(e[1], 10) : 0
    },
    rotation: {
      angle: t && t[0] ? parseInt(t[0], 10) : 0,
      cx: t && t[1] ? parseInt(t[1], 10) : void 0,
      cy: t && t[2] ? parseInt(t[2], 10) : void 0
    },
    scale: {
      sx: i,
      sy: n && n[1] ? parseFloat(n[1]) : i
    }
  };
}
function gl(s, e) {
  const t = e.x * s.a + e.y * s.c + 0, n = e.x * s.b + e.y * s.d + 0;
  return { x: t, y: n };
}
function t3(s) {
  const e = gl(s, { x: 0, y: 1 }), t = gl(s, { x: 1, y: 0 }), n = 180 / Math.PI * Math.atan2(e.y, e.x) - 90, i = 180 / Math.PI * Math.atan2(t.y, t.x);
  return {
    skewX: n,
    skewY: i,
    translateX: s.e,
    translateY: s.f,
    scaleX: Math.sqrt(s.a * s.a + s.b * s.b),
    scaleY: Math.sqrt(s.c * s.c + s.d * s.d),
    rotation: n
  };
}
function n3(s) {
  let e, t, n, i;
  return s ? (e = s.a == null ? 1 : s.a, i = s.d == null ? 1 : s.d, t = s.b, n = s.c) : e = i = 1, {
    sx: t ? Math.sqrt(e * e + t * t) : e,
    sy: n ? Math.sqrt(n * n + i * i) : i
  };
}
function s3(s) {
  let e = { x: 0, y: 1 };
  s && (e = gl(s, e));
  const t = 180 * Math.atan2(e.y, e.x) / Math.PI % 360 - 90;
  return {
    angle: t % 360 + (t < 0 ? 360 : 0)
  };
}
function i3(s) {
  return {
    tx: s && s.e || 0,
    ty: s && s.f || 0
  };
}
function ei(s, e, t = {}) {
  if (e == null)
    return ir(ge(s, "transform"));
  if (t.absolute) {
    s.setAttribute("transform", xi(e));
    return;
  }
  const n = s.transform, i = _i(e);
  n.baseVal.appendItem(i);
}
function Fh(s, e, t = 0, n = {}) {
  let i = ge(s, "transform");
  const r = Yo(i);
  if (e == null)
    return r.translation;
  i = r.raw, i = i.replace(/translate\([^)]*\)/g, "").trim();
  const o = n.absolute ? e : r.translation.tx + e, a = n.absolute ? t : r.translation.ty + t, l = "translate(".concat(o, ",").concat(a, ")");
  s.setAttribute("transform", "".concat(l, " ").concat(i).trim());
}
function pl(s, e, t, n, i = {}) {
  let r = ge(s, "transform");
  const o = Yo(r);
  if (e == null)
    return o.rotation;
  r = o.raw, r = r.replace(/rotate\([^)]*\)/g, "").trim(), e %= 360;
  const a = i.absolute ? e : o.rotation.angle + e, l = t != null && n != null ? ",".concat(t, ",").concat(n) : "", c = "rotate(".concat(a).concat(l, ")");
  s.setAttribute("transform", "".concat(r, " ").concat(c).trim());
}
function ml(s, e, t) {
  let n = ge(s, "transform");
  const i = Yo(n);
  if (e == null)
    return i.scale;
  t = t == null ? e : t, n = i.raw, n = n.replace(/scale\([^)]*\)/g, "").trim();
  const r = "scale(".concat(e, ",").concat(t, ")");
  s.setAttribute("transform", "".concat(n, " ").concat(r).trim());
}
function Bi(s, e) {
  if (jn(e) && jn(s)) {
    const t = e.getScreenCTM(), n = s.getScreenCTM();
    if (t && n)
      return t.inverse().multiply(n);
  }
  return We();
}
function r3(s, e) {
  let t = We();
  if (jn(e) && jn(s)) {
    let n = s;
    const i = [];
    for (; n && n !== e; ) {
      const r = n.getAttribute("transform") || null, o = ir(r);
      i.push(o), n = n.parentNode;
    }
    i.reverse().forEach((r) => {
      t = t.multiply(r);
    });
  }
  return t;
}
function o3(s, e, t) {
  const n = s instanceof SVGSVGElement ? s : s.ownerSVGElement, i = n.createSVGPoint();
  i.x = e, i.y = t;
  try {
    const r = n.getScreenCTM(), o = i.matrixTransform(r.inverse()), a = Bi(s, n).inverse();
    return o.matrixTransform(a);
  } catch (r) {
    return i;
  }
}
var Et;
(function(s) {
  const e = {};
  function t(r) {
    return e[r] || {};
  }
  s.get = t;
  function n(r, o) {
    e[r] = o;
  }
  s.register = n;
  function i(r) {
    delete e[r];
  }
  s.unregister = i;
})(Et || (Et = {}));
var ns;
(function(s) {
  const e = /* @__PURE__ */ new WeakMap();
  function t(r) {
    return e.has(r) || e.set(r, { events: /* @__PURE__ */ Object.create(null) }), e.get(r);
  }
  s.ensure = t;
  function n(r) {
    return e.get(r);
  }
  s.get = n;
  function i(r) {
    return e.delete(r);
  }
  s.remove = i;
})(ns || (ns = {}));
var Z;
(function(s) {
  s.returnTrue = () => !0, s.returnFalse = () => !1;
  function e(i) {
    i.stopPropagation();
  }
  s.stopPropagationCallback = e;
  function t(i, r, o) {
    i.addEventListener != null && i.addEventListener(r, o);
  }
  s.addEventListener = t;
  function n(i, r, o) {
    i.removeEventListener != null && i.removeEventListener(r, o);
  }
  s.removeEventListener = n;
})(Z || (Z = {}));
(function(s) {
  const e = /[^\x20\t\r\n\f]+/g, t = /^([^.]*)(?:\.(.+)|)/;
  function n(a) {
    return (a || "").match(e) || [""];
  }
  s.splitType = n;
  function i(a) {
    const l = t.exec(a) || [];
    return {
      originType: l[1] ? l[1].trim() : l[1],
      namespaces: l[2] ? l[2].split(".").map((c) => c.trim()).sort() : []
    };
  }
  s.normalizeType = i;
  function r(a) {
    return a.nodeType === 1 || a.nodeType === 9 || !+a.nodeType;
  }
  s.isValidTarget = r;
  function o(a, l) {
    if (l) {
      const c = a;
      return c.querySelector != null && c.querySelector(l) != null;
    }
    return !0;
  }
  s.isValidSelector = o;
})(Z || (Z = {}));
(function(s) {
  let e = 0;
  const t = /* @__PURE__ */ new WeakMap();
  function n(a) {
    return t.has(a) || (t.set(a, e), e += 1), t.get(a);
  }
  s.ensureHandlerId = n;
  function i(a) {
    return t.get(a);
  }
  s.getHandlerId = i;
  function r(a) {
    return t.delete(a);
  }
  s.removeHandlerId = r;
  function o(a, l) {
    return t.set(a, l);
  }
  s.setHandlerId = o;
})(Z || (Z = {}));
(function(s) {
  function e(t, n) {
    const i = [], r = ns.get(t), o = r && r.events && r.events[n.type], a = o && o.handlers || [], l = o ? o.delegateCount : 0;
    if (l > 0 && // Support: Firefox <=42 - 66+
    // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
    // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
    // Support: IE 11+
    // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
    !(n.type === "click" && typeof n.button == "number" && n.button >= 1)) {
      for (let c = n.target; c !== t; c = c.parentNode || t)
        if (c.nodeType === 1 && !(n.type === "click" && c.disabled === !0)) {
          const u = [], d = {};
          for (let f = 0; f < l; f += 1) {
            const g = a[f], p = g.selector;
            if (p != null && d[p] == null) {
              const m = t, w = [];
              m.querySelectorAll(p).forEach((v) => {
                w.push(v);
              }), d[p] = w.includes(c);
            }
            d[p] && u.push(g);
          }
          u.length && i.push({ elem: c, handlers: u });
        }
    }
    return l < a.length && i.push({ elem: t, handlers: a.slice(l) }), i;
  }
  s.getHandlerQueue = e;
})(Z || (Z = {}));
(function(s) {
  function e(t) {
    return t != null && t === t.window;
  }
  s.isWindow = e;
})(Z || (Z = {}));
(function(s) {
  function e(t, n) {
    const i = t.nodeType === 9 ? t.documentElement : t, r = n && n.parentNode;
    return t === r || !!(r && r.nodeType === 1 && // Support: IE 9 - 11+
    // IE doesn't have `contains` on SVG.
    (i.contains ? i.contains(r) : t.compareDocumentPosition && t.compareDocumentPosition(r) & 16));
  }
  s.contains = e;
})(Z || (Z = {}));
class Wt {
  constructor(e, t) {
    this.isDefaultPrevented = Z.returnFalse, this.isPropagationStopped = Z.returnFalse, this.isImmediatePropagationStopped = Z.returnFalse, this.isSimulated = !1, this.preventDefault = () => {
      const n = this.originalEvent;
      this.isDefaultPrevented = Z.returnTrue, n && !this.isSimulated && n.preventDefault();
    }, this.stopPropagation = () => {
      const n = this.originalEvent;
      this.isPropagationStopped = Z.returnTrue, n && !this.isSimulated && n.stopPropagation();
    }, this.stopImmediatePropagation = () => {
      const n = this.originalEvent;
      this.isImmediatePropagationStopped = Z.returnTrue, n && !this.isSimulated && n.stopImmediatePropagation(), this.stopPropagation();
    }, typeof e == "string" ? this.type = e : e.type && (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented ? Z.returnTrue : Z.returnFalse, this.target = e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget, this.timeStamp = e.timeStamp), t && Object.assign(this, t), this.timeStamp || (this.timeStamp = Date.now());
  }
}
(function(s) {
  function e(t) {
    return t instanceof s ? t : new s(t);
  }
  s.create = e;
})(Wt || (Wt = {}));
(function(s) {
  function e(t, n) {
    Object.defineProperty(s.prototype, t, {
      enumerable: !0,
      configurable: !0,
      get: typeof n == "function" ? (
        // eslint-disable-next-line
        function() {
          if (this.originalEvent)
            return n(this.originalEvent);
        }
      ) : (
        // eslint-disable-next-line
        function() {
          if (this.originalEvent)
            return this.originalEvent[t];
        }
      ),
      set(i) {
        Object.defineProperty(this, t, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: i
        });
      }
    });
  }
  s.addProperty = e;
})(Wt || (Wt = {}));
(function(s) {
  const e = {
    bubbles: !0,
    cancelable: !0,
    eventPhase: !0,
    detail: !0,
    view: !0,
    button: !0,
    buttons: !0,
    clientX: !0,
    clientY: !0,
    offsetX: !0,
    offsetY: !0,
    pageX: !0,
    pageY: !0,
    screenX: !0,
    screenY: !0,
    toElement: !0,
    pointerId: !0,
    pointerType: !0,
    char: !0,
    code: !0,
    charCode: !0,
    key: !0,
    keyCode: !0,
    touches: !0,
    changedTouches: !0,
    targetTouches: !0,
    which: !0,
    altKey: !0,
    ctrlKey: !0,
    metaKey: !0,
    shiftKey: !0
  };
  Object.keys(e).forEach((t) => s.addProperty(t, e[t]));
})(Wt || (Wt = {}));
(function(s) {
  Et.register("load", {
    noBubble: !0
  });
})();
(function(s) {
  Et.register("beforeunload", {
    postDispatch(e, t) {
      t.result !== void 0 && t.originalEvent && (t.originalEvent.returnValue = t.result);
    }
  });
})();
(function(s) {
  Et.register("mouseenter", {
    delegateType: "mouseover",
    bindType: "mouseover",
    handle(e, t) {
      let n;
      const i = t.relatedTarget, r = t.handleObj;
      return (!i || i !== e && !Z.contains(e, i)) && (t.type = r.originType, n = r.handler.call(e, t), t.type = "mouseover"), n;
    }
  }), Et.register("mouseleave", {
    delegateType: "mouseout",
    bindType: "mouseout",
    handle(e, t) {
      let n;
      const i = t.relatedTarget, r = t.handleObj;
      return (!i || i !== e && !Z.contains(e, i)) && (t.type = r.originType, n = r.handler.call(e, t), t.type = "mouseout"), n;
    }
  });
})();
var a3 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
}, rr;
(function(s) {
  let e;
  function t(o, a, l, c, u) {
    if (!Z.isValidTarget(o))
      return;
    let d;
    if (typeof l != "function") {
      const { handler: m, selector: w } = l, v = a3(l, ["handler", "selector"]);
      l = m, u = w, d = v;
    }
    const f = ns.ensure(o);
    let g = f.handler;
    g == null && (g = f.handler = function(m, ...w) {
      return e !== m.type ? i(o, m, ...w) : void 0;
    });
    const p = Z.ensureHandlerId(l);
    Z.splitType(a).forEach((m) => {
      const { originType: w, namespaces: v } = Z.normalizeType(m);
      if (!w)
        return;
      let y = w, b = Et.get(y);
      y = (u ? b.delegateType : b.bindType) || y, b = Et.get(y);
      const x = Object.assign({
        type: y,
        originType: w,
        data: c,
        selector: u,
        guid: p,
        handler: l,
        namespace: v.join(".")
      }, d), C = f.events;
      let A = C[y];
      A || (A = C[y] = { handlers: [], delegateCount: 0 }, (!b.setup || b.setup(o, c, v, g) === !1) && Z.addEventListener(o, y, g)), b.add && (Z.removeHandlerId(x.handler), b.add(o, x), Z.setHandlerId(x.handler, p)), u ? (A.handlers.splice(A.delegateCount, 0, x), A.delegateCount += 1) : A.handlers.push(x);
    });
  }
  s.on = t;
  function n(o, a, l, c, u) {
    const d = ns.get(o);
    if (!d)
      return;
    const f = d.events;
    f && (Z.splitType(a).forEach((g) => {
      const { originType: p, namespaces: m } = Z.normalizeType(g);
      if (!p) {
        Object.keys(f).forEach((C) => {
          n(o, C + g, l, c, !0);
        });
        return;
      }
      let w = p;
      const v = Et.get(w);
      w = (c ? v.delegateType : v.bindType) || w;
      const y = f[w];
      if (!y)
        return;
      const b = m.length > 0 ? new RegExp("(^|\\.)".concat(m.join("\\.(?:.*\\.|)"), "(\\.|$)")) : null, x = y.handlers.length;
      for (let C = y.handlers.length - 1; C >= 0; C -= 1) {
        const A = y.handlers[C];
        (u || p === A.originType) && (!l || Z.getHandlerId(l) === A.guid) && (b == null || A.namespace && b.test(A.namespace)) && (c == null || c === A.selector || c === "**" && A.selector) && (y.handlers.splice(C, 1), A.selector && (y.delegateCount -= 1), v.remove && v.remove(o, A));
      }
      x && y.handlers.length === 0 && ((!v.teardown || v.teardown(o, m, d.handler) === !1) && Z.removeEventListener(o, w, d.handler), delete f[w]);
    }), Object.keys(f).length === 0 && ns.remove(o));
  }
  s.off = n;
  function i(o, a, ...l) {
    const c = Wt.create(a);
    c.delegateTarget = o;
    const u = Et.get(c.type);
    if (u.preDispatch && u.preDispatch(o, c) === !1)
      return;
    const d = Z.getHandlerQueue(o, c);
    for (let f = 0, g = d.length; f < g && !c.isPropagationStopped(); f += 1) {
      const p = d[f];
      c.currentTarget = p.elem;
      for (let m = 0, w = p.handlers.length; m < w && !c.isImmediatePropagationStopped(); m += 1) {
        const v = p.handlers[m];
        if (c.rnamespace == null || v.namespace && c.rnamespace.test(v.namespace)) {
          c.handleObj = v, c.data = v.data;
          const y = Et.get(v.originType).handle, b = y ? y(p.elem, c, ...l) : v.handler.call(p.elem, c, ...l);
          b !== void 0 && (c.result = b, b === !1 && (c.preventDefault(), c.stopPropagation()));
        }
      }
    }
    return u.postDispatch && u.postDispatch(o, c), c.result;
  }
  s.dispatch = i;
  function r(o, a, l, c) {
    let u = o, d = typeof o == "string" ? o : o.type, f = typeof o == "string" || u.namespace == null ? [] : u.namespace.split(".");
    const g = l;
    if (g.nodeType === 3 || g.nodeType === 8)
      return;
    d.indexOf(".") > -1 && (f = d.split("."), d = f.shift(), f.sort());
    const p = d.indexOf(":") < 0 && "on".concat(d);
    u = o instanceof Wt ? o : new Wt(d, typeof o == "object" ? o : null), u.namespace = f.join("."), u.rnamespace = u.namespace ? new RegExp("(^|\\.)".concat(f.join("\\.(?:.*\\.|)"), "(\\.|$)")) : null, u.result = void 0, u.target || (u.target = g);
    const m = [u];
    Array.isArray(a) ? m.push(...a) : m.push(a);
    const w = Et.get(d);
    if (!c && w.trigger && w.trigger(g, u, a) === !1)
      return;
    let v;
    const y = [g];
    if (!c && !w.noBubble && !Z.isWindow(g)) {
      v = w.delegateType || d;
      let x = g, C = g.parentNode;
      for (; C != null; )
        y.push(C), x = C, C = C.parentNode;
      const A = g.ownerDocument || document;
      if (x === A) {
        const k = x.defaultView || x.parentWindow || window;
        y.push(k);
      }
    }
    let b = g;
    for (let x = 0, C = y.length; x < C && !u.isPropagationStopped(); x += 1) {
      const A = y[x];
      b = A, u.type = x > 1 ? v : w.bindType || d;
      const k = ns.get(A);
      k && k.events[u.type] && k.handler && k.handler.call(A, ...m);
      const O = p && A[p] || null;
      O && Z.isValidTarget(A) && (u.result = O.call(A, ...m), u.result === !1 && u.preventDefault());
    }
    if (u.type = d, !c && !u.isDefaultPrevented()) {
      const x = w.preventDefault;
      if ((x == null || x(y.pop(), u, a) === !1) && Z.isValidTarget(g) && p && typeof g[d] == "function" && !Z.isWindow(g)) {
        const C = g[p];
        C && (g[p] = null), e = d, u.isPropagationStopped() && b.addEventListener(d, Z.stopPropagationCallback), g[d](), u.isPropagationStopped() && b.removeEventListener(d, Z.stopPropagationCallback), e = void 0, C && (g[p] = C);
      }
    }
    return u.result;
  }
  s.trigger = r;
})(rr || (rr = {}));
var Xe;
(function(s) {
  function e(r, o, a, l, c) {
    return Fi.on(r, o, a, l, c), r;
  }
  s.on = e;
  function t(r, o, a, l, c) {
    return Fi.on(r, o, a, l, c, !0), r;
  }
  s.once = t;
  function n(r, o, a, l) {
    return Fi.off(r, o, a, l), r;
  }
  s.off = n;
  function i(r, o, a, l) {
    return rr.trigger(o, a, r, l), r;
  }
  s.trigger = i;
})(Xe || (Xe = {}));
var Fi;
(function(s) {
  function e(n, i, r, o, a, l) {
    if (typeof i == "object") {
      typeof r != "string" && (o = o || r, r = void 0), Object.keys(i).forEach((c) => e(n, c, r, o, i[c], l));
      return;
    }
    if (o == null && a == null ? (a = r, o = r = void 0) : a == null && (typeof r == "string" ? (a = o, o = void 0) : (a = o, o = r, r = void 0)), a === !1)
      a = Z.returnFalse;
    else if (!a)
      return;
    if (l) {
      const c = a;
      a = function(u, ...d) {
        return s.off(n, u), c.call(this, u, ...d);
      }, Z.setHandlerId(a, Z.ensureHandlerId(c));
    }
    rr.on(n, i, a, o, r);
  }
  s.on = e;
  function t(n, i, r, o) {
    const a = i;
    if (a && a.preventDefault != null && a.handleObj != null) {
      const l = a.handleObj;
      t(a.delegateTarget, l.namespace ? "".concat(l.originType, ".").concat(l.namespace) : l.originType, l.selector, l.handler);
      return;
    }
    if (typeof i == "object") {
      const l = i;
      Object.keys(l).forEach((c) => t(n, c, r, l[c]));
      return;
    }
    (r === !1 || typeof r == "function") && (o = r, r = void 0), o === !1 && (o = Z.returnFalse), rr.off(n, i, o, r);
  }
  s.off = t;
})(Fi || (Fi = {}));
class zf {
  constructor(e, t, n) {
    this.animationFrameId = 0, this.deltaX = 0, this.deltaY = 0, this.eventName = In.isEventSupported("wheel") ? "wheel" : "mousewheel", this.target = e, this.onWheelCallback = t, this.onWheelGuard = n, this.onWheel = this.onWheel.bind(this), this.didWheel = this.didWheel.bind(this);
  }
  enable() {
    this.target.addEventListener(this.eventName, this.onWheel, {
      passive: !1
    });
  }
  disable() {
    this.target.removeEventListener(this.eventName, this.onWheel);
  }
  onWheel(e) {
    if (this.onWheelGuard != null && !this.onWheelGuard(e))
      return;
    this.deltaX += e.deltaX, this.deltaY += e.deltaY, e.preventDefault();
    let t;
    (this.deltaX !== 0 || this.deltaY !== 0) && (e.stopPropagation(), t = !0), t === !0 && this.animationFrameId === 0 && (this.animationFrameId = requestAnimationFrame(() => {
      this.didWheel(e);
    }));
  }
  didWheel(e) {
    this.animationFrameId = 0, this.onWheelCallback(e, this.deltaX, this.deltaY), this.deltaX = 0, this.deltaY = 0;
  }
}
function Vf(s, e = 60) {
  let t = null;
  return (...n) => {
    t && clearTimeout(t), t = window.setTimeout(() => {
      s.apply(this, n);
    }, e);
  };
}
function l3(s) {
  let e = null, t = [];
  const n = () => {
    if (getComputedStyle(s).position === "static") {
      const c = s.style;
      c.position = "relative";
    }
    const l = document.createElement("object");
    return l.onload = () => {
      l.contentDocument.defaultView.addEventListener("resize", i), i();
    }, l.style.display = "block", l.style.position = "absolute", l.style.top = "0", l.style.left = "0", l.style.height = "100%", l.style.width = "100%", l.style.overflow = "hidden", l.style.pointerEvents = "none", l.style.zIndex = "-1", l.style.opacity = "0", l.setAttribute("tabindex", "-1"), l.type = "text/html", s.appendChild(l), l.data = "about:blank", l;
  }, i = Vf(() => {
    t.forEach((l) => l(s));
  }), r = (l) => {
    e || (e = n()), t.indexOf(l) === -1 && t.push(l);
  }, o = () => {
    e && e.parentNode && (e.contentDocument && e.contentDocument.defaultView.removeEventListener("resize", i), e.parentNode.removeChild(e), e = null, t = []);
  };
  return {
    element: s,
    bind: r,
    destroy: o,
    unbind: (l) => {
      const c = t.indexOf(l);
      c !== -1 && t.splice(c, 1), t.length === 0 && e && o();
    }
  };
}
function c3(s) {
  let e = null, t = [];
  const n = Vf(() => {
    t.forEach((l) => {
      l(s);
    });
  }), i = () => {
    const l = new ResizeObserver(n);
    return l.observe(s), n(), l;
  }, r = (l) => {
    e || (e = i()), t.indexOf(l) === -1 && t.push(l);
  }, o = () => {
    e && (e.disconnect(), t = [], e = null);
  };
  return {
    element: s,
    bind: r,
    destroy: o,
    unbind: (l) => {
      const c = t.indexOf(l);
      c !== -1 && t.splice(c, 1), t.length === 0 && e && o();
    }
  };
}
const h3 = typeof ResizeObserver < "u" ? c3 : l3;
var Co;
(function(s) {
  const e = /* @__PURE__ */ new WeakMap();
  function t(i) {
    let r = e.get(i);
    return r || (r = h3(i), e.set(i, r), r);
  }
  function n(i) {
    i.destroy(), e.delete(i.element);
  }
  s.bind = (i, r) => {
    const o = t(i);
    return o.bind(r), () => o.unbind(r);
  }, s.clear = (i) => {
    const r = t(i);
    n(r);
  };
})(Co || (Co = {}));
class or {
  constructor(e = {}) {
    this.comparator = e.comparator || or.defaultComparator, this.index = {}, this.data = e.data || [], this.heapify();
  }
  /**
   * Returns `true` if the priority queue is empty, `false` otherwise.
   */
  isEmpty() {
    return this.data.length === 0;
  }
  /**
   * Inserts a value with priority to the queue. Optionally pass a unique
   * id of this item. Passing unique IDs for each item you insert allows
   * you to use the `updatePriority()` operation.
   * @param priority
   * @param value
   * @param id
   */
  insert(e, t, n) {
    const i = { priority: e, value: t }, r = this.data.length;
    return n && (i.id = n, this.index[n] = r), this.data.push(i), this.bubbleUp(r), this;
  }
  /**
   * Returns the value of an item with the highest priority.
   */
  peek() {
    return this.data[0] ? this.data[0].value : null;
  }
  /**
   * Returns the highest priority in the queue.
   */
  peekPriority() {
    return this.data[0] ? this.data[0].priority : null;
  }
  updatePriority(e, t) {
    const n = this.index[e];
    if (typeof n > "u")
      throw new Error("Node with id '".concat(e, "' was not found in the heap."));
    const i = this.data, r = i[n].priority, o = this.comparator(t, r);
    o < 0 ? (i[n].priority = t, this.bubbleUp(n)) : o > 0 && (i[n].priority = t, this.bubbleDown(n));
  }
  /**
   * Removes the item with the highest priority from the queue
   *
   * @returns The value of the removed item.
   */
  remove() {
    const e = this.data, t = e[0], n = e.pop();
    return t.id && delete this.index[t.id], e.length > 0 && (e[0] = n, n.id && (this.index[n.id] = 0), this.bubbleDown(0)), t ? t.value : null;
  }
  heapify() {
    for (let e = 0; e < this.data.length; e += 1)
      this.bubbleUp(e);
  }
  bubbleUp(e) {
    const t = this.data;
    let n, i, r = e;
    for (; r > 0 && (i = r - 1 >>> 1, this.comparator(t[r].priority, t[i].priority) < 0); ) {
      n = t[i], t[i] = t[r];
      let o = t[r].id;
      o != null && (this.index[o] = i), t[r] = n, o = t[r].id, o != null && (this.index[o] = r), r = i;
    }
  }
  bubbleDown(e) {
    const t = this.data, n = t.length - 1;
    let i = e;
    for (; ; ) {
      const r = (i << 1) + 1, o = r + 1;
      let a = i;
      if (r <= n && this.comparator(t[r].priority, t[a].priority) < 0 && (a = r), o <= n && this.comparator(t[o].priority, t[a].priority) < 0 && (a = o), a !== i) {
        const l = t[a];
        t[a] = t[i];
        let c = t[i].id;
        c != null && (this.index[c] = a), t[i] = l, c = t[i].id, c != null && (this.index[c] = i), i = a;
      } else
        break;
    }
  }
}
(function(s) {
  s.defaultComparator = (e, t) => e - t;
})(or || (or = {}));
var wl;
(function(s) {
  function e(t, n, i = (r, o) => 1) {
    const r = {}, o = {}, a = {}, l = new or();
    for (r[n] = 0, Object.keys(t).forEach((c) => {
      c !== n && (r[c] = 1 / 0), l.insert(r[c], c, c);
    }); !l.isEmpty(); ) {
      const c = l.remove();
      a[c] = !0;
      const u = t[c] || [];
      for (let d = 0; d < u.length; d += 1) {
        const f = u[d];
        if (!a[f]) {
          const g = r[c] + i(c, f);
          g < r[f] && (r[f] = g, o[f] = c, l.updatePriority(f, g));
        }
      }
    }
    return o;
  }
  s.run = e;
})(wl || (wl = {}));
class rn {
  constructor(e, t, n, i) {
    if (e == null)
      return this.set(255, 255, 255, 1);
    if (typeof e == "number")
      return this.set(e, t, n, i);
    if (typeof e == "string")
      return rn.fromString(e) || this;
    if (Array.isArray(e))
      return this.set(e);
    this.set(e.r, e.g, e.b, e.a == null ? 1 : e.a);
  }
  blend(e, t, n) {
    this.set(e.r + (t.r - e.r) * n, e.g + (t.g - e.g) * n, e.b + (t.b - e.b) * n, e.a + (t.a - e.a) * n);
  }
  lighten(e) {
    const t = rn.lighten(this.toArray(), e);
    this.r = t[0], this.g = t[1], this.b = t[2], this.a = t[3];
  }
  darken(e) {
    this.lighten(-e);
  }
  set(e, t, n, i) {
    const r = Array.isArray(e) ? e[0] : e, o = Array.isArray(e) ? e[1] : t, a = Array.isArray(e) ? e[2] : n, l = Array.isArray(e) ? e[3] : i;
    return this.r = Math.round(Mt(r, 0, 255)), this.g = Math.round(Mt(o, 0, 255)), this.b = Math.round(Mt(a, 0, 255)), this.a = l == null ? 1 : Mt(l, 0, 1), this;
  }
  toHex() {
    const e = ["r", "g", "b"].map((t) => {
      const n = this[t].toString(16);
      return n.length < 2 ? "0".concat(n) : n;
    });
    return "#".concat(e.join(""));
  }
  toRGBA() {
    return this.toArray();
  }
  toHSLA() {
    return rn.rgba2hsla(this.r, this.g, this.b, this.a);
  }
  toCSS(e) {
    const t = "".concat(this.r, ",").concat(this.g, ",").concat(this.b, ",");
    return e ? "rgb(".concat(t, ")") : "rgba(".concat(t, ",").concat(this.a, ")");
  }
  toGrey() {
    return rn.makeGrey(Math.round((this.r + this.g + this.b) / 3), this.a);
  }
  toArray() {
    return [this.r, this.g, this.b, this.a];
  }
  toString() {
    return this.toCSS();
  }
}
(function(s) {
  function e(b) {
    return new s(b);
  }
  s.fromArray = e;
  function t(b) {
    return new s([...p(b), 1]);
  }
  s.fromHex = t;
  function n(b) {
    const x = b.toLowerCase().match(/^rgba?\(([\s.,0-9]+)\)/);
    if (x) {
      const C = x[1].split(/\s*,\s*/).map((A) => parseInt(A, 10));
      return new s(C);
    }
    return null;
  }
  s.fromRGBA = n;
  function i(b, x, C) {
    C < 0 && ++C, C > 1 && --C;
    const A = 6 * C;
    return A < 1 ? b + (x - b) * A : 2 * C < 1 ? x : 3 * C < 2 ? b + (x - b) * (2 / 3 - C) * 6 : b;
  }
  function r(b) {
    const x = b.toLowerCase().match(/^hsla?\(([\s.,0-9]+)\)/);
    if (x) {
      const C = x[2].split(/\s*,\s*/), A = (parseFloat(C[0]) % 360 + 360) % 360 / 360, k = parseFloat(C[1]) / 100, O = parseFloat(C[2]) / 100, P = C[3] == null ? 1 : parseInt(C[3], 10);
      return new s(c(A, k, O, P));
    }
    return null;
  }
  s.fromHSLA = r;
  function o(b) {
    if (b.startsWith("#"))
      return t(b);
    if (b.startsWith("rgb"))
      return n(b);
    const x = s.named[b];
    return x ? t(x) : r(b);
  }
  s.fromString = o;
  function a(b, x) {
    return s.fromArray([b, b, b, x]);
  }
  s.makeGrey = a;
  function l(b, x, C, A) {
    const k = Array.isArray(b) ? b[0] : b, O = Array.isArray(b) ? b[1] : x, P = Array.isArray(b) ? b[2] : C, D = Array.isArray(b) ? b[3] : A, N = Math.max(k, O, P), F = Math.min(k, O, P), ee = (N + F) / 2;
    let X = 0, _ = 0;
    if (F !== N) {
      const I = N - F;
      switch (_ = ee > 0.5 ? I / (2 - N - F) : I / (N + F), N) {
        case k:
          X = (O - P) / I + (O < P ? 6 : 0);
          break;
        case O:
          X = (P - k) / I + 2;
          break;
        case P:
          X = (k - O) / I + 4;
          break;
      }
      X /= 6;
    }
    return [X, _, ee, D == null ? 1 : D];
  }
  s.rgba2hsla = l;
  function c(b, x, C, A) {
    const k = Array.isArray(b) ? b[0] : b, O = Array.isArray(b) ? b[1] : x, P = Array.isArray(b) ? b[2] : C, D = Array.isArray(b) ? b[3] : A, N = P <= 0.5 ? P * (O + 1) : P + O - P * O, F = 2 * P - N;
    return [
      i(F, N, k + 1 / 3) * 256,
      i(F, N, k) * 256,
      i(F, N, k - 1 / 3) * 256,
      D == null ? 1 : D
    ];
  }
  s.hsla2rgba = c;
  function u(b) {
    return new s(Math.round(Math.random() * 256), Math.round(Math.random() * 256), Math.round(Math.random() * 256), b ? void 0 : parseFloat(Math.random().toFixed(2)));
  }
  s.random = u;
  function d() {
    const b = "0123456789ABCDEF";
    let x = "#";
    for (let C = 0; C < 6; C += 1)
      x += b[Math.floor(Math.random() * 16)];
    return x;
  }
  s.randomHex = d;
  function f(b) {
    return u(b).toString();
  }
  s.randomRGBA = f;
  function g(b, x) {
    if (typeof b == "string") {
      const P = b[0] === "#", [D, N, F] = p(b);
      return x ? D * 0.299 + N * 0.587 + F * 0.114 > 186 ? "#000000" : "#ffffff" : "".concat(P ? "#" : "").concat(m(255 - D, 255 - N, 255 - F));
    }
    const C = b[0], A = b[1], k = b[2], O = b[3];
    return x ? C * 0.299 + A * 0.587 + k * 0.114 > 186 ? [0, 0, 0, O] : [255, 255, 255, O] : [255 - C, 255 - A, 255 - k, O];
  }
  s.invert = g;
  function p(b) {
    const x = b.indexOf("#") === 0 ? b : "#".concat(b);
    let C = Number("0x".concat(x.substr(1)));
    if (!(x.length === 4 || x.length === 7) || Number.isNaN(C))
      throw new Error("Invalid hex color.");
    const A = x.length === 4 ? 4 : 8, k = (1 << A) - 1, O = ["b", "g", "r"].map(() => {
      const P = C & k;
      return C >>= A, A === 4 ? 17 * P : P;
    });
    return [O[2], O[1], O[0]];
  }
  function m(b, x, C) {
    const A = (k) => k.length < 2 ? "0".concat(k) : k;
    return "".concat(A(b.toString(16))).concat(A(x.toString(16))).concat(A(C.toString(16)));
  }
  function w(b, x) {
    return y(b, x);
  }
  s.lighten = w;
  function v(b, x) {
    return y(b, -x);
  }
  s.darken = v;
  function y(b, x) {
    if (typeof b == "string") {
      const k = b[0] === "#", O = parseInt(k ? b.substr(1) : b, 16), P = Mt((O >> 16) + x, 0, 255), D = Mt((O >> 8 & 255) + x, 0, 255), N = Mt((O & 255) + x, 0, 255);
      return "".concat(k ? "#" : "").concat((N | D << 8 | P << 16).toString(16));
    }
    const C = m(b[0], b[1], b[2]), A = p(y(C, x));
    return [A[0], A[1], A[2], b[3]];
  }
})(rn || (rn = {}));
(function(s) {
  s.named = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    burntsienna: "#ea7e5d",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };
})(rn || (rn = {}));
class yl {
  constructor() {
    this.clear();
  }
  clear() {
    this.map = /* @__PURE__ */ new WeakMap(), this.arr = [];
  }
  has(e) {
    return this.map.has(e);
  }
  get(e) {
    return this.map.get(e);
  }
  set(e, t) {
    this.map.set(e, t), this.arr.push(e);
  }
  delete(e) {
    const t = this.arr.indexOf(e);
    t >= 0 && this.arr.splice(t, 1);
    const n = this.map.get(e);
    return this.map.delete(e), n;
  }
  each(e) {
    this.arr.forEach((t) => {
      const n = this.map.get(t);
      e(n, t);
    });
  }
  dispose() {
    this.clear();
  }
}
var ti;
(function(s) {
  function e(i) {
    const r = [], o = [];
    return Array.isArray(i) ? r.push(...i) : i.split("|").forEach((a) => {
      a.indexOf("&") === -1 ? r.push(a) : o.push(...a.split("&"));
    }), { or: r, and: o };
  }
  s.parse = e;
  function t(i, r) {
    if (i != null && r != null) {
      const o = e(i), a = e(r), l = o.or.sort(), c = a.or.sort(), u = o.and.sort(), d = a.and.sort(), f = (g, p) => g.length === p.length && (g.length === 0 || g.every((m, w) => m === p[w]));
      return f(l, c) && f(u, d);
    }
    return i == null && r == null;
  }
  s.equals = t;
  function n(i, r, o) {
    if (r == null || Array.isArray(r) && r.length === 0)
      return o ? i.altKey !== !0 && i.ctrlKey !== !0 && i.metaKey !== !0 && i.shiftKey !== !0 : !0;
    const { or: a, and: l } = e(r), c = (u) => {
      const d = "".concat(u.toLowerCase(), "Key");
      return i[d] === !0;
    };
    return a.some((u) => c(u)) && l.every((u) => c(u));
  }
  s.isMatch = n;
})(ti || (ti = {}));
var ys;
(function(s) {
  s.linear = (e) => e, s.quad = (e) => e * e, s.cubic = (e) => e * e * e, s.inout = (e) => {
    if (e <= 0)
      return 0;
    if (e >= 1)
      return 1;
    const t = e * e, n = t * e;
    return 4 * (e < 0.5 ? n : 3 * (e - t) + n - 0.75);
  }, s.exponential = (e) => Math.pow(2, 10 * (e - 1)), s.bounce = (e) => {
    for (let t = 0, n = 1; ; t += n, n /= 2)
      if (e >= (7 - 4 * t) / 11) {
        const i = (11 - 6 * t - 11 * e) / 4;
        return -i * i + n * n;
      }
  };
})(ys || (ys = {}));
(function(s) {
  s.decorators = {
    reverse(e) {
      return (t) => 1 - e(1 - t);
    },
    reflect(e) {
      return (t) => 0.5 * (t < 0.5 ? e(2 * t) : 2 - e(2 - 2 * t));
    },
    clamp(e, t = 0, n = 1) {
      return (i) => {
        const r = e(i);
        return r < t ? t : r > n ? n : r;
      };
    },
    back(e = 1.70158) {
      return (t) => t * t * ((e + 1) * t - e);
    },
    elastic(e = 1.5) {
      return (t) => Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * e / 3 * t);
    }
  };
})(ys || (ys = {}));
(function(s) {
  function e(_) {
    return -1 * Math.cos(_ * (Math.PI / 2)) + 1;
  }
  s.easeInSine = e;
  function t(_) {
    return Math.sin(_ * (Math.PI / 2));
  }
  s.easeOutSine = t;
  function n(_) {
    return -0.5 * (Math.cos(Math.PI * _) - 1);
  }
  s.easeInOutSine = n;
  function i(_) {
    return _ * _;
  }
  s.easeInQuad = i;
  function r(_) {
    return _ * (2 - _);
  }
  s.easeOutQuad = r;
  function o(_) {
    return _ < 0.5 ? 2 * _ * _ : -1 + (4 - 2 * _) * _;
  }
  s.easeInOutQuad = o;
  function a(_) {
    return _ * _ * _;
  }
  s.easeInCubic = a;
  function l(_) {
    const I = _ - 1;
    return I * I * I + 1;
  }
  s.easeOutCubic = l;
  function c(_) {
    return _ < 0.5 ? 4 * _ * _ * _ : (_ - 1) * (2 * _ - 2) * (2 * _ - 2) + 1;
  }
  s.easeInOutCubic = c;
  function u(_) {
    return _ * _ * _ * _;
  }
  s.easeInQuart = u;
  function d(_) {
    const I = _ - 1;
    return 1 - I * I * I * I;
  }
  s.easeOutQuart = d;
  function f(_) {
    const I = _ - 1;
    return _ < 0.5 ? 8 * _ * _ * _ * _ : 1 - 8 * I * I * I * I;
  }
  s.easeInOutQuart = f;
  function g(_) {
    return _ * _ * _ * _ * _;
  }
  s.easeInQuint = g;
  function p(_) {
    const I = _ - 1;
    return 1 + I * I * I * I * I;
  }
  s.easeOutQuint = p;
  function m(_) {
    const I = _ - 1;
    return _ < 0.5 ? 16 * _ * _ * _ * _ * _ : 1 + 16 * I * I * I * I * I;
  }
  s.easeInOutQuint = m;
  function w(_) {
    return _ === 0 ? 0 : Math.pow(2, 10 * (_ - 1));
  }
  s.easeInExpo = w;
  function v(_) {
    return _ === 1 ? 1 : -Math.pow(2, -10 * _) + 1;
  }
  s.easeOutExpo = v;
  function y(_) {
    if (_ === 0 || _ === 1)
      return _;
    const I = _ * 2, W = I - 1;
    return I < 1 ? 0.5 * Math.pow(2, 10 * W) : 0.5 * (-Math.pow(2, -10 * W) + 2);
  }
  s.easeInOutExpo = y;
  function b(_) {
    const I = _ / 1;
    return -1 * (Math.sqrt(1 - I * _) - 1);
  }
  s.easeInCirc = b;
  function x(_) {
    const I = _ - 1;
    return Math.sqrt(1 - I * I);
  }
  s.easeOutCirc = x;
  function C(_) {
    const I = _ * 2, W = I - 2;
    return I < 1 ? -0.5 * (Math.sqrt(1 - I * I) - 1) : 0.5 * (Math.sqrt(1 - W * W) + 1);
  }
  s.easeInOutCirc = C;
  function A(_, I = 1.70158) {
    return _ * _ * ((I + 1) * _ - I);
  }
  s.easeInBack = A;
  function k(_, I = 1.70158) {
    const W = _ / 1 - 1;
    return W * W * ((I + 1) * W + I) + 1;
  }
  s.easeOutBack = k;
  function O(_, I = 1.70158) {
    const W = _ * 2, oe = W - 2, re = I * 1.525;
    return W < 1 ? 0.5 * W * W * ((re + 1) * W - re) : 0.5 * (oe * oe * ((re + 1) * oe + re) + 2);
  }
  s.easeInOutBack = O;
  function P(_, I = 0.7) {
    if (_ === 0 || _ === 1)
      return _;
    const oe = _ / 1 - 1, re = 1 - I, xe = re / (2 * Math.PI) * Math.asin(1);
    return -(Math.pow(2, 10 * oe) * // eslint-disable-line
    Math.sin((oe - xe) * (2 * Math.PI) / re));
  }
  s.easeInElastic = P;
  function D(_, I = 0.7) {
    const W = 1 - I, oe = _ * 2;
    if (_ === 0 || _ === 1)
      return _;
    const re = W / (2 * Math.PI) * Math.asin(1);
    return Math.pow(2, -10 * oe) * // eslint-disable-line
    Math.sin((oe - re) * (2 * Math.PI) / W) + 1;
  }
  s.easeOutElastic = D;
  function N(_, I = 0.65) {
    const W = 1 - I;
    if (_ === 0 || _ === 1)
      return _;
    const oe = _ * 2, re = oe - 1, xe = W / (2 * Math.PI) * Math.asin(1);
    return oe < 1 ? -0.5 * (Math.pow(2, 10 * re) * // eslint-disable-line
    Math.sin((re - xe) * (2 * Math.PI) / W)) : Math.pow(2, -10 * re) * // eslint-disable-line
    Math.sin((re - xe) * (2 * Math.PI) / W) * 0.5 + 1;
  }
  s.easeInOutElastic = N;
  function F(_) {
    const I = _ / 1;
    if (I < 1 / 2.75)
      return 7.5625 * I * I;
    if (I < 2 / 2.75) {
      const W = I - 0.5454545454545454;
      return 7.5625 * W * W + 0.75;
    }
    if (I < 2.5 / 2.75) {
      const W = I - 0.8181818181818182;
      return 7.5625 * W * W + 0.9375;
    }
    {
      const W = I - 0.9545454545454546;
      return 7.5625 * W * W + 0.984375;
    }
  }
  s.easeOutBounce = F;
  function ee(_) {
    return 1 - F(1 - _);
  }
  s.easeInBounce = ee;
  function X(_) {
    return _ < 0.5 ? ee(_ * 2) * 0.5 : F(_ * 2 - 1) * 0.5 + 0.5;
  }
  s.easeInOutBounce = X;
})(ys || (ys = {}));
var ss;
(function(s) {
  s.number = (e, t) => {
    const n = t - e;
    return (i) => e + n * i;
  }, s.object = (e, t) => {
    const n = Object.keys(e);
    return (i) => {
      const r = {};
      for (let o = n.length - 1; o !== -1; o -= 1) {
        const a = n[o];
        r[a] = e[a] + (t[a] - e[a]) * i;
      }
      return r;
    };
  }, s.unit = (e, t) => {
    const n = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/, i = n.exec(e), r = n.exec(t), o = r ? r[1] : "", a = i ? +i[1] : 0, l = r ? +r[1] : 0, c = o.indexOf("."), u = c > 0 ? o[1].length - c - 1 : 0, d = l - a, f = i ? i[2] : "";
    return (g) => (a + d * g).toFixed(u) + f;
  }, s.color = (e, t) => {
    const n = parseInt(e.slice(1), 16), i = parseInt(t.slice(1), 16), r = n & 255, o = (i & 255) - r, a = n & 65280, l = (i & 65280) - a, c = n & 16711680, u = (i & 16711680) - c;
    return (d) => {
      const f = r + o * d & 255, g = a + l * d & 65280, p = c + u * d & 16711680;
      return "#".concat((1 << 24 | f | g | p).toString(16).slice(1));
    };
  };
})(ss || (ss = {}));
const $i = [];
function u3(s, e) {
  const t = $i.find((n) => n.name === s);
  if (!(t && (t.loadTimes += 1, t.loadTimes > 1)) && !In.isApplyingHMR()) {
    const n = document.createElement("style");
    n.setAttribute("type", "text/css"), n.textContent = e;
    const i = document.querySelector("head");
    i && i.insertBefore(n, i.firstChild), $i.push({
      name: s,
      loadTimes: 1,
      styleElement: n
    });
  }
}
function d3(s) {
  const e = $i.findIndex((t) => t.name === s);
  if (e > -1) {
    const t = $i[e];
    if (t.loadTimes -= 1, t.loadTimes > 0)
      return;
    let n = t.styleElement;
    n && n.parentNode && n.parentNode.removeChild(n), n = null, $i.splice(e, 1);
  }
}
var de;
(function(s) {
  function e(n) {
    return 180 * n / Math.PI % 360;
  }
  s.toDeg = e, s.toRad = function(n, i = !1) {
    return (i ? n : n % 360) * Math.PI / 180;
  };
  function t(n) {
    return n % 360 + (n < 0 ? 360 : 0);
  }
  s.normalize = t;
})(de || (de = {}));
var ue;
(function(s) {
  function e(a, l = 0) {
    return Number.isInteger(a) ? a : +a.toFixed(l);
  }
  s.round = e;
  function t(a, l) {
    let c, u;
    if (l == null ? (u = a == null ? 1 : a, c = 0) : (u = l, c = a == null ? 0 : a), u < c) {
      const d = c;
      c = u, u = d;
    }
    return Math.floor(Math.random() * (u - c + 1) + c);
  }
  s.random = t;
  function n(a, l, c) {
    return Number.isNaN(a) ? NaN : Number.isNaN(l) || Number.isNaN(c) ? 0 : l < c ? a < l ? l : a > c ? c : a : a < c ? c : a > l ? l : a;
  }
  s.clamp = n;
  function i(a, l) {
    return l * Math.round(a / l);
  }
  s.snapToGrid = i;
  function r(a, l) {
    return l != null && a != null && l.x >= a.x && l.x <= a.x + a.width && l.y >= a.y && l.y <= a.y + a.height;
  }
  s.containsPoint = r;
  function o(a, l) {
    const c = a.x - l.x, u = a.y - l.y;
    return c * c + u * u;
  }
  s.squaredLength = o;
})(ue || (ue = {}));
class Un {
  valueOf() {
    return this.toJSON();
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
}
class M extends Un {
  constructor(e, t) {
    super(), this.x = e == null ? 0 : e, this.y = t == null ? 0 : t;
  }
  /**
   * Rounds the point to the given precision.
   */
  round(e = 0) {
    return this.x = ue.round(this.x, e), this.y = ue.round(this.y, e), this;
  }
  add(e, t) {
    const n = M.create(e, t);
    return this.x += n.x, this.y += n.y, this;
  }
  update(e, t) {
    const n = M.create(e, t);
    return this.x = n.x, this.y = n.y, this;
  }
  translate(e, t) {
    const n = M.create(e, t);
    return this.x += n.x, this.y += n.y, this;
  }
  /**
   * Rotate the point by `degree` around `center`.
   */
  rotate(e, t) {
    const n = M.rotate(this, e, t);
    return this.x = n.x, this.y = n.y, this;
  }
  /**
   * Scale point by `sx` and `sy` around the given `origin`. If origin is
   * not specified, the point is scaled around `0, 0`.
   */
  scale(e, t, n = new M()) {
    const i = M.create(n);
    return this.x = i.x + e * (this.x - i.x), this.y = i.y + t * (this.y - i.y), this;
  }
  /**
   * Chooses the point closest to this point from among `points`. If `points`
   * is an empty array, `null` is returned.
   */
  closest(e) {
    if (e.length === 1)
      return M.create(e[0]);
    let t = null, n = 1 / 0;
    return e.forEach((i) => {
      const r = this.squaredDistance(i);
      r < n && (t = i, n = r);
    }), t ? M.create(t) : null;
  }
  /**
   * Returns the distance between the point and another point `p`.
   */
  distance(e) {
    return Math.sqrt(this.squaredDistance(e));
  }
  /**
   * Returns the squared distance between the point and another point `p`.
   *
   * Useful for distance comparisons in which real distance is not necessary
   * (saves one `Math.sqrt()` operation).
   */
  squaredDistance(e) {
    const t = M.create(e), n = this.x - t.x, i = this.y - t.y;
    return n * n + i * i;
  }
  manhattanDistance(e) {
    const t = M.create(e);
    return Math.abs(t.x - this.x) + Math.abs(t.y - this.y);
  }
  /**
   * Returns the magnitude of the point vector.
   *
   * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)
   */
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01;
  }
  /**
   * Returns the angle(in degrees) between vector from this point to `p` and
   * the x-axis.
   */
  theta(e = new M()) {
    const t = M.create(e), n = -(t.y - this.y), i = t.x - this.x;
    let r = Math.atan2(n, i);
    return r < 0 && (r = 2 * Math.PI + r), 180 * r / Math.PI;
  }
  /**
   * Returns the angle(in degrees) between vector from this point to `p1` and
   * the vector from this point to `p2`.
   *
   * The ordering of points `p1` and `p2` is important.
   *
   * The function returns a value between `0` and `180` when the angle (in the
   * direction from `p1` to `p2`) is clockwise, and a value between `180` and
   * `360` when the angle is counterclockwise.
   *
   * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.
   */
  angleBetween(e, t) {
    if (this.equals(e) || this.equals(t))
      return NaN;
    let n = this.theta(t) - this.theta(e);
    return n < 0 && (n += 360), n;
  }
  /**
   * Returns the angle(in degrees) between the line from `(0,0)` and this point
   * and the line from `(0,0)` to `p`.
   *
   * The function returns a value between `0` and `180` when the angle (in the
   * direction from this point to `p`) is clockwise, and a value between `180`
   * and `360` when the angle is counterclockwise. Returns `NaN` if called from
   * point `(0,0)` or if `p` is `(0,0)`.
   */
  vectorAngle(e) {
    return new M(0, 0).angleBetween(this, e);
  }
  /**
   * Converts rectangular to polar coordinates.
   */
  toPolar(e) {
    return this.update(M.toPolar(this, e)), this;
  }
  /**
   * Returns the change in angle(in degrees) that is the result of moving the
   * point from its previous position to its current position.
   *
   * More specifically, this function computes the angle between the line from
   * the ref point to the previous position of this point(i.e. current position
   * `-dx`, `-dy`) and the line from the `ref` point to the current position of
   * this point.
   *
   * The function returns a positive value between `0` and `180` when the angle
   * (in the direction from previous position of this point to its current
   * position) is clockwise, and a negative value between `0` and `-180` when
   * the angle is counterclockwise.
   *
   * The function returns `0` if the previous and current positions of this
   * point are the same (i.e. both `dx` and `dy` are `0`).
   */
  changeInAngle(e, t, n = new M()) {
    return this.clone().translate(-e, -t).theta(n) - this.theta(n);
  }
  /**
   * If the point lies outside the rectangle `rect`, adjust the point so that
   * it becomes the nearest point on the boundary of `rect`.
   */
  adhereToRect(e) {
    return ue.containsPoint(e, this) || (this.x = Math.min(Math.max(this.x, e.x), e.x + e.width), this.y = Math.min(Math.max(this.y, e.y), e.y + e.height)), this;
  }
  /**
   * Returns the bearing(cardinal direction) between me and the given point.
   *
   * @see https://en.wikipedia.org/wiki/Cardinal_direction
   */
  bearing(e) {
    const t = M.create(e), n = de.toRad(this.y), i = de.toRad(t.y), r = this.x, o = t.x, a = de.toRad(o - r), l = Math.sin(a) * Math.cos(i), c = Math.cos(n) * Math.sin(i) - Math.sin(n) * Math.cos(i) * Math.cos(a), u = de.toDeg(Math.atan2(l, c)), d = ["NE", "E", "SE", "S", "SW", "W", "NW", "N"];
    let f = u - 22.5;
    return f < 0 && (f += 360), f = parseInt(f / 45, 10), d[f];
  }
  /**
   * Returns the cross product of the vector from me to `p1` and the vector
   * from me to `p2`.
   *
   * The left-hand rule is used because the coordinate system is left-handed.
   */
  cross(e, t) {
    if (e != null && t != null) {
      const n = M.create(e), i = M.create(t);
      return (i.x - this.x) * (n.y - this.y) - (i.y - this.y) * (n.x - this.x);
    }
    return NaN;
  }
  /**
   * Returns the dot product of this point with given other point.
   */
  dot(e) {
    const t = M.create(e);
    return this.x * t.x + this.y * t.y;
  }
  diff(e, t) {
    if (typeof e == "number")
      return new M(this.x - e, this.y - t);
    const n = M.create(e);
    return new M(this.x - n.x, this.y - n.y);
  }
  /**
   * Returns an interpolation between me and point `p` for a parametert in
   * the closed interval `[0, 1]`.
   */
  lerp(e, t) {
    const n = M.create(e);
    return new M((1 - t) * this.x + t * n.x, (1 - t) * this.y + t * n.y);
  }
  /**
   * Normalize the point vector, scale the line segment between `(0, 0)`
   * and the point in order for it to have the given length. If length is
   * not specified, it is considered to be `1`; in that case, a unit vector
   * is computed.
   */
  normalize(e = 1) {
    const t = e / this.magnitude();
    return this.scale(t, t);
  }
  /**
   * Moves this point along the line starting from `ref` to this point by a
   * certain `distance`.
   */
  move(e, t) {
    const n = M.create(e), i = de.toRad(n.theta(this));
    return this.translate(Math.cos(i) * t, -Math.sin(i) * t);
  }
  /**
   * Returns a point that is the reflection of me with the center of inversion
   * in `ref` point.
   */
  reflection(e) {
    return M.create(e).move(this, this.distance(e));
  }
  snapToGrid(e, t) {
    return this.x = ue.snapToGrid(this.x, e), this.y = ue.snapToGrid(this.y, t == null ? e : t), this;
  }
  equals(e) {
    const t = M.create(e);
    return t != null && t.x === this.x && t.y === this.y;
  }
  clone() {
    return M.clone(this);
  }
  /**
   * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.
   */
  toJSON() {
    return M.toJSON(this);
  }
  serialize() {
    return "".concat(this.x, " ").concat(this.y);
  }
}
(function(s) {
  function e(t) {
    return t != null && t instanceof s;
  }
  s.isPoint = e;
})(M || (M = {}));
(function(s) {
  function e(n) {
    return n != null && typeof n == "object" && typeof n.x == "number" && typeof n.y == "number";
  }
  s.isPointLike = e;
  function t(n) {
    return n != null && Array.isArray(n) && n.length === 2 && typeof n[0] == "number" && typeof n[1] == "number";
  }
  s.isPointData = t;
})(M || (M = {}));
(function(s) {
  function e(d, f) {
    return d == null || typeof d == "number" ? new s(d, f) : t(d);
  }
  s.create = e;
  function t(d) {
    return s.isPoint(d) ? new s(d.x, d.y) : Array.isArray(d) ? new s(d[0], d[1]) : new s(d.x, d.y);
  }
  s.clone = t;
  function n(d) {
    return s.isPoint(d) ? { x: d.x, y: d.y } : Array.isArray(d) ? { x: d[0], y: d[1] } : { x: d.x, y: d.y };
  }
  s.toJSON = n;
  function i(d, f, g = new s()) {
    let p = Math.abs(d * Math.cos(f)), m = Math.abs(d * Math.sin(f));
    const w = t(g), v = de.normalize(de.toDeg(f));
    return v < 90 ? m = -m : v < 180 ? (p = -p, m = -m) : v < 270 && (p = -p), new s(w.x + p, w.y + m);
  }
  s.fromPolar = i;
  function r(d, f = new s()) {
    const g = t(d), p = t(f), m = g.x - p.x, w = g.y - p.y;
    return new s(
      Math.sqrt(m * m + w * w),
      // r
      de.toRad(p.theta(g))
    );
  }
  s.toPolar = r;
  function o(d, f) {
    return d === f ? !0 : d != null && f != null ? d.x === f.x && d.y === f.y : !1;
  }
  s.equals = o;
  function a(d, f) {
    if (d == null && f != null || d != null && f == null || d != null && f != null && d.length !== f.length)
      return !1;
    if (d != null && f != null) {
      for (let g = 0, p = d.length; g < p; g += 1)
        if (!o(d[g], f[g]))
          return !1;
    }
    return !0;
  }
  s.equalPoints = a;
  function l(d, f, g, p) {
    return new s(ue.random(d, f), ue.random(g, p));
  }
  s.random = l;
  function c(d, f, g) {
    const p = de.toRad(de.normalize(-f)), m = Math.sin(p), w = Math.cos(p);
    return u(d, w, m, g);
  }
  s.rotate = c;
  function u(d, f, g, p = new s()) {
    const m = t(d), w = t(p), v = m.x - w.x, y = m.y - w.y, b = v * f - y * g, x = y * f + v * g;
    return new s(b + w.x, x + w.y);
  }
  s.rotateEx = u;
})(M || (M = {}));
class R extends Un {
  get left() {
    return this.x;
  }
  get top() {
    return this.y;
  }
  get right() {
    return this.x + this.width;
  }
  get bottom() {
    return this.y + this.height;
  }
  get origin() {
    return new M(this.x, this.y);
  }
  get topLeft() {
    return new M(this.x, this.y);
  }
  get topCenter() {
    return new M(this.x + this.width / 2, this.y);
  }
  get topRight() {
    return new M(this.x + this.width, this.y);
  }
  get center() {
    return new M(this.x + this.width / 2, this.y + this.height / 2);
  }
  get bottomLeft() {
    return new M(this.x, this.y + this.height);
  }
  get bottomCenter() {
    return new M(this.x + this.width / 2, this.y + this.height);
  }
  get bottomRight() {
    return new M(this.x + this.width, this.y + this.height);
  }
  get corner() {
    return new M(this.x + this.width, this.y + this.height);
  }
  get rightMiddle() {
    return new M(this.x + this.width, this.y + this.height / 2);
  }
  get leftMiddle() {
    return new M(this.x, this.y + this.height / 2);
  }
  get topLine() {
    return new $(this.topLeft, this.topRight);
  }
  get rightLine() {
    return new $(this.topRight, this.bottomRight);
  }
  get bottomLine() {
    return new $(this.bottomLeft, this.bottomRight);
  }
  get leftLine() {
    return new $(this.topLeft, this.bottomLeft);
  }
  constructor(e, t, n, i) {
    super(), this.x = e == null ? 0 : e, this.y = t == null ? 0 : t, this.width = n == null ? 0 : n, this.height = i == null ? 0 : i;
  }
  getOrigin() {
    return this.origin;
  }
  getTopLeft() {
    return this.topLeft;
  }
  getTopCenter() {
    return this.topCenter;
  }
  getTopRight() {
    return this.topRight;
  }
  getCenter() {
    return this.center;
  }
  getCenterX() {
    return this.x + this.width / 2;
  }
  getCenterY() {
    return this.y + this.height / 2;
  }
  getBottomLeft() {
    return this.bottomLeft;
  }
  getBottomCenter() {
    return this.bottomCenter;
  }
  getBottomRight() {
    return this.bottomRight;
  }
  getCorner() {
    return this.corner;
  }
  getRightMiddle() {
    return this.rightMiddle;
  }
  getLeftMiddle() {
    return this.leftMiddle;
  }
  getTopLine() {
    return this.topLine;
  }
  getRightLine() {
    return this.rightLine;
  }
  getBottomLine() {
    return this.bottomLine;
  }
  getLeftLine() {
    return this.leftLine;
  }
  /**
   * Returns a rectangle that is the bounding box of the rectangle.
   *
   * If `angle` is specified, the bounding box calculation will take into
   * account the rotation of the rectangle by angle degrees around its center.
   */
  bbox(e) {
    if (!e)
      return this.clone();
    const t = de.toRad(e), n = Math.abs(Math.sin(t)), i = Math.abs(Math.cos(t)), r = this.width * i + this.height * n, o = this.width * n + this.height * i;
    return new R(this.x + (this.width - r) / 2, this.y + (this.height - o) / 2, r, o);
  }
  round(e = 0) {
    return this.x = ue.round(this.x, e), this.y = ue.round(this.y, e), this.width = ue.round(this.width, e), this.height = ue.round(this.height, e), this;
  }
  add(e, t, n, i) {
    const r = R.create(e, t, n, i), o = Math.min(this.x, r.x), a = Math.min(this.y, r.y), l = Math.max(this.x + this.width, r.x + r.width), c = Math.max(this.y + this.height, r.y + r.height);
    return this.x = o, this.y = a, this.width = l - o, this.height = c - a, this;
  }
  update(e, t, n, i) {
    const r = R.create(e, t, n, i);
    return this.x = r.x, this.y = r.y, this.width = r.width, this.height = r.height, this;
  }
  inflate(e, t) {
    const n = e, i = t != null ? t : e;
    return this.x -= n, this.y -= i, this.width += 2 * n, this.height += 2 * i, this;
  }
  snapToGrid(e, t) {
    const n = this.origin.snapToGrid(e, t), i = this.corner.snapToGrid(e, t);
    return this.x = n.x, this.y = n.y, this.width = i.x - n.x, this.height = i.y - n.y, this;
  }
  translate(e, t) {
    const n = M.create(e, t);
    return this.x += n.x, this.y += n.y, this;
  }
  scale(e, t, n = new M()) {
    const i = this.origin.scale(e, t, n);
    return this.x = i.x, this.y = i.y, this.width *= e, this.height *= t, this;
  }
  rotate(e, t = this.getCenter()) {
    if (e !== 0) {
      const n = de.toRad(e), i = Math.cos(n), r = Math.sin(n);
      let o = this.getOrigin(), a = this.getTopRight(), l = this.getBottomRight(), c = this.getBottomLeft();
      o = M.rotateEx(o, i, r, t), a = M.rotateEx(a, i, r, t), l = M.rotateEx(l, i, r, t), c = M.rotateEx(c, i, r, t);
      const u = new R(o.x, o.y, 0, 0);
      u.add(a.x, a.y, 0, 0), u.add(l.x, l.y, 0, 0), u.add(c.x, c.y, 0, 0), this.update(u);
    }
    return this;
  }
  rotate90() {
    const e = (this.width - this.height) / 2;
    this.x += e, this.y -= e;
    const t = this.width;
    return this.width = this.height, this.height = t, this;
  }
  /**
   * Translates the rectangle by `rect.x` and `rect.y` and expand it by
   * `rect.width` and `rect.height`.
   */
  moveAndExpand(e) {
    const t = R.clone(e);
    return this.x += t.x || 0, this.y += t.y || 0, this.width += t.width || 0, this.height += t.height || 0, this;
  }
  /**
   * Returns an object where `sx` and `sy` give the maximum scaling that can be
   * applied to the rectangle so that it would still fit into `limit`. If
   * `origin` is specified, the rectangle is scaled around it; otherwise, it is
   * scaled around its center.
   */
  getMaxScaleToFit(e, t = this.center) {
    const n = R.clone(e), i = t.x, r = t.y;
    let o = 1 / 0, a = 1 / 0, l = 1 / 0, c = 1 / 0, u = 1 / 0, d = 1 / 0, f = 1 / 0, g = 1 / 0;
    const p = n.topLeft;
    p.x < i && (o = (this.x - i) / (p.x - i)), p.y < r && (u = (this.y - r) / (p.y - r));
    const m = n.bottomRight;
    m.x > i && (a = (this.x + this.width - i) / (m.x - i)), m.y > r && (d = (this.y + this.height - r) / (m.y - r));
    const w = n.topRight;
    w.x > i && (l = (this.x + this.width - i) / (w.x - i)), w.y < r && (f = (this.y - r) / (w.y - r));
    const v = n.bottomLeft;
    return v.x < i && (c = (this.x - i) / (v.x - i)), v.y > r && (g = (this.y + this.height - r) / (v.y - r)), {
      sx: Math.min(o, a, l, c),
      sy: Math.min(u, d, f, g)
    };
  }
  /**
   * Returns a number that specifies the maximum scaling that can be applied to
   * the rectangle along both axes so that it would still fit into `limit`. If
   * `origin` is specified, the rectangle is scaled around it; otherwise, it is
   * scaled around its center.
   */
  getMaxUniformScaleToFit(e, t = this.center) {
    const n = this.getMaxScaleToFit(e, t);
    return Math.min(n.sx, n.sy);
  }
  containsPoint(e, t) {
    return ue.containsPoint(this, M.create(e, t));
  }
  containsRect(e, t, n, i) {
    const r = R.create(e, t, n, i), o = this.x, a = this.y, l = this.width, c = this.height, u = r.x, d = r.y, f = r.width, g = r.height;
    return l === 0 || c === 0 || f === 0 || g === 0 ? !1 : u >= o && d >= a && u + f <= o + l && d + g <= a + c;
  }
  /**
   * Returns an array of the intersection points of the rectangle and the line.
   * Return `null` if no intersection exists.
   */
  intersectsWithLine(e) {
    const t = [
      this.topLine,
      this.rightLine,
      this.bottomLine,
      this.leftLine
    ], n = [], i = [];
    return t.forEach((r) => {
      const o = e.intersectsWithLine(r);
      o !== null && i.indexOf(o.toString()) < 0 && (n.push(o), i.push(o.toString()));
    }), n.length > 0 ? n : null;
  }
  /**
   * Returns the point on the boundary of the rectangle that is the intersection
   * of the rectangle with a line starting in the center the rectangle ending in
   * the point `p`.
   *
   * If `angle` is specified, the intersection will take into account the
   * rotation of the rectangle by `angle` degrees around its center.
   */
  intersectsWithLineFromCenterToPoint(e, t) {
    const n = M.clone(e), i = this.center;
    let r = null;
    t != null && t !== 0 && n.rotate(t, i);
    const o = [this.topLine, this.rightLine, this.bottomLine, this.leftLine], a = new $(i, n);
    for (let l = o.length - 1; l >= 0; l -= 1) {
      const c = o[l].intersectsWithLine(a);
      if (c !== null) {
        r = c;
        break;
      }
    }
    return r && t != null && t !== 0 && r.rotate(-t, i), r;
  }
  intersectsWithRect(e, t, n, i) {
    const r = R.create(e, t, n, i);
    if (!this.isIntersectWithRect(r))
      return null;
    const o = this.origin, a = this.corner, l = r.origin, c = r.corner, u = Math.max(o.x, l.x), d = Math.max(o.y, l.y);
    return new R(u, d, Math.min(a.x, c.x) - u, Math.min(a.y, c.y) - d);
  }
  isIntersectWithRect(e, t, n, i) {
    const r = R.create(e, t, n, i), o = this.origin, a = this.corner, l = r.origin, c = r.corner;
    return !(c.x <= o.x || c.y <= o.y || l.x >= a.x || l.y >= a.y);
  }
  /**
   * Normalize the rectangle, i.e. make it so that it has non-negative
   * width and height. If width is less than `0`, the function swaps left and
   * right corners and if height is less than `0`, the top and bottom corners
   * are swapped.
   */
  normalize() {
    let e = this.x, t = this.y, n = this.width, i = this.height;
    return this.width < 0 && (e = this.x + this.width, n = -this.width), this.height < 0 && (t = this.y + this.height, i = -this.height), this.x = e, this.y = t, this.width = n, this.height = i, this;
  }
  /**
   * Returns a rectangle that is a union of this rectangle and rectangle `rect`.
   */
  union(e) {
    const t = R.clone(e), n = this.origin, i = this.corner, r = t.origin, o = t.corner, a = Math.min(n.x, r.x), l = Math.min(n.y, r.y), c = Math.max(i.x, o.x), u = Math.max(i.y, o.y);
    return new R(a, l, c - a, u - l);
  }
  /**
   * Returns a string ("top", "left", "right" or "bottom") denoting the side of
   * the rectangle which is nearest to the point `p`.
   */
  getNearestSideToPoint(e) {
    const t = M.clone(e), n = t.x - this.x, i = this.x + this.width - t.x, r = t.y - this.y, o = this.y + this.height - t.y;
    let a = n, l = "left";
    return i < a && (a = i, l = "right"), r < a && (a = r, l = "top"), o < a && (l = "bottom"), l;
  }
  /**
   * Returns a point on the boundary of the rectangle nearest to the point `p`.
   */
  getNearestPointToPoint(e) {
    const t = M.clone(e);
    if (this.containsPoint(t)) {
      const n = this.getNearestSideToPoint(t);
      if (n === "left")
        return new M(this.x, t.y);
      if (n === "top")
        return new M(t.x, this.y);
      if (n === "right")
        return new M(this.x + this.width, t.y);
      if (n === "bottom")
        return new M(t.x, this.y + this.height);
    }
    return t.adhereToRect(this);
  }
  equals(e) {
    return e != null && e.x === this.x && e.y === this.y && e.width === this.width && e.height === this.height;
  }
  clone() {
    return new R(this.x, this.y, this.width, this.height);
  }
  toJSON() {
    return { x: this.x, y: this.y, width: this.width, height: this.height };
  }
  serialize() {
    return "".concat(this.x, " ").concat(this.y, " ").concat(this.width, " ").concat(this.height);
  }
}
(function(s) {
  function e(t) {
    return t != null && t instanceof s;
  }
  s.isRectangle = e;
})(R || (R = {}));
(function(s) {
  function e(t) {
    return t != null && typeof t == "object" && typeof t.x == "number" && typeof t.y == "number" && typeof t.width == "number" && typeof t.height == "number";
  }
  s.isRectangleLike = e;
})(R || (R = {}));
(function(s) {
  function e(o, a, l, c) {
    return o == null || typeof o == "number" ? new s(o, a, l, c) : t(o);
  }
  s.create = e;
  function t(o) {
    return s.isRectangle(o) ? o.clone() : Array.isArray(o) ? new s(o[0], o[1], o[2], o[3]) : new s(o.x, o.y, o.width, o.height);
  }
  s.clone = t;
  function n(o) {
    return new s(o.x - o.a, o.y - o.b, 2 * o.a, 2 * o.b);
  }
  s.fromEllipse = n;
  function i(o) {
    return new s(0, 0, o.width, o.height);
  }
  s.fromSize = i;
  function r(o, a) {
    return new s(o.x, o.y, a.width, a.height);
  }
  s.fromPositionAndSize = r;
})(R || (R = {}));
class $ extends Un {
  get center() {
    return new M((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);
  }
  constructor(e, t, n, i) {
    super(), typeof e == "number" && typeof t == "number" ? (this.start = new M(e, t), this.end = new M(n, i)) : (this.start = M.create(e), this.end = M.create(t));
  }
  getCenter() {
    return this.center;
  }
  /**
   * Rounds the line to the given `precision`.
   */
  round(e = 0) {
    return this.start.round(e), this.end.round(e), this;
  }
  translate(e, t) {
    return typeof e == "number" ? (this.start.translate(e, t), this.end.translate(e, t)) : (this.start.translate(e), this.end.translate(e)), this;
  }
  /**
   * Rotate the line by `angle` around `origin`.
   */
  rotate(e, t) {
    return this.start.rotate(e, t), this.end.rotate(e, t), this;
  }
  /**
   * Scale the line by `sx` and `sy` about the given `origin`. If origin is not
   * specified, the line is scaled around `0,0`.
   */
  scale(e, t, n) {
    return this.start.scale(e, t, n), this.end.scale(e, t, n), this;
  }
  /**
   * Returns the length of the line.
   */
  length() {
    return Math.sqrt(this.squaredLength());
  }
  /**
   * Useful for distance comparisons in which real length is not necessary
   * (saves one `Math.sqrt()` operation).
   */
  squaredLength() {
    const e = this.start.x - this.end.x, t = this.start.y - this.end.y;
    return e * e + t * t;
  }
  /**
   * Scale the line so that it has the requested length. The start point of
   * the line is preserved.
   */
  setLength(e) {
    const t = this.length();
    if (!t)
      return this;
    const n = e / t;
    return this.scale(n, n, this.start);
  }
  parallel(e) {
    const t = this.clone();
    if (!t.isDifferentiable())
      return t;
    const { start: n, end: i } = t, r = n.clone().rotate(270, i), o = i.clone().rotate(90, n);
    return n.move(o, e), i.move(r, e), t;
  }
  /**
   * Returns the vector of the line with length equal to length of the line.
   */
  vector() {
    return new M(this.end.x - this.start.x, this.end.y - this.start.y);
  }
  /**
   * Returns the angle of incline of the line.
   *
   * The function returns `NaN` if the start and end endpoints of the line
   * both lie at the same coordinates(it is impossible to determine the angle
   * of incline of a line that appears to be a point). The
   * `line.isDifferentiable()` function may be used in advance to determine
   * whether the angle of incline can be computed for a given line.
   */
  angle() {
    const e = new M(this.start.x + 1, this.start.y);
    return this.start.angleBetween(this.end, e);
  }
  /**
   * Returns a rectangle that is the bounding box of the line.
   */
  bbox() {
    const e = Math.min(this.start.x, this.end.x), t = Math.min(this.start.y, this.end.y), n = Math.max(this.start.x, this.end.x), i = Math.max(this.start.y, this.end.y);
    return new R(e, t, n - e, i - t);
  }
  /**
   * Returns the bearing (cardinal direction) of the line.
   *
   * The return value is one of the following strings:
   * 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW' and 'N'.
   *
   * The function returns 'N' if the two endpoints of the line are coincident.
   */
  bearing() {
    return this.start.bearing(this.end);
  }
  /**
   * Returns the point on the line that lies closest to point `p`.
   */
  closestPoint(e) {
    return this.pointAt(this.closestPointNormalizedLength(e));
  }
  /**
   * Returns the length of the line up to the point that lies closest to point `p`.
   */
  closestPointLength(e) {
    return this.closestPointNormalizedLength(e) * this.length();
  }
  /**
   * Returns a line that is tangent to the line at the point that lies closest
   * to point `p`.
   */
  closestPointTangent(e) {
    return this.tangentAt(this.closestPointNormalizedLength(e));
  }
  /**
   * Returns the normalized length (distance from the start of the line / total
   * line length) of the line up to the point that lies closest to point.
   */
  closestPointNormalizedLength(e) {
    const t = this.vector().dot(new $(this.start, e).vector()), n = Math.min(1, Math.max(0, t / this.squaredLength()));
    return Number.isNaN(n) ? 0 : n;
  }
  /**
   * Returns a point on the line that lies `rate` (normalized length) away from
   * the beginning of the line.
   */
  pointAt(e) {
    const t = this.start, n = this.end;
    return e <= 0 ? t.clone() : e >= 1 ? n.clone() : t.lerp(n, e);
  }
  /**
   * Returns a point on the line that lies length away from the beginning of
   * the line.
   */
  pointAtLength(e) {
    const t = this.start, n = this.end;
    let i = !0;
    e < 0 && (i = !1, e = -e);
    const r = this.length();
    if (e >= r)
      return i ? n.clone() : t.clone();
    const o = (i ? e : r - e) / r;
    return this.pointAt(o);
  }
  /**
   * Divides the line into two lines at the point that lies `rate` (normalized
   * length) away from the beginning of the line.
   */
  divideAt(e) {
    const t = this.pointAt(e);
    return [
      new $(this.start, t),
      new $(t, this.end)
    ];
  }
  /**
   * Divides the line into two lines at the point that lies length away from
   * the beginning of the line.
   */
  divideAtLength(e) {
    const t = this.pointAtLength(e);
    return [
      new $(this.start, t),
      new $(t, this.end)
    ];
  }
  /**
   * Returns `true` if the point `p` lies on the line. Return `false` otherwise.
   */
  containsPoint(e) {
    const t = this.start, n = this.end;
    if (t.cross(e, n) !== 0)
      return !1;
    const i = this.length();
    return !(new $(t, e).length() > i || new $(e, n).length() > i);
  }
  intersect(e, t) {
    const n = e.intersectsWithLine(this, t);
    return n ? Array.isArray(n) ? n : [n] : null;
  }
  /**
   * Returns the intersection point of the line with another line. Returns
   * `null` if no intersection exists.
   */
  intersectsWithLine(e) {
    const t = new M(this.end.x - this.start.x, this.end.y - this.start.y), n = new M(e.end.x - e.start.x, e.end.y - e.start.y), i = t.x * n.y - t.y * n.x, r = new M(e.start.x - this.start.x, e.start.y - this.start.y), o = r.x * n.y - r.y * n.x, a = r.x * t.y - r.y * t.x;
    if (i === 0 || o * i < 0 || a * i < 0)
      return null;
    if (i > 0) {
      if (o > i || a > i)
        return null;
    } else if (o < i || a < i)
      return null;
    return new M(this.start.x + o * t.x / i, this.start.y + o * t.y / i);
  }
  /**
   * Returns `true` if a tangent line can be found for the line.
   *
   * Tangents cannot be found if both of the line endpoints are coincident
   * (the line appears to be a point).
   */
  isDifferentiable() {
    return !this.start.equals(this.end);
  }
  /**
   * Returns the perpendicular distance between the line and point. The
   * distance is positive if the point lies to the right of the line, negative
   * if the point lies to the left of the line, and `0` if the point lies on
   * the line.
   */
  pointOffset(e) {
    const t = M.clone(e), n = this.start, i = this.end;
    return ((i.x - n.x) * (t.y - n.y) - (i.y - n.y) * (t.x - n.x)) / this.length();
  }
  pointSquaredDistance(e, t) {
    const n = M.create(e, t);
    return this.closestPoint(n).squaredDistance(n);
  }
  pointDistance(e, t) {
    const n = M.create(e, t);
    return this.closestPoint(n).distance(n);
  }
  /**
   * Returns a line tangent to the line at point that lies `rate` (normalized
   * length) away from the beginning of the line.
   */
  tangentAt(e) {
    if (!this.isDifferentiable())
      return null;
    const t = this.start, n = this.end, i = this.pointAt(e), r = new $(t, n);
    return r.translate(i.x - t.x, i.y - t.y), r;
  }
  /**
   * Returns a line tangent to the line at point that lies `length` away from
   * the beginning of the line.
   */
  tangentAtLength(e) {
    if (!this.isDifferentiable())
      return null;
    const t = this.start, n = this.end, i = this.pointAtLength(e), r = new $(t, n);
    return r.translate(i.x - t.x, i.y - t.y), r;
  }
  relativeCcw(e, t) {
    const n = M.create(e, t);
    let i = n.x - this.start.x, r = n.y - this.start.y;
    const o = this.end.x - this.start.x, a = this.end.y - this.start.y;
    let l = i * a - r * o;
    return l === 0 && (l = i * o + r * a, l > 0 && (i -= o, r -= a, l = i * o + r * a, l < 0 && (l = 0))), l < 0 ? -1 : l > 0 ? 1 : 0;
  }
  /**
   * Return `true` if the line equals the other line.
   */
  equals(e) {
    return e != null && this.start.x === e.start.x && this.start.y === e.start.y && this.end.x === e.end.x && this.end.y === e.end.y;
  }
  /**
   * Returns another line which is a clone of the line.
   */
  clone() {
    return new $(this.start, this.end);
  }
  toJSON() {
    return { start: this.start.toJSON(), end: this.end.toJSON() };
  }
  serialize() {
    return [this.start.serialize(), this.end.serialize()].join(" ");
  }
}
(function(s) {
  function e(t) {
    return t != null && t instanceof s;
  }
  s.isLine = e;
})($ || ($ = {}));
class It extends Un {
  get center() {
    return new M(this.x, this.y);
  }
  constructor(e, t, n, i) {
    super(), this.x = e == null ? 0 : e, this.y = t == null ? 0 : t, this.a = n == null ? 0 : n, this.b = i == null ? 0 : i;
  }
  /**
   * Returns a rectangle that is the bounding box of the ellipse.
   */
  bbox() {
    return R.fromEllipse(this);
  }
  /**
   * Returns a point that is the center of the ellipse.
   */
  getCenter() {
    return this.center;
  }
  inflate(e, t) {
    const n = e, i = t != null ? t : e;
    return this.a += 2 * n, this.b += 2 * i, this;
  }
  normalizedDistance(e, t) {
    const n = M.create(e, t), i = n.x - this.x, r = n.y - this.y, o = this.a, a = this.b;
    return i * i / (o * o) + r * r / (a * a);
  }
  containsPoint(e, t) {
    return this.normalizedDistance(e, t) <= 1;
  }
  /**
   * Returns an array of the intersection points of the ellipse and the line.
   * Returns `null` if no intersection exists.
   */
  intersectsWithLine(e) {
    const t = [], n = this.a, i = this.b, r = e.start, o = e.end, a = e.vector(), l = r.diff(new M(this.x, this.y)), c = new M(a.x / (n * n), a.y / (i * i)), u = new M(l.x / (n * n), l.y / (i * i)), d = a.dot(c), f = a.dot(u), g = l.dot(u) - 1, p = f * f - d * g;
    if (p < 0)
      return null;
    if (p > 0) {
      const m = Math.sqrt(p), w = (-f - m) / d, v = (-f + m) / d;
      if ((w < 0 || w > 1) && (v < 0 || v > 1))
        return null;
      w >= 0 && w <= 1 && t.push(r.lerp(o, w)), v >= 0 && v <= 1 && t.push(r.lerp(o, v));
    } else {
      const m = -f / d;
      if (m >= 0 && m <= 1)
        t.push(r.lerp(o, m));
      else
        return null;
    }
    return t;
  }
  /**
   * Returns the point on the boundary of the ellipse that is the
   * intersection of the ellipse with a line starting in the center
   * of the ellipse ending in the point `p`.
   *
   * If angle is specified, the intersection will take into account
   * the rotation of the ellipse by angle degrees around its center.
   */
  intersectsWithLineFromCenterToPoint(e, t = 0) {
    const n = M.clone(e);
    t && n.rotate(t, this.getCenter());
    const i = n.x - this.x, r = n.y - this.y;
    let o;
    if (i === 0)
      return o = this.bbox().getNearestPointToPoint(n), t ? o.rotate(-t, this.getCenter()) : o;
    const a = r / i, l = a * a, c = this.a * this.a, u = this.b * this.b;
    let d = Math.sqrt(1 / (1 / c + l / u));
    d = i < 0 ? -d : d;
    const f = a * d;
    return o = new M(this.x + d, this.y + f), t ? o.rotate(-t, this.getCenter()) : o;
  }
  /**
   * Returns the angle between the x-axis and the tangent from a point. It is
   * valid for points lying on the ellipse boundary only.
   */
  tangentTheta(e) {
    const t = M.clone(e), n = t.x, i = t.y, r = this.a, o = this.b, a = this.bbox().center, l = a.x, c = a.y, u = 30, d = n > a.x + r / 2, f = n < a.x - r / 2;
    let g, p;
    return d || f ? (p = n > a.x ? i - u : i + u, g = r * r / (n - l) - r * r * (i - c) * (p - c) / (o * o * (n - l)) + l) : (g = i > a.y ? n + u : n - u, p = o * o / (i - c) - o * o * (n - l) * (g - l) / (r * r * (i - c)) + c), new M(g, p).theta(t);
  }
  scale(e, t) {
    return this.a *= e, this.b *= t, this;
  }
  rotate(e, t) {
    const n = R.fromEllipse(this);
    n.rotate(e, t);
    const i = It.fromRect(n);
    return this.a = i.a, this.b = i.b, this.x = i.x, this.y = i.y, this;
  }
  translate(e, t) {
    const n = M.create(e, t);
    return this.x += n.x, this.y += n.y, this;
  }
  equals(e) {
    return e != null && e.x === this.x && e.y === this.y && e.a === this.a && e.b === this.b;
  }
  clone() {
    return new It(this.x, this.y, this.a, this.b);
  }
  toJSON() {
    return { x: this.x, y: this.y, a: this.a, b: this.b };
  }
  serialize() {
    return "".concat(this.x, " ").concat(this.y, " ").concat(this.a, " ").concat(this.b);
  }
}
(function(s) {
  function e(t) {
    return t != null && t instanceof s;
  }
  s.isEllipse = e;
})(It || (It = {}));
(function(s) {
  function e(i, r, o, a) {
    return i == null || typeof i == "number" ? new s(i, r, o, a) : t(i);
  }
  s.create = e;
  function t(i) {
    return s.isEllipse(i) ? i.clone() : Array.isArray(i) ? new s(i[0], i[1], i[2], i[3]) : new s(i.x, i.y, i.a, i.b);
  }
  s.parse = t;
  function n(i) {
    const r = i.center;
    return new s(r.x, r.y, i.width / 2, i.height / 2);
  }
  s.fromRect = n;
})(It || (It = {}));
const f3 = new RegExp("^[\\s\\dLMCZz,.]*$");
function g3(s) {
  return typeof s != "string" ? !1 : f3.test(s);
}
function ja(s, e) {
  return (s % e + e) % e;
}
function p3(s, e, t, n, i) {
  const r = [], o = s[s.length - 1], a = e != null && e > 0, l = e || 0;
  if (n && a) {
    s = s.slice();
    const d = s[0], f = new M(o.x + (d.x - o.x) / 2, o.y + (d.y - o.y) / 2);
    s.splice(0, 0, f);
  }
  let c = s[0], u = 1;
  for (t ? r.push("M", c.x, c.y) : r.push("L", c.x, c.y); u < (n ? s.length : s.length - 1); ) {
    let d = s[ja(u, s.length)], f = c.x - d.x, g = c.y - d.y;
    if (a && (f !== 0 || g !== 0) && (i == null || i.indexOf(u - 1) < 0)) {
      let p = Math.sqrt(f * f + g * g);
      const m = f * Math.min(l, p / 2) / p, w = g * Math.min(l, p / 2) / p, v = d.x + m, y = d.y + w;
      r.push("L", v, y);
      let b = s[ja(u + 1, s.length)];
      for (; u < s.length - 2 && Math.round(b.x - d.x) === 0 && Math.round(b.y - d.y) === 0; )
        b = s[ja(u + 2, s.length)], u += 1;
      f = b.x - d.x, g = b.y - d.y, p = Math.max(1, Math.sqrt(f * f + g * g));
      const x = f * Math.min(l, p / 2) / p, C = g * Math.min(l, p / 2) / p, A = d.x + x, k = d.y + C;
      r.push("Q", d.x, d.y, A, k), d = new M(A, k);
    } else
      r.push("L", d.x, d.y);
    c = d, u += 1;
  }
  return n ? r.push("Z") : r.push("L", o.x, o.y), r.map((d) => typeof d == "string" ? d : +d.toFixed(3)).join(" ");
}
function Hf(s, e = {}) {
  const t = [];
  return s && s.length && s.forEach((n) => {
    Array.isArray(n) ? t.push({ x: n[0], y: n[1] }) : t.push({ x: n.x, y: n.y });
  }), p3(t, e.round, e.initialMove == null || e.initialMove, e.close, e.exclude);
}
function Eo(s, e, t, n, i = 0, r = 0, o = 0, a, l) {
  if (t === 0 || n === 0)
    return [];
  a -= s, l -= e, t = Math.abs(t), n = Math.abs(n);
  const c = -a / 2, u = -l / 2, d = Math.cos(i * Math.PI / 180), f = Math.sin(i * Math.PI / 180), g = d * c + f * u, p = -1 * f * c + d * u, m = g * g, w = p * p, v = t * t, y = n * n, b = m / v + w / y;
  let x;
  if (b > 1)
    t = Math.sqrt(b) * t, n = Math.sqrt(b) * n, x = 0;
  else {
    let st = 1;
    r === o && (st = -1), x = st * Math.sqrt((v * y - v * w - y * m) / (v * w + y * m));
  }
  const C = x * t * p / n, A = -1 * x * n * g / t, k = d * C - f * A + a / 2, O = f * C + d * A + l / 2;
  let P = Math.atan2((p - A) / n, (g - C) / t) - Math.atan2(0, 1), D = P >= 0 ? P : 2 * Math.PI + P;
  P = Math.atan2((-p - A) / n, (-g - C) / t) - Math.atan2((p - A) / n, (g - C) / t);
  let N = P >= 0 ? P : 2 * Math.PI + P;
  o === 0 && N > 0 ? N -= 2 * Math.PI : o !== 0 && N < 0 && (N += 2 * Math.PI);
  const F = N * 2 / Math.PI, ee = Math.ceil(F < 0 ? -1 * F : F), X = N / ee, _ = 8 / 3 * Math.sin(X / 4) * Math.sin(X / 4) / Math.sin(X / 2), I = d * t, W = d * n, oe = f * t, re = f * n;
  let xe = Math.cos(D), ce = Math.sin(D), bn = -_ * (I * ce + re * xe), bt = -_ * (oe * ce - W * xe), ut = 0, Ft = 0;
  const dt = [];
  for (let st = 0; st < ee; st += 1) {
    D += X, xe = Math.cos(D), ce = Math.sin(D), ut = I * xe - re * ce + k, Ft = oe * xe + W * ce + O;
    const Jn = -_ * (I * ce + re * xe), Yn = -_ * (oe * ce - W * xe), $t = st * 6;
    dt[$t] = Number(bn + s), dt[$t + 1] = Number(bt + e), dt[$t + 2] = Number(ut - Jn + s), dt[$t + 3] = Number(Ft - Yn + e), dt[$t + 4] = Number(ut + s), dt[$t + 5] = Number(Ft + e), bn = ut + Jn, bt = Ft + Yn;
  }
  return dt.map((st) => +st.toFixed(2));
}
function m3(s, e, t, n, i = 0, r = 0, o = 0, a, l) {
  const c = [], u = Eo(s, e, t, n, i, r, o, a, l);
  if (u != null)
    for (let d = 0, f = u.length; d < f; d += 6)
      c.push("C", u[d], u[d + 1], u[d + 2], u[d + 3], u[d + 4], u[d + 5]);
  return c.join(" ");
}
class Oe extends Un {
  get start() {
    return this.points[0] || null;
  }
  get end() {
    return this.points[this.points.length - 1] || null;
  }
  constructor(e) {
    if (super(), e != null) {
      if (typeof e == "string")
        return Oe.parse(e);
      this.points = e.map((t) => M.create(t));
    } else
      this.points = [];
  }
  scale(e, t, n = new M()) {
    return this.points.forEach((i) => i.scale(e, t, n)), this;
  }
  rotate(e, t) {
    return this.points.forEach((n) => n.rotate(e, t)), this;
  }
  translate(e, t) {
    const n = M.create(e, t);
    return this.points.forEach((i) => i.translate(n.x, n.y)), this;
  }
  round(e = 0) {
    return this.points.forEach((t) => t.round(e)), this;
  }
  bbox() {
    if (this.points.length === 0)
      return new R();
    let e = 1 / 0, t = -1 / 0, n = 1 / 0, i = -1 / 0;
    const r = this.points;
    for (let o = 0, a = r.length; o < a; o += 1) {
      const l = r[o], c = l.x, u = l.y;
      c < e && (e = c), c > t && (t = c), u < n && (n = u), u > i && (i = u);
    }
    return new R(e, n, t - e, i - n);
  }
  closestPoint(e) {
    const t = this.closestPointLength(e);
    return this.pointAtLength(t);
  }
  closestPointLength(e) {
    const t = this.points, n = t.length;
    if (n === 0 || n === 1)
      return 0;
    let i = 0, r = 0, o = 1 / 0;
    for (let a = 0, l = n - 1; a < l; a += 1) {
      const c = new $(t[a], t[a + 1]), u = c.length(), d = c.closestPointNormalizedLength(e), g = c.pointAt(d).squaredDistance(e);
      g < o && (o = g, r = i + d * u), i += u;
    }
    return r;
  }
  closestPointNormalizedLength(e) {
    const t = this.length();
    return t === 0 ? 0 : this.closestPointLength(e) / t;
  }
  closestPointTangent(e) {
    const t = this.closestPointLength(e);
    return this.tangentAtLength(t);
  }
  containsPoint(e) {
    if (this.points.length === 0)
      return !1;
    const t = M.clone(e), n = t.x, i = t.y, r = this.points, o = r.length;
    let a = o - 1, l = 0;
    for (let c = 0; c < o; c += 1) {
      const u = r[a], d = r[c];
      if (t.equals(u))
        return !0;
      const f = new $(u, d);
      if (f.containsPoint(e))
        return !0;
      if (i <= u.y && i > d.y || i > u.y && i <= d.y) {
        const g = u.x - n > d.x - n ? u.x - n : d.x - n;
        if (g >= 0) {
          const p = new M(n + g, i), m = new $(e, p);
          f.intersectsWithLine(m) && (l += 1);
        }
      }
      a = c;
    }
    return l % 2 === 1;
  }
  intersectsWithLine(e) {
    const t = [];
    for (let n = 0, i = this.points.length - 1; n < i; n += 1) {
      const r = this.points[n], o = this.points[n + 1], a = e.intersectsWithLine(new $(r, o));
      a && t.push(a);
    }
    return t.length > 0 ? t : null;
  }
  isDifferentiable() {
    for (let e = 0, t = this.points.length - 1; e < t; e += 1) {
      const n = this.points[e], i = this.points[e + 1];
      if (new $(n, i).isDifferentiable())
        return !0;
    }
    return !1;
  }
  length() {
    let e = 0;
    for (let t = 0, n = this.points.length - 1; t < n; t += 1) {
      const i = this.points[t], r = this.points[t + 1];
      e += i.distance(r);
    }
    return e;
  }
  pointAt(e) {
    const t = this.points, n = t.length;
    if (n === 0)
      return null;
    if (n === 1 || e <= 0)
      return t[0].clone();
    if (e >= 1)
      return t[n - 1].clone();
    const r = this.length() * e;
    return this.pointAtLength(r);
  }
  pointAtLength(e) {
    const t = this.points, n = t.length;
    if (n === 0)
      return null;
    if (n === 1)
      return t[0].clone();
    let i = !0;
    e < 0 && (i = !1, e = -e);
    let r = 0;
    for (let a = 0, l = n - 1; a < l; a += 1) {
      const c = i ? a : l - 1 - a, u = t[c], d = t[c + 1], f = new $(u, d), g = u.distance(d);
      if (e <= r + g)
        return f.pointAtLength((i ? 1 : -1) * (e - r));
      r += g;
    }
    return (i ? t[n - 1] : t[0]).clone();
  }
  tangentAt(e) {
    const n = this.points.length;
    if (n === 0 || n === 1)
      return null;
    e < 0 && (e = 0), e > 1 && (e = 1);
    const r = this.length() * e;
    return this.tangentAtLength(r);
  }
  tangentAtLength(e) {
    const t = this.points, n = t.length;
    if (n === 0 || n === 1)
      return null;
    let i = !0;
    e < 0 && (i = !1, e = -e);
    let r, o = 0;
    for (let a = 0, l = n - 1; a < l; a += 1) {
      const c = i ? a : l - 1 - a, u = t[c], d = t[c + 1], f = new $(u, d), g = u.distance(d);
      if (f.isDifferentiable()) {
        if (e <= o + g)
          return f.tangentAtLength((i ? 1 : -1) * (e - o));
        r = f;
      }
      o += g;
    }
    if (r) {
      const a = i ? 1 : 0;
      return r.tangentAt(a);
    }
    return null;
  }
  simplify(e = {}) {
    const t = this.points;
    if (t.length < 3)
      return this;
    const n = e.threshold || 0;
    let i = 0;
    for (; t[i + 2]; ) {
      const r = i, o = i + 1, a = i + 2, l = t[r], c = t[o], u = t[a];
      new $(l, u).closestPoint(c).distance(c) <= n ? t.splice(o, 1) : i += 1;
    }
    return this;
  }
  toHull() {
    const e = this.points, t = e.length;
    if (t === 0)
      return new Oe();
    let n = e[0];
    for (let f = 1; f < t; f += 1)
      (e[f].y < n.y || e[f].y === n.y && e[f].x > n.x) && (n = e[f]);
    const i = [];
    for (let f = 0; f < t; f += 1) {
      let g = n.theta(e[f]);
      g === 0 && (g = 360), i.push([e[f], f, g]);
    }
    if (i.sort((f, g) => {
      let p = f[2] - g[2];
      return p === 0 && (p = g[1] - f[1]), p;
    }), i.length > 2) {
      const f = i[i.length - 1];
      i.unshift(f);
    }
    const r = {}, o = [], a = (f) => "".concat(f[0].toString(), "@").concat(f[1]);
    for (; i.length !== 0; ) {
      const f = i.pop(), g = f[0];
      if (r[a(f)])
        continue;
      let p = !1;
      for (; !p; )
        if (o.length < 2)
          o.push(f), p = !0;
        else {
          const m = o.pop(), w = m[0], v = o.pop(), y = v[0], b = y.cross(w, g);
          if (b < 0)
            o.push(v), o.push(m), o.push(f), p = !0;
          else if (b === 0) {
            const C = w.angleBetween(y, g);
            Math.abs(C - 180) < 1e-10 || w.equals(g) || y.equals(w) ? (r[a(m)] = w, o.push(v)) : Math.abs((C + 1) % 360 - 1) < 1e-10 && (o.push(v), i.push(m));
          } else
            r[a(m)] = w, o.push(v);
        }
    }
    o.length > 2 && o.pop();
    let l, c = -1;
    for (let f = 0, g = o.length; f < g; f += 1) {
      const p = o[f][1];
      (l === void 0 || p < l) && (l = p, c = f);
    }
    let u = [];
    if (c > 0) {
      const f = o.slice(c), g = o.slice(0, c);
      u = f.concat(g);
    } else
      u = o;
    const d = [];
    for (let f = 0, g = u.length; f < g; f += 1)
      d.push(u[f][0]);
    return new Oe(d);
  }
  equals(e) {
    return e == null || e.points.length !== this.points.length ? !1 : e.points.every((t, n) => t.equals(this.points[n]));
  }
  clone() {
    return new Oe(this.points.map((e) => e.clone()));
  }
  toJSON() {
    return this.points.map((e) => e.toJSON());
  }
  serialize() {
    return this.points.map((e) => "".concat(e.serialize())).join(" ");
  }
}
(function(s) {
  function e(t) {
    return t != null && t instanceof s;
  }
  s.isPolyline = e;
})(Oe || (Oe = {}));
(function(s) {
  function e(t) {
    const n = t.trim();
    if (n === "")
      return new s();
    const i = [], r = n.split(/\s*,\s*|\s+/);
    for (let o = 0, a = r.length; o < a; o += 2)
      i.push({ x: +r[o], y: +r[o + 1] });
    return new s(i);
  }
  s.parse = e;
})(Oe || (Oe = {}));
class Se extends Un {
  constructor(e, t, n, i) {
    super(), this.PRECISION = 3, this.start = M.create(e), this.controlPoint1 = M.create(t), this.controlPoint2 = M.create(n), this.end = M.create(i);
  }
  bbox() {
    const e = this.start, t = this.controlPoint1, n = this.controlPoint2, i = this.end, r = e.x, o = e.y, a = t.x, l = t.y, c = n.x, u = n.y, d = i.x, f = i.y, g = [], p = [[], []];
    let m, w, v, y, b, x, C, A;
    for (let I = 0; I < 2; I += 1) {
      if (I === 0 ? (w = 6 * r - 12 * a + 6 * c, m = -3 * r + 9 * a - 9 * c + 3 * d, v = 3 * a - 3 * r) : (w = 6 * o - 12 * l + 6 * u, m = -3 * o + 9 * l - 9 * u + 3 * f, v = 3 * l - 3 * o), Math.abs(m) < 1e-12) {
        if (Math.abs(w) < 1e-12)
          continue;
        y = -v / w, y > 0 && y < 1 && g.push(y);
        continue;
      }
      C = w * w - 4 * v * m, A = Math.sqrt(C), !(C < 0) && (b = (-w + A) / (2 * m), b > 0 && b < 1 && g.push(b), x = (-w - A) / (2 * m), x > 0 && x < 1 && g.push(x));
    }
    let k, O, P, D = g.length;
    const N = D;
    for (; D; )
      D -= 1, y = g[D], P = 1 - y, k = P * P * P * r + 3 * P * P * y * a + 3 * P * y * y * c + y * y * y * d, p[0][D] = k, O = P * P * P * o + 3 * P * P * y * l + 3 * P * y * y * u + y * y * y * f, p[1][D] = O;
    g[N] = 0, g[N + 1] = 1, p[0][N] = r, p[1][N] = o, p[0][N + 1] = d, p[1][N + 1] = f, g.length = N + 2, p[0].length = N + 2, p[1].length = N + 2;
    const F = Math.min.apply(null, p[0]), ee = Math.min.apply(null, p[1]), X = Math.max.apply(null, p[0]), _ = Math.max.apply(null, p[1]);
    return new R(F, ee, X - F, _ - ee);
  }
  closestPoint(e, t = {}) {
    return this.pointAtT(this.closestPointT(e, t));
  }
  closestPointLength(e, t = {}) {
    const n = this.getOptions(t);
    return this.lengthAtT(this.closestPointT(e, n), n);
  }
  closestPointNormalizedLength(e, t = {}) {
    const n = this.getOptions(t), i = this.closestPointLength(e, n);
    if (!i)
      return 0;
    const r = this.length(n);
    return r === 0 ? 0 : i / r;
  }
  closestPointT(e, t = {}) {
    const n = this.getPrecision(t), i = this.getDivisions(t), r = Math.pow(10, -n);
    let o = null, a = 0, l = 0, c = 0, u = 0, d = 0, f = null;
    const g = i.length;
    let p = g > 0 ? 1 / g : 0;
    for (i.forEach((m, w) => {
      const v = m.start.distance(e), y = m.end.distance(e), b = v + y;
      (f == null || b < f) && (o = m, a = w * p, l = (w + 1) * p, c = v, u = y, f = b, d = m.endpointDistance());
    }); ; ) {
      const m = c ? Math.abs(c - u) / c : 0, w = u != null ? Math.abs(c - u) / u : 0, v = m < r || w < r, y = c ? c < d * r : !0, b = u ? u < d * r : !0;
      if (v || (y || b))
        return c <= u ? a : l;
      const C = o.divide(0.5);
      p /= 2;
      const A = C[0].start.distance(e), k = C[0].end.distance(e), O = A + k, P = C[1].start.distance(e), D = C[1].end.distance(e), N = P + D;
      O <= N ? (o = C[0], l -= p, c = A, u = k) : (o = C[1], a += p, c = P, u = D);
    }
  }
  closestPointTangent(e, t = {}) {
    return this.tangentAtT(this.closestPointT(e, t));
  }
  containsPoint(e, t = {}) {
    return this.toPolyline(t).containsPoint(e);
  }
  divideAt(e, t = {}) {
    if (e <= 0)
      return this.divideAtT(0);
    if (e >= 1)
      return this.divideAtT(1);
    const n = this.tAt(e, t);
    return this.divideAtT(n);
  }
  divideAtLength(e, t = {}) {
    const n = this.tAtLength(e, t);
    return this.divideAtT(n);
  }
  divide(e) {
    return this.divideAtT(e);
  }
  divideAtT(e) {
    const t = this.start, n = this.controlPoint1, i = this.controlPoint2, r = this.end;
    if (e <= 0)
      return [
        new Se(t, t, t, t),
        new Se(t, n, i, r)
      ];
    if (e >= 1)
      return [
        new Se(t, n, i, r),
        new Se(r, r, r, r)
      ];
    const o = this.getSkeletonPoints(e), a = o.startControlPoint1, l = o.startControlPoint2, c = o.divider, u = o.dividerControlPoint1, d = o.dividerControlPoint2;
    return [
      new Se(t, a, l, c),
      new Se(c, u, d, r)
    ];
  }
  endpointDistance() {
    return this.start.distance(this.end);
  }
  getSkeletonPoints(e) {
    const t = this.start, n = this.controlPoint1, i = this.controlPoint2, r = this.end;
    if (e <= 0)
      return {
        startControlPoint1: t.clone(),
        startControlPoint2: t.clone(),
        divider: t.clone(),
        dividerControlPoint1: n.clone(),
        dividerControlPoint2: i.clone()
      };
    if (e >= 1)
      return {
        startControlPoint1: n.clone(),
        startControlPoint2: i.clone(),
        divider: r.clone(),
        dividerControlPoint1: r.clone(),
        dividerControlPoint2: r.clone()
      };
    const o = new $(t, n).pointAt(e), a = new $(n, i).pointAt(e), l = new $(i, r).pointAt(e), c = new $(o, a).pointAt(e), u = new $(a, l).pointAt(e), d = new $(c, u).pointAt(e);
    return {
      startControlPoint1: o,
      startControlPoint2: c,
      divider: d,
      dividerControlPoint1: u,
      dividerControlPoint2: l
    };
  }
  getSubdivisions(e = {}) {
    const t = this.getPrecision(e);
    let n = [
      new Se(this.start, this.controlPoint1, this.controlPoint2, this.end)
    ];
    if (t === 0)
      return n;
    let i = this.endpointDistance();
    const r = Math.pow(10, -t);
    let o = 0;
    for (; ; ) {
      o += 1;
      const a = [];
      n.forEach((u) => {
        const d = u.divide(0.5);
        a.push(d[0], d[1]);
      });
      const l = a.reduce((u, d) => u + d.endpointDistance(), 0), c = l !== 0 ? (l - i) / l : 0;
      if (o > 1 && c < r)
        return a;
      n = a, i = l;
    }
  }
  length(e = {}) {
    return this.getDivisions(e).reduce((n, i) => n + i.endpointDistance(), 0);
  }
  lengthAtT(e, t = {}) {
    if (e <= 0)
      return 0;
    const n = t.precision === void 0 ? this.PRECISION : t.precision;
    return this.divide(e)[0].length({ precision: n });
  }
  pointAt(e, t = {}) {
    if (e <= 0)
      return this.start.clone();
    if (e >= 1)
      return this.end.clone();
    const n = this.tAt(e, t);
    return this.pointAtT(n);
  }
  pointAtLength(e, t = {}) {
    const n = this.tAtLength(e, t);
    return this.pointAtT(n);
  }
  pointAtT(e) {
    return e <= 0 ? this.start.clone() : e >= 1 ? this.end.clone() : this.getSkeletonPoints(e).divider;
  }
  isDifferentiable() {
    const e = this.start, t = this.controlPoint1, n = this.controlPoint2, i = this.end;
    return !(e.equals(t) && t.equals(n) && n.equals(i));
  }
  tangentAt(e, t = {}) {
    if (!this.isDifferentiable())
      return null;
    e < 0 ? e = 0 : e > 1 && (e = 1);
    const n = this.tAt(e, t);
    return this.tangentAtT(n);
  }
  tangentAtLength(e, t = {}) {
    if (!this.isDifferentiable())
      return null;
    const n = this.tAtLength(e, t);
    return this.tangentAtT(n);
  }
  tangentAtT(e) {
    if (!this.isDifferentiable())
      return null;
    e < 0 && (e = 0), e > 1 && (e = 1);
    const t = this.getSkeletonPoints(e), n = t.startControlPoint2, i = t.dividerControlPoint1, r = t.divider, o = new $(n, i);
    return o.translate(r.x - n.x, r.y - n.y), o;
  }
  getPrecision(e = {}) {
    return e.precision == null ? this.PRECISION : e.precision;
  }
  getDivisions(e = {}) {
    if (e.subdivisions != null)
      return e.subdivisions;
    const t = this.getPrecision(e);
    return this.getSubdivisions({ precision: t });
  }
  getOptions(e = {}) {
    const t = this.getPrecision(e), n = this.getDivisions(e);
    return { precision: t, subdivisions: n };
  }
  tAt(e, t = {}) {
    if (e <= 0)
      return 0;
    if (e >= 1)
      return 1;
    const n = this.getOptions(t), r = this.length(n) * e;
    return this.tAtLength(r, n);
  }
  tAtLength(e, t = {}) {
    let n = !0;
    e < 0 && (n = !1, e = -e);
    const i = this.getPrecision(t), r = this.getDivisions(t), o = { precision: i, subdivisions: r };
    let a = null, l, c, u = 0, d = 0, f = 0;
    const g = r.length;
    let p = g > 0 ? 1 / g : 0;
    for (let v = 0; v < g; v += 1) {
      const y = n ? v : g - 1 - v, b = r[v], x = b.endpointDistance();
      if (e <= f + x) {
        a = b, l = y * p, c = (y + 1) * p, u = n ? e - f : x + f - e, d = n ? x + f - e : e - f;
        break;
      }
      f += x;
    }
    if (a == null)
      return n ? 1 : 0;
    const m = this.length(o), w = Math.pow(10, -i);
    for (; ; ) {
      let v;
      if (v = m !== 0 ? u / m : 0, v < w)
        return l;
      if (v = m !== 0 ? d / m : 0, v < w)
        return c;
      let y, b;
      const x = a.divide(0.5);
      p /= 2;
      const C = x[0].endpointDistance(), A = x[1].endpointDistance();
      u <= C ? (a = x[0], c -= p, y = u, b = C - y) : (a = x[1], l += p, y = u - C, b = A - y), u = y, d = b;
    }
  }
  toPoints(e = {}) {
    const t = this.getDivisions(e), n = [t[0].start.clone()];
    return t.forEach((i) => n.push(i.end.clone())), n;
  }
  toPolyline(e = {}) {
    return new Oe(this.toPoints(e));
  }
  scale(e, t, n) {
    return this.start.scale(e, t, n), this.controlPoint1.scale(e, t, n), this.controlPoint2.scale(e, t, n), this.end.scale(e, t, n), this;
  }
  rotate(e, t) {
    return this.start.rotate(e, t), this.controlPoint1.rotate(e, t), this.controlPoint2.rotate(e, t), this.end.rotate(e, t), this;
  }
  translate(e, t) {
    return typeof e == "number" ? (this.start.translate(e, t), this.controlPoint1.translate(e, t), this.controlPoint2.translate(e, t), this.end.translate(e, t)) : (this.start.translate(e), this.controlPoint1.translate(e), this.controlPoint2.translate(e), this.end.translate(e)), this;
  }
  equals(e) {
    return e != null && this.start.equals(e.start) && this.controlPoint1.equals(e.controlPoint1) && this.controlPoint2.equals(e.controlPoint2) && this.end.equals(e.end);
  }
  clone() {
    return new Se(this.start, this.controlPoint1, this.controlPoint2, this.end);
  }
  toJSON() {
    return {
      start: this.start.toJSON(),
      controlPoint1: this.controlPoint1.toJSON(),
      controlPoint2: this.controlPoint2.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    return [
      this.start.serialize(),
      this.controlPoint1.serialize(),
      this.controlPoint2.serialize(),
      this.end.serialize()
    ].join(" ");
  }
}
(function(s) {
  function e(t) {
    return t != null && t instanceof s;
  }
  s.isCurve = e;
})(Se || (Se = {}));
(function(s) {
  function e(i) {
    const r = i.length, o = [], a = [];
    let l = 2;
    o[0] = i[0] / l;
    for (let c = 1; c < r; c += 1)
      a[c] = 1 / l, l = (c < r - 1 ? 4 : 3.5) - a[c], o[c] = (i[c] - o[c - 1]) / l;
    for (let c = 1; c < r; c += 1)
      o[r - c - 1] -= a[r - c] * o[r - c];
    return o;
  }
  function t(i) {
    const r = i.map((f) => M.clone(f)), o = [], a = [], l = r.length - 1;
    if (l === 1)
      return o[0] = new M((2 * r[0].x + r[1].x) / 3, (2 * r[0].y + r[1].y) / 3), a[0] = new M(2 * o[0].x - r[0].x, 2 * o[0].y - r[0].y), [o, a];
    const c = [];
    for (let f = 1; f < l - 1; f += 1)
      c[f] = 4 * r[f].x + 2 * r[f + 1].x;
    c[0] = r[0].x + 2 * r[1].x, c[l - 1] = (8 * r[l - 1].x + r[l].x) / 2;
    const u = e(c);
    for (let f = 1; f < l - 1; f += 1)
      c[f] = 4 * r[f].y + 2 * r[f + 1].y;
    c[0] = r[0].y + 2 * r[1].y, c[l - 1] = (8 * r[l - 1].y + r[l].y) / 2;
    const d = e(c);
    for (let f = 0; f < l; f += 1)
      o.push(new M(u[f], d[f])), f < l - 1 ? a.push(new M(2 * r[f + 1].x - u[f + 1], 2 * r[f + 1].y - d[f + 1])) : a.push(new M((r[l].x + u[l - 1]) / 2, (r[l].y + d[l - 1]) / 2));
    return [o, a];
  }
  function n(i) {
    if (i == null || Array.isArray(i) && i.length < 2)
      throw new Error("At least 2 points are required");
    const r = t(i), o = [];
    for (let a = 0, l = r[0].length; a < l; a += 1) {
      const c = new M(r[0][a].x, r[0][a].y), u = new M(r[1][a].x, r[1][a].y);
      o.push(new s(i[a], c, u, i[a + 1]));
    }
    return o;
  }
  s.throughPoints = n;
})(Se || (Se = {}));
class Xo extends Un {
  constructor() {
    super(...arguments), this.isVisible = !0, this.isSegment = !0, this.isSubpathStart = !1;
  }
  get end() {
    return this.endPoint;
  }
  get start() {
    if (this.previousSegment == null)
      throw new Error("Missing previous segment. (This segment cannot be the first segment of a path, or segment has not yet been added to a path.)");
    return this.previousSegment.end;
  }
  closestPointT(e, t) {
    if (this.closestPointNormalizedLength)
      return this.closestPointNormalizedLength(e);
    throw new Error("Neither `closestPointT` nor `closestPointNormalizedLength` method is implemented.");
  }
  // eslint-disable-next-line
  lengthAtT(e, t) {
    if (e <= 0)
      return 0;
    const n = this.length();
    return e >= 1 ? n : n * e;
  }
  divideAtT(e) {
    if (this.divideAt)
      return this.divideAt(e);
    throw new Error("Neither `divideAtT` nor `divideAt` method is implemented.");
  }
  pointAtT(e) {
    if (this.pointAt)
      return this.pointAt(e);
    throw new Error("Neither `pointAtT` nor `pointAt` method is implemented.");
  }
  tangentAtT(e) {
    if (this.tangentAt)
      return this.tangentAt(e);
    throw new Error("Neither `tangentAtT` nor `tangentAt` method is implemented.");
  }
}
class tt extends Xo {
  constructor(e, t) {
    super(), $.isLine(e) ? this.endPoint = e.end.clone().round(2) : this.endPoint = M.create(e, t).round(2);
  }
  get type() {
    return "L";
  }
  get line() {
    return new $(this.start, this.end);
  }
  bbox() {
    return this.line.bbox();
  }
  closestPoint(e) {
    return this.line.closestPoint(e);
  }
  closestPointLength(e) {
    return this.line.closestPointLength(e);
  }
  closestPointNormalizedLength(e) {
    return this.line.closestPointNormalizedLength(e);
  }
  closestPointTangent(e) {
    return this.line.closestPointTangent(e);
  }
  length() {
    return this.line.length();
  }
  divideAt(e) {
    const t = this.line.divideAt(e);
    return [new tt(t[0]), new tt(t[1])];
  }
  divideAtLength(e) {
    const t = this.line.divideAtLength(e);
    return [new tt(t[0]), new tt(t[1])];
  }
  getSubdivisions() {
    return [];
  }
  pointAt(e) {
    return this.line.pointAt(e);
  }
  pointAtLength(e) {
    return this.line.pointAtLength(e);
  }
  tangentAt(e) {
    return this.line.tangentAt(e);
  }
  tangentAtLength(e) {
    return this.line.tangentAtLength(e);
  }
  isDifferentiable() {
    return this.previousSegment == null ? !1 : !this.start.equals(this.end);
  }
  clone() {
    return new tt(this.end);
  }
  scale(e, t, n) {
    return this.end.scale(e, t, n), this;
  }
  rotate(e, t) {
    return this.end.rotate(e, t), this;
  }
  translate(e, t) {
    return typeof e == "number" ? this.end.translate(e, t) : this.end.translate(e), this;
  }
  equals(e) {
    return this.type === e.type && this.start.equals(e.start) && this.end.equals(e.end);
  }
  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    const e = this.end;
    return "".concat(this.type, " ").concat(e.x, " ").concat(e.y);
  }
}
(function(s) {
  function e(...t) {
    const n = t.length, i = t[0];
    if ($.isLine(i))
      return new s(i);
    if (M.isPointLike(i))
      return n === 1 ? new s(i) : t.map((o) => new s(o));
    if (n === 2)
      return new s(+t[0], +t[1]);
    const r = [];
    for (let o = 0; o < n; o += 2) {
      const a = +t[o], l = +t[o + 1];
      r.push(new s(a, l));
    }
    return r;
  }
  s.create = e;
})(tt || (tt = {}));
class ni extends Xo {
  get end() {
    if (!this.subpathStartSegment)
      throw new Error("Missing subpath start segment. (This segment needs a subpath start segment (e.g. MoveTo), or segment has not yet been added to a path.)");
    return this.subpathStartSegment.end;
  }
  get type() {
    return "Z";
  }
  get line() {
    return new $(this.start, this.end);
  }
  bbox() {
    return this.line.bbox();
  }
  closestPoint(e) {
    return this.line.closestPoint(e);
  }
  closestPointLength(e) {
    return this.line.closestPointLength(e);
  }
  closestPointNormalizedLength(e) {
    return this.line.closestPointNormalizedLength(e);
  }
  closestPointTangent(e) {
    return this.line.closestPointTangent(e);
  }
  length() {
    return this.line.length();
  }
  divideAt(e) {
    const t = this.line.divideAt(e);
    return [
      // do not actually cut into the segment, first divided part can stay as Z
      t[1].isDifferentiable() ? new tt(t[0]) : this.clone(),
      new tt(t[1])
    ];
  }
  divideAtLength(e) {
    const t = this.line.divideAtLength(e);
    return [
      t[1].isDifferentiable() ? new tt(t[0]) : this.clone(),
      new tt(t[1])
    ];
  }
  getSubdivisions() {
    return [];
  }
  pointAt(e) {
    return this.line.pointAt(e);
  }
  pointAtLength(e) {
    return this.line.pointAtLength(e);
  }
  tangentAt(e) {
    return this.line.tangentAt(e);
  }
  tangentAtLength(e) {
    return this.line.tangentAtLength(e);
  }
  isDifferentiable() {
    return !this.previousSegment || !this.subpathStartSegment ? !1 : !this.start.equals(this.end);
  }
  scale() {
    return this;
  }
  rotate() {
    return this;
  }
  translate() {
    return this;
  }
  equals(e) {
    return this.type === e.type && this.start.equals(e.start) && this.end.equals(e.end);
  }
  clone() {
    return new ni();
  }
  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    return this.type;
  }
}
(function(s) {
  function e() {
    return new s();
  }
  s.create = e;
})(ni || (ni = {}));
class si extends Xo {
  constructor(e, t) {
    super(), this.isVisible = !1, this.isSubpathStart = !0, $.isLine(e) || Se.isCurve(e) ? this.endPoint = e.end.clone().round(2) : this.endPoint = M.create(e, t).round(2);
  }
  get start() {
    throw new Error("Illegal access. Moveto segments should not need a start property.");
  }
  get type() {
    return "M";
  }
  bbox() {
    return null;
  }
  closestPoint() {
    return this.end.clone();
  }
  closestPointLength() {
    return 0;
  }
  closestPointNormalizedLength() {
    return 0;
  }
  closestPointT() {
    return 1;
  }
  closestPointTangent() {
    return null;
  }
  length() {
    return 0;
  }
  lengthAtT() {
    return 0;
  }
  divideAt() {
    return [this.clone(), this.clone()];
  }
  divideAtLength() {
    return [this.clone(), this.clone()];
  }
  getSubdivisions() {
    return [];
  }
  pointAt() {
    return this.end.clone();
  }
  pointAtLength() {
    return this.end.clone();
  }
  pointAtT() {
    return this.end.clone();
  }
  tangentAt() {
    return null;
  }
  tangentAtLength() {
    return null;
  }
  tangentAtT() {
    return null;
  }
  isDifferentiable() {
    return !1;
  }
  scale(e, t, n) {
    return this.end.scale(e, t, n), this;
  }
  rotate(e, t) {
    return this.end.rotate(e, t), this;
  }
  translate(e, t) {
    return typeof e == "number" ? this.end.translate(e, t) : this.end.translate(e), this;
  }
  clone() {
    return new si(this.end);
  }
  equals(e) {
    return this.type === e.type && this.end.equals(e.end);
  }
  toJSON() {
    return {
      type: this.type,
      end: this.end.toJSON()
    };
  }
  serialize() {
    const e = this.end;
    return "".concat(this.type, " ").concat(e.x, " ").concat(e.y);
  }
}
(function(s) {
  function e(...t) {
    const n = t.length, i = t[0];
    if ($.isLine(i))
      return new s(i);
    if (Se.isCurve(i))
      return new s(i);
    if (M.isPointLike(i)) {
      if (n === 1)
        return new s(i);
      const o = [];
      for (let a = 0; a < n; a += 1)
        a === 0 ? o.push(new s(t[a])) : o.push(new tt(t[a]));
      return o;
    }
    if (n === 2)
      return new s(+t[0], +t[1]);
    const r = [];
    for (let o = 0; o < n; o += 2) {
      const a = +t[o], l = +t[o + 1];
      o === 0 ? r.push(new s(a, l)) : r.push(new tt(a, l));
    }
    return r;
  }
  s.create = e;
})(si || (si = {}));
class Ct extends Xo {
  constructor(e, t, n, i, r, o) {
    super(), Se.isCurve(e) ? (this.controlPoint1 = e.controlPoint1.clone().round(2), this.controlPoint2 = e.controlPoint2.clone().round(2), this.endPoint = e.end.clone().round(2)) : typeof e == "number" ? (this.controlPoint1 = new M(e, t).round(2), this.controlPoint2 = new M(n, i).round(2), this.endPoint = new M(r, o).round(2)) : (this.controlPoint1 = M.create(e).round(2), this.controlPoint2 = M.create(t).round(2), this.endPoint = M.create(n).round(2));
  }
  get type() {
    return "C";
  }
  get curve() {
    return new Se(this.start, this.controlPoint1, this.controlPoint2, this.end);
  }
  bbox() {
    return this.curve.bbox();
  }
  closestPoint(e) {
    return this.curve.closestPoint(e);
  }
  closestPointLength(e) {
    return this.curve.closestPointLength(e);
  }
  closestPointNormalizedLength(e) {
    return this.curve.closestPointNormalizedLength(e);
  }
  closestPointTangent(e) {
    return this.curve.closestPointTangent(e);
  }
  length() {
    return this.curve.length();
  }
  divideAt(e, t = {}) {
    const n = this.curve.divideAt(e, t);
    return [new Ct(n[0]), new Ct(n[1])];
  }
  divideAtLength(e, t = {}) {
    const n = this.curve.divideAtLength(e, t);
    return [new Ct(n[0]), new Ct(n[1])];
  }
  divideAtT(e) {
    const t = this.curve.divideAtT(e);
    return [new Ct(t[0]), new Ct(t[1])];
  }
  getSubdivisions() {
    return [];
  }
  pointAt(e) {
    return this.curve.pointAt(e);
  }
  pointAtLength(e) {
    return this.curve.pointAtLength(e);
  }
  tangentAt(e) {
    return this.curve.tangentAt(e);
  }
  tangentAtLength(e) {
    return this.curve.tangentAtLength(e);
  }
  isDifferentiable() {
    if (!this.previousSegment)
      return !1;
    const e = this.start, t = this.controlPoint1, n = this.controlPoint2, i = this.end;
    return !(e.equals(t) && t.equals(n) && n.equals(i));
  }
  scale(e, t, n) {
    return this.controlPoint1.scale(e, t, n), this.controlPoint2.scale(e, t, n), this.end.scale(e, t, n), this;
  }
  rotate(e, t) {
    return this.controlPoint1.rotate(e, t), this.controlPoint2.rotate(e, t), this.end.rotate(e, t), this;
  }
  translate(e, t) {
    return typeof e == "number" ? (this.controlPoint1.translate(e, t), this.controlPoint2.translate(e, t), this.end.translate(e, t)) : (this.controlPoint1.translate(e), this.controlPoint2.translate(e), this.end.translate(e)), this;
  }
  equals(e) {
    return this.start.equals(e.start) && this.end.equals(e.end) && this.controlPoint1.equals(e.controlPoint1) && this.controlPoint2.equals(e.controlPoint2);
  }
  clone() {
    return new Ct(this.controlPoint1, this.controlPoint2, this.end);
  }
  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      controlPoint1: this.controlPoint1.toJSON(),
      controlPoint2: this.controlPoint2.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    const e = this.controlPoint1, t = this.controlPoint2, n = this.end;
    return [this.type, e.x, e.y, t.x, t.y, n.x, n.y].join(" ");
  }
}
(function(s) {
  function e(...t) {
    const n = t.length, i = t[0];
    if (Se.isCurve(i))
      return new s(i);
    if (M.isPointLike(i)) {
      if (n === 3)
        return new s(t[0], t[1], t[2]);
      const o = [];
      for (let a = 0; a < n; a += 3)
        o.push(new s(t[a], t[a + 1], t[a + 2]));
      return o;
    }
    if (n === 6)
      return new s(t[0], t[1], t[2], t[3], t[4], t[5]);
    const r = [];
    for (let o = 0; o < n; o += 6)
      r.push(new s(t[o], t[o + 1], t[o + 2], t[o + 3], t[o + 4], t[o + 5]));
    return r;
  }
  s.create = e;
})(Ct || (Ct = {}));
function Vr(s, e, t) {
  return {
    x: s * Math.cos(t) - e * Math.sin(t),
    y: s * Math.sin(t) + e * Math.cos(t)
  };
}
function $h(s, e, t, n, i, r) {
  const o = 0.3333333333333333, a = 2 / 3;
  return [
    o * s + a * t,
    o * e + a * n,
    o * i + a * t,
    o * r + a * n,
    i,
    r
  ];
}
function Uf(s, e, t, n, i, r, o, a, l, c) {
  const u = Math.PI * 120 / 180, d = Math.PI / 180 * (+i || 0);
  let f = [], g, p, m, w, v;
  if (c)
    p = c[0], m = c[1], w = c[2], v = c[3];
  else {
    g = Vr(s, e, -d), s = g.x, e = g.y, g = Vr(a, l, -d), a = g.x, l = g.y;
    const X = (s - a) / 2, _ = (e - l) / 2;
    let I = X * X / (t * t) + _ * _ / (n * n);
    I > 1 && (I = Math.sqrt(I), t = I * t, n = I * n);
    const W = t * t, oe = n * n, re = (r === o ? -1 : 1) * Math.sqrt(Math.abs((W * oe - W * _ * _ - oe * X * X) / (W * _ * _ + oe * X * X)));
    w = re * t * _ / n + (s + a) / 2, v = re * -n * X / t + (e + l) / 2, p = Math.asin((e - v) / n), m = Math.asin((l - v) / n), p = s < w ? Math.PI - p : p, m = a < w ? Math.PI - m : m, p < 0 && (p = Math.PI * 2 + p), m < 0 && (m = Math.PI * 2 + m), o && p > m && (p -= Math.PI * 2), !o && m > p && (m -= Math.PI * 2);
  }
  let y = m - p;
  if (Math.abs(y) > u) {
    const X = m, _ = a, I = l;
    m = p + u * (o && m > p ? 1 : -1), a = w + t * Math.cos(m), l = v + n * Math.sin(m), f = Uf(a, l, t, n, i, 0, o, _, I, [
      m,
      X,
      w,
      v
    ]);
  }
  y = m - p;
  const b = Math.cos(p), x = Math.sin(p), C = Math.cos(m), A = Math.sin(m), k = Math.tan(y / 4), O = 4 / 3 * (t * k), P = 4 / 3 * (n * k), D = [s, e], N = [s + O * x, e - P * b], F = [a + O * A, l - P * C], ee = [a, l];
  if (N[0] = 2 * D[0] - N[0], N[1] = 2 * D[1] - N[1], c)
    return [N, F, ee].concat(f);
  {
    f = [N, F, ee].concat(f).join().split(",");
    const X = [], _ = f.length;
    for (let I = 0; I < _; I += 1)
      X[I] = I % 2 ? Vr(+f[I - 1], +f[I], d).y : Vr(+f[I], +f[I + 1], d).x;
    return X;
  }
}
function w3(s) {
  if (!s)
    return null;
  const e = "	\n\v\f\r   ᠎             　\u2028\u2029", t = new RegExp(
    "([a-z])[".concat(e, ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[").concat(e, "]*,?[").concat(e, "]*)+)"),
    // eslint-disable-line
    "ig"
  ), n = new RegExp(
    // eslint-disable-next-line
    "(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[".concat(e, "]*,?[").concat(e, "]*"),
    "ig"
  ), i = {
    a: 7,
    c: 6,
    h: 1,
    l: 2,
    m: 2,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    z: 0
  }, r = [];
  return s.replace(t, (o, a, l) => {
    const c = [];
    let u = a.toLowerCase();
    l.replace(n, (f, g) => (g && c.push(+g), f)), u === "m" && c.length > 2 && (r.push([a, ...c.splice(0, 2)]), u = "l", a = a === "m" ? "l" : "L");
    const d = i[u];
    for (; c.length >= d && (r.push([a, ...c.splice(0, d)]), !!d); )
      ;
    return o;
  }), r;
}
function y3(s) {
  const e = w3(s);
  if (!e || !e.length)
    return [["M", 0, 0]];
  let t = 0, n = 0, i = 0, r = 0;
  const o = [];
  for (let a = 0, l = e.length; a < l; a += 1) {
    const c = [];
    o.push(c);
    const u = e[a], d = u[0];
    if (d !== d.toUpperCase())
      switch (c[0] = d.toUpperCase(), c[0]) {
        case "A":
          c[1] = u[1], c[2] = u[2], c[3] = u[3], c[4] = u[4], c[5] = u[5], c[6] = +u[6] + t, c[7] = +u[7] + n;
          break;
        case "V":
          c[1] = +u[1] + n;
          break;
        case "H":
          c[1] = +u[1] + t;
          break;
        case "M":
          i = +u[1] + t, r = +u[2] + n;
          for (let f = 1, g = u.length; f < g; f += 1)
            c[f] = +u[f] + (f % 2 ? t : n);
          break;
        default:
          for (let f = 1, g = u.length; f < g; f += 1)
            c[f] = +u[f] + (f % 2 ? t : n);
          break;
      }
    else
      for (let f = 0, g = u.length; f < g; f += 1)
        c[f] = u[f];
    switch (c[0]) {
      case "Z":
        t = +i, n = +r;
        break;
      case "H":
        t = c[1];
        break;
      case "V":
        n = c[1];
        break;
      case "M":
        i = c[c.length - 2], r = c[c.length - 1], t = c[c.length - 2], n = c[c.length - 1];
        break;
      default:
        t = c[c.length - 2], n = c[c.length - 1];
        break;
    }
  }
  return o;
}
function b3(s) {
  const e = y3(s), t = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };
  function n(l, c, u) {
    let d, f;
    if (!l)
      return ["C", c.x, c.y, c.x, c.y, c.x, c.y];
    switch (l[0] in { T: 1, Q: 1 } || (c.qx = null, c.qy = null), l[0]) {
      case "M":
        c.X = l[1], c.Y = l[2];
        break;
      case "A":
        return parseFloat(l[1]) === 0 || parseFloat(l[2]) === 0 ? ["L", l[6], l[7]] : ["C"].concat(Uf.apply(0, [c.x, c.y].concat(l.slice(1))));
      case "S":
        return u === "C" || u === "S" ? (d = c.x * 2 - c.bx, f = c.y * 2 - c.by) : (d = c.x, f = c.y), ["C", d, f].concat(l.slice(1));
      case "T":
        return u === "Q" || u === "T" ? (c.qx = c.x * 2 - c.qx, c.qy = c.y * 2 - c.qy) : (c.qx = c.x, c.qy = c.y), ["C"].concat($h(c.x, c.y, c.qx, c.qy, l[1], l[2]));
      case "Q":
        return c.qx = l[1], c.qy = l[2], ["C"].concat($h(c.x, c.y, l[1], l[2], l[3], l[4]));
      case "H":
        return ["L"].concat(l[1], c.y);
      case "V":
        return ["L"].concat(c.x, l[1]);
    }
    return l;
  }
  function i(l, c) {
    if (l[c].length > 7) {
      l[c].shift();
      const u = l[c];
      for (; u.length; )
        r[c] = "A", c += 1, l.splice(c, 0, ["C"].concat(u.splice(0, 6)));
      l.splice(c, 1), a = e.length;
    }
  }
  const r = [];
  let o = "", a = e.length;
  for (let l = 0; l < a; l += 1) {
    let c = "";
    e[l] && (c = e[l][0]), c !== "C" && (r[l] = c, l > 0 && (o = r[l - 1])), e[l] = n(e[l], t, o), r[l] !== "A" && c === "C" && (r[l] = "C"), i(e, l);
    const u = e[l], d = u.length;
    t.x = u[d - 2], t.y = u[d - 1], t.bx = parseFloat(u[d - 4]) || t.x, t.by = parseFloat(u[d - 3]) || t.y;
  }
  return (!e[0][0] || e[0][0] !== "M") && e.unshift(["M", 0, 0]), e;
}
function v3(s) {
  return b3(s).map((e) => e.map((t) => typeof t == "string" ? t : ue.round(t, 2))).join(",").split(",").join(" ");
}
class V extends Un {
  constructor(e) {
    if (super(), this.PRECISION = 3, this.segments = [], Array.isArray(e))
      if ($.isLine(e[0]) || Se.isCurve(e[0])) {
        let t = null;
        e.forEach((i, r) => {
          r === 0 && this.appendSegment(V.createSegment("M", i.start)), t != null && !t.end.equals(i.start) && this.appendSegment(V.createSegment("M", i.start)), $.isLine(i) ? this.appendSegment(V.createSegment("L", i.end)) : Se.isCurve(i) && this.appendSegment(V.createSegment("C", i.controlPoint1, i.controlPoint2, i.end)), t = i;
        });
      } else
        e.forEach((n) => {
          n.isSegment && this.appendSegment(n);
        });
    else
      e != null && ($.isLine(e) ? (this.appendSegment(V.createSegment("M", e.start)), this.appendSegment(V.createSegment("L", e.end))) : Se.isCurve(e) ? (this.appendSegment(V.createSegment("M", e.start)), this.appendSegment(V.createSegment("C", e.controlPoint1, e.controlPoint2, e.end))) : Oe.isPolyline(e) ? e.points && e.points.length && e.points.forEach((t, n) => {
        const i = n === 0 ? V.createSegment("M", t) : V.createSegment("L", t);
        this.appendSegment(i);
      }) : e.isSegment && this.appendSegment(e));
  }
  get start() {
    const e = this.segments, t = e.length;
    if (t === 0)
      return null;
    for (let n = 0; n < t; n += 1) {
      const i = e[n];
      if (i.isVisible)
        return i.start;
    }
    return e[t - 1].end;
  }
  get end() {
    const e = this.segments, t = e.length;
    if (t === 0)
      return null;
    for (let n = t - 1; n >= 0; n -= 1) {
      const i = e[n];
      if (i.isVisible)
        return i.end;
    }
    return e[t - 1].end;
  }
  moveTo(...e) {
    return this.appendSegment(si.create.call(null, ...e));
  }
  lineTo(...e) {
    return this.appendSegment(tt.create.call(null, ...e));
  }
  curveTo(...e) {
    return this.appendSegment(Ct.create.call(null, ...e));
  }
  arcTo(e, t, n, i, r, o, a) {
    const l = this.end || new M(), c = typeof o == "number" ? Eo(l.x, l.y, e, t, n, i, r, o, a) : Eo(l.x, l.y, e, t, n, i, r, o.x, o.y);
    if (c != null)
      for (let u = 0, d = c.length; u < d; u += 6)
        this.curveTo(c[u], c[u + 1], c[u + 2], c[u + 3], c[u + 4], c[u + 5]);
    return this;
  }
  quadTo(e, t, n, i) {
    const r = this.end || new M(), o = ["M", r.x, r.y];
    if (typeof e == "number")
      o.push("Q", e, t, n, i);
    else {
      const l = t;
      o.push("Q", e.x, e.y, l.x, l.y);
    }
    const a = V.parse(o.join(" "));
    return this.appendSegment(a.segments.slice(1)), this;
  }
  close() {
    return this.appendSegment(ni.create());
  }
  drawPoints(e, t = {}) {
    const n = Hf(e, t), i = V.parse(n);
    i && i.segments && this.appendSegment(i.segments);
  }
  bbox() {
    const e = this.segments, t = e.length;
    if (t === 0)
      return null;
    let n;
    for (let r = 0; r < t; r += 1) {
      const o = e[r];
      if (o.isVisible) {
        const a = o.bbox();
        a != null && (n = n ? n.union(a) : a);
      }
    }
    if (n != null)
      return n;
    const i = e[t - 1];
    return new R(i.end.x, i.end.y, 0, 0);
  }
  appendSegment(e) {
    const t = this.segments.length;
    let n = t !== 0 ? this.segments[t - 1] : null, i;
    const r = null;
    if (Array.isArray(e))
      for (let o = 0, a = e.length; o < a; o += 1) {
        const l = e[o];
        i = this.prepareSegment(l, n, r), this.segments.push(i), n = i;
      }
    else
      e != null && e.isSegment && (i = this.prepareSegment(e, n, r), this.segments.push(i));
    return this;
  }
  insertSegment(e, t) {
    const n = this.segments.length;
    if (e < 0 && (e = n + e + 1), e > n || e < 0)
      throw new Error("Index out of range.");
    let i, r = null, o = null;
    if (n !== 0 && (e >= 1 ? (r = this.segments[e - 1], o = r.nextSegment) : (r = null, o = this.segments[0])), !Array.isArray(t))
      i = this.prepareSegment(t, r, o), this.segments.splice(e, 0, i);
    else
      for (let a = 0, l = t.length; a < l; a += 1) {
        const c = t[a];
        i = this.prepareSegment(c, r, o), this.segments.splice(e + a, 0, i), r = i;
      }
    return this;
  }
  removeSegment(e) {
    const t = this.fixIndex(e), n = this.segments.splice(t, 1)[0], i = n.previousSegment, r = n.nextSegment;
    return i && (i.nextSegment = r), r && (r.previousSegment = i), n.isSubpathStart && r && this.updateSubpathStartSegment(r), n;
  }
  replaceSegment(e, t) {
    const n = this.fixIndex(e);
    let i;
    const r = this.segments[n];
    let o = r.previousSegment;
    const a = r.nextSegment;
    let l = r.isSubpathStart;
    if (!Array.isArray(t))
      i = this.prepareSegment(t, o, a), this.segments.splice(n, 1, i), l && i.isSubpathStart && (l = !1);
    else {
      this.segments.splice(e, 1);
      for (let c = 0, u = t.length; c < u; c += 1) {
        const d = t[c];
        i = this.prepareSegment(d, o, a), this.segments.splice(e + c, 0, i), o = i, l && i.isSubpathStart && (l = !1);
      }
    }
    l && a && this.updateSubpathStartSegment(a);
  }
  getSegment(e) {
    const t = this.fixIndex(e);
    return this.segments[t];
  }
  fixIndex(e) {
    const t = this.segments.length;
    if (t === 0)
      throw new Error("Path has no segments.");
    let n = e;
    for (; n < 0; )
      n = t + n;
    if (n >= t || n < 0)
      throw new Error("Index out of range.");
    return n;
  }
  segmentAt(e, t = {}) {
    const n = this.segmentIndexAt(e, t);
    return n ? this.getSegment(n) : null;
  }
  segmentAtLength(e, t = {}) {
    const n = this.segmentIndexAtLength(e, t);
    return n ? this.getSegment(n) : null;
  }
  segmentIndexAt(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    const n = ue.clamp(e, 0, 1), i = this.getOptions(t), o = this.length(i) * n;
    return this.segmentIndexAtLength(o, i);
  }
  segmentIndexAtLength(e, t = {}) {
    const n = this.segments.length;
    if (n === 0)
      return null;
    let i = !0;
    e < 0 && (i = !1, e = -e);
    const r = this.getPrecision(t), o = this.getSubdivisions(t);
    let a = 0, l = null;
    for (let c = 0; c < n; c += 1) {
      const u = i ? c : n - 1 - c, d = this.segments[u], f = o[u], g = d.length({ precision: r, subdivisions: f });
      if (d.isVisible) {
        if (e <= a + g)
          return u;
        l = u;
      }
      a += g;
    }
    return l;
  }
  getSegmentSubdivisions(e = {}) {
    const t = this.getPrecision(e), n = [];
    for (let i = 0, r = this.segments.length; i < r; i += 1) {
      const a = this.segments[i].getSubdivisions({ precision: t });
      n.push(a);
    }
    return n;
  }
  updateSubpathStartSegment(e) {
    let t = e.previousSegment, n = e;
    for (; n && !n.isSubpathStart; )
      t != null ? n.subpathStartSegment = t.subpathStartSegment : n.subpathStartSegment = null, t = n, n = n.nextSegment;
  }
  prepareSegment(e, t, n) {
    e.previousSegment = t, e.nextSegment = n, t != null && (t.nextSegment = e), n != null && (n.previousSegment = e);
    let i = e;
    return e.isSubpathStart && (e.subpathStartSegment = e, i = n), i != null && this.updateSubpathStartSegment(i), e;
  }
  closestPoint(e, t = {}) {
    const n = this.closestPointT(e, t);
    return n ? this.pointAtT(n) : null;
  }
  closestPointLength(e, t = {}) {
    const n = this.getOptions(t), i = this.closestPointT(e, n);
    return i ? this.lengthAtT(i, n) : 0;
  }
  closestPointNormalizedLength(e, t = {}) {
    const n = this.getOptions(t), i = this.closestPointLength(e, n);
    if (i === 0)
      return 0;
    const r = this.length(n);
    return r === 0 ? 0 : i / r;
  }
  closestPointT(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    const n = this.getPrecision(t), i = this.getSubdivisions(t);
    let r, o = 1 / 0;
    for (let a = 0, l = this.segments.length; a < l; a += 1) {
      const c = this.segments[a], u = i[a];
      if (c.isVisible) {
        const d = c.closestPointT(e, {
          precision: n,
          subdivisions: u
        }), f = c.pointAtT(d), g = ue.squaredLength(f, e);
        g < o && (r = { segmentIndex: a, value: d }, o = g);
      }
    }
    return r || { segmentIndex: this.segments.length - 1, value: 1 };
  }
  closestPointTangent(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    const n = this.getPrecision(t), i = this.getSubdivisions(t);
    let r, o = 1 / 0;
    for (let a = 0, l = this.segments.length; a < l; a += 1) {
      const c = this.segments[a], u = i[a];
      if (c.isDifferentiable()) {
        const d = c.closestPointT(e, {
          precision: n,
          subdivisions: u
        }), f = c.pointAtT(d), g = ue.squaredLength(f, e);
        g < o && (r = c.tangentAtT(d), o = g);
      }
    }
    return r || null;
  }
  containsPoint(e, t = {}) {
    const n = this.toPolylines(t);
    if (!n)
      return !1;
    let i = 0;
    for (let r = 0, o = n.length; r < o; r += 1)
      n[r].containsPoint(e) && (i += 1);
    return i % 2 === 1;
  }
  pointAt(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    if (e <= 0)
      return this.start.clone();
    if (e >= 1)
      return this.end.clone();
    const n = this.getOptions(t), r = this.length(n) * e;
    return this.pointAtLength(r, n);
  }
  pointAtLength(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    if (e === 0)
      return this.start.clone();
    let n = !0;
    e < 0 && (n = !1, e = -e);
    const i = this.getPrecision(t), r = this.getSubdivisions(t);
    let o, a = 0;
    for (let c = 0, u = this.segments.length; c < u; c += 1) {
      const d = n ? c : u - 1 - c, f = this.segments[d], g = r[d], p = f.length({
        precision: i,
        subdivisions: g
      });
      if (f.isVisible) {
        if (e <= a + p)
          return f.pointAtLength((n ? 1 : -1) * (e - a), {
            precision: i,
            subdivisions: g
          });
        o = f;
      }
      a += p;
    }
    return o ? n ? o.end : o.start : this.segments[this.segments.length - 1].end.clone();
  }
  pointAtT(e) {
    const t = this.segments, n = t.length;
    if (n === 0)
      return null;
    const i = e.segmentIndex;
    if (i < 0)
      return t[0].pointAtT(0);
    if (i >= n)
      return t[n - 1].pointAtT(1);
    const r = ue.clamp(e.value, 0, 1);
    return t[i].pointAtT(r);
  }
  divideAt(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    const n = ue.clamp(e, 0, 1), i = this.getOptions(t), o = this.length(i) * n;
    return this.divideAtLength(o, i);
  }
  divideAtLength(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    let n = !0;
    e < 0 && (n = !1, e = -e);
    const i = this.getPrecision(t), r = this.getSubdivisions(t);
    let o = 0, a, l, c, u, d;
    for (let C = 0, A = this.segments.length; C < A; C += 1) {
      const k = n ? C : A - 1 - C, O = this.getSegment(k), P = r[k], D = { precision: i, subdivisions: P }, N = O.length(D);
      if (O.isDifferentiable() && (c = O, u = k, e <= o + N)) {
        l = k, a = O.divideAtLength((n ? 1 : -1) * (e - o), D);
        break;
      }
      o += N;
    }
    if (!c)
      return null;
    a || (l = u, d = n ? 1 : 0, a = c.divideAtT(d));
    const f = this.clone(), g = l;
    f.replaceSegment(g, a);
    const p = g;
    let m = g + 1, w = g + 2;
    a[0].isDifferentiable() || (f.removeSegment(p), m -= 1, w -= 1);
    const v = f.getSegment(m).start;
    f.insertSegment(m, V.createSegment("M", v)), w += 1, a[1].isDifferentiable() || (f.removeSegment(w - 1), w -= 1);
    const y = w - p - 1;
    for (let C = w, A = f.segments.length; C < A; C += 1) {
      const k = this.getSegment(C - y), O = f.getSegment(C);
      if (O.type === "Z" && !k.subpathStartSegment.end.equals(O.subpathStartSegment.end)) {
        const P = V.createSegment("L", k.end);
        f.replaceSegment(C, P);
      }
    }
    const b = new V(f.segments.slice(0, m)), x = new V(f.segments.slice(m));
    return [b, x];
  }
  intersectsWithLine(e, t = {}) {
    const n = this.toPolylines(t);
    if (n == null)
      return null;
    let i = null;
    for (let r = 0, o = n.length; r < o; r += 1) {
      const a = n[r], l = e.intersect(a);
      l && (i == null && (i = []), Array.isArray(l) ? i.push(...l) : i.push(l));
    }
    return i;
  }
  isDifferentiable() {
    for (let e = 0, t = this.segments.length; e < t; e += 1)
      if (this.segments[e].isDifferentiable())
        return !0;
    return !1;
  }
  isValid() {
    const e = this.segments;
    return e.length === 0 || e[0].type === "M";
  }
  length(e = {}) {
    if (this.segments.length === 0)
      return 0;
    const t = this.getSubdivisions(e);
    let n = 0;
    for (let i = 0, r = this.segments.length; i < r; i += 1) {
      const o = this.segments[i], a = t[i];
      n += o.length({ subdivisions: a });
    }
    return n;
  }
  lengthAtT(e, t = {}) {
    const n = this.segments.length;
    if (n === 0)
      return 0;
    let i = e.segmentIndex;
    if (i < 0)
      return 0;
    let r = ue.clamp(e.value, 0, 1);
    i >= n && (i = n - 1, r = 1);
    const o = this.getPrecision(t), a = this.getSubdivisions(t);
    let l = 0;
    for (let d = 0; d < i; d += 1) {
      const f = this.segments[d], g = a[d];
      l += f.length({ precision: o, subdivisions: g });
    }
    const c = this.segments[i], u = a[i];
    return l += c.lengthAtT(r, { precision: o, subdivisions: u }), l;
  }
  tangentAt(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    const n = ue.clamp(e, 0, 1), i = this.getOptions(t), o = this.length(i) * n;
    return this.tangentAtLength(o, i);
  }
  tangentAtLength(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    let n = !0;
    e < 0 && (n = !1, e = -e);
    const i = this.getPrecision(t), r = this.getSubdivisions(t);
    let o, a = 0;
    for (let l = 0, c = this.segments.length; l < c; l += 1) {
      const u = n ? l : c - 1 - l, d = this.segments[u], f = r[u], g = d.length({ precision: i, subdivisions: f });
      if (d.isDifferentiable()) {
        if (e <= a + g)
          return d.tangentAtLength((n ? 1 : -1) * (e - a), {
            precision: i,
            subdivisions: f
          });
        o = d;
      }
      a += g;
    }
    if (o) {
      const l = n ? 1 : 0;
      return o.tangentAtT(l);
    }
    return null;
  }
  tangentAtT(e) {
    const t = this.segments.length;
    if (t === 0)
      return null;
    const n = e.segmentIndex;
    if (n < 0)
      return this.segments[0].tangentAtT(0);
    if (n >= t)
      return this.segments[t - 1].tangentAtT(1);
    const i = ue.clamp(e.value, 0, 1);
    return this.segments[n].tangentAtT(i);
  }
  getPrecision(e = {}) {
    return e.precision == null ? this.PRECISION : e.precision;
  }
  getSubdivisions(e = {}) {
    if (e.segmentSubdivisions == null) {
      const t = this.getPrecision(e);
      return this.getSegmentSubdivisions({ precision: t });
    }
    return e.segmentSubdivisions;
  }
  getOptions(e = {}) {
    const t = this.getPrecision(e), n = this.getSubdivisions(e);
    return { precision: t, segmentSubdivisions: n };
  }
  toPoints(e = {}) {
    const t = this.segments, n = t.length;
    if (n === 0)
      return null;
    const i = this.getSubdivisions(e), r = [];
    let o = [];
    for (let a = 0; a < n; a += 1) {
      const l = t[a];
      if (l.isVisible) {
        const c = i[a];
        c.length > 0 ? c.forEach((u) => o.push(u.start)) : o.push(l.start);
      } else
        o.length > 0 && (o.push(t[a - 1].end), r.push(o), o = []);
    }
    return o.length > 0 && (o.push(this.end), r.push(o)), r;
  }
  toPolylines(e = {}) {
    const t = this.toPoints(e);
    return t ? t.map((n) => new Oe(n)) : null;
  }
  scale(e, t, n) {
    return this.segments.forEach((i) => i.scale(e, t, n)), this;
  }
  rotate(e, t) {
    return this.segments.forEach((n) => n.rotate(e, t)), this;
  }
  translate(e, t) {
    return typeof e == "number" ? this.segments.forEach((n) => n.translate(e, t)) : this.segments.forEach((n) => n.translate(e)), this;
  }
  clone() {
    const e = new V();
    return this.segments.forEach((t) => e.appendSegment(t.clone())), e;
  }
  equals(e) {
    if (e == null)
      return !1;
    const t = this.segments, n = e.segments, i = t.length;
    if (n.length !== i)
      return !1;
    for (let r = 0; r < i; r += 1) {
      const o = t[r], a = n[r];
      if (o.type !== a.type || !o.equals(a))
        return !1;
    }
    return !0;
  }
  toJSON() {
    return this.segments.map((e) => e.toJSON());
  }
  serialize() {
    if (!this.isValid())
      throw new Error("Invalid path segments.");
    return this.segments.map((e) => e.serialize()).join(" ");
  }
  toString() {
    return this.serialize();
  }
}
(function(s) {
  function e(t) {
    return t != null && t instanceof s;
  }
  s.isPath = e;
})(V || (V = {}));
(function(s) {
  function e(n) {
    if (!n)
      return new s();
    const i = new s(), r = /(?:[a-zA-Z] *)(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)? *,? *)|(?:-?\.\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\d|-|\.)/g, o = s.normalize(n).match(r);
    if (o != null)
      for (let a = 0, l = o.length; a < l; a += 1) {
        const c = o[a], u = /(?:[a-zA-Z])|(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)?))|(?:(?:-?\.\d+))/g, d = c.match(u);
        if (d != null) {
          const f = d[0], g = d.slice(1).map((m) => +m), p = t.call(null, f, ...g);
          i.appendSegment(p);
        }
      }
    return i;
  }
  s.parse = e;
  function t(n, ...i) {
    if (n === "M")
      return si.create.call(null, ...i);
    if (n === "L")
      return tt.create.call(null, ...i);
    if (n === "C")
      return Ct.create.call(null, ...i);
    if (n === "z" || n === "Z")
      return ni.create();
    throw new Error('Invalid path segment type "'.concat(n, '"'));
  }
  s.createSegment = t;
})(V || (V = {}));
(function(s) {
  s.normalize = v3, s.isValid = g3, s.drawArc = m3, s.drawPoints = Hf, s.arcToCurves = Eo;
})(V || (V = {}));
class Le {
  constructor(e) {
    this.options = Object.assign({}, e), this.data = this.options.data || {}, this.register = this.register.bind(this), this.unregister = this.unregister.bind(this);
  }
  get names() {
    return Object.keys(this.data);
  }
  register(e, t, n = !1) {
    if (typeof e == "object") {
      Object.entries(e).forEach(([o, a]) => {
        this.register(o, a, t);
      });
      return;
    }
    this.exist(e) && !n && !In.isApplyingHMR() && this.onDuplicated(e);
    const i = this.options.process, r = i ? J(i, this, e, t) : t;
    return this.data[e] = r, r;
  }
  unregister(e) {
    const t = e ? this.data[e] : null;
    return delete this.data[e], t;
  }
  get(e) {
    return e ? this.data[e] : null;
  }
  exist(e) {
    return e ? this.data[e] != null : !1;
  }
  onDuplicated(e) {
    try {
      throw this.options.onConflict && J(this.options.onConflict, this, e), new Error("".concat(_c(this.options.type), " with name '").concat(e, "' already registered."));
    } catch (t) {
      throw t;
    }
  }
  onNotFound(e, t) {
    throw new Error(this.getSpellingSuggestion(e, t));
  }
  getSpellingSuggestion(e, t) {
    const n = this.getSpellingSuggestionForName(e), i = t ? "".concat(t, " ").concat(Sp(this.options.type)) : this.options.type;
    return (
      // eslint-disable-next-line
      "".concat(_c(i), " with name '").concat(e, "' does not exist.").concat(n ? " Did you mean '".concat(n, "'?") : "")
    );
  }
  getSpellingSuggestionForName(e) {
    return b6(e, Object.keys(this.data), (t) => t);
  }
}
(function(s) {
  function e(t) {
    return new s(t);
  }
  s.create = e;
})(Le || (Le = {}));
const x3 = {
  color: "#aaaaaa",
  thickness: 1,
  markup: "rect",
  update(s, e) {
    const t = e.thickness * e.sx, n = e.thickness * e.sy;
    ge(s, {
      width: t,
      height: n,
      rx: t,
      ry: n,
      fill: e.color
    });
  }
}, C3 = {
  color: "#aaaaaa",
  thickness: 1,
  markup: "rect",
  update(s, e) {
    const t = e.sx <= 1 ? e.thickness * e.sx : e.thickness;
    ge(s, {
      width: t,
      height: t,
      rx: t,
      ry: t,
      fill: e.color
    });
  }
}, E3 = {
  color: "rgba(224,224,224,1)",
  thickness: 1,
  markup: "path",
  update(s, e) {
    let t;
    const n = e.width, i = e.height, r = e.thickness;
    n - r >= 0 && i - r >= 0 ? t = ["M", n, 0, "H0 M0 0 V0", i].join(" ") : t = "M 0 0 0 0", ge(s, {
      d: t,
      stroke: e.color,
      "stroke-width": e.thickness
    });
  }
}, S3 = [
  {
    color: "rgba(224,224,224,1)",
    thickness: 1,
    markup: "path",
    update(s, e) {
      let t;
      const n = e.width, i = e.height, r = e.thickness;
      n - r >= 0 && i - r >= 0 ? t = ["M", n, 0, "H0 M0 0 V0", i].join(" ") : t = "M 0 0 0 0", ge(s, {
        d: t,
        stroke: e.color,
        "stroke-width": e.thickness
      });
    }
  },
  {
    color: "rgba(224,224,224,0.2)",
    thickness: 3,
    factor: 4,
    markup: "path",
    update(s, e) {
      let t;
      const n = e.factor || 1, i = e.width * n, r = e.height * n, o = e.thickness;
      i - o >= 0 && r - o >= 0 ? t = ["M", i, 0, "H0 M0 0 V0", r].join(" ") : t = "M 0 0 0 0", e.width = i, e.height = r, ge(s, {
        d: t,
        stroke: e.color,
        "stroke-width": e.thickness
      });
    }
  }
], A3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  dot: x3,
  doubleMesh: S3,
  fixedDot: C3,
  mesh: E3
}, Symbol.toStringTag, { value: "Module" }));
class _n {
  constructor() {
    this.patterns = {}, this.root = G.create(bo(), {
      width: "100%",
      height: "100%"
    }, [Bt("defs")]).node;
  }
  add(e, t) {
    const n = this.root.childNodes[0];
    n && n.appendChild(t), this.patterns[e] = t, G.create("rect", {
      width: "100%",
      height: "100%",
      fill: "url(#".concat(e, ")")
    }).appendTo(this.root);
  }
  get(e) {
    return this.patterns[e];
  }
  has(e) {
    return this.patterns[e] != null;
  }
}
(function(s) {
  s.presets = A3, s.registry = Le.create({
    type: "grid"
  }), s.registry.register(s.presets, !0);
})(_n || (_n = {}));
const qf = function(s) {
  const e = document.createElement("canvas"), t = s.width, n = s.height;
  e.width = t * 2, e.height = n;
  const i = e.getContext("2d");
  return i.drawImage(s, 0, 0, t, n), i.translate(2 * t, 0), i.scale(-1, 1), i.drawImage(s, 0, 0, t, n), e;
}, Gf = function(s) {
  const e = document.createElement("canvas"), t = s.width, n = s.height;
  e.width = t, e.height = n * 2;
  const i = e.getContext("2d");
  return i.drawImage(s, 0, 0, t, n), i.translate(0, 2 * n), i.scale(1, -1), i.drawImage(s, 0, 0, t, n), e;
}, Wf = function(s) {
  const e = document.createElement("canvas"), t = s.width, n = s.height;
  e.width = 2 * t, e.height = 2 * n;
  const i = e.getContext("2d");
  return i.drawImage(s, 0, 0, t, n), i.setTransform(-1, 0, 0, -1, e.width, e.height), i.drawImage(s, 0, 0, t, n), i.setTransform(-1, 0, 0, 1, e.width, 0), i.drawImage(s, 0, 0, t, n), i.setTransform(1, 0, 0, -1, 0, e.height), i.drawImage(s, 0, 0, t, n), e;
}, M3 = function(s, e) {
  const t = s.width, n = s.height, i = document.createElement("canvas");
  i.width = t * 3, i.height = n * 3;
  const r = i.getContext("2d"), o = e.angle != null ? -e.angle : -20, a = de.toRad(o), l = i.width / 4, c = i.height / 4;
  for (let u = 0; u < 4; u += 1)
    for (let d = 0; d < 4; d += 1)
      (u + d) % 2 > 0 && (r.setTransform(1, 0, 0, 1, (2 * u - 1) * l, (2 * d - 1) * c), r.rotate(a), r.drawImage(s, -t / 2, -n / 2, t, n));
  return i;
}, k3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  flipX: qf,
  flipXY: Wf,
  flipY: Gf,
  watermark: M3
}, Symbol.toStringTag, { value: "Module" }));
var ar;
(function(s) {
  s.presets = Object.assign({}, k3), s.presets["flip-x"] = qf, s.presets["flip-y"] = Gf, s.presets["flip-xy"] = Wf, s.registry = Le.create({
    type: "background pattern"
  }), s.registry.register(s.presets, !0);
})(ar || (ar = {}));
function pc(s, e) {
  return s != null ? s : e;
}
function Ge(s, e) {
  return s != null && Number.isFinite(s) ? s : e;
}
function P3(s = {}) {
  const e = pc(s.color, "blue"), t = Ge(s.width, 1), n = Ge(s.margin, 2), i = Ge(s.opacity, 1), r = n, o = n + t;
  return '\n    <filter>\n      <feFlood flood-color="'.concat(e, '" flood-opacity="').concat(i, '" result="colored"/>\n      <feMorphology in="SourceAlpha" result="morphedOuter" operator="dilate" radius="').concat(o, '" />\n      <feMorphology in="SourceAlpha" result="morphedInner" operator="dilate" radius="').concat(r, '" />\n      <feComposite result="morphedOuterColored" in="colored" in2="morphedOuter" operator="in"/>\n      <feComposite operator="xor" in="morphedOuterColored" in2="morphedInner" result="outline"/>\n      <feMerge>\n        <feMergeNode in="outline"/>\n        <feMergeNode in="SourceGraphic"/>\n      </feMerge>\n    </filter>\n  ').trim();
}
function _3(s = {}) {
  const e = pc(s.color, "red"), t = Ge(s.blur, 0), n = Ge(s.width, 1), i = Ge(s.opacity, 1);
  return '\n      <filter>\n        <feFlood flood-color="'.concat(e, '" flood-opacity="').concat(i, '" result="colored"/>\n        <feMorphology result="morphed" in="SourceGraphic" operator="dilate" radius="').concat(n, '"/>\n        <feComposite result="composed" in="colored" in2="morphed" operator="in"/>\n        <feGaussianBlur result="blured" in="composed" stdDeviation="').concat(t, '"/>\n        <feBlend in="SourceGraphic" in2="blured" mode="normal"/>\n      </filter>\n    ').trim();
}
function O3(s = {}) {
  const e = Ge(s.x, 2), t = s.y != null && Number.isFinite(s.y) ? [e, s.y] : e;
  return '\n    <filter>\n      <feGaussianBlur stdDeviation="'.concat(t, '"/>\n    </filter>\n  ').trim();
}
function T3(s = {}) {
  const e = Ge(s.dx, 0), t = Ge(s.dy, 0), n = pc(s.color, "black"), i = Ge(s.blur, 4), r = Ge(s.opacity, 1);
  return "SVGFEDropShadowElement" in window ? '<filter>\n         <feDropShadow stdDeviation="'.concat(i, '" dx="').concat(e, '" dy="').concat(t, '" flood-color="').concat(n, '" flood-opacity="').concat(r, '" />\n       </filter>').trim() : '<filter>\n         <feGaussianBlur in="SourceAlpha" stdDeviation="'.concat(i, '" />\n         <feOffset dx="').concat(e, '" dy="').concat(t, '" result="offsetblur" />\n         <feFlood flood-color="').concat(n, '" />\n         <feComposite in2="offsetblur" operator="in" />\n         <feComponentTransfer>\n           <feFuncA type="linear" slope="').concat(r, '" />\n         </feComponentTransfer>\n         <feMerge>\n           <feMergeNode/>\n           <feMergeNode in="SourceGraphic"/>\n         </feMerge>\n       </filter>').trim();
}
function L3(s = {}) {
  const e = Ge(s.amount, 1), t = 0.2126 + 0.7874 * (1 - e), n = 0.7152 - 0.7152 * (1 - e), i = 0.0722 - 0.0722 * (1 - e), r = 0.2126 - 0.2126 * (1 - e), o = 0.7152 + 0.2848 * (1 - e), a = 0.0722 - 0.0722 * (1 - e), l = 0.2126 - 0.2126 * (1 - e), c = 0.0722 + 0.9278 * (1 - e);
  return '\n    <filter>\n      <feColorMatrix type="matrix" values="'.concat(t, " ").concat(n, " ").concat(i, " 0 0 ").concat(r, " ").concat(o, " ").concat(a, " 0 0 ").concat(l, " ").concat(n, " ").concat(c, ' 0 0 0 0 0 1 0"/>\n    </filter>\n  ').trim();
}
function N3(s = {}) {
  const e = Ge(s.amount, 1), t = 0.393 + 0.607 * (1 - e), n = 0.769 - 0.769 * (1 - e), i = 0.189 - 0.189 * (1 - e), r = 0.349 - 0.349 * (1 - e), o = 0.686 + 0.314 * (1 - e), a = 0.168 - 0.168 * (1 - e), l = 0.272 - 0.272 * (1 - e), c = 0.534 - 0.534 * (1 - e), u = 0.131 + 0.869 * (1 - e);
  return '\n      <filter>\n        <feColorMatrix type="matrix" values="'.concat(t, " ").concat(n, " ").concat(i, " 0 0 ").concat(r, " ").concat(o, " ").concat(a, " 0 0 ").concat(l, " ").concat(c, " ").concat(u, ' 0 0 0 0 0 1 0"/>\n      </filter>\n    ').trim();
}
function D3(s = {}) {
  const e = Ge(s.amount, 1);
  return '\n      <filter>\n        <feColorMatrix type="saturate" values="'.concat(1 - e, '"/>\n      </filter>\n    ').trim();
}
function I3(s = {}) {
  const e = Ge(s.angle, 0);
  return '\n      <filter>\n        <feColorMatrix type="hueRotate" values="'.concat(e, '"/>\n      </filter>\n    ').trim();
}
function j3(s = {}) {
  const e = Ge(s.amount, 1), t = 1 - e;
  return '\n      <filter>\n        <feComponentTransfer>\n          <feFuncR type="table" tableValues="'.concat(e, " ").concat(t, '"/>\n          <feFuncG type="table" tableValues="').concat(e, " ").concat(t, '"/>\n          <feFuncB type="table" tableValues="').concat(e, " ").concat(t, '"/>\n        </feComponentTransfer>\n      </filter>\n    ').trim();
}
function R3(s = {}) {
  const e = Ge(s.amount, 1);
  return '\n    <filter>\n      <feComponentTransfer>\n        <feFuncR type="linear" slope="'.concat(e, '"/>\n        <feFuncG type="linear" slope="').concat(e, '"/>\n        <feFuncB type="linear" slope="').concat(e, '"/>\n      </feComponentTransfer>\n    </filter>\n  ').trim();
}
function B3(s = {}) {
  const e = Ge(s.amount, 1), t = 0.5 - e / 2;
  return '\n    <filter>\n     <feComponentTransfer>\n        <feFuncR type="linear" slope="'.concat(e, '" intercept="').concat(t, '"/>\n        <feFuncG type="linear" slope="').concat(e, '" intercept="').concat(t, '"/>\n        <feFuncB type="linear" slope="').concat(e, '" intercept="').concat(t, '"/>\n      </feComponentTransfer>\n    </filter>\n  ').trim();
}
const F3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  blur: O3,
  brightness: R3,
  contrast: B3,
  dropShadow: T3,
  grayScale: L3,
  highlight: _3,
  hueRotate: I3,
  invert: j3,
  outline: P3,
  saturate: D3,
  sepia: N3
}, Symbol.toStringTag, { value: "Module" }));
var ii;
(function(s) {
  s.presets = F3, s.registry = Le.create({
    type: "filter"
  }), s.registry.register(s.presets, !0);
})(ii || (ii = {}));
const $3 = {
  xlinkHref: "xlink:href",
  xlinkShow: "xlink:show",
  xlinkRole: "xlink:role",
  xlinkType: "xlink:type",
  xlinkArcrole: "xlink:arcrole",
  xlinkTitle: "xlink:title",
  xlinkActuate: "xlink:actuate",
  xmlSpace: "xml:space",
  xmlBase: "xml:base",
  xmlLang: "xml:lang",
  preserveAspectRatio: "preserveAspectRatio",
  requiredExtension: "requiredExtension",
  requiredFeatures: "requiredFeatures",
  systemLanguage: "systemLanguage",
  externalResourcesRequired: "externalResourceRequired"
}, z3 = {
  // We do not set `ref` attribute directly on an element.
  // The attribute itself does not qualify for relative positioning.
}, Jf = {
  position: Zo("x", "width", "origin")
}, Yf = {
  position: Zo("y", "height", "origin")
}, V3 = {
  position: Zo("x", "width", "corner")
}, H3 = {
  position: Zo("y", "height", "corner")
}, Xf = {
  set: Rn("width", "width")
}, Zf = {
  set: Rn("height", "height")
}, U3 = {
  set: Rn("rx", "width")
}, q3 = {
  set: Rn("ry", "height")
}, Kf = {
  set: ((s) => {
    const e = Rn(s, "width"), t = Rn(s, "height");
    return function(n, i) {
      const r = i.refBBox, o = r.height > r.width ? e : t;
      return J(o, this, n, i);
    };
  })("r")
}, G3 = {
  set(s, { refBBox: e }) {
    let t = parseFloat(s);
    const n = un(s);
    n && (t /= 100);
    const i = Math.sqrt(e.height * e.height + e.width * e.width);
    let r;
    return Number.isFinite(t) && (n || t >= 0 && t <= 1 ? r = t * i : r = Math.max(t + i, 0)), { r };
  }
}, W3 = {
  set: Rn("cx", "width")
}, J3 = {
  set: Rn("cy", "height")
}, Qf = {
  set: ng({ resetOffset: !0 })
}, Y3 = {
  set: ng({ resetOffset: !1 })
}, eg = {
  set: sg({ resetOffset: !0 })
}, X3 = {
  set: sg({ resetOffset: !1 })
}, Z3 = Kf, K3 = Qf, Q3 = eg, ey = Jf, ty = Yf, ny = Xf, sy = Zf;
function Zo(s, e, t) {
  return (n, { refBBox: i }) => {
    if (n == null)
      return null;
    let r = parseFloat(n);
    const o = un(n);
    o && (r /= 100);
    let a;
    if (Number.isFinite(r)) {
      const c = i[t];
      o || r > 0 && r < 1 ? a = c[s] + i[e] * r : a = c[s] + r;
    }
    const l = new M();
    return l[s] = a || 0, l;
  };
}
function Rn(s, e) {
  return function(t, { refBBox: n }) {
    let i = parseFloat(t);
    const r = un(t);
    r && (i /= 100);
    const o = {};
    if (Number.isFinite(i)) {
      const a = r || i >= 0 && i <= 1 ? i * n[e] : Math.max(i + n[e], 0);
      o[s] = a;
    }
    return o;
  };
}
function tg(s, e) {
  const t = "x6-shape", n = e && e.resetOffset;
  return function(i, { elem: r, refBBox: o }) {
    let a = ws(r, t);
    if (!a || a.value !== i) {
      const m = s(i);
      a = {
        value: i,
        shape: m,
        shapeBBox: m.bbox()
      }, ws(r, t, a);
    }
    const l = a.shape.clone(), c = a.shapeBBox.clone(), u = c.getOrigin(), d = o.getOrigin();
    c.x = d.x, c.y = d.y;
    const f = o.getMaxScaleToFit(c, d), g = c.width === 0 || o.width === 0 ? 1 : f.sx, p = c.height === 0 || o.height === 0 ? 1 : f.sy;
    return l.scale(g, p, u), n && l.translate(-u.x, -u.y), l;
  };
}
function ng(s) {
  function e(n) {
    return V.parse(n);
  }
  const t = tg(e, s);
  return (n, i) => ({
    d: t(n, i).serialize()
  });
}
function sg(s) {
  const e = tg((t) => new Oe(t), s);
  return (t, n) => ({
    points: e(t, n).serialize()
  });
}
const iy = {
  qualify: gn,
  set(s, { view: e }) {
    return "url(#".concat(e.graph.defineGradient(s), ")");
  }
}, ry = {
  qualify: gn,
  set(s, { view: e }) {
    const t = e.cell, n = Object.assign({}, s);
    if (t.isEdge() && n.type === "linearGradient") {
      const i = e, r = i.sourcePoint, o = i.targetPoint;
      n.id = "gradient-".concat(n.type, "-").concat(t.id), n.attrs = Object.assign(Object.assign({}, n.attrs), { x1: r.x, y1: r.y, x2: o.x, y2: o.y, gradientUnits: "userSpaceOnUse" }), e.graph.defs.remove(n.id);
    }
    return "url(#".concat(e.graph.defineGradient(n), ")");
  }
}, ig = {
  qualify(s, { attrs: e }) {
    return e.textWrap == null || !gn(e.textWrap);
  },
  set(s, { view: e, elem: t, attrs: n }) {
    const i = "x6-text", r = ws(t, i), o = (u) => {
      try {
        return JSON.parse(u);
      } catch (d) {
        return u;
      }
    }, a = {
      x: n.x,
      eol: n.eol,
      annotations: o(n.annotations),
      textPath: o(n["text-path"] || n.textPath),
      textVerticalAnchor: n["text-vertical-anchor"] || n.textVerticalAnchor,
      displayEmpty: (n["display-empty"] || n.displayEmpty) === "true",
      lineHeight: n["line-height"] || n.lineHeight
    }, l = n["font-size"] || n.fontSize, c = JSON.stringify([s, a]);
    if (l && t.setAttribute("font-size", l), r == null || r !== c) {
      const u = a.textPath;
      if (u != null && typeof u == "object") {
        const d = u.selector;
        if (typeof d == "string") {
          const f = e.find(d)[0];
          f instanceof SVGPathElement && (hc(f), a.textPath = Object.assign({ "xlink:href": "#".concat(f.id) }, u));
        }
      }
      If(t, "".concat(s), a), ws(t, i, c);
    }
  }
}, oy = {
  qualify: gn,
  set(s, { view: e, elem: t, attrs: n, refBBox: i }) {
    const r = s, o = r.width || 0;
    un(o) ? i.width *= parseFloat(o) / 100 : o <= 0 ? i.width += o : i.width = o;
    const a = r.height || 0;
    un(a) ? i.height *= parseFloat(a) / 100 : a <= 0 ? i.height += a : i.height = a;
    let l, c = r.text;
    c == null && (c = n.text || (t == null ? void 0 : t.textContent)), c != null ? l = jf("".concat(c), i, {
      "font-weight": n["font-weight"] || n.fontWeight,
      "font-size": n["font-size"] || n.fontSize,
      "font-family": n["font-family"] || n.fontFamily,
      lineHeight: n.lineHeight
    }, {
      // svgDocument: view.graph.view.svg,
      ellipsis: r.ellipsis
      // hyphen: info.hyphen as string,
      // breakWord: info.breakWord as boolean,
    }) : l = "", J(ig.set, this, l, {
      view: e,
      elem: t,
      attrs: n,
      refBBox: i,
      cell: e.cell
    });
  }
}, Ci = (s, { attrs: e }) => e.text !== void 0, ay = {
  qualify: Ci
}, ly = {
  qualify: Ci
}, cy = {
  qualify: Ci
}, hy = {
  qualify: Ci
}, uy = {
  qualify: Ci
}, dy = {
  qualify: Ci
}, fy = {
  qualify(s, { elem: e }) {
    return e instanceof SVGElement;
  },
  set(s, { elem: e }) {
    const t = "x6-title", n = "".concat(s), i = ws(e, t);
    if (i == null || i !== n) {
      ws(e, t, n);
      const r = e.firstChild;
      if (r && r.tagName.toUpperCase() === "TITLE") {
        const o = r;
        o.textContent = n;
      } else {
        const o = document.createElementNS(e.namespaceURI, "title");
        o.textContent = n, e.insertBefore(o, r);
      }
    }
  }
}, gy = {
  offset: rg("x", "width", "right")
}, py = {
  offset: rg("y", "height", "bottom")
}, my = {
  offset(s, { refBBox: e }) {
    return s ? { x: -e.x, y: -e.y } : { x: 0, y: 0 };
  }
};
function rg(s, e, t) {
  return (n, { refBBox: i }) => {
    const r = new M();
    let o;
    return n === "middle" ? o = i[e] / 2 : n === t ? o = i[e] : typeof n == "number" && Number.isFinite(n) ? o = n > -1 && n < 1 ? -i[e] * n : -n : un(n) ? o = i[e] * parseFloat(n) / 100 : o = 0, r[s] = -(i[s] + o), r;
  };
}
const wy = {
  qualify: gn,
  set(s, { elem: e }) {
    Sr(e, s);
  }
}, yy = {
  set(s, { elem: e }) {
    e.innerHTML = "".concat(s);
  }
}, by = {
  qualify: gn,
  set(s, { view: e }) {
    return "url(#".concat(e.graph.defineFilter(s), ")");
  }
}, vy = {
  set(s) {
    return s != null && typeof s == "object" && s.id ? s.id : s;
  }
};
function qn(s, e, t) {
  let n, i;
  typeof e == "object" ? (n = e.x, i = e.y) : (n = e, i = t);
  const r = V.parse(s), o = r.bbox();
  if (o) {
    let a = -o.height / 2 - o.y, l = -o.width / 2 - o.x;
    typeof n == "number" && (l -= n), typeof i == "number" && (a -= i), r.translate(l, a);
  }
  return r.serialize();
}
var og = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
const xy = (s) => {
  var { size: e, width: t, height: n, offset: i, open: r } = s, o = og(s, ["size", "width", "height", "offset", "open"]);
  return ag({ size: e, width: t, height: n, offset: i }, r === !0, !0, void 0, o);
}, Cy = (s) => {
  var { size: e, width: t, height: n, offset: i, factor: r } = s, o = og(s, ["size", "width", "height", "offset", "factor"]);
  return ag({ size: e, width: t, height: n, offset: i }, !1, !1, r, o);
};
function ag(s, e, t, n = 3 / 4, i = {}) {
  const r = s.size || 10, o = s.width || r, a = s.height || r, l = new V(), c = {};
  if (e)
    l.moveTo(o, 0).lineTo(0, a / 2).lineTo(o, a), c.fill = "none";
  else {
    if (l.moveTo(0, a / 2), l.lineTo(o, 0), !t) {
      const u = Mt(n, 0, 1);
      l.lineTo(o * u, a / 2);
    }
    l.lineTo(o, a), l.close();
  }
  return Object.assign(Object.assign(Object.assign({}, c), i), { tagName: "path", d: qn(l.serialize(), {
    x: s.offset != null ? s.offset : -o / 2
  }) });
}
var Ey = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
const Sy = (s) => {
  var { size: e, width: t, height: n, offset: i } = s, r = Ey(s, ["size", "width", "height", "offset"]);
  const o = e || 10, a = t || o, l = n || o, c = new V();
  return c.moveTo(0, l / 2).lineTo(a / 2, 0).lineTo(a, l / 2).lineTo(a / 2, l).close(), Object.assign(Object.assign({}, r), { tagName: "path", d: qn(c.serialize(), i == null ? -a / 2 : i) });
};
var Ay = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
const My = (s) => {
  var { d: e, offsetX: t, offsetY: n } = s, i = Ay(s, ["d", "offsetX", "offsetY"]);
  return Object.assign(Object.assign({}, i), { tagName: "path", d: qn(e, t, n) });
};
var ky = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
const Py = (s) => {
  var { size: e, width: t, height: n, offset: i } = s, r = ky(s, ["size", "width", "height", "offset"]);
  const o = e || 10, a = t || o, l = n || o, c = new V();
  return c.moveTo(0, 0).lineTo(a, l).moveTo(0, l).lineTo(a, 0), Object.assign(Object.assign({}, r), { tagName: "path", fill: "none", d: qn(c.serialize(), i || -a / 2) });
};
var _y = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
const Oy = (s) => {
  var { width: e, height: t, offset: n, open: i, flip: r } = s, o = _y(s, ["width", "height", "offset", "open", "flip"]);
  let a = t || 6;
  const l = e || 10, c = i === !0, u = r === !0, d = Object.assign(Object.assign({}, o), { tagName: "path" });
  u && (a = -a);
  const f = new V();
  return f.moveTo(0, a).lineTo(l, 0), c ? d.fill = "none" : (f.lineTo(l, a), f.close()), d.d = qn(f.serialize(), {
    x: n || -l / 2,
    y: a / 2
  }), d;
};
var lg = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
const cg = (s) => {
  var { r: e } = s, t = lg(s, ["r"]);
  const n = e || 5;
  return Object.assign(Object.assign({ cx: n }, t), { tagName: "circle", r: n });
}, Ty = (s) => {
  var { r: e } = s, t = lg(s, ["r"]);
  const n = e || 5, i = new V();
  return i.moveTo(n, 0).lineTo(n, n * 2), i.moveTo(0, n).lineTo(n * 2, n), {
    children: [
      Object.assign(Object.assign({}, cg({ r: n })), { fill: "none" }),
      Object.assign(Object.assign({}, t), { tagName: "path", d: qn(i.serialize(), -n) })
    ]
  };
};
var Ly = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
const Ny = (s) => {
  var { rx: e, ry: t } = s, n = Ly(s, ["rx", "ry"]);
  const i = e || 5, r = t || 5;
  return Object.assign(Object.assign({ cx: i }, n), { tagName: "ellipse", rx: i, ry: r });
}, Dy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  async: Oy,
  block: xy,
  circle: cg,
  circlePlus: Ty,
  classic: Cy,
  cross: Py,
  diamond: Sy,
  ellipse: Ny,
  path: My
}, Symbol.toStringTag, { value: "Module" }));
var Bn;
(function(s) {
  s.presets = Dy, s.registry = Le.create({
    type: "marker"
  }), s.registry.register(s.presets, !0);
})(Bn || (Bn = {}));
(function(s) {
  s.normalize = qn;
})(Bn || (Bn = {}));
var Iy = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
function mc(s) {
  return typeof s == "string" || gn(s);
}
const jy = {
  qualify: mc,
  set(s, { view: e, attrs: t }) {
    return wc("marker-start", s, e, t);
  }
}, Ry = {
  qualify: mc,
  set(s, { view: e, attrs: t }) {
    return wc("marker-end", s, e, t, {
      transform: "rotate(180)"
    });
  }
}, By = {
  qualify: mc,
  set(s, { view: e, attrs: t }) {
    return wc("marker-mid", s, e, t);
  }
};
function wc(s, e, t, n, i = {}) {
  const r = typeof e == "string" ? { name: e } : e, { name: o, args: a } = r, l = Iy(r, ["name", "args"]);
  let c = l;
  if (o && typeof o == "string") {
    const d = Bn.registry.get(o);
    if (d)
      c = d(Object.assign(Object.assign({}, l), a));
    else
      return Bn.registry.onNotFound(o);
  }
  const u = Object.assign(Object.assign(Object.assign({}, Fy(n, s)), i), c);
  return {
    [s]: "url(#".concat(t.graph.defineMarker(u), ")")
  };
}
function Fy(s, e) {
  const t = {}, n = s.stroke;
  typeof n == "string" && (t.stroke = n, t.fill = n);
  let i = s.strokeOpacity;
  if (i == null && (i = s["stroke-opacity"]), i == null && (i = s.opacity), i != null && (t["stroke-opacity"] = i, t["fill-opacity"] = i), e !== "marker-mid") {
    const r = parseFloat(s.strokeWidth || s["stroke-width"]);
    if (Number.isFinite(r) && r > 1) {
      const o = Math.ceil(r / 2);
      t.refX = e === "marker-start" ? o : -o;
    }
  }
  return t;
}
const Ar = (s, { view: e }) => e.cell.isEdge(), $y = {
  qualify: Ar,
  set(s, e) {
    var t, n, i, r;
    const o = e.view, a = s.reverse || !1, l = s.stubs || 0;
    let c;
    if (Number.isFinite(l) && l !== 0)
      if (a) {
        let u, d;
        const f = o.getConnectionLength() || 0;
        l < 0 ? (u = (f + l) / 2, d = -l) : (u = l, d = f - l * 2);
        const g = o.getConnection();
        c = (r = (i = (n = (t = g == null ? void 0 : g.divideAtLength(u)) === null || t === void 0 ? void 0 : t[1]) === null || n === void 0 ? void 0 : n.divideAtLength(d)) === null || i === void 0 ? void 0 : i[0]) === null || r === void 0 ? void 0 : r.serialize();
      } else {
        let u;
        l < 0 ? u = ((o.getConnectionLength() || 0) + l) / 2 : u = l;
        const d = o.getConnection();
        if (d) {
          const f = d.divideAtLength(u), g = d.divideAtLength(-u);
          f && g && (c = "".concat(f[0].serialize(), " ").concat(g[1].serialize()));
        }
      }
    return { d: c || o.getConnectionPathData() };
  }
}, hg = {
  qualify: Ar,
  set: Ko("getTangentAtLength", { rotate: !0 })
}, zy = {
  qualify: Ar,
  set: Ko("getTangentAtLength", { rotate: !1 })
}, ug = {
  qualify: Ar,
  set: Ko("getTangentAtRatio", { rotate: !0 })
}, Vy = {
  qualify: Ar,
  set: Ko("getTangentAtRatio", { rotate: !1 })
}, Hy = hg, Uy = ug;
function Ko(s, e) {
  const t = { x: 1, y: 0 };
  return (n, i) => {
    let r, o;
    const a = i.view, l = a[s](Number(n));
    return l ? (o = e.rotate ? l.vector().vectorAngle(t) : 0, r = l.start) : (r = a.path.start, o = 0), o === 0 ? { transform: "translate(".concat(r.x, ",").concat(r.y, "')") } : {
      transform: "translate(".concat(r.x, ",").concat(r.y, "') rotate(").concat(o, ")")
    };
  };
}
const qy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  annotations: hy,
  atConnectionLength: Hy,
  atConnectionLengthIgnoreGradient: zy,
  atConnectionLengthKeepGradient: hg,
  atConnectionRatio: Uy,
  atConnectionRatioIgnoreGradient: Vy,
  atConnectionRatioKeepGradient: ug,
  connection: $y,
  displayEmpty: dy,
  eol: uy,
  fill: iy,
  filter: by,
  html: yy,
  lineHeight: ay,
  port: vy,
  ref: z3,
  refCx: W3,
  refCy: J3,
  refD: K3,
  refDKeepOffset: Y3,
  refDResetOffset: Qf,
  refDx: V3,
  refDy: H3,
  refHeight: Zf,
  refHeight2: sy,
  refPoints: Q3,
  refPointsKeepOffset: X3,
  refPointsResetOffset: eg,
  refR: Z3,
  refRCircumscribed: G3,
  refRInscribed: Kf,
  refRx: U3,
  refRy: q3,
  refWidth: Xf,
  refWidth2: ny,
  refX: Jf,
  refX2: ey,
  refY: Yf,
  refY2: ty,
  resetOffset: my,
  sourceMarker: jy,
  stroke: ry,
  style: wy,
  targetMarker: Ry,
  text: ig,
  textPath: cy,
  textVerticalAnchor: ly,
  textWrap: oy,
  title: fy,
  vertexMarker: By,
  xAlign: gy,
  yAlign: py
}, Symbol.toStringTag, { value: "Module" }));
var Xt;
(function(s) {
  function e(t, n, i) {
    return !!(t != null && (typeof t == "string" || typeof t.qualify != "function" || J(t.qualify, this, n, i)));
  }
  s.isValidDefinition = e;
})(Xt || (Xt = {}));
(function(s) {
  s.presets = Object.assign(Object.assign({}, $3), qy), s.registry = Le.create({
    type: "attribute definition"
  }), s.registry.register(s.presets, !0);
})(Xt || (Xt = {}));
const jt = {
  prefixCls: "x6",
  autoInsertCSS: !0,
  useCSSSelector: !0,
  prefix(s) {
    return "".concat(jt.prefixCls, "-").concat(s);
  }
}, zh = jt.prefix("highlighted"), Gy = {
  highlight(s, e, t) {
    const n = t && t.className || zh;
    ie(e, n);
  },
  unhighlight(s, e, t) {
    const n = t && t.className || zh;
    kt(e, n);
  }
}, Vh = jt.prefix("highlight-opacity"), Wy = {
  highlight(s, e) {
    ie(e, Vh);
  },
  unhighlight(s, e) {
    kt(e, Vh);
  }
};
var le;
(function(s) {
  s.normalizeMarker = qn;
  function e(f, g) {
    const p = e3(f.x, f.y).matrixTransform(g);
    return new M(p.x, p.y);
  }
  s.transformPoint = e;
  function t(f, g) {
    return new $(e(f.start, g), e(f.end, g));
  }
  s.transformLine = t;
  function n(f, g) {
    let p = f instanceof Oe ? f.points : f;
    return Array.isArray(p) || (p = []), new Oe(p.map((m) => e(m, g)));
  }
  s.transformPolyline = n;
  function i(f, g) {
    const m = Bt("svg").createSVGPoint();
    m.x = f.x, m.y = f.y;
    const w = m.matrixTransform(g);
    m.x = f.x + f.width, m.y = f.y;
    const v = m.matrixTransform(g);
    m.x = f.x + f.width, m.y = f.y + f.height;
    const y = m.matrixTransform(g);
    m.x = f.x, m.y = f.y + f.height;
    const b = m.matrixTransform(g), x = Math.min(w.x, v.x, y.x, b.x), C = Math.max(w.x, v.x, y.x, b.x), A = Math.min(w.y, v.y, y.y, b.y), k = Math.max(w.y, v.y, y.y, b.y);
    return new R(x, A, C - x, k - A);
  }
  s.transformRectangle = i;
  function r(f, g, p) {
    let m;
    const w = f.ownerSVGElement;
    if (!w)
      return new R(0, 0, 0, 0);
    try {
      m = f.getBBox();
    } catch (y) {
      m = {
        x: f.clientLeft,
        y: f.clientTop,
        width: f.clientWidth,
        height: f.clientHeight
      };
    }
    if (g)
      return R.create(m);
    const v = Bi(f, p || w);
    return i(m, v);
  }
  s.bbox = r;
  function o(f, g = {}) {
    let p;
    if (!f.ownerSVGElement || !jn(f)) {
      if (Lh(f)) {
        const { left: y, top: b, width: x, height: C } = a(f);
        return new R(y, b, x, C);
      }
      return new R(0, 0, 0, 0);
    }
    let w = g.target;
    if (!g.recursive) {
      try {
        p = f.getBBox();
      } catch (b) {
        p = {
          x: f.clientLeft,
          y: f.clientTop,
          width: f.clientWidth,
          height: f.clientHeight
        };
      }
      if (!w)
        return R.create(p);
      const y = Bi(f, w);
      return i(p, y);
    }
    {
      const y = f.childNodes, b = y.length;
      if (b === 0)
        return o(f, {
          target: w
        });
      w || (w = f);
      for (let x = 0; x < b; x += 1) {
        const C = y[x];
        let A;
        C.childNodes.length === 0 ? A = o(C, {
          target: w
        }) : A = o(C, {
          target: w,
          recursive: !0
        }), p ? p = p.union(A) : p = A;
      }
      return p;
    }
  }
  s.getBBox = o;
  function a(f) {
    let g = 0, p = 0, m = 0, w = 0;
    if (f) {
      let v = f;
      for (; v; )
        g += v.offsetLeft, p += v.offsetTop, v = v.offsetParent, v && (g += parseInt(jh(v, "borderLeft"), 10), p += parseInt(jh(v, "borderTop"), 10));
      m = f.offsetWidth, w = f.offsetHeight;
    }
    return {
      left: g,
      top: p,
      width: m,
      height: w
    };
  }
  s.getBoundingOffsetRect = a;
  function l(f) {
    const g = (p) => {
      const m = f.getAttribute(p), w = m ? parseFloat(m) : 0;
      return Number.isNaN(w) ? 0 : w;
    };
    switch (f instanceof SVGElement && f.nodeName.toLowerCase()) {
      case "rect":
        return new R(g("x"), g("y"), g("width"), g("height"));
      case "circle":
        return new It(g("cx"), g("cy"), g("r"), g("r"));
      case "ellipse":
        return new It(g("cx"), g("cy"), g("rx"), g("ry"));
      case "polyline": {
        const p = xo(f);
        return new Oe(p);
      }
      case "polygon": {
        const p = xo(f);
        return p.length > 1 && p.push(p[0]), new Oe(p);
      }
      case "path": {
        let p = f.getAttribute("d");
        return V.isValid(p) || (p = V.normalize(p)), V.parse(p);
      }
      case "line":
        return new $(g("x1"), g("y1"), g("x2"), g("y2"));
    }
    return o(f);
  }
  s.toGeometryShape = l;
  function c(f, g, p, m) {
    const w = M.create(g), v = M.create(p);
    m || (m = f instanceof SVGSVGElement ? f : f.ownerSVGElement);
    const y = ml(f);
    f.setAttribute("transform", "");
    const b = o(f, {
      target: m
    }).scale(y.sx, y.sy), x = _i();
    x.setTranslate(-b.x - b.width / 2, -b.y - b.height / 2);
    const C = _i(), A = w.angleBetween(v, w.clone().translate(1, 0));
    A && C.setRotate(A, 0, 0);
    const k = _i(), O = w.clone().move(v, b.width / 2);
    k.setTranslate(2 * w.x - O.x, 2 * w.y - O.y);
    const P = Bi(f, m), D = _i();
    D.setMatrix(k.matrix.multiply(C.matrix.multiply(x.matrix.multiply(P.scale(y.sx, y.sy))))), f.setAttribute("transform", xi(D.matrix));
  }
  s.translateAndAutoOrient = c;
  function u(f) {
    if (f == null)
      return null;
    let g = f;
    do {
      let p = g.tagName;
      if (typeof p != "string")
        return null;
      if (p = p.toUpperCase(), xr(g, "x6-port"))
        g = g.nextElementSibling;
      else if (p === "G")
        g = g.firstElementChild;
      else if (p === "TITLE")
        g = g.nextElementSibling;
      else
        break;
    } while (g);
    return g;
  }
  s.findShapeNode = u;
  function d(f) {
    const g = u(f);
    if (!jn(g)) {
      if (Lh(f)) {
        const { left: w, top: v, width: y, height: b } = a(f);
        return new R(w, v, y, b);
      }
      return new R(0, 0, 0, 0);
    }
    return l(g).bbox() || R.create();
  }
  s.getBBoxV2 = d;
})(le || (le = {}));
const Jy = {
  padding: 3,
  rx: 0,
  ry: 0,
  attrs: {
    "stroke-width": 3,
    stroke: "#FEB663"
  }
}, Yy = {
  highlight(s, e, t) {
    const n = Sn.getHighlighterId(e, t);
    if (Sn.hasCache(n))
      return;
    t = mu({}, t, Jy);
    const i = G.create(e);
    let r, o;
    try {
      r = i.toPathData();
    } catch (u) {
      o = le.bbox(i.node, !0), r = Bf(Object.assign(Object.assign({}, t), o));
    }
    const a = Bt("path");
    if (ge(a, Object.assign({ d: r, "pointer-events": "none", "vector-effect": "non-scaling-stroke", fill: "none" }, t.attrs ? sr(t.attrs) : null)), s.isEdgeElement(e))
      ge(a, "d", s.getConnectionPathData());
    else {
      let u = i.getTransformToElement(s.container);
      const d = t.padding;
      if (d) {
        o == null && (o = le.bbox(i.node, !0));
        const f = o.x + o.width / 2, g = o.y + o.height / 2;
        o = le.transformRectangle(o, u);
        const p = Math.max(o.width, 1), m = Math.max(o.height, 1), w = (p + d) / p, v = (m + d) / m, y = We({
          a: w,
          b: 0,
          c: 0,
          d: v,
          e: f - w * f,
          f: g - v * g
        });
        u = u.multiply(y);
      }
      ei(a, u);
    }
    ie(a, jt.prefix("highlight-stroke"));
    const l = s.cell, c = () => Sn.removeHighlighter(n);
    l.on("removed", c), l.model && l.model.on("reseted", c), s.container.appendChild(a), Sn.setCache(n, a);
  },
  unhighlight(s, e, t) {
    Sn.removeHighlighter(Sn.getHighlighterId(e, t));
  }
};
var Sn;
(function(s) {
  function e(o, a) {
    return hc(o), o.id + JSON.stringify(a);
  }
  s.getHighlighterId = e;
  const t = {};
  function n(o, a) {
    t[o] = a;
  }
  s.setCache = n;
  function i(o) {
    return t[o] != null;
  }
  s.hasCache = i;
  function r(o) {
    const a = t[o];
    a && (Qs(a), delete t[o]);
  }
  s.removeHighlighter = r;
})(Sn || (Sn = {}));
const Xy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  className: Gy,
  opacity: Wy,
  stroke: Yy
}, Symbol.toStringTag, { value: "Module" }));
var cn;
(function(s) {
  function e(t, n) {
    if (typeof n.highlight != "function")
      throw new Error("Highlighter '".concat(t, "' is missing required `highlight()` method"));
    if (typeof n.unhighlight != "function")
      throw new Error("Highlighter '".concat(t, "' is missing required `unhighlight()` method"));
  }
  s.check = e;
})(cn || (cn = {}));
(function(s) {
  s.presets = Xy, s.registry = Le.create({
    type: "highlighter"
  }), s.registry.register(s.presets, !0);
})(cn || (cn = {}));
function bl(s, e = {}) {
  return new M(Lt(e.x, s.width), Lt(e.y, s.height));
}
function yc(s, e, t) {
  return Object.assign({ angle: e, position: s.toJSON() }, t);
}
const Zy = (s, e) => s.map(({ x: t, y: n, angle: i }) => yc(bl(e, { x: t, y: n }), i || 0)), Ky = (s, e, t) => {
  const n = t.start || 0, i = t.step || 20;
  return dg(s, e, n, (r, o) => (r + 0.5 - o / 2) * i);
}, Qy = (s, e, t) => {
  const n = t.start || 0, i = t.step || 360 / s.length;
  return dg(s, e, n, (r) => r * i);
};
function dg(s, e, t, n) {
  const i = e.getCenter(), r = e.getTopCenter(), o = e.width / e.height, a = It.fromRect(e), l = s.length;
  return s.map((c, u) => {
    const d = t + n(u, l), f = r.clone().rotate(-d, i).scale(o, 1, i), g = c.compensateRotate ? -a.tangentTheta(f) : 0;
    return (c.dx || c.dy) && f.translate(c.dx || 0, c.dy || 0), c.dr && f.move(i, c.dr), yc(f.round(), g, c);
  });
}
var e8 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
const t8 = (s, e, t) => {
  const n = bl(e, t.start || e.getOrigin()), i = bl(e, t.end || e.getCorner());
  return Mr(s, n, i, t);
}, n8 = (s, e, t) => Mr(s, e.getTopLeft(), e.getBottomLeft(), t), s8 = (s, e, t) => Mr(s, e.getTopRight(), e.getBottomRight(), t), i8 = (s, e, t) => Mr(s, e.getTopLeft(), e.getTopRight(), t), r8 = (s, e, t) => Mr(s, e.getBottomLeft(), e.getBottomRight(), t);
function Mr(s, e, t, n) {
  const i = new $(e, t), r = s.length;
  return s.map((o, a) => {
    var { strict: l } = o, c = e8(o, ["strict"]);
    const u = l || n.strict ? (a + 1) / (r + 1) : (a + 0.5) / r, d = i.pointAt(u);
    return (c.dx || c.dy) && d.translate(c.dx || 0, c.dy || 0), yc(d.round(), 0, c);
  });
}
const o8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  absolute: Zy,
  bottom: r8,
  ellipse: Ky,
  ellipseSpread: Qy,
  left: n8,
  line: t8,
  right: s8,
  top: i8
}, Symbol.toStringTag, { value: "Module" }));
var as;
(function(s) {
  s.presets = o8, s.registry = Le.create({
    type: "port layout"
  }), s.registry.register(s.presets, !0);
})(as || (as = {}));
const a8 = {
  position: { x: 0, y: 0 },
  angle: 0,
  attrs: {
    ".": {
      y: "0",
      "text-anchor": "start"
    }
  }
};
function Gn(s, e) {
  const { x: t, y: n, angle: i, attrs: r } = e || {};
  return mu({}, { angle: i, attrs: r, position: { x: t, y: n } }, s, a8);
}
const l8 = (s, e, t) => Gn({ position: e.getTopLeft() }, t), c8 = (s, e, t) => Gn({
  position: { x: -15, y: 0 },
  attrs: { ".": { y: ".3em", "text-anchor": "end" } }
}, t), h8 = (s, e, t) => Gn({
  position: { x: 15, y: 0 },
  attrs: { ".": { y: ".3em", "text-anchor": "start" } }
}, t), u8 = (s, e, t) => Gn({
  position: { x: 0, y: -15 },
  attrs: { ".": { "text-anchor": "middle" } }
}, t), d8 = (s, e, t) => Gn({
  position: { x: 0, y: 15 },
  attrs: { ".": { y: ".6em", "text-anchor": "middle" } }
}, t), f8 = (s, e, t) => fg(s, e, !1, t), g8 = (s, e, t) => fg(s, e, !0, t), p8 = (s, e, t) => gg(s, e, !1, t), m8 = (s, e, t) => gg(s, e, !0, t);
function fg(s, e, t, n) {
  const i = n.offset != null ? n.offset : 15, r = e.getCenter().theta(s), o = pg(e);
  let a, l, c, u, d = 0;
  return r < o[1] || r > o[2] ? (a = ".3em", l = i, c = 0, u = "start") : r < o[0] ? (a = "0", l = 0, c = -i, t ? (d = -90, u = "start") : u = "middle") : r < o[3] ? (a = ".3em", l = -i, c = 0, u = "end") : (a = ".6em", l = 0, c = i, t ? (d = 90, u = "start") : u = "middle"), Gn({
    position: {
      x: Math.round(l),
      y: Math.round(c)
    },
    angle: d,
    attrs: {
      ".": {
        y: a,
        "text-anchor": u
      }
    }
  }, n);
}
function gg(s, e, t, n) {
  const i = n.offset != null ? n.offset : 15, r = e.getCenter().theta(s), o = pg(e);
  let a, l, c, u, d = 0;
  return r < o[1] || r > o[2] ? (a = ".3em", l = -i, c = 0, u = "end") : r < o[0] ? (a = ".6em", l = 0, c = i, t ? (d = 90, u = "start") : u = "middle") : r < o[3] ? (a = ".3em", l = i, c = 0, u = "start") : (a = "0em", l = 0, c = -i, t ? (d = -90, u = "start") : u = "middle"), Gn({
    position: {
      x: Math.round(l),
      y: Math.round(c)
    },
    angle: d,
    attrs: {
      ".": {
        y: a,
        "text-anchor": u
      }
    }
  }, n);
}
function pg(s) {
  const e = s.getCenter(), t = e.theta(s.getTopLeft()), n = e.theta(s.getBottomLeft()), i = e.theta(s.getBottomRight()), r = e.theta(s.getTopRight());
  return [t, r, i, n];
}
const w8 = (s, e, t) => mg(s.diff(e.getCenter()), !1, t), y8 = (s, e, t) => mg(s.diff(e.getCenter()), !0, t);
function mg(s, e, t) {
  const n = t.offset != null ? t.offset : 20, i = new M(0, 0), r = -s.theta(i), o = s.clone().move(i, n).diff(s).round();
  let a = ".3em", l, c = r;
  return (r + 90) % 180 === 0 ? (l = e ? "end" : "middle", !e && r === -270 && (a = "0em")) : r > -270 && r < -90 ? (l = "start", c = r - 180) : l = "end", Gn({
    position: o.round().toJSON(),
    angle: e ? c : 0,
    attrs: {
      ".": {
        y: a,
        "text-anchor": l
      }
    }
  }, t);
}
const b8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bottom: d8,
  inside: p8,
  insideOriented: m8,
  left: c8,
  manual: l8,
  outside: f8,
  outsideOriented: g8,
  radial: w8,
  radialOriented: y8,
  right: h8,
  top: u8
}, Symbol.toStringTag, { value: "Module" }));
var ri;
(function(s) {
  s.presets = b8, s.registry = Le.create({
    type: "port label layout"
  }), s.registry.register(s.presets, !0);
})(ri || (ri = {}));
var v8 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class ve extends yt {
  get priority() {
    return 2;
  }
  /** If need remove `this.container` DOM */
  get disposeContainer() {
    return !0;
  }
  constructor() {
    super(), this.cid = vl.uniqueId(), ve.views[this.cid] = this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  confirmUpdate(e, t) {
    return 0;
  }
  empty(e = this.container) {
    return Cr(e), this;
  }
  unmount(e = this.container) {
    return Qs(e), this;
  }
  remove(e = this.container) {
    return e === this.container ? (this.removeEventListeners(document), this.onRemove(), delete ve.views[this.cid], this.disposeContainer && this.unmount(e)) : this.unmount(e), this;
  }
  onRemove() {
  }
  setClass(e, t = this.container) {
    t.classList.value = Array.isArray(e) ? e.join(" ") : e;
  }
  addClass(e, t = this.container) {
    return ie(t, Array.isArray(e) ? e.join(" ") : e), this;
  }
  removeClass(e, t = this.container) {
    return kt(t, Array.isArray(e) ? e.join(" ") : e), this;
  }
  setStyle(e, t = this.container) {
    return Sr(t, e), this;
  }
  setAttrs(e, t = this.container) {
    return e != null && t != null && ge(t, e), this;
  }
  /**
   * Returns the value of the specified attribute of `node`.
   *
   * If the node does not set a value for attribute, start recursing up
   * the DOM tree from node to lookup for attribute at the ancestors of
   * node. If the recursion reaches CellView's root node and attribute
   * is not found even there, return `null`.
   */
  findAttr(e, t = this.container) {
    let n = t;
    for (; n && n.nodeType === 1; ) {
      const i = n.getAttribute(e);
      if (i != null)
        return i;
      if (n === this.container)
        return null;
      n = n.parentNode;
    }
    return null;
  }
  find(e, t = this.container, n = this.selectors) {
    return ve.find(e, t, n).elems;
  }
  findOne(e, t = this.container, n = this.selectors) {
    const i = this.find(e, t, n);
    return i.length > 0 ? i[0] : null;
  }
  findByAttr(e, t = this.container) {
    let n = t;
    for (; n && n.getAttribute; ) {
      const i = n.getAttribute(e);
      if ((i != null || n === this.container) && i !== "false")
        return n;
      n = n.parentNode;
    }
    return null;
  }
  getSelector(e, t) {
    let n;
    if (e === this.container)
      return typeof t == "string" && (n = "> ".concat(t)), n;
    if (e) {
      const i = dc(e) + 1;
      n = "".concat(e.tagName.toLowerCase(), ":nth-child(").concat(i, ")"), t && (n += " > ".concat(t)), n = this.getSelector(e.parentNode, n);
    }
    return n;
  }
  prefixClassName(e) {
    return jt.prefix(e);
  }
  delegateEvents(e, t) {
    if (e == null)
      return this;
    t || this.undelegateEvents();
    const n = /^(\S+)\s*(.*)$/;
    return Object.keys(e).forEach((i) => {
      const r = i.match(n);
      if (r == null)
        return;
      const o = this.getEventHandler(e[i]);
      typeof o == "function" && this.delegateEvent(r[1], r[2], o);
    }), this;
  }
  undelegateEvents() {
    return Xe.off(this.container, this.getEventNamespace()), this;
  }
  delegateDocumentEvents(e, t) {
    return this.addEventListeners(document, e, t), this;
  }
  undelegateDocumentEvents() {
    return this.removeEventListeners(document), this;
  }
  delegateEvent(e, t, n) {
    return Xe.on(this.container, e + this.getEventNamespace(), t, n), this;
  }
  undelegateEvent(e, t, n) {
    const i = e + this.getEventNamespace();
    return t == null ? Xe.off(this.container, i) : typeof t == "string" ? Xe.off(this.container, i, t, n) : Xe.off(this.container, i, t), this;
  }
  addEventListeners(e, t, n) {
    if (t == null)
      return this;
    const i = this.getEventNamespace();
    return Object.keys(t).forEach((r) => {
      const o = this.getEventHandler(t[r]);
      typeof o == "function" && Xe.on(e, r + i, n, o);
    }), this;
  }
  removeEventListeners(e) {
    return e != null && Xe.off(e, this.getEventNamespace()), this;
  }
  getEventNamespace() {
    return ".".concat(jt.prefixCls, "-event-").concat(this.cid);
  }
  // eslint-disable-next-line
  getEventHandler(e) {
    let t;
    if (typeof e == "string") {
      const n = this[e];
      typeof n == "function" && (t = (...i) => n.call(this, ...i));
    } else
      t = (...n) => e.call(this, ...n);
    return t;
  }
  getEventTarget(e, t = {}) {
    const { target: n, type: i, clientX: r = 0, clientY: o = 0 } = e;
    return t.fromPoint || i === "touchmove" || i === "touchend" ? document.elementFromPoint(r, o) : n;
  }
  stopPropagation(e) {
    return this.setEventData(e, { propagationStopped: !0 }), this;
  }
  isPropagationStopped(e) {
    return this.getEventData(e).propagationStopped === !0;
  }
  getEventData(e) {
    return this.eventData(e);
  }
  setEventData(e, t) {
    return this.eventData(e, t);
  }
  eventData(e, t) {
    if (e == null)
      throw new TypeError("Event object required");
    let n = e.data;
    const i = "__".concat(this.cid, "__");
    return t == null ? n == null ? {} : n[i] || {} : (n == null && (n = e.data = {}), n[i] == null ? n[i] = Object.assign({}, t) : n[i] = Object.assign(Object.assign({}, n[i]), t), n[i]);
  }
  normalizeEvent(e) {
    return ve.normalizeEvent(e);
  }
  dispose() {
    this.remove();
  }
}
v8([
  ve.dispose()
], ve.prototype, "dispose", null);
(function(s) {
  function e(i, r) {
    return r ? Bt(i || "g") : uc(i || "div");
  }
  s.createElement = e;
  function t(i, r, o) {
    if (!i || i === ".")
      return { elems: [r] };
    if (o) {
      const a = o[i];
      if (a)
        return { elems: Array.isArray(a) ? a : [a] };
    }
    {
      const a = i.includes(">") ? ":scope ".concat(i) : i;
      return {
        isCSSSelector: !0,
        // $(rootElem).find(selector).toArray() as Element[]
        elems: Array.prototype.slice.call(r.querySelectorAll(a))
      };
    }
  }
  s.find = t;
  function n(i) {
    let r = i;
    const o = i.originalEvent, a = o && o.changedTouches && o.changedTouches[0];
    if (a) {
      for (const l in i)
        a[l] === void 0 && (a[l] = i[l]);
      r = a;
    }
    return r;
  }
  s.normalizeEvent = n;
})(ve || (ve = {}));
(function(s) {
  s.views = {};
  function e(t) {
    return s.views[t] || null;
  }
  s.getView = e;
})(ve || (ve = {}));
var vl;
(function(s) {
  let e = 0;
  function t() {
    const n = "v".concat(e);
    return e += 1, n;
  }
  s.uniqueId = t;
})(vl || (vl = {}));
class x8 {
  constructor(e) {
    this.view = e, this.clean();
  }
  clean() {
    this.elemCache && this.elemCache.dispose(), this.elemCache = new yl(), this.pathCache = {};
  }
  get(e) {
    return this.elemCache.has(e) || this.elemCache.set(e, {}), this.elemCache.get(e);
  }
  getData(e) {
    const t = this.get(e);
    return t.data || (t.data = {}), t.data;
  }
  getMatrix(e) {
    const t = this.get(e);
    if (t.matrix == null) {
      const n = this.view.container;
      t.matrix = r3(e, n);
    }
    return We(t.matrix);
  }
  getShape(e) {
    const t = this.get(e);
    return t.shape == null && (t.shape = le.toGeometryShape(e)), t.shape.clone();
  }
  getBoundingRect(e) {
    const t = this.get(e);
    return t.boundingRect == null && (t.boundingRect = le.getBBoxV2(e)), t.boundingRect.clone();
  }
}
var be;
(function(s) {
  function e(c) {
    return c != null && !t(c);
  }
  s.isJSONMarkup = e;
  function t(c) {
    return c != null && typeof c == "string";
  }
  s.isStringMarkup = t;
  function n(c) {
    return c == null || t(c) ? c : Ae(c);
  }
  s.clone = n;
  function i(c) {
    return "".concat(c).trim().replace(/[\r|\n]/g, " ").replace(/>\s+</g, "><");
  }
  s.sanitize = i;
  function r(c, u = { ns: Ue.svg }) {
    const d = document.createDocumentFragment(), f = {}, g = {}, p = [
      {
        markup: Array.isArray(c) ? c : [c],
        parent: d,
        ns: u.ns
      }
    ];
    for (; p.length > 0; ) {
      const m = p.pop();
      let w = m.ns || Ue.svg;
      const v = m.markup, y = m.parent;
      v.forEach((b) => {
        const x = b.tagName;
        if (!x)
          throw new TypeError("Invalid tagName");
        b.ns && (w = b.ns);
        const C = w ? uc(x, w) : Th(x), A = b.attrs;
        A && ge(C, sr(A));
        const k = b.style;
        k && Sr(C, k);
        const O = b.className;
        O != null && C.setAttribute("class", Array.isArray(O) ? O.join(" ") : O), b.textContent && (C.textContent = b.textContent);
        const P = b.selector;
        if (P != null) {
          if (g[P])
            throw new TypeError("Selector must be unique");
          g[P] = C;
        }
        if (b.groupSelector) {
          let N = b.groupSelector;
          Array.isArray(N) || (N = [N]), N.forEach((F) => {
            f[F] || (f[F] = []), f[F].push(C);
          });
        }
        y.appendChild(C);
        const D = b.children;
        Array.isArray(D) && p.push({ ns: w, markup: D, parent: C });
      });
    }
    return Object.keys(f).forEach((m) => {
      if (g[m])
        throw new Error("Ambiguous group selector");
      g[m] = f[m];
    }), { fragment: d, selectors: g, groups: f };
  }
  s.parseJSONMarkup = r;
  function o(c) {
    return c instanceof SVGElement ? Bt("g") : Th("div");
  }
  function a(c) {
    if (t(c)) {
      const g = G.createVectors(c), p = g.length;
      if (p === 1)
        return {
          elem: g[0].node
        };
      if (p > 1) {
        const m = o(g[0].node);
        return g.forEach((w) => {
          m.appendChild(w.node);
        }), { elem: m };
      }
      return {};
    }
    const u = r(c), d = u.fragment;
    let f = null;
    return d.childNodes.length > 1 ? (f = o(d.firstChild), f.appendChild(d)) : f = d.firstChild, { elem: f, selectors: u.selectors };
  }
  s.renderMarkup = a;
  function l(c) {
    const u = G.createVectors(c), d = document.createDocumentFragment();
    for (let f = 0, g = u.length; f < g; f += 1) {
      const p = u[f].node;
      d.appendChild(p);
    }
    return { fragment: d, selectors: {} };
  }
  s.parseLabelStringMarkup = l;
})(be || (be = {}));
(function(s) {
  function e(t, n, i) {
    if (t != null) {
      let r;
      const o = t.tagName.toLowerCase();
      if (t === n)
        return typeof i == "string" ? r = "> ".concat(o, " > ").concat(i) : r = "> ".concat(o), r;
      const a = t.parentNode;
      if (a && a.childNodes.length > 1) {
        const l = dc(t) + 1;
        r = "".concat(o, ":nth-child(").concat(l, ")");
      } else
        r = o;
      return i && (r += " > ".concat(i)), e(t.parentNode, n, r);
    }
    return i;
  }
  s.getSelector = e;
})(be || (be = {}));
(function(s) {
  function e() {
    return "g";
  }
  s.getPortContainerMarkup = e;
  function t() {
    return {
      tagName: "circle",
      selector: "circle",
      attrs: {
        r: 10,
        fill: "#FFFFFF",
        stroke: "#000000"
      }
    };
  }
  s.getPortMarkup = t;
  function n() {
    return {
      tagName: "text",
      selector: "text",
      attrs: {
        fill: "#000000"
      }
    };
  }
  s.getPortLabelMarkup = n;
})(be || (be = {}));
(function(s) {
  function e() {
    return [
      {
        tagName: "path",
        selector: "wrap",
        groupSelector: "lines",
        attrs: {
          fill: "none",
          cursor: "pointer",
          stroke: "transparent",
          strokeLinecap: "round"
        }
      },
      {
        tagName: "path",
        selector: "line",
        groupSelector: "lines",
        attrs: {
          fill: "none",
          pointerEvents: "none"
        }
      }
    ];
  }
  s.getEdgeMarkup = e;
})(be || (be = {}));
(function(s) {
  function e(t = !1) {
    return {
      tagName: "foreignObject",
      selector: "fo",
      children: [
        {
          ns: Ue.xhtml,
          tagName: "body",
          selector: "foBody",
          attrs: {
            xmlns: Ue.xhtml
          },
          style: {
            width: "100%",
            height: "100%",
            background: "transparent"
          },
          children: t ? [] : [
            {
              tagName: "div",
              selector: "foContent",
              style: {
                width: "100%",
                height: "100%"
              }
            }
          ]
        }
      ]
    };
  }
  s.getForeignObjectMarkup = e;
})(be || (be = {}));
class wg {
  constructor(e) {
    this.view = e;
  }
  get cell() {
    return this.view.cell;
  }
  getDefinition(e) {
    return this.cell.getAttrDefinition(e);
  }
  processAttrs(e, t) {
    let n, i, r, o;
    const a = [];
    return Object.keys(t).forEach((l) => {
      const c = t[l], u = this.getDefinition(l), d = J(Xt.isValidDefinition, this.view, u, c, {
        elem: e,
        attrs: t,
        cell: this.cell,
        view: this.view
      });
      if (u && d)
        typeof u == "string" ? (n == null && (n = {}), n[u] = c) : c !== null && a.push({ name: l, definition: u });
      else {
        n == null && (n = {});
        const f = _f.includes(l) ? l : hf(l);
        n[f] = c;
      }
    }), a.forEach(({ name: l, definition: c }) => {
      const u = t[l];
      typeof c.set == "function" && (i == null && (i = {}), i[l] = u), typeof c.offset == "function" && (r == null && (r = {}), r[l] = u), typeof c.position == "function" && (o == null && (o = {}), o[l] = u);
    }), {
      raw: t,
      normal: n,
      set: i,
      offset: r,
      position: o
    };
  }
  mergeProcessedAttrs(e, t) {
    e.set = Object.assign(Object.assign({}, e.set), t.set), e.position = Object.assign(Object.assign({}, e.position), t.position), e.offset = Object.assign(Object.assign({}, e.offset), t.offset);
    const n = e.normal && e.normal.transform;
    n != null && t.normal && (t.normal.transform = n), e.normal = t.normal;
  }
  findAttrs(e, t, n, i) {
    const r = [], o = new yl();
    return Object.keys(e).forEach((a) => {
      const l = e[a];
      if (!gn(l))
        return;
      const { isCSSSelector: c, elems: u } = ve.find(a, t, i);
      n[a] = u;
      for (let d = 0, f = u.length; d < f; d += 1) {
        const g = u[d], p = i && i[a] === g, m = o.get(g);
        if (m) {
          m.array || (r.push(g), m.array = !0, m.attrs = [m.attrs], m.priority = [m.priority]);
          const w = m.attrs, v = m.priority;
          if (p)
            w.unshift(l), v.unshift(-1);
          else {
            const y = Ap(v, c ? -1 : f);
            w.splice(y, 0, l), v.splice(y, 0, f);
          }
        } else
          o.set(g, {
            elem: g,
            attrs: l,
            priority: p ? -1 : f,
            array: !1
          });
      }
    }), r.forEach((a) => {
      const l = o.get(a), c = l.attrs;
      l.attrs = c.reduceRight((u, d) => De(u, d), {});
    }), o;
  }
  updateRelativeAttrs(e, t, n) {
    const i = t.raw || {};
    let r = t.normal || {};
    const o = t.set, a = t.position, l = t.offset, c = () => ({
      elem: e,
      cell: this.cell,
      view: this.view,
      attrs: i,
      refBBox: n.clone()
    });
    if (o != null && Object.keys(o).forEach((w) => {
      const v = o[w], y = this.getDefinition(w);
      if (y != null) {
        const b = J(y.set, this.view, v, c());
        typeof b == "object" ? r = Object.assign(Object.assign({}, r), b) : b != null && (r[w] = b);
      }
    }), e instanceof HTMLElement) {
      this.view.setAttrs(r, e);
      return;
    }
    const u = r.transform, d = u ? "".concat(u) : null, f = ir(d), g = new M(f.e, f.f);
    u && (delete r.transform, f.e = 0, f.f = 0);
    let p = !1;
    a != null && Object.keys(a).forEach((w) => {
      const v = a[w], y = this.getDefinition(w);
      if (y != null) {
        const b = J(y.position, this.view, v, c());
        b != null && (p = !0, g.translate(M.create(b)));
      }
    }), this.view.setAttrs(r, e);
    let m = !1;
    if (l != null) {
      const w = this.view.getBoundingRectOfElement(e);
      if (w.width > 0 && w.height > 0) {
        const v = le.transformRectangle(w, f);
        Object.keys(l).forEach((y) => {
          const b = l[y], x = this.getDefinition(y);
          if (x != null) {
            const C = J(x.offset, this.view, b, {
              elem: e,
              cell: this.cell,
              view: this.view,
              attrs: i,
              refBBox: v
            });
            C != null && (m = !0, g.translate(M.create(C)));
          }
        });
      }
    }
    (u != null || p || m) && (g.round(1), f.e = g.x, f.f = g.y, e.setAttribute("transform", xi(f)));
  }
  update(e, t, n) {
    const i = {}, r = this.findAttrs(n.attrs || t, e, i, n.selectors), o = n.attrs ? this.findAttrs(t, e, i, n.selectors) : r, a = [];
    r.each((u) => {
      const d = u.elem, f = u.attrs, g = this.processAttrs(d, f);
      if (g.set == null && g.position == null && g.offset == null)
        this.view.setAttrs(g.normal, d);
      else {
        const p = o.get(d), m = p ? p.attrs : null, w = m && f.ref == null ? m.ref : f.ref;
        let v;
        if (w) {
          if (v = (i[w] || this.view.find(w, e, n.selectors))[0], !v)
            throw new Error('"'.concat(w, '" reference does not exist.'));
        } else
          v = null;
        const y = {
          node: d,
          refNode: v,
          attributes: m,
          processedAttributes: g
        }, b = a.findIndex((x) => x.refNode === d);
        b > -1 ? a.splice(b, 0, y) : a.push(y);
      }
    });
    const l = new yl();
    let c;
    a.forEach((u) => {
      const d = u.node, f = u.refNode;
      let g;
      const p = f != null && n.rotatableNode != null && Pf(n.rotatableNode, f);
      if (f && (g = l.get(f)), !g) {
        const v = p ? n.rotatableNode : e;
        g = f ? le.getBBox(f, { target: v }) : n.rootBBox, f && l.set(f, g);
      }
      let m;
      n.attrs && u.attributes ? (m = this.processAttrs(d, u.attributes), this.mergeProcessedAttrs(m, u.processedAttributes)) : m = u.processedAttributes;
      let w = g;
      p && n.rotatableNode != null && !n.rotatableNode.contains(d) && (c || (c = ir(ge(n.rotatableNode, "transform"))), w = le.transformRectangle(g, c)), this.updateRelativeAttrs(d, m, w);
    });
  }
}
class yg {
  get cell() {
    return this.view.cell;
  }
  constructor(e, t, n = []) {
    this.view = e;
    const i = {}, r = {};
    let o = 0;
    Object.keys(t).forEach((l) => {
      let c = t[l];
      Array.isArray(c) || (c = [c]), c.forEach((u) => {
        let d = i[u];
        d || (o += 1, d = i[u] = 1 << o), r[l] |= d;
      });
    });
    let a = n;
    if (Array.isArray(a) || (a = [a]), a.forEach((l) => {
      i[l] || (o += 1, i[l] = 1 << o);
    }), o > 25)
      throw new Error("Maximum number of flags exceeded.");
    this.flags = i, this.attrs = r, this.bootstrap = n;
  }
  getFlag(e) {
    const t = this.flags;
    return t == null ? 0 : Array.isArray(e) ? e.reduce((n, i) => n | t[i], 0) : t[e] | 0;
  }
  hasAction(e, t) {
    return e & this.getFlag(t);
  }
  removeAction(e, t) {
    return e ^ e & this.getFlag(t);
  }
  getBootstrapFlag() {
    return this.getFlag(this.bootstrap);
  }
  getChangedFlag() {
    let e = 0;
    return this.attrs && Object.keys(this.attrs).forEach((t) => {
      this.cell.hasChanged(t) && (e |= this.attrs[t]);
    }), e;
  }
}
var C8 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
}, E8 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
class Te extends ve {
  static getDefaults() {
    return this.defaults;
  }
  static config(e) {
    this.defaults = this.getOptions(e);
  }
  static getOptions(e) {
    const t = (c, u) => u != null ? wu([
      ...Array.isArray(c) ? c : [c],
      ...Array.isArray(u) ? u : [u]
    ]) : Array.isArray(c) ? [...c] : [c], n = Ae(this.getDefaults()), { bootstrap: i, actions: r, events: o, documentEvents: a } = e, l = E8(e, ["bootstrap", "actions", "events", "documentEvents"]);
    return i && (n.bootstrap = t(n.bootstrap, i)), r && Object.entries(r).forEach(([c, u]) => {
      const d = n.actions[c];
      u && d ? n.actions[c] = t(d, u) : u && (n.actions[c] = t(u));
    }), o && (n.events = Object.assign(Object.assign({}, n.events), o)), e.documentEvents && (n.documentEvents = Object.assign(Object.assign({}, n.documentEvents), a)), De(n, l);
  }
  get [Symbol.toStringTag]() {
    return Te.toStringTag;
  }
  constructor(e, t = {}) {
    super(), this.cell = e, this.options = this.ensureOptions(t), this.graph = this.options.graph, this.attr = new wg(this), this.flag = new yg(this, this.options.actions, this.options.bootstrap), this.cache = new x8(this), this.setContainer(this.ensureContainer()), this.setup(), this.init();
  }
  init() {
  }
  onRemove() {
    this.removeTools();
  }
  get priority() {
    return this.options.priority;
  }
  get rootSelector() {
    return this.options.rootSelector;
  }
  getConstructor() {
    return this.constructor;
  }
  ensureOptions(e) {
    return this.getConstructor().getOptions(e);
  }
  getContainerTagName() {
    return this.options.isSvgElement ? "g" : "div";
  }
  getContainerStyle() {
  }
  getContainerAttrs() {
    return {
      "data-cell-id": this.cell.id,
      "data-shape": this.cell.shape
    };
  }
  getContainerClassName() {
    return this.prefixClassName("cell");
  }
  ensureContainer() {
    return ve.createElement(this.getContainerTagName(), this.options.isSvgElement);
  }
  setContainer(e) {
    if (this.container !== e) {
      this.undelegateEvents(), this.container = e, this.options.events != null && this.delegateEvents(this.options.events);
      const t = this.getContainerAttrs();
      t != null && this.setAttrs(t, e);
      const n = this.getContainerStyle();
      n != null && this.setStyle(n, e);
      const i = this.getContainerClassName();
      i != null && this.addClass(i, e);
    }
    return this;
  }
  isNodeView() {
    return !1;
  }
  isEdgeView() {
    return !1;
  }
  render() {
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  confirmUpdate(e, t = {}) {
    return 0;
  }
  getBootstrapFlag() {
    return this.flag.getBootstrapFlag();
  }
  getFlag(e) {
    return this.flag.getFlag(e);
  }
  hasAction(e, t) {
    return this.flag.hasAction(e, t);
  }
  removeAction(e, t) {
    return this.flag.removeAction(e, t);
  }
  handleAction(e, t, n, i) {
    if (this.hasAction(e, t)) {
      n();
      const r = [t];
      return i && (typeof i == "string" ? r.push(i) : r.push(...i)), this.removeAction(e, r);
    }
    return e;
  }
  setup() {
    this.cell.on("changed", this.onCellChanged, this);
  }
  onCellChanged({ options: e }) {
    this.onAttrsChange(e);
  }
  onAttrsChange(e) {
    let t = this.flag.getChangedFlag();
    e.updated || !t || (e.dirty && this.hasAction(t, "update") && (t |= this.getFlag("render")), e.toolId && (e.async = !1), this.graph != null && this.graph.renderer.requestViewUpdate(this, t, e));
  }
  parseJSONMarkup(e, t) {
    const n = be.parseJSONMarkup(e), i = n.selectors, r = this.rootSelector;
    if (t && r) {
      if (i[r])
        throw new Error("Invalid root selector");
      i[r] = t;
    }
    return n;
  }
  can(e) {
    let t = this.graph.options.interacting;
    if (typeof t == "function" && (t = J(t, this.graph, this)), typeof t == "object") {
      let n = t[e];
      return typeof n == "function" && (n = J(n, this.graph, this)), n !== !1;
    }
    return typeof t == "boolean" ? t : !1;
  }
  cleanCache() {
    return this.cache.clean(), this;
  }
  getCache(e) {
    return this.cache.get(e);
  }
  getDataOfElement(e) {
    return this.cache.getData(e);
  }
  getMatrixOfElement(e) {
    return this.cache.getMatrix(e);
  }
  getShapeOfElement(e) {
    return this.cache.getShape(e);
  }
  getBoundingRectOfElement(e) {
    return this.cache.getBoundingRect(e);
  }
  getBBoxOfElement(e) {
    const t = this.getBoundingRectOfElement(e), n = this.getMatrixOfElement(e), i = this.getRootRotatedMatrix(), r = this.getRootTranslatedMatrix();
    return le.transformRectangle(t, r.multiply(i).multiply(n));
  }
  getUnrotatedBBoxOfElement(e) {
    const t = this.getBoundingRectOfElement(e), n = this.getMatrixOfElement(e), i = this.getRootTranslatedMatrix();
    return le.transformRectangle(t, i.multiply(n));
  }
  getBBox(e = {}) {
    let t;
    if (e.useCellGeometry) {
      const n = this.cell, i = n.isNode() ? n.getAngle() : 0;
      t = n.getBBox().bbox(i);
    } else
      t = this.getBBoxOfElement(this.container);
    return this.graph.coord.localToGraphRect(t);
  }
  getRootTranslatedMatrix() {
    const e = this.cell, t = e.isNode() ? e.getPosition() : { x: 0, y: 0 };
    return We().translate(t.x, t.y);
  }
  getRootRotatedMatrix() {
    let e = We();
    const t = this.cell, n = t.isNode() ? t.getAngle() : 0;
    if (n) {
      const i = t.getBBox(), r = i.width / 2, o = i.height / 2;
      e = e.translate(r, o).rotate(n).translate(-r, -o);
    }
    return e;
  }
  findMagnet(e = this.container) {
    return this.findByAttr("magnet", e);
  }
  updateAttrs(e, t, n = {}) {
    n.rootBBox == null && (n.rootBBox = new R()), n.selectors == null && (n.selectors = this.selectors), this.attr.update(e, t, n);
  }
  isEdgeElement(e) {
    return this.cell.isEdge() && (e == null || e === this.container);
  }
  // #region highlight
  prepareHighlight(e, t = {}) {
    const n = e || this.container;
    return t.partial = n === this.container, n;
  }
  highlight(e, t = {}) {
    const n = this.prepareHighlight(e, t);
    return this.notify("cell:highlight", {
      magnet: n,
      options: t,
      view: this,
      cell: this.cell
    }), this.isEdgeView() ? this.notify("edge:highlight", {
      magnet: n,
      options: t,
      view: this,
      edge: this.cell,
      cell: this.cell
    }) : this.isNodeView() && this.notify("node:highlight", {
      magnet: n,
      options: t,
      view: this,
      node: this.cell,
      cell: this.cell
    }), this;
  }
  unhighlight(e, t = {}) {
    const n = this.prepareHighlight(e, t);
    return this.notify("cell:unhighlight", {
      magnet: n,
      options: t,
      view: this,
      cell: this.cell
    }), this.isNodeView() ? this.notify("node:unhighlight", {
      magnet: n,
      options: t,
      view: this,
      node: this.cell,
      cell: this.cell
    }) : this.isEdgeView() && this.notify("edge:unhighlight", {
      magnet: n,
      options: t,
      view: this,
      edge: this.cell,
      cell: this.cell
    }), this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  notifyUnhighlight(e, t) {
  }
  // #endregion
  getEdgeTerminal(e, t, n, i, r) {
    const o = this.cell, a = this.findAttr("port", e), l = e.getAttribute("data-selector"), c = { cell: o.id };
    return l != null && (c.magnet = l), a != null ? (c.port = a, o.isNode() && !o.hasPort(a) && l == null && (c.selector = this.getSelector(e))) : l == null && this.container !== e && (c.selector = this.getSelector(e)), c;
  }
  getMagnetFromEdgeTerminal(e) {
    const t = this.cell, n = this.container, i = e.port;
    let r = e.magnet, o;
    return i != null && t.isNode() && t.hasPort(i) ? o = this.findPortElem(i, r) || n : (r || (r = e.selector), !r && i != null && (r = '[port="'.concat(i, '"]')), o = this.findOne(r, n, this.selectors)), o;
  }
  hasTools(e) {
    const t = this.tools;
    return t == null ? !1 : e == null ? !0 : t.name === e;
  }
  addTools(e) {
    if (this.removeTools(), e) {
      if (!this.can("toolsAddable"))
        return this;
      const t = Ie.isToolsView(e) ? e : new Ie(e);
      this.tools = t, t.config({ view: this }), t.mount();
    }
    return this;
  }
  updateTools(e = {}) {
    return this.tools && this.tools.update(e), this;
  }
  removeTools() {
    return this.tools && (this.tools.remove(), this.tools = null), this;
  }
  hideTools() {
    return this.tools && this.tools.hide(), this;
  }
  showTools() {
    return this.tools && this.tools.show(), this;
  }
  renderTools() {
    const e = this.cell.getTools();
    return this.addTools(e), this;
  }
  notify(e, t) {
    return this.trigger(e, t), this.graph.trigger(e, t), this;
  }
  getEventArgs(e, t, n) {
    const i = this, r = i.cell;
    return t == null || n == null ? { e, view: i, cell: r } : { e, x: t, y: n, view: i, cell: r };
  }
  onClick(e, t, n) {
    this.notify("cell:click", this.getEventArgs(e, t, n));
  }
  onDblClick(e, t, n) {
    this.notify("cell:dblclick", this.getEventArgs(e, t, n));
  }
  onContextMenu(e, t, n) {
    this.notify("cell:contextmenu", this.getEventArgs(e, t, n));
  }
  onMouseDown(e, t, n) {
    this.cell.model && (this.cachedModelForMouseEvent = this.cell.model, this.cachedModelForMouseEvent.startBatch("mouse")), this.notify("cell:mousedown", this.getEventArgs(e, t, n));
  }
  onMouseUp(e, t, n) {
    this.notify("cell:mouseup", this.getEventArgs(e, t, n)), this.cachedModelForMouseEvent && (this.cachedModelForMouseEvent.stopBatch("mouse", { cell: this.cell }), this.cachedModelForMouseEvent = null);
  }
  onMouseMove(e, t, n) {
    this.notify("cell:mousemove", this.getEventArgs(e, t, n));
  }
  onMouseOver(e) {
    this.notify("cell:mouseover", this.getEventArgs(e));
  }
  onMouseOut(e) {
    this.notify("cell:mouseout", this.getEventArgs(e));
  }
  onMouseEnter(e) {
    this.notify("cell:mouseenter", this.getEventArgs(e));
  }
  onMouseLeave(e) {
    this.notify("cell:mouseleave", this.getEventArgs(e));
  }
  onMouseWheel(e, t, n, i) {
    this.notify("cell:mousewheel", Object.assign({ delta: i }, this.getEventArgs(e, t, n)));
  }
  onCustomEvent(e, t, n, i) {
    this.notify("cell:customevent", Object.assign({ name: t }, this.getEventArgs(e, n, i))), this.notify(t, Object.assign({}, this.getEventArgs(e, n, i)));
  }
  onMagnetMouseDown(e, t, n, i) {
  }
  onMagnetDblClick(e, t, n, i) {
  }
  onMagnetContextMenu(e, t, n, i) {
  }
  onLabelMouseDown(e, t, n) {
  }
  checkMouseleave(e) {
    const t = this.getEventTarget(e, { fromPoint: !0 }), n = this.graph.findViewByElem(t);
    n !== this && (this.onMouseLeave(e), n && n.onMouseEnter(e));
  }
  dispose() {
    this.cell.off("changed", this.onCellChanged, this);
  }
}
Te.defaults = {
  isSvgElement: !0,
  rootSelector: "root",
  priority: 0,
  bootstrap: [],
  actions: {}
};
C8([
  Te.dispose()
], Te.prototype, "dispose", null);
(function(s) {
  s.Flag = yg, s.Attr = wg;
})(Te || (Te = {}));
(function(s) {
  s.toStringTag = "X6.".concat(s.name);
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof s)
      return !0;
    const n = t[Symbol.toStringTag], i = t;
    return (n == null || n === s.toStringTag) && typeof i.isNodeView == "function" && typeof i.isEdgeView == "function" && typeof i.confirmUpdate == "function";
  }
  s.isCellView = e;
})(Te || (Te = {}));
(function(s) {
  function e(n) {
    return function(i) {
      i.config({ priority: n });
    };
  }
  s.priority = e;
  function t(n) {
    return function(i) {
      i.config({ bootstrap: n });
    };
  }
  s.bootstrap = t;
})(Te || (Te = {}));
(function(s) {
  s.registry = Le.create({
    type: "view"
  });
})(Te || (Te = {}));
class Ie extends ve {
  get name() {
    return this.options.name;
  }
  get graph() {
    return this.cellView.graph;
  }
  get cell() {
    return this.cellView.cell;
  }
  get [Symbol.toStringTag]() {
    return Ie.toStringTag;
  }
  constructor(e = {}) {
    super(), this.svgContainer = this.createContainer(!0, e), this.htmlContainer = this.createContainer(!1, e), this.config(e);
  }
  createContainer(e, t) {
    const n = e ? ve.createElement("g", !0) : ve.createElement("div", !1);
    return ie(n, this.prefixClassName("cell-tools")), t.className && ie(n, t.className), n;
  }
  config(e) {
    if (this.options = Object.assign(Object.assign({}, this.options), e), !Te.isCellView(e.view) || e.view === this.cellView)
      return this;
    this.cellView = e.view, this.cell.isEdge() ? (ie(this.svgContainer, this.prefixClassName("edge-tools")), ie(this.htmlContainer, this.prefixClassName("edge-tools"))) : this.cell.isNode() && (ie(this.svgContainer, this.prefixClassName("node-tools")), ie(this.htmlContainer, this.prefixClassName("node-tools"))), this.svgContainer.setAttribute("data-cell-id", this.cell.id), this.htmlContainer.setAttribute("data-cell-id", this.cell.id), this.name && (this.svgContainer.setAttribute("data-tools-name", this.name), this.htmlContainer.setAttribute("data-tools-name", this.name));
    const t = this.options.items;
    if (!Array.isArray(t))
      return this;
    this.tools = [];
    const n = [];
    t.forEach((i) => {
      Ie.ToolItem.isToolItem(i) ? i.name === "vertices" ? n.unshift(i) : n.push(i) : (typeof i == "object" ? i.name : i) === "vertices" ? n.unshift(i) : n.push(i);
    });
    for (let i = 0; i < n.length; i += 1) {
      const r = n[i];
      let o;
      if (Ie.ToolItem.isToolItem(r))
        o = r;
      else {
        const a = typeof r == "object" ? r.name : r, l = typeof r == "object" ? r.args || {} : {};
        if (a) {
          if (this.cell.isNode()) {
            const c = ai.registry.get(a);
            if (c)
              o = new c(l);
            else
              return ai.registry.onNotFound(a);
          } else if (this.cell.isEdge()) {
            const c = li.registry.get(a);
            if (c)
              o = new c(l);
            else
              return li.registry.onNotFound(a);
          }
        }
      }
      o && (o.config(this.cellView, this), o.render(), (o.options.isSVGElement !== !1 ? this.svgContainer : this.htmlContainer).appendChild(o.container), this.tools.push(o));
    }
    return this;
  }
  update(e = {}) {
    const t = this.tools;
    return t && t.forEach((n) => {
      e.toolId !== n.cid && n.isVisible() && n.update();
    }), this;
  }
  focus(e) {
    const t = this.tools;
    return t && t.forEach((n) => {
      e === n ? n.show() : n.hide();
    }), this;
  }
  blur(e) {
    const t = this.tools;
    return t && t.forEach((n) => {
      n !== e && !n.isVisible() && (n.show(), n.update());
    }), this;
  }
  hide() {
    return this.focus(null);
  }
  show() {
    return this.blur(null);
  }
  remove() {
    const e = this.tools;
    return e && (e.forEach((t) => t.remove()), this.tools = null), Qs(this.svgContainer), Qs(this.htmlContainer), super.remove();
  }
  mount() {
    const e = this.tools, t = this.cellView;
    if (t && e) {
      const n = e.some((r) => r.options.isSVGElement !== !1), i = e.some((r) => r.options.isSVGElement === !1);
      n && (this.options.local ? t.container : t.graph.view.decorator).appendChild(this.svgContainer), i && this.graph.container.appendChild(this.htmlContainer);
    }
    return this;
  }
}
(function(s) {
  s.toStringTag = "X6.".concat(s.name);
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof s)
      return !0;
    const n = t[Symbol.toStringTag], i = t;
    return (n == null || n === s.toStringTag) && i.graph != null && i.cell != null && typeof i.config == "function" && typeof i.update == "function" && typeof i.focus == "function" && typeof i.blur == "function" && typeof i.show == "function" && typeof i.hide == "function";
  }
  s.isToolsView = e;
})(Ie || (Ie = {}));
(function(s) {
  class e extends ve {
    static getDefaults() {
      return this.defaults;
    }
    static config(n) {
      this.defaults = this.getOptions(n);
    }
    static getOptions(n) {
      return De(Ae(this.getDefaults()), n);
    }
    get graph() {
      return this.cellView.graph;
    }
    get cell() {
      return this.cellView.cell;
    }
    get name() {
      return this.options.name;
    }
    get [Symbol.toStringTag]() {
      return e.toStringTag;
    }
    constructor(n = {}) {
      super(), this.visible = !0, this.options = this.getOptions(n), this.container = ve.createElement(this.options.tagName || "g", this.options.isSVGElement !== !1), ie(this.container, this.prefixClassName("cell-tool")), typeof this.options.className == "string" && ie(this.container, this.options.className), this.init();
    }
    init() {
    }
    getOptions(n) {
      return this.constructor.getOptions(n);
    }
    delegateEvents() {
      return this.options.events && super.delegateEvents(this.options.events), this;
    }
    config(n, i) {
      return this.cellView = n, this.parent = i, this.stamp(this.container), this.cell.isEdge() ? ie(this.container, this.prefixClassName("edge-tool")) : this.cell.isNode() && ie(this.container, this.prefixClassName("node-tool")), this.name && this.container.setAttribute("data-tool-name", this.name), this.delegateEvents(), this;
    }
    render() {
      this.empty();
      const n = this.options.markup;
      if (n) {
        const i = be.parseJSONMarkup(n);
        this.container.appendChild(i.fragment), this.childNodes = i.selectors;
      }
      return this.onRender(), this;
    }
    onRender() {
    }
    update() {
      return this;
    }
    stamp(n) {
      n && n.setAttribute("data-cell-id", this.cellView.cell.id);
    }
    show() {
      return this.container.style.display = "", this.visible = !0, this;
    }
    hide() {
      return this.container.style.display = "none", this.visible = !1, this;
    }
    isVisible() {
      return this.visible;
    }
    focus() {
      const n = this.options.focusOpacity;
      return n != null && Number.isFinite(n) && (this.container.style.opacity = "".concat(n)), this.parent.focus(this), this;
    }
    blur() {
      return this.container.style.opacity = "", this.parent.blur(this), this;
    }
    guard(n) {
      return this.graph == null || this.cellView == null ? !0 : this.graph.view.guard(n, this.cellView);
    }
  }
  e.defaults = {
    isSVGElement: !0,
    tagName: "g"
  }, s.ToolItem = e, function(t) {
    let n = 0;
    function i(o) {
      return o ? oc(o) : (n += 1, "CustomTool".concat(n));
    }
    function r(o) {
      const a = ic(i(o.name), this);
      return a.config(o), a;
    }
    t.define = r;
  }(e = s.ToolItem || (s.ToolItem = {})), function(t) {
    t.toStringTag = "X6.".concat(t.name);
    function n(i) {
      if (i == null)
        return !1;
      if (i instanceof t)
        return !0;
      const r = i[Symbol.toStringTag], o = i;
      return (r == null || r === t.toStringTag) && o.graph != null && o.cell != null && typeof o.config == "function" && typeof o.update == "function" && typeof o.focus == "function" && typeof o.blur == "function" && typeof o.show == "function" && typeof o.hide == "function" && typeof o.isVisible == "function";
    }
    t.isToolItem = n;
  }(e = s.ToolItem || (s.ToolItem = {}));
})(Ie || (Ie = {}));
const S8 = (s) => s;
function Hh(s, e) {
  return e === 0 ? "0%" : "".concat(Math.round(s / e * 100), "%");
}
function bg(s) {
  return (t, n, i, r) => n.isEdgeElement(i) ? M8(s, t, n, i, r) : A8(s, t, n, i, r);
}
function A8(s, e, t, n, i) {
  const r = t.cell, o = r.getAngle(), a = t.getUnrotatedBBoxOfElement(n), l = r.getBBox().getCenter(), c = M.create(i).rotate(o, l);
  let u = c.x - a.x, d = c.y - a.y;
  return s && (u = Hh(u, a.width), d = Hh(d, a.height)), e.anchor = {
    name: "topLeft",
    args: {
      dx: u,
      dy: d,
      rotate: !0
    }
  }, e;
}
function M8(s, e, t, n, i) {
  const r = t.getConnection();
  if (!r)
    return e;
  const o = r.closestPointLength(i);
  if (s) {
    const a = r.length();
    e.anchor = {
      name: "ratio",
      args: {
        ratio: o / a
      }
    };
  } else
    e.anchor = {
      name: "length",
      args: {
        length: o
      }
    };
  return e;
}
const k8 = bg(!0), P8 = bg(!1), _8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  noop: S8,
  pinAbsolute: P8,
  pinRelative: k8
}, Symbol.toStringTag, { value: "Module" }));
var xl;
(function(s) {
  s.presets = _8, s.registry = Le.create({
    type: "connection strategy"
  }), s.registry.register(s.presets, !0);
})(xl || (xl = {}));
function vg(s, e, t, n) {
  return J(xl.presets.pinRelative, this.graph, {}, e, t, s, this.cell, n, {}).anchor;
}
function xg(s, e) {
  return e ? s.cell.getBBox() : s.cell.isEdge() ? s.getConnection().bbox() : s.getUnrotatedBBoxOfElement(s.container);
}
class Fn extends Ie.ToolItem {
  onRender() {
    ie(this.container, this.prefixClassName("cell-tool-button")), this.update();
  }
  update() {
    return this.updatePosition(), this;
  }
  updatePosition() {
    const t = this.cellView.cell.isEdge() ? this.getEdgeMatrix() : this.getNodeMatrix();
    ei(this.container, t, { absolute: !0 });
  }
  getNodeMatrix() {
    const e = this.cellView, t = this.options;
    let { x: n = 0, y: i = 0 } = t;
    const { offset: r, useCellGeometry: o, rotate: a } = t;
    let l = xg(e, o);
    const c = e.cell.getAngle();
    a || (l = l.bbox(c));
    let u = 0, d = 0;
    typeof r == "number" ? (u = r, d = r) : typeof r == "object" && (u = r.x, d = r.y), n = Lt(n, l.width), i = Lt(i, l.height);
    let f = We().translate(l.x + l.width / 2, l.y + l.height / 2);
    return a && (f = f.rotate(c)), f = f.translate(n + u - l.width / 2, i + d - l.height / 2), f;
  }
  getEdgeMatrix() {
    const e = this.cellView, t = this.options, { offset: n = 0, distance: i = 0, rotate: r } = t;
    let o, a, l;
    const c = Lt(i, 1);
    c >= 0 && c <= 1 ? o = e.getTangentAtRatio(c) : o = e.getTangentAtLength(c), o ? (a = o.start, l = o.vector().vectorAngle(new M(1, 0)) || 0) : (a = e.getConnection().start, l = 0);
    let u = We().translate(a.x, a.y).rotate(l);
    return typeof n == "object" ? u = u.translate(n.x || 0, n.y || 0) : u = u.translate(0, n), r || (u = u.rotate(-l)), u;
  }
  onMouseDown(e) {
    if (this.guard(e))
      return;
    e.stopPropagation(), e.preventDefault();
    const t = this.options.onClick;
    typeof t == "function" && J(t, this.cellView, {
      e,
      view: this.cellView,
      cell: this.cellView.cell,
      btn: this
    });
  }
}
(function(s) {
  s.config({
    name: "button",
    useCellGeometry: !0,
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown"
    }
  });
})(Fn || (Fn = {}));
(function(s) {
  s.Remove = s.define({
    name: "button-remove",
    markup: [
      {
        tagName: "circle",
        selector: "button",
        attrs: {
          r: 7,
          fill: "#FF1D00",
          cursor: "pointer"
        }
      },
      {
        tagName: "path",
        selector: "icon",
        attrs: {
          d: "M -3 -3 3 3 M -3 3 3 -3",
          fill: "none",
          stroke: "#FFFFFF",
          "stroke-width": 2,
          "pointer-events": "none"
        }
      }
    ],
    distance: 60,
    offset: 0,
    useCellGeometry: !0,
    onClick({ view: e, btn: t }) {
      t.parent.remove(), e.cell.remove({ ui: !0, toolId: t.cid });
    }
  });
})(Fn || (Fn = {}));
var O8 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
class So extends Ie.ToolItem {
  onRender() {
    if (ie(this.container, this.prefixClassName("cell-tool-boundary")), this.options.attrs) {
      const e = this.options.attrs, { class: t } = e, n = O8(e, ["class"]);
      ge(this.container, sr(n)), t && ie(this.container, t);
    }
    this.update();
  }
  update() {
    const e = this.cellView, t = this.options, { useCellGeometry: n, rotate: i } = t, r = ms(t.padding);
    let o = xg(e, n).moveAndExpand({
      x: -r.left,
      y: -r.top,
      width: r.left + r.right,
      height: r.top + r.bottom
    });
    const a = e.cell;
    if (a.isNode()) {
      const l = a.getAngle();
      if (l)
        if (i) {
          const c = a.getBBox().getCenter();
          pl(this.container, l, c.x, c.y, {
            absolute: !0
          });
        } else
          o = o.bbox(l);
    }
    return ge(this.container, o.toJSON()), this;
  }
}
(function(s) {
  s.config({
    name: "boundary",
    tagName: "rect",
    padding: 10,
    useCellGeometry: !0,
    attrs: {
      fill: "none",
      stroke: "#333",
      "stroke-width": 0.5,
      "stroke-dasharray": "5, 5",
      "pointer-events": "none"
    }
  });
})(So || (So = {}));
class lr extends Ie.ToolItem {
  constructor() {
    super(...arguments), this.handles = [];
  }
  get vertices() {
    return this.cellView.cell.getVertices();
  }
  onRender() {
    return this.addClass(this.prefixClassName("edge-tool-vertices")), this.options.addable && this.updatePath(), this.resetHandles(), this.renderHandles(), this;
  }
  update() {
    return this.vertices.length === this.handles.length ? this.updateHandles() : (this.resetHandles(), this.renderHandles()), this.options.addable && this.updatePath(), this;
  }
  resetHandles() {
    const e = this.handles;
    this.handles = [], e && e.forEach((t) => {
      this.stopHandleListening(t), t.remove();
    });
  }
  renderHandles() {
    const e = this.vertices;
    for (let t = 0, n = e.length; t < n; t += 1) {
      const i = e[t], r = this.options.createHandle, o = this.options.processHandle, a = r({
        index: t,
        graph: this.graph,
        guard: (l) => this.guard(l),
        attrs: this.options.attrs || {}
      });
      o && o(a), a.updatePosition(i.x, i.y), this.stamp(a.container), this.container.appendChild(a.container), this.handles.push(a), this.startHandleListening(a);
    }
  }
  updateHandles() {
    const e = this.vertices;
    for (let t = 0, n = e.length; t < n; t += 1) {
      const i = e[t], r = this.handles[t];
      r && r.updatePosition(i.x, i.y);
    }
  }
  updatePath() {
    const e = this.childNodes.connection;
    e && e.setAttribute("d", this.cellView.getConnectionPathData());
  }
  startHandleListening(e) {
    const t = this.cellView;
    t.can("vertexMovable") && (e.on("change", this.onHandleChange, this), e.on("changing", this.onHandleChanging, this), e.on("changed", this.onHandleChanged, this)), t.can("vertexDeletable") && e.on("remove", this.onHandleRemove, this);
  }
  stopHandleListening(e) {
    const t = this.cellView;
    t.can("vertexMovable") && (e.off("change", this.onHandleChange, this), e.off("changing", this.onHandleChanging, this), e.off("changed", this.onHandleChanged, this)), t.can("vertexDeletable") && e.off("remove", this.onHandleRemove, this);
  }
  getNeighborPoints(e) {
    const t = this.cellView, n = this.vertices, i = e > 0 ? n[e - 1] : t.sourceAnchor, r = e < n.length - 1 ? n[e + 1] : t.targetAnchor;
    return {
      prev: M.create(i),
      next: M.create(r)
    };
  }
  getMouseEventArgs(e) {
    const t = this.normalizeEvent(e), { x: n, y: i } = this.graph.snapToGrid(t.clientX, t.clientY);
    return { e: t, x: n, y: i };
  }
  onHandleChange({ e }) {
    this.focus();
    const t = this.cellView;
    if (t.cell.startBatch("move-vertex", { ui: !0, toolId: this.cid }), !this.options.stopPropagation) {
      const { e: n, x: i, y: r } = this.getMouseEventArgs(e);
      this.eventData(n, { start: { x: i, y: r } }), t.notifyMouseDown(n, i, r);
    }
  }
  onHandleChanging({ handle: e, e: t }) {
    const n = this.cellView, i = e.options.index, { e: r, x: o, y: a } = this.getMouseEventArgs(t), l = { x: o, y: a };
    this.snapVertex(l, i), n.cell.setVertexAt(i, l, { ui: !0, toolId: this.cid }), e.updatePosition(l.x, l.y), this.options.stopPropagation || n.notifyMouseMove(r, o, a);
  }
  stopBatch(e) {
    this.cell.stopBatch("move-vertex", { ui: !0, toolId: this.cid }), e && this.cell.stopBatch("add-vertex", { ui: !0, toolId: this.cid });
  }
  onHandleChanged({ e }) {
    const t = this.options, n = this.cellView;
    if (t.addable && this.updatePath(), !t.removeRedundancies) {
      this.stopBatch(this.eventData(e).vertexAdded);
      return;
    }
    n.removeRedundantLinearVertices({
      ui: !0,
      toolId: this.cid
    }) && this.render(), this.blur(), this.stopBatch(this.eventData(e).vertexAdded);
    const { e: r, x: o, y: a } = this.getMouseEventArgs(e);
    if (!this.options.stopPropagation) {
      n.notifyMouseUp(r, o, a);
      const { start: l } = this.eventData(r);
      if (l) {
        const { x: c, y: u } = l;
        c === o && u === a && n.onClick(r, o, a);
      }
    }
    n.checkMouseleave(r), t.onChanged && t.onChanged({ edge: n.cell, edgeView: n });
  }
  snapVertex(e, t) {
    const n = this.options.snapRadius || 0;
    if (n > 0) {
      const i = this.getNeighborPoints(t), r = i.prev, o = i.next;
      Math.abs(e.x - r.x) < n ? e.x = r.x : Math.abs(e.x - o.x) < n && (e.x = o.x), Math.abs(e.y - r.y) < n ? e.y = i.prev.y : Math.abs(e.y - o.y) < n && (e.y = o.y);
    }
  }
  onHandleRemove({ handle: e, e: t }) {
    if (this.options.removable) {
      const n = e.options.index, i = this.cellView;
      i.cell.removeVertexAt(n, { ui: !0 }), this.options.addable && this.updatePath(), i.checkMouseleave(this.normalizeEvent(t));
    }
  }
  allowAddVertex(e) {
    const t = this.guard(e), n = this.options.addable && this.cellView.can("vertexAddable"), i = this.options.modifiers ? ti.isMatch(e, this.options.modifiers) : !0;
    return !t && n && i;
  }
  onPathMouseDown(e) {
    const t = this.cellView;
    if (!this.allowAddVertex(e))
      return;
    e.stopPropagation(), e.preventDefault();
    const n = this.normalizeEvent(e), i = this.graph.snapToGrid(n.clientX, n.clientY).toJSON();
    t.cell.startBatch("add-vertex", { ui: !0, toolId: this.cid });
    const r = t.getVertexIndex(i.x, i.y);
    this.snapVertex(i, r), t.cell.insertVertex(i, r, {
      ui: !0,
      toolId: this.cid
    }), this.render();
    const o = this.handles[r];
    this.eventData(n, { vertexAdded: !0 }), o.onMouseDown(n);
  }
  onRemove() {
    this.resetHandles();
  }
}
(function(s) {
  class e extends ve {
    get graph() {
      return this.options.graph;
    }
    constructor(n) {
      super(), this.options = n, this.render(), this.delegateEvents({
        mousedown: "onMouseDown",
        touchstart: "onMouseDown",
        dblclick: "onDoubleClick"
      });
    }
    render() {
      this.container = ve.createElement("circle", !0);
      const n = this.options.attrs;
      if (typeof n == "function") {
        const i = s.getDefaults();
        this.setAttrs(Object.assign(Object.assign({}, i.attrs), n(this)));
      } else
        this.setAttrs(n);
      this.addClass(this.prefixClassName("edge-tool-vertex"));
    }
    updatePosition(n, i) {
      this.setAttrs({ cx: n, cy: i });
    }
    onMouseDown(n) {
      this.options.guard(n) || (n.stopPropagation(), n.preventDefault(), this.graph.view.undelegateEvents(), this.delegateDocumentEvents({
        mousemove: "onMouseMove",
        touchmove: "onMouseMove",
        mouseup: "onMouseUp",
        touchend: "onMouseUp",
        touchcancel: "onMouseUp"
      }, n.data), this.emit("change", { e: n, handle: this }));
    }
    onMouseMove(n) {
      this.emit("changing", { e: n, handle: this });
    }
    onMouseUp(n) {
      this.emit("changed", { e: n, handle: this }), this.undelegateDocumentEvents(), this.graph.view.delegateEvents();
    }
    onDoubleClick(n) {
      this.emit("remove", { e: n, handle: this });
    }
  }
  s.Handle = e;
})(lr || (lr = {}));
(function(s) {
  const e = jt.prefix("edge-tool-vertex-path");
  s.config({
    name: "vertices",
    snapRadius: 20,
    addable: !0,
    removable: !0,
    removeRedundancies: !0,
    stopPropagation: !0,
    attrs: {
      r: 6,
      fill: "#333",
      stroke: "#fff",
      cursor: "move",
      "stroke-width": 2
    },
    createHandle: (t) => new s.Handle(t),
    markup: [
      {
        tagName: "path",
        selector: "connection",
        className: e,
        attrs: {
          fill: "none",
          stroke: "transparent",
          "stroke-width": 10,
          cursor: "pointer"
        }
      }
    ],
    events: {
      ["mousedown .".concat(e)]: "onPathMouseDown",
      ["touchstart .".concat(e)]: "onPathMouseDown"
    }
  });
})(lr || (lr = {}));
class cr extends Ie.ToolItem {
  constructor() {
    super(...arguments), this.handles = [];
  }
  get vertices() {
    return this.cellView.cell.getVertices();
  }
  update() {
    return this.render(), this;
  }
  onRender() {
    ie(this.container, this.prefixClassName("edge-tool-segments")), this.resetHandles();
    const e = this.cellView, t = [...this.vertices];
    t.unshift(e.sourcePoint), t.push(e.targetPoint);
    for (let n = 0, i = t.length; n < i - 1; n += 1) {
      const r = t[n], o = t[n + 1], a = this.renderHandle(r, o, n);
      this.stamp(a.container), this.handles.push(a);
    }
    return this;
  }
  renderHandle(e, t, n) {
    const i = this.options.createHandle({
      index: n,
      graph: this.graph,
      guard: (r) => this.guard(r),
      attrs: this.options.attrs || {}
    });
    return this.options.processHandle && this.options.processHandle(i), this.updateHandle(i, e, t), this.container.appendChild(i.container), this.startHandleListening(i), i;
  }
  startHandleListening(e) {
    e.on("change", this.onHandleChange, this), e.on("changing", this.onHandleChanging, this), e.on("changed", this.onHandleChanged, this);
  }
  stopHandleListening(e) {
    e.off("change", this.onHandleChange, this), e.off("changing", this.onHandleChanging, this), e.off("changed", this.onHandleChanged, this);
  }
  resetHandles() {
    const e = this.handles;
    this.handles = [], e && e.forEach((t) => {
      this.stopHandleListening(t), t.remove();
    });
  }
  shiftHandleIndexes(e) {
    const t = this.handles;
    for (let n = 0, i = t.length; n < i; n += 1)
      t[n].options.index += e;
  }
  resetAnchor(e, t) {
    const n = this.cellView.cell, i = {
      ui: !0,
      toolId: this.cid
    };
    t ? n.prop([e, "anchor"], t, i) : n.removeProp([e, "anchor"], i);
  }
  snapHandle(e, t, n) {
    const i = e.options.axis, r = e.options.index, l = this.cellView.cell.getVertices(), c = l[r - 2] || n.sourceAnchor, u = l[r + 1] || n.targetAnchor, d = this.options.snapRadius;
    return Math.abs(t[i] - c[i]) < d ? t[i] = c[i] : Math.abs(t[i] - u[i]) < d && (t[i] = u[i]), t;
  }
  onHandleChanging({ handle: e, e: t }) {
    const n = this.graph, i = this.options, r = this.cellView, o = i.anchor, a = e.options.axis, l = e.options.index - 1, c = this.getEventData(t), u = this.normalizeEvent(t), d = n.snapToGrid(u.clientX, u.clientY), f = this.snapHandle(e, d.clone(), c), g = Ae(this.vertices);
    let p = g[l], m = g[l + 1];
    const w = r.sourceView, v = r.sourceBBox;
    let y = !1, b = !1;
    if (p ? l === 0 ? v.containsPoint(p) ? (g.shift(), this.shiftHandleIndexes(-1), y = !0) : (p[a] = f[a], b = !0) : p[a] = f[a] : (p = r.sourceAnchor.toJSON(), p[a] = f[a], v.containsPoint(p) ? y = !0 : (g.unshift(p), this.shiftHandleIndexes(1), b = !0)), typeof o == "function" && w) {
      if (y) {
        const O = c.sourceAnchor.clone();
        O[a] = f[a];
        const P = J(o, r, O, w, r.sourceMagnet || w.container, "source", r, this);
        this.resetAnchor("source", P);
      }
      b && this.resetAnchor("source", c.sourceAnchorDef);
    }
    const x = r.targetView, C = r.targetBBox;
    let A = !1, k = !1;
    if (m ? l === g.length - 2 ? C.containsPoint(m) ? (g.pop(), A = !0) : (m[a] = f[a], k = !0) : m[a] = f[a] : (m = r.targetAnchor.toJSON(), m[a] = f[a], C.containsPoint(m) ? A = !0 : (g.push(m), k = !0)), typeof o == "function" && x) {
      if (A) {
        const O = c.targetAnchor.clone();
        O[a] = f[a];
        const P = J(o, r, O, x, r.targetMagnet || x.container, "target", r, this);
        this.resetAnchor("target", P);
      }
      k && this.resetAnchor("target", c.targetAnchorDef);
    }
    M.equalPoints(g, this.vertices) || this.cellView.cell.setVertices(g, { ui: !0, toolId: this.cid }), this.updateHandle(e, p, m, 0), i.stopPropagation || r.notifyMouseMove(u, d.x, d.y);
  }
  onHandleChange({ handle: e, e: t }) {
    const n = this.options, i = this.handles, r = this.cellView, o = e.options.index;
    if (Array.isArray(i)) {
      for (let a = 0, l = i.length; a < l; a += 1)
        a !== o && i[a].hide();
      if (this.focus(), this.setEventData(t, {
        sourceAnchor: r.sourceAnchor.clone(),
        targetAnchor: r.targetAnchor.clone(),
        sourceAnchorDef: Ae(this.cell.prop(["source", "anchor"])),
        targetAnchorDef: Ae(this.cell.prop(["target", "anchor"]))
      }), this.cell.startBatch("move-segment", { ui: !0, toolId: this.cid }), !n.stopPropagation) {
        const a = this.normalizeEvent(t), l = this.graph.snapToGrid(a.clientX, a.clientY);
        r.notifyMouseDown(a, l.x, l.y);
      }
    }
  }
  onHandleChanged({ e }) {
    const t = this.options, n = this.cellView;
    t.removeRedundancies && n.removeRedundantLinearVertices({ ui: !0, toolId: this.cid });
    const i = this.normalizeEvent(e), r = this.graph.snapToGrid(i.clientX, i.clientY);
    this.render(), this.blur(), this.cell.stopBatch("move-segment", { ui: !0, toolId: this.cid }), t.stopPropagation || n.notifyMouseUp(i, r.x, r.y), n.checkMouseleave(i), t.onChanged && t.onChanged({ edge: n.cell, edgeView: n });
  }
  updateHandle(e, t, n, i = 0) {
    const r = this.options.precision || 0, o = Math.abs(t.x - n.x) < r, a = Math.abs(t.y - n.y) < r;
    if (o || a) {
      const l = new $(t, n);
      if (l.length() < this.options.threshold)
        e.hide();
      else {
        const u = l.getCenter(), d = o ? "x" : "y";
        u[d] += i || 0;
        const f = l.vector().vectorAngle(new M(1, 0));
        e.updatePosition(u.x, u.y, f, this.cellView), e.show(), e.options.axis = d;
      }
    } else
      e.hide();
  }
  onRemove() {
    this.resetHandles();
  }
}
(function(s) {
  class e extends ve {
    constructor(n) {
      super(), this.options = n, this.render(), this.delegateEvents({
        mousedown: "onMouseDown",
        touchstart: "onMouseDown"
      });
    }
    render() {
      this.container = ve.createElement("rect", !0);
      const n = this.options.attrs;
      if (typeof n == "function") {
        const i = s.getDefaults();
        this.setAttrs(Object.assign(Object.assign({}, i.attrs), n(this)));
      } else
        this.setAttrs(n);
      this.addClass(this.prefixClassName("edge-tool-segment"));
    }
    updatePosition(n, i, r, o) {
      const a = o.getClosestPoint(new M(n, i)) || new M(n, i);
      let l = We().translate(a.x, a.y);
      if (a.equals({ x: n, y: i }))
        l = l.rotate(r);
      else {
        let u = new $(n, i, a.x, a.y).vector().vectorAngle(new M(1, 0));
        u !== 0 && (u += 90), l = l.rotate(u);
      }
      this.setAttrs({
        transform: xi(l),
        cursor: r % 180 === 0 ? "row-resize" : "col-resize"
      });
    }
    onMouseDown(n) {
      this.options.guard(n) || (this.trigger("change", { e: n, handle: this }), n.stopPropagation(), n.preventDefault(), this.options.graph.view.undelegateEvents(), this.delegateDocumentEvents({
        mousemove: "onMouseMove",
        touchmove: "onMouseMove",
        mouseup: "onMouseUp",
        touchend: "onMouseUp",
        touchcancel: "onMouseUp"
      }, n.data));
    }
    onMouseMove(n) {
      this.emit("changing", { e: n, handle: this });
    }
    onMouseUp(n) {
      this.emit("changed", { e: n, handle: this }), this.undelegateDocumentEvents(), this.options.graph.view.delegateEvents();
    }
    show() {
      this.container.style.display = "";
    }
    hide() {
      this.container.style.display = "none";
    }
  }
  s.Handle = e;
})(cr || (cr = {}));
(function(s) {
  s.config({
    name: "segments",
    precision: 0.5,
    threshold: 40,
    snapRadius: 10,
    stopPropagation: !0,
    removeRedundancies: !0,
    attrs: {
      width: 20,
      height: 8,
      x: -10,
      y: -4,
      rx: 4,
      ry: 4,
      fill: "#333",
      stroke: "#fff",
      "stroke-width": 2
    },
    createHandle: (e) => new s.Handle(e),
    anchor: vg
  });
})(cr || (cr = {}));
class Ao extends Ie.ToolItem {
  get type() {
    return this.options.type;
  }
  onRender() {
    ie(this.container, this.prefixClassName("edge-tool-".concat(this.type, "-anchor"))), this.toggleArea(!1), this.update();
  }
  update() {
    const e = this.type;
    return this.cellView.getTerminalView(e) ? (this.updateAnchor(), this.updateArea(), this.container.style.display = "") : this.container.style.display = "none", this;
  }
  updateAnchor() {
    const e = this.childNodes;
    if (!e)
      return;
    const t = e.anchor;
    if (!t)
      return;
    const n = this.type, i = this.cellView, r = this.options, o = i.getTerminalAnchor(n), a = i.cell.prop([n, "anchor"]);
    t.setAttribute("transform", "translate(".concat(o.x, ", ").concat(o.y, ")"));
    const l = a ? r.customAnchorAttrs : r.defaultAnchorAttrs;
    l && Object.keys(l).forEach((c) => {
      t.setAttribute(c, l[c]);
    });
  }
  updateArea() {
    const e = this.childNodes;
    if (!e)
      return;
    const t = e.area;
    if (!t)
      return;
    const n = this.type, i = this.cellView, r = i.getTerminalView(n);
    if (r) {
      const o = r.cell, a = i.getTerminalMagnet(n);
      let l = this.options.areaPadding || 0;
      Number.isFinite(l) || (l = 0);
      let c, u, d;
      r.isEdgeElement(a) ? (c = r.getBBox(), u = 0, d = c.getCenter()) : (c = r.getUnrotatedBBoxOfElement(a), u = o.getAngle(), d = c.getCenter(), u && d.rotate(-u, o.getBBox().getCenter())), c.inflate(l), ge(t, {
        x: -c.width / 2,
        y: -c.height / 2,
        width: c.width,
        height: c.height,
        transform: "translate(".concat(d.x, ", ").concat(d.y, ") rotate(").concat(u, ")")
      });
    }
  }
  toggleArea(e) {
    if (this.childNodes) {
      const t = this.childNodes.area;
      t && (t.style.display = e ? "" : "none");
    }
  }
  onMouseDown(e) {
    this.guard(e) || (e.stopPropagation(), e.preventDefault(), this.graph.view.undelegateEvents(), this.options.documentEvents && this.delegateDocumentEvents(this.options.documentEvents), this.focus(), this.toggleArea(this.options.restrictArea), this.cell.startBatch("move-anchor", {
      ui: !0,
      toolId: this.cid
    }));
  }
  resetAnchor(e) {
    const t = this.type, n = this.cell;
    e ? n.prop([t, "anchor"], e, {
      rewrite: !0,
      ui: !0,
      toolId: this.cid
    }) : n.removeProp([t, "anchor"], {
      ui: !0,
      toolId: this.cid
    });
  }
  onMouseMove(e) {
    const t = this.type, n = this.cellView, i = n.getTerminalView(t);
    if (i == null)
      return;
    const r = this.normalizeEvent(e), o = i.cell, a = n.getTerminalMagnet(t);
    let l = this.graph.coord.clientToLocalPoint(r.clientX, r.clientY);
    const c = this.options.snap;
    if (typeof c == "function") {
      const f = J(c, n, l, i, a, t, n, this);
      l = M.create(f);
    }
    if (this.options.restrictArea)
      if (i.isEdgeElement(a)) {
        const f = i.getClosestPoint(l);
        f && (l = f);
      } else {
        const f = i.getUnrotatedBBoxOfElement(a), g = o.getAngle(), p = o.getBBox().getCenter(), m = l.clone().rotate(g, p);
        f.containsPoint(m) || (l = f.getNearestPointToPoint(m).rotate(-g, p));
      }
    let u;
    const d = this.options.anchor;
    typeof d == "function" && (u = J(d, n, l, i, a, t, n, this)), this.resetAnchor(u), this.update();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onMouseUp(e) {
    this.graph.view.delegateEvents(), this.undelegateDocumentEvents(), this.blur(), this.toggleArea(!1);
    const t = this.cellView;
    this.options.removeRedundancies && t.removeRedundantLinearVertices({ ui: !0, toolId: this.cid }), this.cell.stopBatch("move-anchor", { ui: !0, toolId: this.cid });
  }
  onDblClick() {
    const e = this.options.resetAnchor;
    e && this.resetAnchor(e === !0 ? void 0 : e), this.update();
  }
}
(function(s) {
  s.config({
    tagName: "g",
    markup: [
      {
        tagName: "circle",
        selector: "anchor",
        attrs: {
          cursor: "pointer"
        }
      },
      {
        tagName: "rect",
        selector: "area",
        attrs: {
          "pointer-events": "none",
          fill: "none",
          stroke: "#33334F",
          "stroke-dasharray": "2,4",
          rx: 5,
          ry: 5
        }
      }
    ],
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown",
      dblclick: "onDblClick"
    },
    documentEvents: {
      mousemove: "onMouseMove",
      touchmove: "onMouseMove",
      mouseup: "onMouseUp",
      touchend: "onMouseUp",
      touchcancel: "onMouseUp"
    },
    customAnchorAttrs: {
      "stroke-width": 4,
      stroke: "#33334F",
      fill: "#FFFFFF",
      r: 5
    },
    defaultAnchorAttrs: {
      "stroke-width": 2,
      stroke: "#FFFFFF",
      fill: "#33334F",
      r: 6
    },
    areaPadding: 6,
    snapRadius: 10,
    resetAnchor: !0,
    restrictArea: !0,
    removeRedundancies: !0,
    anchor: vg,
    snap(e, t, n, i, r, o) {
      const a = o.options.snapRadius || 0, l = i === "source", c = l ? 0 : -1, u = this.cell.getVertexAt(c) || this.getTerminalAnchor(l ? "target" : "source");
      return u && (Math.abs(u.x - e.x) < a && (e.x = u.x), Math.abs(u.y - e.y) < a && (e.y = u.y)), e;
    }
  });
})(Ao || (Ao = {}));
const T8 = Ao.define({
  name: "source-anchor",
  type: "source"
}), L8 = Ao.define({
  name: "target-anchor",
  type: "target"
});
var N8 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
class Mo extends Ie.ToolItem {
  get type() {
    return this.options.type;
  }
  get ratio() {
    return this.options.ratio;
  }
  init() {
    if (this.options.attrs) {
      const e = this.options.attrs, { class: t } = e, n = N8(e, ["class"]);
      this.setAttrs(n, this.container), t && ie(this.container, t);
    }
  }
  onRender() {
    ie(this.container, this.prefixClassName("edge-tool-".concat(this.type, "-arrowhead"))), this.update();
  }
  update() {
    const e = this.ratio, t = this.cellView, n = t.getTangentAtRatio(e), i = n ? n.start : t.getPointAtRatio(e), r = n && n.vector().vectorAngle(new M(1, 0)) || 0;
    if (!i)
      return this;
    const o = We().translate(i.x, i.y).rotate(r);
    return ei(this.container, o, { absolute: !0 }), this;
  }
  onMouseDown(e) {
    if (this.guard(e))
      return;
    e.stopPropagation(), e.preventDefault();
    const t = this.cellView;
    if (t.can("arrowheadMovable")) {
      t.cell.startBatch("move-arrowhead", {
        ui: !0,
        toolId: this.cid
      });
      const n = this.graph.snapToGrid(e.clientX, e.clientY), i = t.prepareArrowheadDragging(this.type, {
        x: n.x,
        y: n.y,
        options: Object.assign(Object.assign({}, this.options), { toolId: this.cid })
      });
      this.cellView.setEventData(e, i), this.delegateDocumentEvents(this.options.documentEvents, e.data), t.graph.view.undelegateEvents(), this.container.style.pointerEvents = "none";
    }
    this.focus();
  }
  onMouseMove(e) {
    const t = this.normalizeEvent(e), n = this.graph.snapToGrid(t.clientX, t.clientY);
    this.cellView.onMouseMove(t, n.x, n.y), this.update();
  }
  onMouseUp(e) {
    this.undelegateDocumentEvents();
    const t = this.normalizeEvent(e), n = this.cellView, i = this.graph.snapToGrid(t.clientX, t.clientY);
    n.onMouseUp(t, i.x, i.y), this.graph.view.delegateEvents(), this.blur(), this.container.style.pointerEvents = "", n.cell.stopBatch("move-arrowhead", {
      ui: !0,
      toolId: this.cid
    });
  }
}
(function(s) {
  s.config({
    tagName: "path",
    isSVGElement: !0,
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown"
    },
    documentEvents: {
      mousemove: "onMouseMove",
      touchmove: "onMouseMove",
      mouseup: "onMouseUp",
      touchend: "onMouseUp",
      touchcancel: "onMouseUp"
    }
  });
})(Mo || (Mo = {}));
const D8 = Mo.define({
  name: "source-arrowhead",
  type: "source",
  ratio: 0,
  attrs: {
    d: "M 10 -8 -10 0 10 8 Z",
    fill: "#333",
    stroke: "#fff",
    "stroke-width": 2,
    cursor: "move"
  }
}), I8 = Mo.define({
  name: "target-arrowhead",
  type: "target",
  ratio: 1,
  attrs: {
    d: "M -10 -8 10 0 -10 8 Z",
    fill: "#333",
    stroke: "#fff",
    "stroke-width": 2,
    cursor: "move"
  }
});
class oi extends Ie.ToolItem {
  constructor() {
    super(...arguments), this.labelIndex = -1, this.distance = 0.5, this.dblClick = this.onCellDblClick.bind(this);
  }
  onRender() {
    const e = this.cellView;
    e && e.on("cell:dblclick", this.dblClick);
  }
  createElement() {
    const e = [
      this.prefixClassName("".concat(this.cell.isEdge() ? "edge" : "node", "-tool-editor")),
      this.prefixClassName("cell-tool-editor")
    ];
    this.editor = Ie.createElement("div", !1), this.addClass(e, this.editor), this.editor.contentEditable = "true", this.container.appendChild(this.editor);
  }
  removeElement() {
    this.undelegateDocumentEvents(), this.editor && (this.container.removeChild(this.editor), this.editor = null);
  }
  updateEditor() {
    const { cell: e, editor: t } = this;
    if (!t)
      return;
    const { style: n } = t;
    e.isNode() ? this.updateNodeEditorTransform() : e.isEdge() && this.updateEdgeEditorTransform();
    const { attrs: i } = this.options;
    n.fontSize = "".concat(i.fontSize, "px"), n.fontFamily = i.fontFamily, n.color = i.color, n.backgroundColor = i.backgroundColor;
    const r = this.getCellText() || "";
    return t.innerText = r, this.setCellText(""), this;
  }
  updateNodeEditorTransform() {
    const { graph: e, cell: t, editor: n } = this;
    if (!n)
      return;
    let i = M.create(), r = 20, o = "", { x: a, y: l } = this.options;
    const { width: c, height: u } = this.options;
    if (typeof a < "u" && typeof l < "u") {
      const g = t.getBBox();
      a = Lt(a, g.width), l = Lt(l, g.height), i = g.topLeft.translate(a, l), r = g.width - a * 2;
    } else {
      const g = t.getBBox();
      i = g.center, r = g.width - 4, o = "translate(-50%, -50%)";
    }
    const d = e.scale(), { style: f } = n;
    i = e.localToGraph(i), f.left = "".concat(i.x, "px"), f.top = "".concat(i.y, "px"), f.transform = "scale(".concat(d.sx, ", ").concat(d.sy, ") ").concat(o), f.minWidth = "".concat(r, "px"), typeof c == "number" && (f.width = "".concat(c, "px")), typeof u == "number" && (f.height = "".concat(u, "px"));
  }
  updateEdgeEditorTransform() {
    if (!this.event)
      return;
    const { graph: e, editor: t } = this;
    if (!t)
      return;
    let n = M.create(), i = 20;
    const { style: r } = t, o = this.event.target, a = o.parentElement;
    if (a && xr(a, this.prefixClassName("edge-label"))) {
      const u = a.getAttribute("data-index") || "0";
      this.labelIndex = parseInt(u, 10);
      const d = a.getAttribute("transform"), { translation: f } = Yo(d);
      n = new M(f.tx, f.ty), i = le.getBBox(o).width;
    } else {
      if (!this.options.labelAddable)
        return this;
      n = e.clientToLocal(M.create(this.event.clientX, this.event.clientY));
      const d = this.cellView.path.closestPointLength(n);
      this.distance = d, this.labelIndex = -1;
    }
    n = e.localToGraph(n);
    const c = e.scale();
    r.left = "".concat(n.x, "px"), r.top = "".concat(n.y, "px"), r.minWidth = "".concat(i, "px"), r.transform = "scale(".concat(c.sx, ", ").concat(c.sy, ") translate(-50%, -50%)");
  }
  onDocumentMouseUp(e) {
    if (this.editor && e.target !== this.editor) {
      const t = this.editor.innerText.replace(/\n$/, "") || "";
      this.setCellText(t !== "" ? t : null), this.removeElement();
    }
  }
  onCellDblClick({ e }) {
    this.editor || (e.stopPropagation(), this.removeElement(), this.event = e, this.createElement(), this.updateEditor(), this.autoFocus(), this.delegateDocumentEvents(this.options.documentEvents));
  }
  onMouseDown(e) {
    e.stopPropagation();
  }
  autoFocus() {
    setTimeout(() => {
      this.editor && (this.editor.focus(), this.selectText());
    });
  }
  selectText() {
    if (window.getSelection && this.editor) {
      const e = document.createRange(), t = window.getSelection();
      e.selectNodeContents(this.editor), t.removeAllRanges(), t.addRange(e);
    }
  }
  getCellText() {
    const { getText: e } = this.options;
    if (typeof e == "function")
      return J(e, this.cellView, {
        cell: this.cell,
        index: this.labelIndex
      });
    if (typeof e == "string") {
      if (this.cell.isNode())
        return this.cell.attr(e);
      if (this.cell.isEdge() && this.labelIndex !== -1)
        return this.cell.prop("labels/".concat(this.labelIndex, "/attrs/").concat(e));
    }
  }
  setCellText(e) {
    const t = this.options.setText;
    if (typeof t == "function") {
      J(t, this.cellView, {
        cell: this.cell,
        value: e,
        index: this.labelIndex,
        distance: this.distance
      });
      return;
    }
    if (typeof t == "string") {
      if (this.cell.isNode()) {
        e !== null && this.cell.attr(t, e);
        return;
      }
      if (this.cell.isEdge()) {
        const n = this.cell;
        if (this.labelIndex === -1) {
          if (e) {
            const i = {
              position: {
                distance: this.distance
              },
              attrs: {}
            };
            vi(i, "attrs/".concat(t), e), n.appendLabel(i);
          }
        } else
          e !== null ? n.prop("labels/".concat(this.labelIndex, "/attrs/").concat(t), e) : typeof this.labelIndex == "number" && n.removeLabelAt(this.labelIndex);
      }
    }
  }
  onRemove() {
    const e = this.cellView;
    e && e.off("cell:dblclick", this.dblClick), this.removeElement();
  }
}
(function(s) {
  s.config({
    tagName: "div",
    isSVGElement: !1,
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown"
    },
    documentEvents: {
      mouseup: "onDocumentMouseUp",
      touchend: "onDocumentMouseUp",
      touchcancel: "onDocumentMouseUp"
    }
  });
})(oi || (oi = {}));
(function(s) {
  s.NodeEditor = s.define({
    attrs: {
      fontSize: 14,
      fontFamily: "Arial, helvetica, sans-serif",
      color: "#000",
      backgroundColor: "#fff"
    },
    getText: "text/text",
    setText: "text/text"
  }), s.EdgeEditor = s.define({
    attrs: {
      fontSize: 14,
      fontFamily: "Arial, helvetica, sans-serif",
      color: "#000",
      backgroundColor: "#fff"
    },
    labelAddable: !0,
    getText: "label/text",
    setText: "label/text"
  });
})(oi || (oi = {}));
var Cg = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
}, ai;
(function(s) {
  s.presets = {
    boundary: So,
    button: Fn,
    "button-remove": Fn.Remove,
    "node-editor": oi.NodeEditor
  }, s.registry = Le.create({
    type: "node tool",
    process(e, t) {
      if (typeof t == "function")
        return t;
      let n = Ie.ToolItem;
      const { inherit: i } = t, r = Cg(t, ["inherit"]);
      if (i) {
        const o = this.get(i);
        o == null ? this.onNotFound(i, "inherited") : n = o;
      }
      return r.name == null && (r.name = e), n.define.call(n, r);
    }
  }), s.registry.register(s.presets, !0);
})(ai || (ai = {}));
var li;
(function(s) {
  s.presets = {
    boundary: So,
    vertices: lr,
    segments: cr,
    button: Fn,
    "button-remove": Fn.Remove,
    "source-anchor": T8,
    "target-anchor": L8,
    "source-arrowhead": D8,
    "target-arrowhead": I8,
    "edge-editor": oi.EdgeEditor
  }, s.registry = Le.create({
    type: "edge tool",
    process(e, t) {
      if (typeof t == "function")
        return t;
      let n = Ie.ToolItem;
      const { inherit: i } = t, r = Cg(t, ["inherit"]);
      if (i) {
        const o = this.get(i);
        o == null ? this.onNotFound(i, "inherited") : n = o;
      }
      return r.name == null && (r.name = e), n.define.call(n, r);
    }
  }), s.registry.register(s.presets, !0);
})(li || (li = {}));
const j8 = yn("center"), R8 = yn("topCenter"), B8 = yn("bottomCenter"), F8 = yn("leftMiddle"), $8 = yn("rightMiddle"), z8 = yn("topLeft"), V8 = yn("topRight"), H8 = yn("bottomLeft"), U8 = yn("bottomRight");
function yn(s) {
  return function(e, t, n, i = {}) {
    const r = i.rotate ? e.getUnrotatedBBoxOfElement(t) : e.getBBoxOfElement(t), o = r[s];
    o.x += Lt(i.dx, r.width), o.y += Lt(i.dy, r.height);
    const a = e.cell;
    return i.rotate ? o.rotate(-a.getAngle(), a.getBBox().getCenter()) : o;
  };
}
function Qo(s) {
  return function(e, t, n, i) {
    if (n instanceof Element) {
      const r = this.graph.findViewByElem(n);
      let o;
      if (r)
        if (r.isEdgeElement(n)) {
          const a = i.fixedAt != null ? i.fixedAt : "50%";
          o = Eg(r, a);
        } else
          o = r.getBBoxOfElement(n).getCenter();
      else
        o = new M();
      return s.call(this, e, t, o, i);
    }
    return s.apply(this, arguments);
  };
}
function Eg(s, e) {
  const t = un(e), n = typeof e == "string" ? parseFloat(e) : e;
  return t ? s.getPointAtRatio(n / 100) : s.getPointAtLength(n);
}
const q8 = function(s, e, t, n) {
  const i = de.normalize(s.cell.getAngle()), r = s.getBBoxOfElement(e), o = r.getCenter(), a = r.getTopLeft(), l = r.getBottomRight();
  let c = n.padding;
  if (Number.isFinite(c) || (c = 0), a.y + c <= t.y && t.y <= l.y - c) {
    const u = t.y - o.y;
    o.x += i === 0 || i === 180 ? 0 : u * 1 / Math.tan(de.toRad(i)), o.y += u;
  } else if (a.x + c <= t.x && t.x <= l.x - c) {
    const u = t.x - o.x;
    o.y += i === 90 || i === 270 ? 0 : u * Math.tan(de.toRad(i)), o.x += u;
  }
  return o;
}, G8 = Qo(q8), W8 = function(s, e, t, n, i) {
  const r = s.cell.getConnectionPoint(this.cell, i);
  return (n.dx || n.dy) && r.translate(n.dx || 0, n.dy || 0), r;
}, J8 = function(s, e, t, n) {
  let i, r = 0, o;
  const a = s.cell;
  n.rotate ? (i = s.getUnrotatedBBoxOfElement(e), o = a.getBBox().getCenter(), r = a.getAngle()) : i = s.getBBoxOfElement(e);
  const l = n.padding;
  l != null && Number.isFinite(l) && i.inflate(l), n.rotate && t.rotate(r, o);
  const c = i.getNearestSideToPoint(t);
  let u;
  switch (c) {
    case "left":
      u = i.getLeftMiddle();
      break;
    case "right":
      u = i.getRightMiddle();
      break;
    case "top":
      u = i.getTopCenter();
      break;
    case "bottom":
      u = i.getBottomCenter();
      break;
  }
  const d = n.direction;
  return d === "H" ? (c === "top" || c === "bottom") && (t.x <= i.x + i.width ? u = i.getLeftMiddle() : u = i.getRightMiddle()) : d === "V" && (t.y <= i.y + i.height ? u = i.getTopCenter() : u = i.getBottomCenter()), n.rotate ? u.rotate(-r, o) : u;
}, Y8 = Qo(J8), X8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bottom: B8,
  bottomLeft: H8,
  bottomRight: U8,
  center: j8,
  left: F8,
  midSide: Y8,
  nodeCenter: W8,
  orth: G8,
  right: $8,
  top: R8,
  topLeft: z8,
  topRight: V8
}, Symbol.toStringTag, { value: "Module" }));
var ci;
(function(s) {
  s.presets = X8, s.registry = Le.create({
    type: "node endpoint"
  }), s.registry.register(s.presets, !0);
})(ci || (ci = {}));
const Z8 = function(s, e, t, n) {
  let i = n.ratio != null ? n.ratio : 0.5;
  return i > 1 && (i /= 100), s.getPointAtRatio(i);
}, K8 = function(s, e, t, n) {
  const i = n.length != null ? n.length : 20;
  return s.getPointAtLength(i);
}, Sg = function(s, e, t, n) {
  const i = s.getClosestPoint(t);
  return i != null ? i : new M();
}, Q8 = Qo(Sg), eb = function(s, e, t, n) {
  const r = s.getConnection(), o = s.getConnectionSubdivisions(), a = new $(t.clone().translate(0, 1e6), t.clone().translate(0, -1e6)), l = new $(t.clone().translate(1e6, 0), t.clone().translate(-1e6, 0)), c = a.intersect(r, {
    segmentSubdivisions: o
  }), u = l.intersect(r, {
    segmentSubdivisions: o
  }), d = [];
  return c && d.push(...c), u && d.push(...u), d.length > 0 ? t.closest(d) : n.fallbackAt != null ? Eg(s, n.fallbackAt) : J(Sg, this, s, e, t, n);
}, tb = Qo(eb), nb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  closest: Q8,
  length: K8,
  orth: tb,
  ratio: Z8
}, Symbol.toStringTag, { value: "Module" }));
var hi;
(function(s) {
  s.presets = nb, s.registry = Le.create({
    type: "edge endpoint"
  }), s.registry.register(s.presets, !0);
})(hi || (hi = {}));
function ea(s, e, t) {
  let n;
  if (typeof t == "object") {
    if (Number.isFinite(t.y)) {
      const r = new $(e, s), { start: o, end: a } = r.parallel(t.y);
      e = o, s = a;
    }
    n = t.x;
  } else
    n = t;
  if (n == null || !Number.isFinite(n))
    return s;
  const i = s.distance(e);
  return n === 0 && i > 0 ? s : s.move(e, -Math.min(n, i - 1));
}
function ko(s) {
  const e = s.getAttribute("stroke-width");
  return e === null ? 0 : parseFloat(e) || 0;
}
function sb(s) {
  if (s == null)
    return null;
  let e = s;
  do {
    let t = e.tagName;
    if (typeof t != "string")
      return null;
    if (t = t.toUpperCase(), t === "G")
      e = e.firstElementChild;
    else if (t === "TITLE")
      e = e.nextElementSibling;
    else
      break;
  } while (e);
  return e;
}
const Ag = function(s, e, t, n) {
  const i = e.getBBoxOfElement(t);
  n.stroked && i.inflate(ko(t) / 2);
  const r = s.intersect(i), o = r && r.length ? s.start.closest(r) : s.end;
  return ea(o, s.start, n.offset);
}, ib = function(s, e, t, n, i) {
  const r = e.cell, o = r.isNode() ? r.getAngle() : 0;
  if (o === 0)
    return J(Ag, this, s, e, t, n, i);
  const a = e.getUnrotatedBBoxOfElement(t);
  n.stroked && a.inflate(ko(t) / 2);
  const l = a.getCenter(), c = s.clone().rotate(o, l), u = c.setLength(1e6).intersect(a), d = u && u.length ? c.start.closest(u).rotate(-o, l) : s.end;
  return ea(d, s.start, n.offset);
}, rb = function(s, e, t, n) {
  let i, r;
  const o = s.end, a = n.selector;
  if (typeof a == "string" ? i = e.findOne(a) : Array.isArray(a) ? i = rc(t, a) : i = sb(t), !jn(i)) {
    if (i === t || !jn(t))
      return o;
    i = t;
  }
  const l = e.getShapeOfElement(i), c = e.getMatrixOfElement(i), u = e.getRootTranslatedMatrix(), d = e.getRootRotatedMatrix(), f = u.multiply(d).multiply(c), g = f.inverse(), p = le.transformLine(s, g), m = p.start.clone(), w = e.getDataOfElement(i);
  if (n.insideout === !1) {
    w.shapeBBox == null && (w.shapeBBox = l.bbox());
    const x = w.shapeBBox;
    if (x != null && x.containsPoint(m))
      return o;
  }
  n.extrapolate === !0 && p.setLength(1e6);
  let v;
  if (V.isPath(l)) {
    const x = n.precision || 2;
    w.segmentSubdivisions == null && (w.segmentSubdivisions = l.getSegmentSubdivisions({
      precision: x
    })), v = {
      precision: x,
      segmentSubdivisions: w.segmentSubdivisions
    }, r = p.intersect(l, v);
  } else
    r = p.intersect(l);
  r ? Array.isArray(r) && (r = m.closest(r)) : n.sticky === !0 && (R.isRectangle(l) ? r = l.getNearestPointToPoint(m) : It.isEllipse(l) ? r = l.intersectsWithLineFromCenterToPoint(m) : r = l.closestPoint(m, v));
  const y = r ? le.transformPoint(r, f) : o;
  let b = n.offset || 0;
  return n.stroked !== !1 && (typeof b == "object" ? (b = Object.assign({}, b), b.x == null && (b.x = 0), b.x += ko(i) / 2) : b += ko(i) / 2), ea(y, s.start, b);
};
function ob(s, e, t = 0) {
  const { start: n, end: i } = s;
  let r, o, a, l;
  switch (e) {
    case "left":
      l = "x", r = i, o = n, a = -1;
      break;
    case "right":
      l = "x", r = n, o = i, a = 1;
      break;
    case "top":
      l = "y", r = i, o = n, a = -1;
      break;
    case "bottom":
      l = "y", r = n, o = i, a = 1;
      break;
    default:
      return;
  }
  n[l] < i[l] ? r[l] = o[l] : o[l] = r[l], Number.isFinite(t) && (r[l] += a * t, o[l] += a * t);
}
const ab = function(s, e, t, n) {
  const { alignOffset: i, align: r } = n;
  return r && ob(s, r, i), ea(s.end, s.start, n.offset);
}, lb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  anchor: ab,
  bbox: Ag,
  boundary: rb,
  rect: ib
}, Symbol.toStringTag, { value: "Module" }));
var ui;
(function(s) {
  s.presets = lb, s.registry = Le.create({
    type: "connection point"
  }), s.registry.register(s.presets, !0);
})(ui || (ui = {}));
const cb = function(s) {
  return [...s];
}, hb = function(s, e, t) {
  const n = e.side || "bottom", i = ms(e.padding || 40), r = t.sourceBBox, o = t.targetBBox, a = r.getCenter(), l = o.getCenter();
  let c, u, d;
  switch (n) {
    case "top":
      d = -1, c = "y", u = "height";
      break;
    case "left":
      d = -1, c = "x", u = "width";
      break;
    case "right":
      d = 1, c = "x", u = "width";
      break;
    case "bottom":
    default:
      d = 1, c = "y", u = "height";
      break;
  }
  return a[c] += d * (r[u] / 2 + i[n]), l[c] += d * (o[u] / 2 + i[n]), d * (a[c] - l[c]) > 0 ? l[c] = a[c] : a[c] = l[c], [a.toJSON(), ...s, l.toJSON()];
};
function Hr(s) {
  return new R(s.x, s.y, 0, 0);
}
function Po(s = {}) {
  const e = ms(s.padding || 20);
  return {
    x: -e.left,
    y: -e.top,
    width: e.left + e.right,
    height: e.top + e.bottom
  };
}
function Mg(s, e = {}) {
  return s.sourceBBox.clone().moveAndExpand(Po(e));
}
function kg(s, e = {}) {
  return s.targetBBox.clone().moveAndExpand(Po(e));
}
function ub(s, e = {}) {
  return s.sourceAnchor ? s.sourceAnchor : Mg(s, e).getCenter();
}
function db(s, e = {}) {
  return s.targetAnchor ? s.targetAnchor : kg(s, e).getCenter();
}
const Pg = function(s, e, t) {
  let n = Mg(t, e), i = kg(t, e);
  const r = ub(t, e), o = db(t, e);
  n = n.union(Hr(r)), i = i.union(Hr(o));
  const a = s.map((u) => M.create(u));
  a.unshift(r), a.push(o);
  let l = null;
  const c = [];
  for (let u = 0, d = a.length - 1; u < d; u += 1) {
    let f = null;
    const g = a[u], p = a[u + 1], m = vt.getBearing(g, p) != null;
    if (u === 0)
      u + 1 === d ? n.intersectsWithRect(i.clone().inflate(1)) ? f = vt.insideNode(g, p, n, i) : m || (f = vt.nodeToNode(g, p, n, i)) : n.containsPoint(p) ? f = vt.insideNode(g, p, n, Hr(p).moveAndExpand(Po(e))) : m || (f = vt.nodeToVertex(g, p, n));
    else if (u + 1 === d) {
      const w = m && vt.getBearing(p, g) === l;
      i.containsPoint(g) || w ? f = vt.insideNode(g, p, Hr(g).moveAndExpand(Po(e)), i, l) : m || (f = vt.vertexToNode(g, p, i, l));
    } else
      m || (f = vt.vertexToVertex(g, p, l));
    f ? (c.push(...f.points), l = f.direction) : l = vt.getBearing(g, p), u + 1 < d && c.push(p);
  }
  return c;
};
var vt;
(function(s) {
  const e = {
    N: "S",
    S: "N",
    E: "W",
    W: "E"
  }, t = {
    N: -Math.PI / 2 * 3,
    S: -Math.PI / 2,
    E: 0,
    W: Math.PI
  };
  function n(d, f, g) {
    let p = new M(d.x, f.y);
    return g.containsPoint(p) && (p = new M(f.x, d.y)), p;
  }
  function i(d, f) {
    return d[f === "W" || f === "E" ? "width" : "height"];
  }
  s.getBBoxSize = i;
  function r(d, f) {
    return d.x === f.x ? d.y > f.y ? "N" : "S" : d.y === f.y ? d.x > f.x ? "W" : "E" : null;
  }
  s.getBearing = r;
  function o(d, f, g) {
    const p = new M(d.x, f.y), m = new M(f.x, d.y), w = r(d, p), v = r(d, m), y = g ? e[g] : null, b = w === g || w !== y && (v === y || v !== g) ? p : m;
    return { points: [b], direction: r(b, f) };
  }
  s.vertexToVertex = o;
  function a(d, f, g) {
    const p = n(d, f, g);
    return { points: [p], direction: r(p, f) };
  }
  s.nodeToVertex = a;
  function l(d, f, g, p) {
    const m = [new M(d.x, f.y), new M(f.x, d.y)], w = m.filter((b) => !g.containsPoint(b)), v = w.filter((b) => r(b, d) !== p);
    let y;
    if (v.length > 0)
      return y = v.filter((b) => r(d, b) === p).pop(), y = y || v[0], {
        points: [y],
        direction: r(y, f)
      };
    {
      y = Mp(m, w)[0];
      const b = M.create(f).move(y, -i(g, p) / 2);
      return {
        points: [n(b, d, g), b],
        direction: r(b, f)
      };
    }
  }
  s.vertexToNode = l;
  function c(d, f, g, p) {
    let m = a(f, d, p);
    const w = m.points[0];
    if (g.containsPoint(w)) {
      m = a(d, f, g);
      const v = m.points[0];
      if (p.containsPoint(v)) {
        const y = M.create(d).move(v, -i(g, r(d, v)) / 2), b = M.create(f).move(w, -i(p, r(f, w)) / 2), x = new $(y, b).getCenter(), C = a(d, x, g), A = o(x, f, C.direction);
        m.points = [C.points[0], A.points[0]], m.direction = A.direction;
      }
    }
    return m;
  }
  s.nodeToNode = c;
  function u(d, f, g, p, m) {
    const w = g.union(p).inflate(1), v = w.getCenter(), y = v.distance(f) > v.distance(d), b = y ? f : d, x = y ? d : f;
    let C, A, k;
    m ? (C = M.fromPolar(w.width + w.height, t[m], b), C = w.getNearestPointToPoint(C).move(C, -1)) : C = w.getNearestPointToPoint(b).move(b, 1), A = n(C, x, w);
    let O;
    C.round().equals(A.round()) ? (A = M.fromPolar(w.width + w.height, de.toRad(C.theta(b)) + Math.PI / 2, x), A = w.getNearestPointToPoint(A).move(x, 1).round(), k = n(C, A, w), O = y ? [A, k, C] : [C, k, A]) : O = y ? [A, C] : [C, A];
    const P = r(y ? C : A, f);
    return {
      points: O,
      direction: P
    };
  }
  s.insideNode = u;
})(vt || (vt = {}));
const fb = {
  step: 10,
  maxLoopCount: 2e3,
  precision: 1,
  maxDirectionChange: 90,
  perpendicular: !0,
  excludeTerminals: [],
  excludeNodes: [],
  excludeShapes: [],
  startDirections: ["top", "right", "bottom", "left"],
  endDirections: ["top", "right", "bottom", "left"],
  directionMap: {
    top: { x: 0, y: -1 },
    right: { x: 1, y: 0 },
    bottom: { x: 0, y: 1 },
    left: { x: -1, y: 0 }
  },
  cost() {
    return Mn(this.step, this);
  },
  directions() {
    const s = Mn(this.step, this), e = Mn(this.cost, this);
    return [
      { cost: e, offsetX: s, offsetY: 0 },
      { cost: e, offsetX: -s, offsetY: 0 },
      { cost: e, offsetX: 0, offsetY: s },
      { cost: e, offsetX: 0, offsetY: -s }
    ];
  },
  penalties() {
    const s = Mn(this.step, this);
    return {
      0: 0,
      45: s / 2,
      90: s / 2
    };
  },
  paddingBox() {
    const s = Mn(this.step, this);
    return {
      x: -s,
      y: -s,
      width: 2 * s,
      height: 2 * s
    };
  },
  fallbackRouter: Pg,
  draggingRouter: null,
  snapToGrid: !0
};
function Mn(s, e) {
  return typeof s == "function" ? s.call(e) : s;
}
function gb(s) {
  const e = Object.keys(s).reduce((t, n) => {
    const i = t;
    return n === "fallbackRouter" || n === "draggingRouter" || n === "fallbackRoute" ? i[n] = s[n] : i[n] = Mn(s[n], s), t;
  }, {});
  if (e.padding) {
    const t = ms(e.padding);
    e.paddingBox = {
      x: -t.left,
      y: -t.top,
      width: t.left + t.right,
      height: t.top + t.bottom
    };
  }
  return e.directions.forEach((t) => {
    const n = new M(0, 0), i = new M(t.offsetX, t.offsetY);
    t.angle = de.normalize(n.theta(i));
  }), e;
}
const Uh = 1, qh = 2;
class pb {
  constructor() {
    this.items = [], this.hash = {}, this.values = {};
  }
  add(e, t) {
    this.hash[e] ? this.items.splice(this.items.indexOf(e), 1) : this.hash[e] = Uh, this.values[e] = t;
    const n = kp(this.items, e, (i) => this.values[i]);
    this.items.splice(n, 0, e);
  }
  pop() {
    const e = this.items.shift();
    return e && (this.hash[e] = qh), e;
  }
  isOpen(e) {
    return this.hash[e] === Uh;
  }
  isClose(e) {
    return this.hash[e] === qh;
  }
  isEmpty() {
    return this.items.length === 0;
  }
}
class mb {
  constructor(e) {
    this.options = e, this.mapGridSize = 100, this.map = {};
  }
  /**
   * Builds a map of all nodes for quicker obstacle queries i.e. is a point
   * contained in any obstacle?
   *
   * A simplified grid search.
   */
  build(e, t) {
    const n = this.options, i = n.excludeTerminals.reduce((c, u) => {
      const d = t[u];
      if (d) {
        const f = e.getCell(d.cell);
        f && c.push(f);
      }
      return c;
    }, []);
    let r = [];
    const o = e.getCell(t.getSourceCellId());
    o && (r = Oc(r, o.getAncestors().map((c) => c.id)));
    const a = e.getCell(t.getTargetCellId());
    a && (r = Oc(r, a.getAncestors().map((c) => c.id)));
    const l = this.mapGridSize;
    return e.getNodes().reduce((c, u) => {
      const d = i.some((w) => w.id === u.id), f = u.shape ? n.excludeShapes.includes(u.shape) : !1, g = n.excludeNodes.some((w) => typeof w == "string" ? u.id === w : w === u), p = r.includes(u.id), m = f || d || g || p;
      if (u.isVisible() && !m) {
        const w = u.getBBox().moveAndExpand(n.paddingBox), v = w.getOrigin().snapToGrid(l), y = w.getCorner().snapToGrid(l);
        for (let b = v.x; b <= y.x; b += l)
          for (let x = v.y; x <= y.y; x += l) {
            const C = new M(b, x).toString();
            c[C] == null && (c[C] = []), c[C].push(w);
          }
      }
      return c;
    }, this.map), this;
  }
  isAccessible(e) {
    const t = e.clone().snapToGrid(this.mapGridSize).toString(), n = this.map[t];
    return n ? n.every((i) => !i.containsPoint(e)) : !0;
  }
}
function _g(s, e) {
  const t = s.sourceBBox.clone();
  return e && e.paddingBox ? t.moveAndExpand(e.paddingBox) : t;
}
function Og(s, e) {
  const t = s.targetBBox.clone();
  return e && e.paddingBox ? t.moveAndExpand(e.paddingBox) : t;
}
function Tg(s, e) {
  return s.sourceAnchor ? s.sourceAnchor : _g(s, e).getCenter();
}
function wb(s, e) {
  return s.targetAnchor ? s.targetAnchor : Og(s, e).getCenter();
}
function Ra(s, e, t, n, i) {
  const r = 360 / t, o = s.theta(yb(s, e, n, i)), a = de.normalize(o + r / 2);
  return r * Math.floor(a / r);
}
function yb(s, e, t, n) {
  const i = n.step, r = e.x - s.x, o = e.y - s.y, a = r / t.x, l = o / t.y, c = a * i, u = l * i;
  return new M(s.x + c, s.y + u);
}
function Gh(s, e) {
  const t = Math.abs(s - e);
  return t > 180 ? 360 - t : t;
}
function bb(s, e) {
  const t = e.step;
  return e.directions.forEach((n) => {
    n.gridOffsetX = n.offsetX / t * s.x, n.gridOffsetY = n.offsetY / t * s.y;
  }), e.directions;
}
function vb(s, e, t) {
  return {
    source: e.clone(),
    x: Wh(t.x - e.x, s),
    y: Wh(t.y - e.y, s)
  };
}
function Wh(s, e) {
  if (!s)
    return e;
  const t = Math.abs(s), n = Math.round(t / e);
  if (!n)
    return t;
  const i = n * e, o = (t - i) / n;
  return e + o;
}
function xb(s, e) {
  const t = e.source, n = ue.snapToGrid(s.x - t.x, e.x) + t.x, i = ue.snapToGrid(s.y - t.y, e.y) + t.y;
  return new M(n, i);
}
function Oi(s, e) {
  return s.round(e);
}
function no(s, e, t) {
  return Oi(xb(s.clone(), e), t);
}
function zi(s) {
  return s.toString();
}
function Ba(s) {
  return new M(s.x === 0 ? 0 : Math.abs(s.x) / s.x, s.y === 0 ? 0 : Math.abs(s.y) / s.y);
}
function Jh(s, e) {
  let t = 1 / 0;
  for (let n = 0, i = e.length; n < i; n += 1) {
    const r = s.manhattanDistance(e[n]);
    r < t && (t = r);
  }
  return t;
}
function Yh(s, e, t, n, i) {
  const r = i.precision, o = i.directionMap, a = s.diff(e.getCenter()), l = Object.keys(o).reduce((c, u) => {
    if (t.includes(u)) {
      const d = o[u], f = new M(s.x + d.x * (Math.abs(a.x) + e.width), s.y + d.y * (Math.abs(a.y) + e.height)), p = new $(s, f).intersect(e) || [];
      let m, w = null;
      for (let v = 0; v < p.length; v += 1) {
        const y = p[v], b = s.squaredDistance(y);
        (m == null || b > m) && (m = b, w = y);
      }
      if (w) {
        let v = no(w, n, r);
        e.containsPoint(v) && (v = no(v.translate(d.x * n.x, d.y * n.y), n, r)), c.push(v);
      }
    }
    return c;
  }, []);
  return e.containsPoint(s) || l.push(no(s, n, r)), l;
}
function Cb(s, e, t, n, i) {
  const r = [];
  let o = Ba(i.diff(t)), a = zi(t), l = s[a], c;
  for (; l; ) {
    c = e[a];
    const f = Ba(c.diff(l));
    f.equals(o) || (r.unshift(c), o = f), a = zi(l), l = s[a];
  }
  const u = e[a];
  return Ba(u.diff(n)).equals(o) || r.unshift(u), r;
}
function Eb(s, e, t, n, i) {
  const r = i.precision;
  let o, a;
  R.isRectangle(e) ? o = Oi(Tg(s, i).clone(), r) : o = Oi(e.clone(), r), R.isRectangle(t) ? a = Oi(wb(s, i).clone(), r) : a = Oi(t.clone(), r);
  const l = vb(i.step, o, a), c = o, u = a;
  let d, f;
  if (R.isRectangle(e) ? d = Yh(c, e, i.startDirections, l, i) : d = [c], R.isRectangle(t) ? f = Yh(a, t, i.endDirections, l, i) : f = [u], d = d.filter((g) => n.isAccessible(g)), f = f.filter((g) => n.isAccessible(g)), d.length > 0 && f.length > 0) {
    const g = new pb(), p = {}, m = {}, w = {};
    for (let D = 0, N = d.length; D < N; D += 1) {
      const F = d[D], ee = zi(F);
      g.add(ee, Jh(F, f)), p[ee] = F, w[ee] = 0;
    }
    const v = i.previousDirectionAngle, y = v === void 0;
    let b, x;
    const C = bb(l, i), A = C.length, k = f.reduce((D, N) => {
      const F = zi(N);
      return D.push(F), D;
    }, []), O = M.equalPoints(d, f);
    let P = i.maxLoopCount;
    for (; !g.isEmpty() && P > 0; ) {
      const D = g.pop(), N = p[D], F = m[D], ee = w[D], X = N.equals(c), _ = F == null;
      let I;
      if (_ ? y ? X ? I = null : I = Ra(c, N, A, l, i) : I = v : I = Ra(F, N, A, l, i), !(_ && O) && k.indexOf(D) >= 0)
        return i.previousDirectionAngle = I, Cb(m, p, N, c, u);
      for (let oe = 0; oe < A; oe += 1) {
        b = C[oe];
        const re = b.angle;
        if (x = Gh(I, re), !(y && X) && x > i.maxDirectionChange)
          continue;
        const xe = no(N.clone().translate(b.gridOffsetX || 0, b.gridOffsetY || 0), l, r), ce = zi(xe);
        if (g.isClose(ce) || !n.isAccessible(xe))
          continue;
        if (k.indexOf(ce) >= 0 && !xe.equals(u)) {
          const dt = Ra(xe, u, A, l, i);
          if (Gh(re, dt) > i.maxDirectionChange)
            continue;
        }
        const bn = b.cost, bt = X ? 0 : i.penalties[x], ut = ee + bn + bt;
        (!g.isOpen(ce) || ut < w[ce]) && (p[ce] = xe, m[ce] = N, w[ce] = ut, g.add(ce, ut + Jh(xe, f)));
      }
      P -= 1;
    }
  }
  return i.fallbackRoute ? J(i.fallbackRoute, this, c, u, i) : null;
}
function Sb(s, e = 10) {
  if (s.length <= 1)
    return s;
  for (let t = 0, n = s.length; t < n - 1; t += 1) {
    const i = s[t], r = s[t + 1];
    if (i.x === r.x) {
      const o = e * Math.round(i.x / e);
      i.x !== o && (i.x = o, r.x = o);
    } else if (i.y === r.y) {
      const o = e * Math.round(i.y / e);
      i.y !== o && (i.y = o, r.y = o);
    }
  }
  return s;
}
const Ab = function(s, e, t) {
  const n = gb(e), i = _g(t, n), r = Og(t, n), o = Tg(t, n), a = new mb(n).build(t.graph.model, t.cell), l = s.map((g) => M.create(g)), c = [];
  let u = o, d, f;
  for (let g = 0, p = l.length; g <= p; g += 1) {
    let m = null;
    if (d = f || i, f = l[g], f == null) {
      f = r;
      const v = t.cell;
      if ((v.getSourceCellId() == null || v.getTargetCellId() == null) && typeof n.draggingRouter == "function") {
        const b = d === i ? o : d, x = f.getOrigin();
        m = J(n.draggingRouter, t, b, x, n);
      }
    }
    if (m == null && (m = Eb(t, d, f, a, n)), m === null)
      return console.warn("Unable to execute manhattan algorithm, use orth instead"), J(n.fallbackRouter, this, s, n, t);
    const w = m[0];
    w && w.equals(u) && m.shift(), u = m[m.length - 1] || u, c.push(...m);
  }
  return n.snapToGrid ? Sb(c, t.graph.grid.getGridSize()) : c;
}, Lg = function(s, e, t) {
  return J(Ab, this, s, Object.assign(Object.assign({}, fb), e), t);
}, Mb = {
  maxDirectionChange: 45,
  // an array of directions to find next points on the route
  // different from start/end directions
  directions() {
    const s = Mn(this.step, this), e = Mn(this.cost, this), t = Math.ceil(Math.sqrt(s * s << 1));
    return [
      { cost: e, offsetX: s, offsetY: 0 },
      { cost: t, offsetX: s, offsetY: s },
      { cost: e, offsetX: 0, offsetY: s },
      { cost: t, offsetX: -s, offsetY: s },
      { cost: e, offsetX: -s, offsetY: 0 },
      { cost: t, offsetX: -s, offsetY: -s },
      { cost: e, offsetX: 0, offsetY: -s },
      { cost: t, offsetX: s, offsetY: -s }
    ];
  },
  // a simple route used in situations when main routing method fails
  // (exceed max number of loop iterations, inaccessible)
  fallbackRoute(s, e, t) {
    const n = s.theta(e), i = [];
    let r = { x: e.x, y: s.y }, o = { x: s.x, y: e.y };
    if (n % 180 > 90) {
      const b = r;
      r = o, o = b;
    }
    const a = n % 90 < 45 ? r : o, l = new $(s, a), c = 90 * Math.ceil(n / 90), u = M.fromPolar(l.squaredLength(), de.toRad(c + 135), a), d = new $(e, u), f = l.intersectsWithLine(d), g = f || e, p = f ? g : s, m = 360 / t.directions.length, w = p.theta(e), v = de.normalize(w + m / 2), y = m * Math.floor(v / m);
    return t.previousDirectionAngle = y, g && i.push(g.round()), i.push(e), i;
  }
}, kb = function(s, e, t) {
  return J(Lg, this, s, Object.assign(Object.assign({}, Mb), e), t);
}, Pb = function(s, e, t) {
  const n = e.offset || 32, i = e.min == null ? 16 : e.min;
  let r = 0, o = e.direction;
  const a = t.sourceBBox, l = t.targetBBox, c = a.getCenter(), u = l.getCenter();
  if (typeof n == "number" && (r = n), o == null) {
    let v = l.left - a.right, y = l.top - a.bottom;
    v >= 0 && y >= 0 ? o = v >= y ? "L" : "T" : v <= 0 && y >= 0 ? (v = a.left - l.right, v >= 0 ? o = v >= y ? "R" : "T" : o = "T") : v >= 0 && y <= 0 ? (y = a.top - l.bottom, y >= 0 ? o = v >= y ? "L" : "B" : o = "L") : (v = a.left - l.right, y = a.top - l.bottom, v >= 0 && y >= 0 ? o = v >= y ? "R" : "B" : v <= 0 && y >= 0 ? o = "B" : v >= 0 && y <= 0 ? o = "R" : o = Math.abs(v) > Math.abs(y) ? "R" : "B");
  }
  o === "H" ? o = u.x - c.x >= 0 ? "L" : "R" : o === "V" && (o = u.y - c.y >= 0 ? "T" : "B"), n === "center" && (o === "L" ? r = (l.left - a.right) / 2 : o === "R" ? r = (a.left - l.right) / 2 : o === "T" ? r = (l.top - a.bottom) / 2 : o === "B" && (r = (a.top - l.bottom) / 2));
  let d, f, g;
  const p = o === "L" || o === "R";
  if (p) {
    if (u.y === c.y)
      return [...s];
    g = o === "L" ? 1 : -1, d = "x", f = "width";
  } else {
    if (u.x === c.x)
      return [...s];
    g = o === "T" ? 1 : -1, d = "y", f = "height";
  }
  const m = c.clone(), w = u.clone();
  if (m[d] += g * (a[f] / 2 + r), w[d] -= g * (l[f] / 2 + r), p) {
    const v = m.x, y = w.x, b = a.width / 2 + i, x = l.width / 2 + i;
    u.x > c.x ? y <= v && (m.x = Math.max(y, c.x + b), w.x = Math.min(v, u.x - x)) : y >= v && (m.x = Math.min(y, c.x - b), w.x = Math.max(v, u.x + x));
  } else {
    const v = m.y, y = w.y, b = a.height / 2 + i, x = l.height / 2 + i;
    u.y > c.y ? y <= v && (m.y = Math.max(y, c.y + b), w.y = Math.min(v, u.y - x)) : y >= v && (m.y = Math.min(y, c.y - b), w.y = Math.max(v, u.y + x));
  }
  return [m.toJSON(), ...s, w.toJSON()];
};
function Ls(s, e) {
  if (e != null && e !== !1) {
    const t = typeof e == "boolean" ? 0 : e;
    if (t > 0) {
      const n = M.create(s[1]).move(s[2], t), i = M.create(s[1]).move(s[0], t);
      return [n.toJSON(), ...s, i.toJSON()];
    }
    {
      const n = s[1];
      return [Object.assign({}, n), ...s, Object.assign({}, n)];
    }
  }
  return s;
}
const _b = function(s, e, t) {
  const n = e.width || 50, r = (e.height || 80) / 2, o = e.angle || "auto", a = t.sourceAnchor, l = t.targetAnchor, c = t.sourceBBox, u = t.targetBBox;
  if (a.equals(l)) {
    const d = (v) => {
      const y = de.toRad(v), b = Math.sin(y), x = Math.cos(y), C = new M(a.x + x * n, a.y + b * n), A = new M(C.x - x * r, C.y - b * r), k = A.clone().rotate(-90, C), O = A.clone().rotate(90, C);
      return [k.toJSON(), C.toJSON(), O.toJSON()];
    }, f = (v) => {
      const y = a.clone().move(v, -1), b = new $(y, v);
      return !c.containsPoint(v) && !c.intersectsWithLine(b);
    }, g = [0, 90, 180, 270, 45, 135, 225, 315];
    if (typeof o == "number")
      return Ls(d(o), e.merge);
    const p = c.getCenter();
    if (p.equals(a))
      return Ls(d(0), e.merge);
    const m = p.angleBetween(a, p.clone().translate(1, 0));
    let w = d(m);
    if (f(w[1]))
      return Ls(w, e.merge);
    for (let v = 1, y = g.length; v < y; v += 1)
      if (w = d(m + g[v]), f(w[1]))
        return Ls(w, e.merge);
    return Ls(w, e.merge);
  }
  {
    const d = new $(a, l);
    let f = d.parallel(-n), g = f.getCenter(), p = f.start.clone().move(f.end, r), m = f.end.clone().move(f.start, r);
    const w = d.parallel(-1), v = new $(w.start, g), y = new $(w.end, g);
    if ((c.containsPoint(g) || u.containsPoint(g) || c.intersectsWithLine(v) || c.intersectsWithLine(y) || u.intersectsWithLine(v) || u.intersectsWithLine(y)) && (f = d.parallel(n), g = f.getCenter(), p = f.start.clone().move(f.end, r), m = f.end.clone().move(f.start, r)), e.merge) {
      const b = new $(a, l), x = new $(g, b.center).setLength(Number.MAX_SAFE_INTEGER), C = c.intersectsWithLine(x), A = u.intersectsWithLine(x), k = C ? Array.isArray(C) ? C : [C] : [];
      A && (Array.isArray(A) ? k.push(...A) : k.push(A));
      const O = b.center.closest(k);
      O ? (t.sourceAnchor = O.clone(), t.targetAnchor = O.clone()) : (t.sourceAnchor = b.center.clone(), t.targetAnchor = b.center.clone());
    }
    return Ls([p.toJSON(), g.toJSON(), m.toJSON()], e.merge);
  }
}, Ob = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  er: Pb,
  loop: _b,
  manhattan: Lg,
  metro: kb,
  normal: cb,
  oneSide: hb,
  orth: Pg
}, Symbol.toStringTag, { value: "Module" }));
var On;
(function(s) {
  s.presets = Ob, s.registry = Le.create({
    type: "router"
  }), s.registry.register(s.presets, !0);
})(On || (On = {}));
const Tb = function(s, e, t, n = {}) {
  const i = [s, ...t, e], r = new Oe(i), o = new V(r);
  return n.raw ? o : o.serialize();
}, Lb = function(s, e, t, n = {}) {
  const i = t.length === 3 ? 0 : 1, r = M.create(t[0 + i]), o = M.create(t[2 + i]), a = M.create(t[1 + i]);
  if (!M.equals(s, e)) {
    const c = new M((s.x + e.x) / 2, (s.y + e.y) / 2), u = c.angleBetween(M.create(s).rotate(90, c), a);
    u > 1 && (r.rotate(180 - u, c), o.rotate(180 - u, c), a.rotate(180 - u, c));
  }
  const l = "\n     M ".concat(s.x, " ").concat(s.y, "\n     Q ").concat(r.x, " ").concat(r.y, " ").concat(a.x, " ").concat(a.y, "\n     Q ").concat(o.x, " ").concat(o.y, " ").concat(e.x, " ").concat(e.y, "\n  ");
  return n.raw ? V.parse(l) : l;
}, Nb = function(s, e, t, n = {}) {
  const i = new V();
  i.appendSegment(V.createSegment("M", s));
  const r = 1 / 3, o = 2 / 3, a = n.radius || 10;
  let l, c;
  for (let u = 0, d = t.length; u < d; u += 1) {
    const f = M.create(t[u]), g = t[u - 1] || s, p = t[u + 1] || e;
    l = c || f.distance(g) / 2, c = f.distance(p) / 2;
    const m = -Math.min(a, l), w = -Math.min(a, c), v = f.clone().move(g, m).round(), y = f.clone().move(p, w).round(), b = new M(r * v.x + o * f.x, o * f.y + r * v.y), x = new M(r * y.x + o * f.x, o * f.y + r * y.y);
    i.appendSegment(V.createSegment("L", v)), i.appendSegment(V.createSegment("C", b, x, y));
  }
  return i.appendSegment(V.createSegment("L", e)), n.raw ? i : i.serialize();
}, Db = function(s, e, t, n = {}) {
  let i, r = n.direction;
  if (t && t.length !== 0) {
    const o = [s, ...t, e], a = Se.throughPoints(o);
    i = new V(a);
  } else if (i = new V(), i.appendSegment(V.createSegment("M", s)), r || (r = Math.abs(s.x - e.x) >= Math.abs(s.y - e.y) ? "H" : "V"), r === "H") {
    const o = (s.x + e.x) / 2;
    i.appendSegment(V.createSegment("C", o, s.y, o, e.y, e.x, e.y));
  } else {
    const o = (s.y + e.y) / 2;
    i.appendSegment(V.createSegment("C", s.x, o, e.x, o, e.x, e.y));
  }
  return n.raw ? i : i.serialize();
}, Xh = 1, Ur = 1 / 3, qr = 2 / 3;
function Ib(s) {
  let e = s.graph._jumpOverUpdateList;
  if (e == null && (e = s.graph._jumpOverUpdateList = [], s.graph.on("cell:mouseup", () => {
    const t = s.graph._jumpOverUpdateList;
    setTimeout(() => {
      for (let n = 0; n < t.length; n += 1)
        t[n].update();
    });
  }), s.graph.on("model:reseted", () => {
    e = s.graph._jumpOverUpdateList = [];
  })), e.indexOf(s) < 0) {
    e.push(s);
    const t = () => e.splice(e.indexOf(s), 1);
    s.cell.once("change:connector", t), s.cell.once("removed", t);
  }
}
function Fa(s, e, t = []) {
  const n = [s, ...t, e], i = [];
  return n.forEach((r, o) => {
    const a = n[o + 1];
    a != null && i.push(new $(r, a));
  }), i;
}
function jb(s, e) {
  const t = [];
  return e.forEach((n) => {
    const i = s.intersectsWithLine(n);
    i && t.push(i);
  }), t;
}
function Zh(s, e) {
  return new $(s, e).squaredLength();
}
function Rb(s, e, t) {
  return e.reduce((n, i, r) => {
    if (_o.includes(i))
      return n;
    const o = n.pop() || s, a = M.create(i).move(o.start, -t);
    let l = M.create(i).move(o.start, +t);
    const c = e[r + 1];
    if (c != null) {
      const f = l.distance(c);
      f <= t && (l = c.move(o.start, f), _o.push(c));
    } else if (a.distance(o.end) < t * 2 + Xh)
      return n.push(o), n;
    if (l.distance(o.start) < t * 2 + Xh)
      return n.push(o), n;
    const d = new $(a, l);
    return hr.push(d), n.push(new $(o.start, a), d, new $(l, o.end)), n;
  }, []);
}
function Kh(s, e, t, n) {
  const i = new V();
  let r;
  return r = V.createSegment("M", s[0].start), i.appendSegment(r), s.forEach((o, a) => {
    if (hr.includes(o)) {
      let l, c, u, d;
      if (t === "arc") {
        l = -90, c = o.start.diff(o.end), (c.x < 0 || c.x === 0 && c.y < 0) && (l += 180);
        const g = o.getCenter(), p = new $(g, o.end).rotate(l, g);
        let m;
        m = new $(o.start, g), u = m.pointAt(2 / 3).rotate(l, o.start), d = p.pointAt(1 / 3).rotate(-l, p.end), r = V.createSegment("C", u, d, p.end), i.appendSegment(r), m = new $(g, o.end), u = p.pointAt(1 / 3).rotate(l, p.end), d = m.pointAt(1 / 3).rotate(-l, o.end), r = V.createSegment("C", u, d, o.end), i.appendSegment(r);
      } else if (t === "gap")
        r = V.createSegment("M", o.end), i.appendSegment(r);
      else if (t === "cubic") {
        l = o.start.theta(o.end);
        const f = e * 0.6;
        let g = e * 1.35;
        c = o.start.diff(o.end), (c.x < 0 || c.x === 0 && c.y < 0) && (g *= -1), u = new M(o.start.x + f, o.start.y + g).rotate(l, o.start), d = new M(o.end.x - f, o.end.y + g).rotate(l, o.end), r = V.createSegment("C", u, d, o.end), i.appendSegment(r);
      }
    } else {
      const l = s[a + 1];
      n === 0 || !l || hr.includes(l) ? (r = V.createSegment("L", o.end), i.appendSegment(r)) : Bb(n, i, o.end, o.start, l.end);
    }
  }), i;
}
function Bb(s, e, t, n, i) {
  const r = t.distance(n) / 2, o = t.distance(i) / 2, a = -Math.min(s, r), l = -Math.min(s, o), c = t.clone().move(n, a).round(), u = t.clone().move(i, l).round(), d = new M(Ur * c.x + qr * t.x, qr * t.y + Ur * c.y), f = new M(Ur * u.x + qr * t.x, qr * t.y + Ur * u.y);
  let g;
  g = V.createSegment("L", c), e.appendSegment(g), g = V.createSegment("C", d, f, u), e.appendSegment(g);
}
let hr, _o;
const Fb = function(s, e, t, n = {}) {
  hr = [], _o = [], Ib(this);
  const i = n.size || 5, r = n.type || "arc", o = n.radius || 0, a = n.ignoreConnectors || ["smooth"], l = this.graph, u = l.model.getEdges();
  if (u.length === 1)
    return Kh(Fa(s, e, t), i, r, o);
  const d = this.cell, f = u.indexOf(d), g = l.options.connecting.connector || {}, p = u.filter((x, C) => {
    const A = x.getConnector() || g;
    return a.includes(A.name) ? !1 : C > f ? A.name !== "jumpover" : !0;
  }), m = p.map((x) => l.findViewByCell(x)), w = Fa(s, e, t), v = m.map((x) => x == null ? [] : x === this ? w : Fa(x.sourcePoint, x.targetPoint, x.routePoints)), y = [];
  w.forEach((x) => {
    const C = p.reduce((A, k, O) => {
      if (k !== d) {
        const P = jb(x, v[O]);
        A.push(...P);
      }
      return A;
    }, []).sort((A, k) => Zh(x.start, A) - Zh(x.start, k));
    C.length > 0 ? y.push(...Rb(x, C, i)) : y.push(x);
  });
  const b = Kh(y, i, r, o);
  return hr = [], _o = [], n.raw ? b : b.serialize();
}, $b = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  jumpover: Fb,
  loop: Lb,
  normal: Tb,
  rounded: Nb,
  smooth: Db
}, Symbol.toStringTag, { value: "Module" }));
var ls;
(function(s) {
  s.presets = $b, s.registry = Le.create({
    type: "connector"
  }), s.registry.register(s.presets, !0);
})(ls || (ls = {}));
var zb = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class Ng extends yt {
  constructor(e = {}) {
    super(), this.pending = !1, this.changing = !1, this.data = {}, this.mutate(Ae(e)), this.changed = {};
  }
  mutate(e, t = {}) {
    const n = t.unset === !0, i = t.silent === !0, r = [], o = this.changing;
    this.changing = !0, o || (this.previous = Ae(this.data), this.changed = {});
    const a = this.data, l = this.previous, c = this.changed;
    if (Object.keys(e).forEach((u) => {
      const d = u, f = e[d];
      on(a[d], f) || r.push(d), on(l[d], f) ? delete c[d] : c[d] = f, n ? delete a[d] : a[d] = f;
    }), !i && r.length > 0 && (this.pending = !0, this.pendingOptions = t, r.forEach((u) => {
      this.emit("change:*", {
        key: u,
        options: t,
        store: this,
        current: a[u],
        previous: l[u]
      });
    })), o)
      return this;
    if (!i)
      for (; this.pending; )
        this.pending = !1, this.emit("changed", {
          current: a,
          previous: l,
          store: this,
          options: this.pendingOptions
        });
    return this.pending = !1, this.changing = !1, this.pendingOptions = null, this;
  }
  get(e, t) {
    if (e == null)
      return this.data;
    const n = this.data[e];
    return n == null ? t : n;
  }
  getPrevious(e) {
    if (this.previous) {
      const t = this.previous[e];
      return t == null ? void 0 : t;
    }
  }
  set(e, t, n) {
    return e != null && (typeof e == "object" ? this.mutate(e, t) : this.mutate({ [e]: t }, n)), this;
  }
  remove(e, t) {
    const i = {};
    let r;
    if (typeof e == "string")
      i[e] = void 0, r = t;
    else if (Array.isArray(e))
      e.forEach((o) => i[o] = void 0), r = t;
    else {
      for (const o in this.data)
        i[o] = void 0;
      r = e;
    }
    return this.mutate(i, Object.assign(Object.assign({}, r), { unset: !0 })), this;
  }
  getByPath(e) {
    return rc(this.data, e, "/");
  }
  setByPath(e, t, n = {}) {
    const i = "/", r = Array.isArray(e) ? [...e] : e.split(i), o = Array.isArray(e) ? e.join(i) : e, a = r[0], l = r.length;
    if (n.propertyPath = o, n.propertyValue = t, n.propertyPathArray = r, l === 1)
      this.set(a, t, n);
    else {
      const c = {};
      let u = c, d = a;
      for (let p = 1; p < l; p += 1) {
        const m = r[p], w = Number.isFinite(Number(m));
        u = u[d] = w ? [] : {}, d = m;
      }
      vi(c, r, t, i);
      const f = Ae(this.data);
      n.rewrite && Ph(f, e, i);
      const g = De(f, c);
      this.set(a, g[a], n);
    }
    return this;
  }
  removeByPath(e, t) {
    const n = Array.isArray(e) ? e : e.split("/"), i = n[0];
    if (n.length === 1)
      this.remove(i, t);
    else {
      const r = n.slice(1), o = Ae(this.get(i));
      o && Ph(o, r), this.set(i, o, t);
    }
    return this;
  }
  hasChanged(e) {
    return e == null ? Object.keys(this.changed).length > 0 : e in this.changed;
  }
  /**
   * Returns an object containing all the data that have changed,
   * or `null` if there are no changes. Useful for determining what
   * parts of a view need to be updated.
   */
  getChanges(e) {
    if (e == null)
      return this.hasChanged() ? Ae(this.changed) : null;
    const t = this.changing ? this.previous : this.data, n = {};
    let i;
    for (const r in e) {
      const o = e[r];
      on(t[r], o) || (n[r] = o, i = !0);
    }
    return i ? Ae(n) : null;
  }
  /**
   * Returns a copy of the store's `data` object.
   */
  toJSON() {
    return Ae(this.data);
  }
  clone() {
    const e = this.constructor;
    return new e(this.data);
  }
  dispose() {
    this.off(), this.data = {}, this.previous = {}, this.changed = {}, this.pending = !1, this.changing = !1, this.pendingOptions = null, this.trigger("disposed", { store: this });
  }
}
zb([
  yt.dispose()
], Ng.prototype, "dispose", null);
class ur {
  constructor(e) {
    this.cell = e, this.ids = {}, this.cache = {};
  }
  get() {
    return Object.keys(this.ids);
  }
  start(e, t, n = {}, i = "/") {
    const r = this.cell.getPropByPath(e), o = Pp(n, ur.defaultOptions), a = this.getTiming(o.timing), l = this.getInterp(o.interp, r, t);
    let c = 0;
    const u = Array.isArray(e) ? e.join(i) : e, d = Array.isArray(e) ? e : e.split(i), f = () => {
      const g = (/* @__PURE__ */ new Date()).getTime();
      c === 0 && (c = g);
      let m = (g - c) / o.duration;
      m < 1 ? this.ids[u] = requestAnimationFrame(f) : m = 1;
      const w = l(a(m));
      this.cell.setPropByPath(d, w), n.progress && n.progress(Object.assign({ progress: m, currentValue: w }, this.getArgs(u))), m === 1 && (this.cell.notify("transition:complete", this.getArgs(u)), n.complete && n.complete(this.getArgs(u)), this.cell.notify("transition:finish", this.getArgs(u)), n.finish && n.finish(this.getArgs(u)), this.clean(u));
    };
    return setTimeout(() => {
      this.stop(e, void 0, i), this.cache[u] = { startValue: r, targetValue: t, options: o }, this.ids[u] = requestAnimationFrame(f), this.cell.notify("transition:start", this.getArgs(u)), n.start && n.start(this.getArgs(u));
    }, n.delay), this.stop.bind(this, e, i, n);
  }
  stop(e, t = {}, n = "/") {
    const i = Array.isArray(e) ? e : e.split(n);
    return Object.keys(this.ids).filter((r) => on(i, r.split(n).slice(0, i.length))).forEach((r) => {
      cancelAnimationFrame(this.ids[r]);
      const o = this.cache[r], a = this.getArgs(r), l = Object.assign(Object.assign({}, o.options), t), c = l.jumpedToEnd;
      c && o.targetValue != null && (this.cell.setPropByPath(r, o.targetValue), this.cell.notify("transition:end", Object.assign({}, a)), this.cell.notify("transition:complete", Object.assign({}, a)), l.complete && l.complete(Object.assign({}, a)));
      const u = Object.assign({ jumpedToEnd: c }, a);
      this.cell.notify("transition:stop", Object.assign({}, u)), l.stop && l.stop(Object.assign({}, u)), this.cell.notify("transition:finish", Object.assign({}, a)), l.finish && l.finish(Object.assign({}, a)), this.clean(r);
    }), this;
  }
  clean(e) {
    delete this.ids[e], delete this.cache[e];
  }
  getTiming(e) {
    return typeof e == "string" ? ys[e] : e;
  }
  getInterp(e, t, n) {
    return e ? e(t, n) : typeof n == "number" ? ss.number(t, n) : typeof n == "string" ? n[0] === "#" ? ss.color(t, n) : ss.unit(t, n) : ss.object(t, n);
  }
  getArgs(e) {
    const t = this.cache[e];
    return {
      path: e,
      startValue: t.startValue,
      targetValue: t.targetValue,
      cell: this.cell
    };
  }
}
(function(s) {
  s.defaultOptions = {
    delay: 10,
    duration: 100,
    timing: "linear"
  };
})(ur || (ur = {}));
var Vb = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
}, Dg = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
class se extends yt {
  static config(e) {
    const { markup: t, propHooks: n, attrHooks: i } = e, r = Dg(e, ["markup", "propHooks", "attrHooks"]);
    t != null && (this.markup = t), n && (this.propHooks = this.propHooks.slice(), Array.isArray(n) ? this.propHooks.push(...n) : typeof n == "function" ? this.propHooks.push(n) : Object.values(n).forEach((o) => {
      typeof o == "function" && this.propHooks.push(o);
    })), i && (this.attrHooks = Object.assign(Object.assign({}, this.attrHooks), i)), this.defaults = De({}, this.defaults, r);
  }
  static getMarkup() {
    return this.markup;
  }
  static getDefaults(e) {
    return e ? this.defaults : Ae(this.defaults);
  }
  static getAttrHooks() {
    return this.attrHooks;
  }
  static applyPropHooks(e, t) {
    return this.propHooks.reduce((n, i) => i ? J(i, e, n) : n, t);
  }
  // #endregion
  get [Symbol.toStringTag]() {
    return se.toStringTag;
  }
  constructor(e = {}) {
    super();
    const n = this.constructor.getDefaults(!0), i = De({}, this.preprocess(n), this.preprocess(e));
    this.id = i.id || yo(), this.store = new Ng(i), this.animation = new ur(this), this.setup(), this.init(), this.postprocess(e);
  }
  init() {
  }
  // #region model
  get model() {
    return this._model;
  }
  set model(e) {
    this._model !== e && (this._model = e);
  }
  // #endregion
  preprocess(e, t) {
    const n = e.id, r = this.constructor.applyPropHooks(this, e);
    return n == null && t !== !0 && (r.id = yo()), r;
  }
  postprocess(e) {
  }
  // eslint-disable-line
  setup() {
    this.store.on("change:*", (e) => {
      const { key: t, current: n, previous: i, options: r } = e;
      this.notify("change:*", {
        key: t,
        options: r,
        current: n,
        previous: i,
        cell: this
      }), this.notify("change:".concat(t), {
        options: r,
        current: n,
        previous: i,
        cell: this
      });
      const o = t;
      (o === "source" || o === "target") && this.notify("change:terminal", {
        type: o,
        current: n,
        previous: i,
        options: r,
        cell: this
      });
    }), this.store.on("changed", ({ options: e }) => this.notify("changed", { options: e, cell: this }));
  }
  notify(e, t) {
    this.trigger(e, t);
    const n = this.model;
    return n && (n.notify("cell:".concat(e), t), this.isNode() ? n.notify("node:".concat(e), Object.assign(Object.assign({}, t), { node: this })) : this.isEdge() && n.notify("edge:".concat(e), Object.assign(Object.assign({}, t), { edge: this }))), this;
  }
  isNode() {
    return !1;
  }
  isEdge() {
    return !1;
  }
  isSameStore(e) {
    return this.store === e.store;
  }
  get view() {
    return this.store.get("view");
  }
  get shape() {
    return this.store.get("shape", "");
  }
  getProp(e, t) {
    return e == null ? this.store.get() : this.store.get(e, t);
  }
  setProp(e, t, n) {
    if (typeof e == "string")
      this.store.set(e, t, n);
    else {
      const i = this.preprocess(e, !0);
      this.store.set(De({}, this.getProp(), i), t), this.postprocess(e);
    }
    return this;
  }
  removeProp(e, t) {
    return typeof e == "string" || Array.isArray(e) ? this.store.removeByPath(e, t) : this.store.remove(t), this;
  }
  hasChanged(e) {
    return e == null ? this.store.hasChanged() : this.store.hasChanged(e);
  }
  getPropByPath(e) {
    return this.store.getByPath(e);
  }
  setPropByPath(e, t, n = {}) {
    return this.model && (e === "children" ? this._children = t ? t.map((i) => this.model.getCell(i)).filter((i) => i != null) : null : e === "parent" && (this._parent = t ? this.model.getCell(t) : null)), this.store.setByPath(e, t, n), this;
  }
  removePropByPath(e, t = {}) {
    const n = Array.isArray(e) ? e : e.split("/");
    return n[0] === "attrs" && (t.dirty = !0), this.store.removeByPath(n, t), this;
  }
  prop(e, t, n) {
    return e == null ? this.getProp() : typeof e == "string" || Array.isArray(e) ? arguments.length === 1 ? this.getPropByPath(e) : t == null ? this.removePropByPath(e, n || {}) : this.setPropByPath(e, t, n || {}) : this.setProp(e, t || {});
  }
  previous(e) {
    return this.store.getPrevious(e);
  }
  // #endregion
  // #region zIndex
  get zIndex() {
    return this.getZIndex();
  }
  set zIndex(e) {
    e == null ? this.removeZIndex() : this.setZIndex(e);
  }
  getZIndex() {
    return this.store.get("zIndex");
  }
  setZIndex(e, t = {}) {
    return this.store.set("zIndex", e, t), this;
  }
  removeZIndex(e = {}) {
    return this.store.remove("zIndex", e), this;
  }
  toFront(e = {}) {
    const t = this.model;
    if (t) {
      let n = t.getMaxZIndex(), i;
      e.deep ? (i = this.getDescendants({ deep: !0, breadthFirst: !0 }), i.unshift(this)) : i = [this], n = n - i.length + 1;
      const r = t.total();
      let o = t.indexOf(this) !== r - i.length;
      o || (o = i.some((a, l) => a.getZIndex() !== n + l)), o && this.batchUpdate("to-front", () => {
        n += i.length, i.forEach((a, l) => {
          a.setZIndex(n + l, e);
        });
      });
    }
    return this;
  }
  toBack(e = {}) {
    const t = this.model;
    if (t) {
      let n = t.getMinZIndex(), i;
      e.deep ? (i = this.getDescendants({ deep: !0, breadthFirst: !0 }), i.unshift(this)) : i = [this];
      let r = t.indexOf(this) !== 0;
      r || (r = i.some((o, a) => o.getZIndex() !== n + a)), r && this.batchUpdate("to-back", () => {
        n -= i.length, i.forEach((o, a) => {
          o.setZIndex(n + a, e);
        });
      });
    }
    return this;
  }
  // #endregion
  // #region markup
  get markup() {
    return this.getMarkup();
  }
  set markup(e) {
    e == null ? this.removeMarkup() : this.setMarkup(e);
  }
  getMarkup() {
    let e = this.store.get("markup");
    return e == null && (e = this.constructor.getMarkup()), e;
  }
  setMarkup(e, t = {}) {
    return this.store.set("markup", e, t), this;
  }
  removeMarkup(e = {}) {
    return this.store.remove("markup", e), this;
  }
  // #endregion
  // #region attrs
  get attrs() {
    return this.getAttrs();
  }
  set attrs(e) {
    e == null ? this.removeAttrs() : this.setAttrs(e);
  }
  getAttrs() {
    const e = this.store.get("attrs");
    return e ? Object.assign({}, e) : {};
  }
  setAttrs(e, t = {}) {
    if (e == null)
      this.removeAttrs(t);
    else {
      const n = (i) => this.store.set("attrs", i, t);
      if (t.overwrite === !0)
        n(e);
      else {
        const i = this.getAttrs();
        t.deep === !1 ? n(Object.assign(Object.assign({}, i), e)) : n(De({}, i, e));
      }
    }
    return this;
  }
  replaceAttrs(e, t = {}) {
    return this.setAttrs(e, Object.assign(Object.assign({}, t), { overwrite: !0 }));
  }
  updateAttrs(e, t = {}) {
    return this.setAttrs(e, Object.assign(Object.assign({}, t), { deep: !1 }));
  }
  removeAttrs(e = {}) {
    return this.store.remove("attrs", e), this;
  }
  getAttrDefinition(e) {
    if (!e)
      return null;
    const n = this.constructor.getAttrHooks() || {};
    let i = n[e] || Xt.registry.get(e);
    if (!i) {
      const r = No(e);
      i = n[r] || Xt.registry.get(r);
    }
    return i || null;
  }
  getAttrByPath(e) {
    return e == null || e === "" ? this.getAttrs() : this.getPropByPath(this.prefixAttrPath(e));
  }
  setAttrByPath(e, t, n = {}) {
    return this.setPropByPath(this.prefixAttrPath(e), t, n), this;
  }
  removeAttrByPath(e, t = {}) {
    return this.removePropByPath(this.prefixAttrPath(e), t), this;
  }
  prefixAttrPath(e) {
    return Array.isArray(e) ? ["attrs"].concat(e) : "attrs/".concat(e);
  }
  attr(e, t, n) {
    return e == null ? this.getAttrByPath() : typeof e == "string" || Array.isArray(e) ? arguments.length === 1 ? this.getAttrByPath(e) : t == null ? this.removeAttrByPath(e, n || {}) : this.setAttrByPath(e, t, n || {}) : this.setAttrs(e, t || {});
  }
  // #endregion
  // #region visible
  get visible() {
    return this.isVisible();
  }
  set visible(e) {
    this.setVisible(e);
  }
  setVisible(e, t = {}) {
    return this.store.set("visible", e, t), this;
  }
  isVisible() {
    return this.store.get("visible") !== !1;
  }
  show(e = {}) {
    return this.isVisible() || this.setVisible(!0, e), this;
  }
  hide(e = {}) {
    return this.isVisible() && this.setVisible(!1, e), this;
  }
  toggleVisible(e, t = {}) {
    const n = typeof e == "boolean" ? e : !this.isVisible(), i = typeof e == "boolean" ? t : e;
    return n ? this.show(i) : this.hide(i), this;
  }
  // #endregion
  // #region data
  get data() {
    return this.getData();
  }
  set data(e) {
    this.setData(e);
  }
  getData() {
    return this.store.get("data");
  }
  setData(e, t = {}) {
    if (e == null)
      this.removeData(t);
    else {
      const n = (i) => this.store.set("data", i, t);
      if (t.overwrite === !0)
        n(e);
      else {
        const i = this.getData();
        t.deep === !1 ? n(typeof e == "object" ? Object.assign(Object.assign({}, i), e) : e) : n(De({}, i, e));
      }
    }
    return this;
  }
  replaceData(e, t = {}) {
    return this.setData(e, Object.assign(Object.assign({}, t), { overwrite: !0 }));
  }
  updateData(e, t = {}) {
    return this.setData(e, Object.assign(Object.assign({}, t), { deep: !1 }));
  }
  removeData(e = {}) {
    return this.store.remove("data", e), this;
  }
  // #endregion
  // #region parent children
  get parent() {
    return this.getParent();
  }
  get children() {
    return this.getChildren();
  }
  getParentId() {
    return this.store.get("parent");
  }
  getParent() {
    const e = this.getParentId();
    if (e && this.model) {
      const t = this.model.getCell(e);
      return this._parent = t, t;
    }
    return null;
  }
  getChildren() {
    const e = this.store.get("children");
    if (e && e.length && this.model) {
      const t = e.map((n) => {
        var i;
        return (i = this.model) === null || i === void 0 ? void 0 : i.getCell(n);
      }).filter((n) => n != null);
      return this._children = t, [...t];
    }
    return null;
  }
  hasParent() {
    return this.parent != null;
  }
  isParentOf(e) {
    return e != null && e.getParent() === this;
  }
  isChildOf(e) {
    return e != null && this.getParent() === e;
  }
  eachChild(e, t) {
    return this.children && this.children.forEach(e, t), this;
  }
  filterChild(e, t) {
    return this.children ? this.children.filter(e, t) : [];
  }
  getChildCount() {
    return this.children == null ? 0 : this.children.length;
  }
  getChildIndex(e) {
    return this.children == null ? -1 : this.children.indexOf(e);
  }
  getChildAt(e) {
    return this.children != null && e >= 0 ? this.children[e] : null;
  }
  getAncestors(e = {}) {
    const t = [];
    let n = this.getParent();
    for (; n; )
      t.push(n), n = e.deep !== !1 ? n.getParent() : null;
    return t;
  }
  getDescendants(e = {}) {
    if (e.deep !== !1) {
      if (e.breadthFirst) {
        const t = [], n = this.getChildren() || [];
        for (; n.length > 0; ) {
          const i = n.shift(), r = i.getChildren();
          t.push(i), r && n.push(...r);
        }
        return t;
      }
      {
        const t = this.getChildren() || [];
        return t.forEach((n) => {
          t.push(...n.getDescendants(e));
        }), t;
      }
    }
    return this.getChildren() || [];
  }
  isDescendantOf(e, t = {}) {
    if (e == null)
      return !1;
    if (t.deep !== !1) {
      let n = this.getParent();
      for (; n; ) {
        if (n === e)
          return !0;
        n = n.getParent();
      }
      return !1;
    }
    return this.isChildOf(e);
  }
  isAncestorOf(e, t = {}) {
    return e == null ? !1 : e.isDescendantOf(this, t);
  }
  contains(e) {
    return this.isAncestorOf(e);
  }
  getCommonAncestor(...e) {
    return se.getCommonAncestor(this, ...e);
  }
  setParent(e, t = {}) {
    return this._parent = e, e ? this.store.set("parent", e.id, t) : this.store.remove("parent", t), this;
  }
  setChildren(e, t = {}) {
    return this._children = e, e != null ? this.store.set("children", e.map((n) => n.id), t) : this.store.remove("children", t), this;
  }
  unembed(e, t = {}) {
    const n = this.children;
    if (n != null && e != null) {
      const i = this.getChildIndex(e);
      i !== -1 && (n.splice(i, 1), e.setParent(null, t), this.setChildren(n, t));
    }
    return this;
  }
  embed(e, t = {}) {
    return e.addTo(this, t), this;
  }
  addTo(e, t = {}) {
    return se.isCell(e) ? e.addChild(this, t) : e.addCell(this, t), this;
  }
  insertTo(e, t, n = {}) {
    return e.insertChild(this, t, n), this;
  }
  addChild(e, t = {}) {
    return this.insertChild(e, void 0, t);
  }
  insertChild(e, t, n = {}) {
    if (e != null && e !== this) {
      const i = e.getParent(), r = this !== i;
      let o = t;
      if (o == null && (o = this.getChildCount(), r || (o -= 1)), i) {
        const l = i.getChildren();
        if (l) {
          const c = l.indexOf(e);
          c >= 0 && (e.setParent(null, n), l.splice(c, 1), i.setChildren(l, n));
        }
      }
      let a = this.children;
      if (a == null ? (a = [], a.push(e)) : a.splice(o, 0, e), e.setParent(this, n), this.setChildren(a, n), r && this.model) {
        const l = this.model.getIncomingEdges(this), c = this.model.getOutgoingEdges(this);
        l && l.forEach((u) => u.updateParent(n)), c && c.forEach((u) => u.updateParent(n));
      }
      this.model && this.model.addCell(e, n);
    }
    return this;
  }
  removeFromParent(e = {}) {
    const t = this.getParent();
    if (t != null) {
      const n = t.getChildIndex(this);
      t.removeChildAt(n, e);
    }
    return this;
  }
  removeChild(e, t = {}) {
    const n = this.getChildIndex(e);
    return this.removeChildAt(n, t);
  }
  removeChildAt(e, t = {}) {
    const n = this.getChildAt(e);
    return this.children != null && n != null && (this.unembed(n, t), n.remove(t)), n;
  }
  remove(e = {}) {
    return this.batchUpdate("remove", () => {
      const t = this.getParent();
      t && t.removeChild(this, e), e.deep !== !1 && this.eachChild((n) => n.remove(e)), this.model && this.model.removeCell(this, e);
    }), this;
  }
  transition(e, t, n = {}, i = "/") {
    return this.animation.start(e, t, n, i);
  }
  stopTransition(e, t, n = "/") {
    return this.animation.stop(e, t, n), this;
  }
  getTransitions() {
    return this.animation.get();
  }
  // #endregion
  // #region transform
  // eslint-disable-next-line
  translate(e, t, n) {
    return this;
  }
  scale(e, t, n, i) {
    return this;
  }
  addTools(e, t, n) {
    const i = Array.isArray(e) ? e : [e], r = typeof t == "string" ? t : null, o = typeof t == "object" ? t : typeof n == "object" ? n : {};
    if (o.reset)
      return this.setTools({ name: r, items: i, local: o.local }, o);
    let a = Ae(this.getTools());
    if (a == null || r == null || a.name === r)
      return a == null && (a = {}), a.items || (a.items = []), a.name = r, a.items = [...a.items, ...i], this.setTools(Object.assign({}, a), o);
  }
  setTools(e, t = {}) {
    return e == null ? this.removeTools() : this.store.set("tools", se.normalizeTools(e), t), this;
  }
  getTools() {
    return this.store.get("tools");
  }
  removeTools(e = {}) {
    return this.store.remove("tools", e), this;
  }
  hasTools(e) {
    const t = this.getTools();
    return t == null ? !1 : e == null ? !0 : t.name === e;
  }
  hasTool(e) {
    const t = this.getTools();
    return t == null ? !1 : t.items.some((n) => typeof n == "string" ? n === e : n.name === e);
  }
  removeTool(e, t = {}) {
    const n = Ae(this.getTools());
    if (n) {
      let i = !1;
      const r = n.items.slice(), o = (a) => {
        r.splice(a, 1), i = !0;
      };
      if (typeof e == "number")
        o(e);
      else
        for (let a = r.length - 1; a >= 0; a -= 1) {
          const l = r[a];
          (typeof l == "string" ? l === e : l.name === e) && o(a);
        }
      i && (n.items = r, this.setTools(n, t));
    }
    return this;
  }
  // #endregion
  // #region common
  // eslint-disable-next-line
  getBBox(e) {
    return new R();
  }
  // eslint-disable-next-line
  getConnectionPoint(e, t) {
    return new M();
  }
  toJSON(e = {}) {
    const t = Object.assign({}, this.store.get()), n = Object.prototype.toString, i = this.isNode() ? "node" : this.isEdge() ? "edge" : "cell";
    if (!t.shape) {
      const p = this.constructor;
      throw new Error("Unable to serialize ".concat(i, ' missing "shape" prop, check the ').concat(i, ' "').concat(p.name || n.call(p), '"'));
    }
    const r = this.constructor, o = e.diff === !0, a = t.attrs || {}, l = r.getDefaults(!0), c = o ? this.preprocess(l, !0) : l, u = c.attrs || {}, d = {};
    Object.entries(t).forEach(([p, m]) => {
      if (m != null && !Array.isArray(m) && typeof m == "object" && !gn(m))
        throw new Error("Can only serialize ".concat(i, ' with plain-object props, but got a "').concat(n.call(m), '" type of key "').concat(p, '" on ').concat(i, ' "').concat(this.id, '"'));
      if (p !== "attrs" && p !== "shape" && o) {
        const w = c[p];
        on(m, w) && delete t[p];
      }
    }), Object.keys(a).forEach((p) => {
      const m = a[p], w = u[p];
      Object.keys(m).forEach((v) => {
        const y = m[v], b = w ? w[v] : null;
        y != null && typeof y == "object" && !Array.isArray(y) ? Object.keys(y).forEach((x) => {
          const C = y[x];
          if (w == null || b == null || !Pi(b) || !on(b[x], C)) {
            d[p] == null && (d[p] = {}), d[p][v] == null && (d[p][v] = {});
            const A = d[p][v];
            A[x] = C;
          }
        }) : (w == null || !on(b, y)) && (d[p] == null && (d[p] = {}), d[p][v] = y);
      });
    });
    const f = Object.assign(Object.assign({}, t), { attrs: yu(d) ? void 0 : d });
    f.attrs == null && delete f.attrs;
    const g = f;
    return g.angle === 0 && delete g.angle, Ae(g);
  }
  clone(e = {}) {
    if (!e.deep) {
      const n = Object.assign({}, this.store.get());
      e.keepId || delete n.id, delete n.parent, delete n.children;
      const i = this.constructor;
      return new i(n);
    }
    return se.deepClone(this)[this.id];
  }
  findView(e) {
    return e.findViewByCell(this);
  }
  // #endregion
  // #region batch
  startBatch(e, t = {}, n = this.model) {
    return this.notify("batch:start", { name: e, data: t, cell: this }), n && n.startBatch(e, Object.assign(Object.assign({}, t), { cell: this })), this;
  }
  stopBatch(e, t = {}, n = this.model) {
    return n && n.stopBatch(e, Object.assign(Object.assign({}, t), { cell: this })), this.notify("batch:stop", { name: e, data: t, cell: this }), this;
  }
  batchUpdate(e, t, n) {
    const i = this.model;
    this.startBatch(e, n, i);
    const r = t();
    return this.stopBatch(e, n, i), r;
  }
  // #endregion
  // #region IDisposable
  dispose() {
    this.removeFromParent(), this.store.dispose();
  }
}
se.defaults = {};
se.attrHooks = {};
se.propHooks = [];
Vb([
  yt.dispose()
], se.prototype, "dispose", null);
(function(s) {
  function e(t) {
    return typeof t == "string" ? { items: [t] } : Array.isArray(t) ? { items: t } : t.items ? t : {
      items: [t]
    };
  }
  s.normalizeTools = e;
})(se || (se = {}));
(function(s) {
  s.toStringTag = "X6.".concat(s.name);
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof s)
      return !0;
    const n = t[Symbol.toStringTag], i = t;
    return (n == null || n === s.toStringTag) && typeof i.isNode == "function" && typeof i.isEdge == "function" && typeof i.prop == "function" && typeof i.attr == "function";
  }
  s.isCell = e;
})(se || (se = {}));
(function(s) {
  function e(...r) {
    const o = r.filter((l) => l != null).map((l) => l.getAncestors()).sort((l, c) => l.length - c.length);
    return o.shift().find((l) => o.every((c) => c.includes(l))) || null;
  }
  s.getCommonAncestor = e;
  function t(r, o = {}) {
    let a = null;
    for (let l = 0, c = r.length; l < c; l += 1) {
      const u = r[l];
      let d = u.getBBox(o);
      if (d) {
        if (u.isNode()) {
          const f = u.getAngle();
          f != null && f !== 0 && (d = d.bbox(f));
        }
        a = a == null ? d : a.union(d);
      }
    }
    return a;
  }
  s.getCellsBBox = t;
  function n(r) {
    const o = [r, ...r.getDescendants({ deep: !0 })];
    return s.cloneCells(o);
  }
  s.deepClone = n;
  function i(r) {
    const o = wu(r), a = o.reduce((l, c) => (l[c.id] = c.clone(), l), {});
    return o.forEach((l) => {
      const c = a[l.id];
      if (c.isEdge()) {
        const f = c.getSourceCellId(), g = c.getTargetCellId();
        f && a[f] && c.setSource(Object.assign(Object.assign({}, c.getSource()), { cell: a[f].id })), g && a[g] && c.setTarget(Object.assign(Object.assign({}, c.getTarget()), { cell: a[g].id }));
      }
      const u = l.getParent();
      u && a[u.id] && c.setParent(a[u.id]);
      const d = l.getChildren();
      if (d && d.length) {
        const f = d.reduce((g, p) => (a[p.id] && g.push(a[p.id]), g), []);
        f.length > 0 && c.setChildren(f);
      }
    }), a;
  }
  s.cloneCells = i;
})(se || (se = {}));
(function(s) {
  s.config({
    propHooks(e) {
      var { tools: t } = e, n = Dg(e, ["tools"]);
      return t && (n.tools = s.normalizeTools(t)), n;
    }
  });
})(se || (se = {}));
var di;
(function(s) {
  let e, t;
  function n(o, a) {
    return a ? e != null && e.exist(o) : t != null && t.exist(o);
  }
  s.exist = n;
  function i(o) {
    e = o;
  }
  s.setEdgeRegistry = i;
  function r(o) {
    t = o;
  }
  s.setNodeRegistry = r;
})(di || (di = {}));
class Hb {
  constructor(e) {
    this.ports = [], this.groups = {}, this.init(Ae(e));
  }
  getPorts() {
    return this.ports;
  }
  getGroup(e) {
    return e != null ? this.groups[e] : null;
  }
  getPortsByGroup(e) {
    return this.ports.filter((t) => t.group === e || t.group == null && e == null);
  }
  getPortsLayoutByGroup(e, t) {
    const n = this.getPortsByGroup(e), i = e ? this.getGroup(e) : null, r = i ? i.position : null, o = r ? r.name : null;
    let a;
    if (o != null) {
      const d = as.registry.get(o);
      if (d == null)
        return as.registry.onNotFound(o);
      a = d;
    } else
      a = as.presets.left;
    const l = n.map((d) => d && d.position && d.position.args || {}), c = r && r.args || {};
    return a(l, t, c).map((d, f) => {
      const g = n[f];
      return {
        portLayout: d,
        portId: g.id,
        portSize: g.size,
        portAttrs: g.attrs,
        labelSize: g.label.size,
        labelLayout: this.getPortLabelLayout(g, M.create(d.position), t)
      };
    });
  }
  init(e) {
    const { groups: t, items: n } = e;
    t != null && Object.keys(t).forEach((i) => {
      this.groups[i] = this.parseGroup(t[i]);
    }), Array.isArray(n) && n.forEach((i) => {
      this.ports.push(this.parsePort(i));
    });
  }
  parseGroup(e) {
    return Object.assign(Object.assign({}, e), { label: this.getLabel(e, !0), position: this.getPortPosition(e.position, !0) });
  }
  parsePort(e) {
    const t = Object.assign({}, e), n = this.getGroup(e.group) || {};
    return t.markup = t.markup || n.markup, t.attrs = De({}, n.attrs, t.attrs), t.position = this.createPosition(n, t), t.label = De({}, n.label, this.getLabel(t)), t.zIndex = this.getZIndex(n, t), t.size = Object.assign(Object.assign({}, n.size), t.size), t;
  }
  getZIndex(e, t) {
    return typeof t.zIndex == "number" ? t.zIndex : typeof e.zIndex == "number" || e.zIndex === "auto" ? e.zIndex : "auto";
  }
  createPosition(e, t) {
    return De({
      name: "left",
      args: {}
    }, e.position, { args: t.args });
  }
  getPortPosition(e, t = !1) {
    if (e == null) {
      if (t)
        return { name: "left", args: {} };
    } else {
      if (typeof e == "string")
        return {
          name: e,
          args: {}
        };
      if (Array.isArray(e))
        return {
          name: "absolute",
          args: { x: e[0], y: e[1] }
        };
      if (typeof e == "object")
        return e;
    }
    return { args: {} };
  }
  getPortLabelPosition(e, t = !1) {
    if (e == null) {
      if (t)
        return { name: "left", args: {} };
    } else {
      if (typeof e == "string")
        return {
          name: e,
          args: {}
        };
      if (typeof e == "object")
        return e;
    }
    return { args: {} };
  }
  getLabel(e, t = !1) {
    const n = e.label || {};
    return n.position = this.getPortLabelPosition(n.position, t), n;
  }
  getPortLabelLayout(e, t, n) {
    const i = e.label.position.name || "left", r = e.label.position.args || {}, o = ri.registry.get(i) || ri.presets.left;
    return o ? o(t, n, r) : null;
  }
}
var ta = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
let $e = class Ig extends se {
  get [Symbol.toStringTag]() {
    return Ig.toStringTag;
  }
  constructor(e = {}) {
    super(e), this.initPorts();
  }
  preprocess(e, t) {
    const { x: n, y: i, width: r, height: o } = e, a = ta(e, ["x", "y", "width", "height"]);
    if (n != null || i != null) {
      const l = a.position;
      a.position = Object.assign(Object.assign({}, l), { x: n != null ? n : l ? l.x : 0, y: i != null ? i : l ? l.y : 0 });
    }
    if (r != null || o != null) {
      const l = a.size;
      a.size = Object.assign(Object.assign({}, l), { width: r != null ? r : l ? l.width : 0, height: o != null ? o : l ? l.height : 0 });
    }
    return super.preprocess(a, t);
  }
  isNode() {
    return !0;
  }
  size(e, t, n) {
    return e === void 0 ? this.getSize() : typeof e == "number" ? this.setSize(e, t, n) : this.setSize(e, t);
  }
  getSize() {
    const e = this.store.get("size");
    return e ? Object.assign({}, e) : { width: 1, height: 1 };
  }
  setSize(e, t, n) {
    return typeof e == "object" ? this.resize(e.width, e.height, t) : this.resize(e, t, n), this;
  }
  resize(e, t, n = {}) {
    this.startBatch("resize", n);
    const i = n.direction;
    if (i) {
      const r = this.getSize();
      switch (i) {
        case "left":
        case "right":
          t = r.height;
          break;
        case "top":
        case "bottom":
          e = r.width;
          break;
      }
      let a = {
        right: 0,
        "top-right": 0,
        top: 1,
        "top-left": 1,
        left: 2,
        "bottom-left": 2,
        bottom: 3,
        "bottom-right": 3
      }[i];
      const l = de.normalize(this.getAngle() || 0);
      n.absolute && (a += Math.floor((l + 45) / 90), a %= 4);
      const c = this.getBBox();
      let u;
      a === 0 ? u = c.getBottomLeft() : a === 1 ? u = c.getCorner() : a === 2 ? u = c.getTopRight() : u = c.getOrigin();
      const d = u.clone().rotate(-l, c.getCenter()), f = Math.sqrt(e * e + t * t) / 2;
      let g = a * Math.PI / 2;
      g += Math.atan(a % 2 === 0 ? t / e : e / t), g -= de.toRad(l);
      const m = M.fromPolar(f, g, d).clone().translate(e / -2, t / -2);
      this.store.set("size", { width: e, height: t }, n), this.setPosition(m.x, m.y, n);
    } else
      this.store.set("size", { width: e, height: t }, n);
    return this.stopBatch("resize", n), this;
  }
  scale(e, t, n, i = {}) {
    const r = this.getBBox().scale(e, t, n == null ? void 0 : n);
    return this.startBatch("scale", i), this.setPosition(r.x, r.y, i), this.resize(r.width, r.height, i), this.stopBatch("scale"), this;
  }
  position(e, t, n) {
    return typeof e == "number" ? this.setPosition(e, t, n) : this.getPosition(e);
  }
  getPosition(e = {}) {
    if (e.relative) {
      const n = this.getParent();
      if (n != null && n.isNode()) {
        const i = this.getPosition(), r = n.getPosition();
        return {
          x: i.x - r.x,
          y: i.y - r.y
        };
      }
    }
    const t = this.store.get("position");
    return t ? Object.assign({}, t) : { x: 0, y: 0 };
  }
  setPosition(e, t, n = {}) {
    let i, r, o;
    if (typeof e == "object" ? (i = e.x, r = e.y, o = t || {}) : (i = e, r = t, o = n || {}), o.relative) {
      const a = this.getParent();
      if (a != null && a.isNode()) {
        const l = a.getPosition();
        i += l.x, r += l.y;
      }
    }
    if (o.deep) {
      const a = this.getPosition();
      this.translate(i - a.x, r - a.y, o);
    } else
      this.store.set("position", { x: i, y: r }, o);
    return this;
  }
  translate(e = 0, t = 0, n = {}) {
    if (e === 0 && t === 0)
      return this;
    n.translateBy = n.translateBy || this.id;
    const i = this.getPosition();
    if (n.restrict != null && n.translateBy === this.id) {
      const o = this.getBBox({ deep: !0 }), a = n.restrict, l = i.x - o.x, c = i.y - o.y, u = Math.max(a.x + l, Math.min(a.x + a.width + l - o.width, i.x + e)), d = Math.max(a.y + c, Math.min(a.y + a.height + c - o.height, i.y + t));
      e = u - i.x, t = d - i.y;
    }
    const r = {
      x: i.x + e,
      y: i.y + t
    };
    return n.tx = e, n.ty = t, n.transition ? (typeof n.transition != "object" && (n.transition = {}), this.transition("position", r, Object.assign(Object.assign({}, n.transition), { interp: ss.object })), this.eachChild((o) => {
      var a;
      ((a = n.exclude) === null || a === void 0 ? void 0 : a.includes(o)) || o.translate(e, t, n);
    })) : (this.startBatch("translate", n), this.store.set("position", r, n), this.eachChild((o) => {
      var a;
      ((a = n.exclude) === null || a === void 0 ? void 0 : a.includes(o)) || o.translate(e, t, n);
    }), this.stopBatch("translate", n)), this;
  }
  angle(e, t) {
    return e == null ? this.getAngle() : this.rotate(e, t);
  }
  getAngle() {
    return this.store.get("angle", 0);
  }
  rotate(e, t = {}) {
    const n = this.getAngle();
    if (t.center) {
      const i = this.getSize(), r = this.getPosition(), o = this.getBBox().getCenter();
      o.rotate(n - e, t.center);
      const a = o.x - i.width / 2 - r.x, l = o.y - i.height / 2 - r.y;
      this.startBatch("rotate", { angle: e, options: t }), this.setPosition(r.x + a, r.y + l, t), this.rotate(e, Object.assign(Object.assign({}, t), { center: null })), this.stopBatch("rotate");
    } else
      this.store.set("angle", t.absolute ? e : (n + e) % 360, t);
    return this;
  }
  // #endregion
  // #region common
  getBBox(e = {}) {
    if (e.deep) {
      const t = this.getDescendants({ deep: !0, breadthFirst: !0 });
      return t.push(this), se.getCellsBBox(t);
    }
    return R.fromPositionAndSize(this.getPosition(), this.getSize());
  }
  getConnectionPoint(e, t) {
    const n = this.getBBox(), i = n.getCenter(), r = e.getTerminal(t);
    if (r == null)
      return i;
    const o = r.port;
    if (!o || !this.hasPort(o))
      return i;
    const a = this.getPort(o);
    if (!a || !a.group)
      return i;
    const c = this.getPortsPosition(a.group)[o].position, u = M.create(c).translate(n.getOrigin()), d = this.getAngle();
    return d && u.rotate(-d, i), u;
  }
  /**
   * Sets cell's size and position based on the children bbox and given padding.
   */
  fit(e = {}) {
    const n = (this.getChildren() || []).filter((c) => c.isNode());
    if (n.length === 0)
      return this;
    this.startBatch("fit-embeds", e), e.deep && n.forEach((c) => c.fit(e));
    let { x: i, y: r, width: o, height: a } = se.getCellsBBox(n);
    const l = ms(e.padding);
    return i -= l.left, r -= l.top, o += l.left + l.right, a += l.bottom + l.top, this.store.set({
      position: { x: i, y: r },
      size: { width: o, height: a }
    }, e), this.stopBatch("fit-embeds"), this;
  }
  // #endregion
  // #region ports
  get portContainerMarkup() {
    return this.getPortContainerMarkup();
  }
  set portContainerMarkup(e) {
    this.setPortContainerMarkup(e);
  }
  getDefaultPortContainerMarkup() {
    return this.store.get("defaultPortContainerMarkup") || be.getPortContainerMarkup();
  }
  getPortContainerMarkup() {
    return this.store.get("portContainerMarkup") || this.getDefaultPortContainerMarkup();
  }
  setPortContainerMarkup(e, t = {}) {
    return this.store.set("portContainerMarkup", be.clone(e), t), this;
  }
  get portMarkup() {
    return this.getPortMarkup();
  }
  set portMarkup(e) {
    this.setPortMarkup(e);
  }
  getDefaultPortMarkup() {
    return this.store.get("defaultPortMarkup") || be.getPortMarkup();
  }
  getPortMarkup() {
    return this.store.get("portMarkup") || this.getDefaultPortMarkup();
  }
  setPortMarkup(e, t = {}) {
    return this.store.set("portMarkup", be.clone(e), t), this;
  }
  get portLabelMarkup() {
    return this.getPortLabelMarkup();
  }
  set portLabelMarkup(e) {
    this.setPortLabelMarkup(e);
  }
  getDefaultPortLabelMarkup() {
    return this.store.get("defaultPortLabelMarkup") || be.getPortLabelMarkup();
  }
  getPortLabelMarkup() {
    return this.store.get("portLabelMarkup") || this.getDefaultPortLabelMarkup();
  }
  setPortLabelMarkup(e, t = {}) {
    return this.store.set("portLabelMarkup", be.clone(e), t), this;
  }
  get ports() {
    const e = this.store.get("ports", { items: [] });
    return e.items == null && (e.items = []), e;
  }
  getPorts() {
    return Ae(this.ports.items);
  }
  getPortsByGroup(e) {
    return this.getPorts().filter((t) => t.group === e);
  }
  getPort(e) {
    return Ae(this.ports.items.find((t) => t.id && t.id === e));
  }
  getPortAt(e) {
    return this.ports.items[e] || null;
  }
  hasPorts() {
    return this.ports.items.length > 0;
  }
  hasPort(e) {
    return this.getPortIndex(e) !== -1;
  }
  getPortIndex(e) {
    const t = typeof e == "string" ? e : e.id;
    return t != null ? this.ports.items.findIndex((n) => n.id === t) : -1;
  }
  getPortsPosition(e) {
    const t = this.getSize();
    return this.port.getPortsLayoutByGroup(e, new R(0, 0, t.width, t.height)).reduce((i, r) => {
      const o = r.portLayout;
      return i[r.portId] = {
        position: Object.assign({}, o.position),
        angle: o.angle || 0
      }, i;
    }, {});
  }
  getPortProp(e, t) {
    return this.getPropByPath(this.prefixPortPath(e, t));
  }
  setPortProp(e, t, n, i) {
    if (typeof t == "string" || Array.isArray(t)) {
      const a = this.prefixPortPath(e, t), l = n;
      return this.setPropByPath(a, l, i);
    }
    const r = this.prefixPortPath(e), o = t;
    return this.setPropByPath(r, o, n);
  }
  removePortProp(e, t, n) {
    return typeof t == "string" || Array.isArray(t) ? this.removePropByPath(this.prefixPortPath(e, t), n) : this.removePropByPath(this.prefixPortPath(e), t);
  }
  portProp(e, t, n, i) {
    return t == null ? this.getPortProp(e) : typeof t == "string" || Array.isArray(t) ? arguments.length === 2 ? this.getPortProp(e, t) : n == null ? this.removePortProp(e, t, i) : this.setPortProp(e, t, n, i) : this.setPortProp(e, t, n);
  }
  prefixPortPath(e, t) {
    const n = this.getPortIndex(e);
    if (n === -1)
      throw new Error('Unable to find port with id: "'.concat(e, '"'));
    return t == null || t === "" ? ["ports", "items", "".concat(n)] : Array.isArray(t) ? ["ports", "items", "".concat(n), ...t] : "ports/items/".concat(n, "/").concat(t);
  }
  addPort(e, t) {
    const n = [...this.ports.items];
    return n.push(e), this.setPropByPath("ports/items", n, t), this;
  }
  addPorts(e, t) {
    return this.setPropByPath("ports/items", [...this.ports.items, ...e], t), this;
  }
  insertPort(e, t, n) {
    const i = [...this.ports.items];
    return i.splice(e, 0, t), this.setPropByPath("ports/items", i, n), this;
  }
  removePort(e, t = {}) {
    return this.removePortAt(this.getPortIndex(e), t);
  }
  removePortAt(e, t = {}) {
    if (e >= 0) {
      const n = [...this.ports.items];
      n.splice(e, 1), t.rewrite = !0, this.setPropByPath("ports/items", n, t);
    }
    return this;
  }
  removePorts(e, t) {
    let n;
    if (Array.isArray(e)) {
      if (n = t || {}, e.length) {
        n.rewrite = !0;
        const r = [...this.ports.items].filter((o) => !e.some((a) => {
          const l = typeof a == "string" ? a : a.id;
          return o.id === l;
        }));
        this.setPropByPath("ports/items", r, n);
      }
    } else
      n = e || {}, n.rewrite = !0, this.setPropByPath("ports/items", [], n);
    return this;
  }
  getParsedPorts() {
    return this.port.getPorts();
  }
  getParsedGroups() {
    return this.port.groups;
  }
  getPortsLayoutByGroup(e, t) {
    return this.port.getPortsLayoutByGroup(e, t);
  }
  initPorts() {
    this.updatePortData(), this.on("change:ports", () => {
      this.processRemovedPort(), this.updatePortData();
    });
  }
  processRemovedPort() {
    const e = this.ports, t = {};
    e.items.forEach((o) => {
      o.id && (t[o.id] = !0);
    });
    const n = {};
    (this.store.getPrevious("ports") || {
      items: []
    }).items.forEach((o) => {
      o.id && !t[o.id] && (n[o.id] = !0);
    });
    const r = this.model;
    r && !yu(n) && (r.getConnectedEdges(this, { incoming: !0 }).forEach((l) => {
      const c = l.getTargetPortId();
      c && n[c] && l.remove();
    }), r.getConnectedEdges(this, { outgoing: !0 }).forEach((l) => {
      const c = l.getSourcePortId();
      c && n[c] && l.remove();
    }));
  }
  validatePorts() {
    const e = {}, t = [];
    return this.ports.items.forEach((n) => {
      typeof n != "object" && t.push("Invalid port ".concat(n, ".")), n.id == null && (n.id = this.generatePortId()), e[n.id] && t.push("Duplicitied port id."), e[n.id] = !0;
    }), t;
  }
  generatePortId() {
    return yo();
  }
  updatePortData() {
    const e = this.validatePorts();
    if (e.length > 0)
      throw this.store.set("ports", this.store.getPrevious("ports")), new Error(e.join(" "));
    const t = this.port ? this.port.getPorts() : null;
    this.port = new Hb(this.ports);
    const n = this.port.getPorts(), i = t ? n.filter((o) => t.find((a) => a.id === o.id) ? null : o) : [...n], r = t ? t.filter((o) => n.find((a) => a.id === o.id) ? null : o) : [];
    i.length > 0 && this.notify("ports:added", { added: i, cell: this, node: this }), r.length > 0 && this.notify("ports:removed", { removed: r, cell: this, node: this });
  }
};
$e.defaults = {
  angle: 0,
  position: { x: 0, y: 0 },
  size: { width: 1, height: 1 }
};
(function(s) {
  s.toStringTag = "X6.".concat(s.name);
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof s)
      return !0;
    const n = t[Symbol.toStringTag], i = t;
    return (n == null || n === s.toStringTag) && typeof i.isNode == "function" && typeof i.isEdge == "function" && typeof i.prop == "function" && typeof i.attr == "function" && typeof i.size == "function" && typeof i.position == "function";
  }
  s.isNode = e;
})($e || ($e = {}));
(function(s) {
  s.config({
    propHooks(e) {
      var { ports: t } = e, n = ta(e, ["ports"]);
      return t && (n.ports = Array.isArray(t) ? { items: t } : t), n;
    }
  });
})($e || ($e = {}));
(function(s) {
  s.registry = Le.create({
    type: "node",
    process(e, t) {
      if (di.exist(e, !0))
        throw new Error("Node with name '".concat(e, "' was registered by anthor Edge"));
      if (typeof t == "function")
        return t.config({ shape: e }), t;
      let n = s;
      const { inherit: i } = t, r = ta(t, ["inherit"]);
      if (i)
        if (typeof i == "string") {
          const a = this.get(i);
          a == null ? this.onNotFound(i, "inherited") : n = a;
        } else
          n = i;
      r.constructorName == null && (r.constructorName = e);
      const o = n.define.call(n, r);
      return o.config({ shape: e }), o;
    }
  }), di.setNodeRegistry(s.registry);
})($e || ($e = {}));
(function(s) {
  let e = 0;
  function t(r) {
    return r ? oc(r) : (e += 1, "CustomNode".concat(e));
  }
  function n(r) {
    const { constructorName: o, overwrite: a } = r, l = ta(r, ["constructorName", "overwrite"]), c = ic(t(o || l.shape), this);
    return c.config(l), l.shape && s.registry.register(l.shape, c, a), c;
  }
  s.define = n;
  function i(r) {
    const o = r.shape || "rect", a = s.registry.get(o);
    return a ? new a(r) : s.registry.onNotFound(o);
  }
  s.create = i;
})($e || ($e = {}));
var na = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
let Me = class jg extends se {
  get [Symbol.toStringTag]() {
    return jg.toStringTag;
  }
  constructor(e = {}) {
    super(e);
  }
  preprocess(e, t) {
    const { source: n, sourceCell: i, sourcePort: r, sourcePoint: o, target: a, targetCell: l, targetPort: c, targetPoint: u } = e, f = na(e, ["source", "sourceCell", "sourcePort", "sourcePoint", "target", "targetCell", "targetPort", "targetPoint"]), g = (p) => typeof p == "string" || typeof p == "number";
    if (n != null)
      if (se.isCell(n))
        f.source = { cell: n.id };
      else if (g(n))
        f.source = { cell: n };
      else if (M.isPoint(n))
        f.source = n.toJSON();
      else if (Array.isArray(n))
        f.source = { x: n[0], y: n[1] };
      else {
        const p = n.cell;
        se.isCell(p) ? f.source = Object.assign(Object.assign({}, n), { cell: p.id }) : f.source = n;
      }
    if (i != null || r != null) {
      let p = f.source;
      if (i != null) {
        const m = g(i) ? i : i.id;
        p ? p.cell = m : p = f.source = { cell: m };
      }
      r != null && p && (p.port = r);
    } else
      o != null && (f.source = M.create(o).toJSON());
    if (a != null)
      if (se.isCell(a))
        f.target = { cell: a.id };
      else if (g(a))
        f.target = { cell: a };
      else if (M.isPoint(a))
        f.target = a.toJSON();
      else if (Array.isArray(a))
        f.target = { x: a[0], y: a[1] };
      else {
        const p = a.cell;
        se.isCell(p) ? f.target = Object.assign(Object.assign({}, a), { cell: p.id }) : f.target = a;
      }
    if (l != null || c != null) {
      let p = f.target;
      if (l != null) {
        const m = g(l) ? l : l.id;
        p ? p.cell = m : p = f.target = { cell: m };
      }
      c != null && p && (p.port = c);
    } else
      u != null && (f.target = M.create(u).toJSON());
    return super.preprocess(f, t);
  }
  setup() {
    super.setup(), this.on("change:labels", (e) => this.onLabelsChanged(e)), this.on("change:vertices", (e) => this.onVertexsChanged(e));
  }
  isEdge() {
    return !0;
  }
  // #region terminal
  disconnect(e = {}) {
    return this.store.set({
      source: { x: 0, y: 0 },
      target: { x: 0, y: 0 }
    }, e), this;
  }
  get source() {
    return this.getSource();
  }
  set source(e) {
    this.setSource(e);
  }
  getSource() {
    return this.getTerminal("source");
  }
  getSourceCellId() {
    return this.source.cell;
  }
  getSourcePortId() {
    return this.source.port;
  }
  setSource(e, t, n = {}) {
    return this.setTerminal("source", e, t, n);
  }
  get target() {
    return this.getTarget();
  }
  set target(e) {
    this.setTarget(e);
  }
  getTarget() {
    return this.getTerminal("target");
  }
  getTargetCellId() {
    return this.target.cell;
  }
  getTargetPortId() {
    return this.target.port;
  }
  setTarget(e, t, n = {}) {
    return this.setTerminal("target", e, t, n);
  }
  getTerminal(e) {
    return Object.assign({}, this.store.get(e));
  }
  setTerminal(e, t, n, i = {}) {
    if (se.isCell(t))
      return this.store.set(e, De({}, n, { cell: t.id }), i), this;
    const r = t;
    return M.isPoint(t) || r.x != null && r.y != null ? (this.store.set(e, De({}, n, { x: r.x, y: r.y }), i), this) : (this.store.set(e, Ae(t), i), this);
  }
  getSourcePoint() {
    return this.getTerminalPoint("source");
  }
  getTargetPoint() {
    return this.getTerminalPoint("target");
  }
  getTerminalPoint(e) {
    const t = this[e];
    if (M.isPointLike(t))
      return M.create(t);
    const n = this.getTerminalCell(e);
    return n ? n.getConnectionPoint(this, e) : new M();
  }
  getSourceCell() {
    return this.getTerminalCell("source");
  }
  getTargetCell() {
    return this.getTerminalCell("target");
  }
  getTerminalCell(e) {
    if (this.model) {
      const t = e === "source" ? this.getSourceCellId() : this.getTargetCellId();
      if (t)
        return this.model.getCell(t);
    }
    return null;
  }
  getSourceNode() {
    return this.getTerminalNode("source");
  }
  getTargetNode() {
    return this.getTerminalNode("target");
  }
  getTerminalNode(e) {
    let t = this;
    const n = {};
    for (; t && t.isEdge(); ) {
      if (n[t.id])
        return null;
      n[t.id] = !0, t = t.getTerminalCell(e);
    }
    return t && t.isNode() ? t : null;
  }
  // #endregion
  // #region router
  get router() {
    return this.getRouter();
  }
  set router(e) {
    e == null ? this.removeRouter() : this.setRouter(e);
  }
  getRouter() {
    return this.store.get("router");
  }
  setRouter(e, t, n) {
    return typeof e == "object" ? this.store.set("router", e, t) : this.store.set("router", { name: e, args: t }, n), this;
  }
  removeRouter(e = {}) {
    return this.store.remove("router", e), this;
  }
  // #endregion
  // #region connector
  get connector() {
    return this.getConnector();
  }
  set connector(e) {
    e == null ? this.removeConnector() : this.setConnector(e);
  }
  getConnector() {
    return this.store.get("connector");
  }
  setConnector(e, t, n) {
    return typeof e == "object" ? this.store.set("connector", e, t) : this.store.set("connector", { name: e, args: t }, n), this;
  }
  removeConnector(e = {}) {
    return this.store.remove("connector", e);
  }
  // #endregion
  // #region labels
  getDefaultLabel() {
    const e = this.constructor, t = this.store.get("defaultLabel") || e.defaultLabel || {};
    return Ae(t);
  }
  get labels() {
    return this.getLabels();
  }
  set labels(e) {
    this.setLabels(e);
  }
  getLabels() {
    return [...this.store.get("labels", [])].map((e) => this.parseLabel(e));
  }
  setLabels(e, t = {}) {
    return this.store.set("labels", Array.isArray(e) ? e : [e], t), this;
  }
  insertLabel(e, t, n = {}) {
    const i = this.getLabels(), r = i.length;
    let o = t != null && Number.isFinite(t) ? t : r;
    return o < 0 && (o = r + o + 1), i.splice(o, 0, this.parseLabel(e)), this.setLabels(i, n);
  }
  appendLabel(e, t = {}) {
    return this.insertLabel(e, -1, t);
  }
  getLabelAt(e) {
    const t = this.getLabels();
    return e != null && Number.isFinite(e) ? this.parseLabel(t[e]) : null;
  }
  setLabelAt(e, t, n = {}) {
    if (e != null && Number.isFinite(e)) {
      const i = this.getLabels();
      i[e] = this.parseLabel(t), this.setLabels(i, n);
    }
    return this;
  }
  removeLabelAt(e, t = {}) {
    const n = this.getLabels(), i = e != null && Number.isFinite(e) ? e : -1, r = n.splice(i, 1);
    return this.setLabels(n, t), r.length ? r[0] : null;
  }
  parseLabel(e) {
    return typeof e == "string" ? this.constructor.parseStringLabel(e) : e;
  }
  onLabelsChanged({ previous: e, current: t }) {
    const n = e && t ? t.filter((r) => e.find((o) => r === o || on(r, o)) ? null : r) : t ? [...t] : [], i = e && t ? e.filter((r) => t.find((o) => r === o || on(r, o)) ? null : r) : e ? [...e] : [];
    n.length > 0 && this.notify("labels:added", { added: n, cell: this, edge: this }), i.length > 0 && this.notify("labels:removed", { removed: i, cell: this, edge: this });
  }
  // #endregion
  // #region vertices
  get vertices() {
    return this.getVertices();
  }
  set vertices(e) {
    this.setVertices(e);
  }
  getVertices() {
    return [...this.store.get("vertices", [])];
  }
  setVertices(e, t = {}) {
    const n = Array.isArray(e) ? e : [e];
    return this.store.set("vertices", n.map((i) => M.toJSON(i)), t), this;
  }
  insertVertex(e, t, n = {}) {
    const i = this.getVertices(), r = i.length;
    let o = t != null && Number.isFinite(t) ? t : r;
    return o < 0 && (o = r + o + 1), i.splice(o, 0, M.toJSON(e)), this.setVertices(i, n);
  }
  appendVertex(e, t = {}) {
    return this.insertVertex(e, -1, t);
  }
  getVertexAt(e) {
    return e != null && Number.isFinite(e) ? this.getVertices()[e] : null;
  }
  setVertexAt(e, t, n = {}) {
    if (e != null && Number.isFinite(e)) {
      const i = this.getVertices();
      i[e] = t, this.setVertices(i, n);
    }
    return this;
  }
  removeVertexAt(e, t = {}) {
    const n = this.getVertices(), i = e != null && Number.isFinite(e) ? e : -1;
    return n.splice(i, 1), this.setVertices(n, t);
  }
  onVertexsChanged({ previous: e, current: t }) {
    const n = e && t ? t.filter((r) => e.find((o) => M.equals(r, o)) ? null : r) : t ? [...t] : [], i = e && t ? e.filter((r) => t.find((o) => M.equals(r, o)) ? null : r) : e ? [...e] : [];
    n.length > 0 && this.notify("vertexs:added", { added: n, cell: this, edge: this }), i.length > 0 && this.notify("vertexs:removed", { removed: i, cell: this, edge: this });
  }
  // #endregion
  // #region markup
  getDefaultMarkup() {
    return this.store.get("defaultMarkup") || be.getEdgeMarkup();
  }
  getMarkup() {
    return super.getMarkup() || this.getDefaultMarkup();
  }
  // #endregion
  // #region transform
  /**
   * Translate the edge vertices (and source and target if they are points)
   * by `tx` pixels in the x-axis and `ty` pixels in the y-axis.
   */
  translate(e, t, n = {}) {
    return n.translateBy = n.translateBy || this.id, n.tx = e, n.ty = t, this.applyToPoints((i) => ({
      x: (i.x || 0) + e,
      y: (i.y || 0) + t
    }), n);
  }
  /**
   * Scales the edge's points (vertices) relative to the given origin.
   */
  scale(e, t, n, i = {}) {
    return this.applyToPoints((r) => M.create(r).scale(e, t, n).toJSON(), i);
  }
  applyToPoints(e, t = {}) {
    const n = {}, i = this.getSource(), r = this.getTarget();
    M.isPointLike(i) && (n.source = e(i)), M.isPointLike(r) && (n.target = e(r));
    const o = this.getVertices();
    return o.length > 0 && (n.vertices = o.map(e)), this.store.set(n, t), this;
  }
  // #endregion
  // #region common
  getBBox() {
    return this.getPolyline().bbox();
  }
  getConnectionPoint() {
    return this.getPolyline().pointAt(0.5);
  }
  getPolyline() {
    const e = [
      this.getSourcePoint(),
      ...this.getVertices().map((t) => M.create(t)),
      this.getTargetPoint()
    ];
    return new Oe(e);
  }
  updateParent(e) {
    let t = null;
    const n = this.getSourceCell(), i = this.getTargetCell(), r = this.getParent();
    return n && i && (n === i || n.isDescendantOf(i) ? t = i : i.isDescendantOf(n) ? t = n : t = se.getCommonAncestor(n, i)), r && t && t.id !== r.id && r.unembed(this, e), t && (!r || r.id !== t.id) && t.embed(this, e), t;
  }
  hasLoop(e = {}) {
    const t = this.getSource(), n = this.getTarget(), i = t.cell, r = n.cell;
    if (!i || !r)
      return !1;
    let o = i === r;
    if (!o && e.deep && this._model) {
      const a = this.getSourceCell(), l = this.getTargetCell();
      a && l && (o = a.isAncestorOf(l, e) || l.isAncestorOf(a, e));
    }
    return o;
  }
  getFragmentAncestor() {
    const e = [this, this.getSourceNode(), this.getTargetNode()].filter((t) => t != null);
    return this.getCommonAncestor(...e);
  }
  isFragmentDescendantOf(e) {
    const t = this.getFragmentAncestor();
    return !!t && (t.id === e.id || t.isDescendantOf(e));
  }
};
Me.defaults = {};
(function(s) {
  function e(t, n) {
    const i = t, r = n;
    return i.cell === r.cell ? i.port === r.port || i.port == null && r.port == null : !1;
  }
  s.equalTerminals = e;
})(Me || (Me = {}));
(function(s) {
  s.defaultLabel = {
    markup: [
      {
        tagName: "rect",
        selector: "body"
      },
      {
        tagName: "text",
        selector: "label"
      }
    ],
    attrs: {
      text: {
        fill: "#000",
        fontSize: 14,
        textAnchor: "middle",
        textVerticalAnchor: "middle",
        pointerEvents: "none"
      },
      rect: {
        ref: "label",
        fill: "#fff",
        rx: 3,
        ry: 3,
        refWidth: 1,
        refHeight: 1,
        refX: 0,
        refY: 0
      }
    },
    position: {
      distance: 0.5
    }
  };
  function e(t) {
    return {
      attrs: { label: { text: t } }
    };
  }
  s.parseStringLabel = e;
})(Me || (Me = {}));
(function(s) {
  s.toStringTag = "X6.".concat(s.name);
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof s)
      return !0;
    const n = t[Symbol.toStringTag], i = t;
    return (n == null || n === s.toStringTag) && typeof i.isNode == "function" && typeof i.isEdge == "function" && typeof i.prop == "function" && typeof i.attr == "function" && typeof i.disconnect == "function" && typeof i.getSource == "function" && typeof i.getTarget == "function";
  }
  s.isEdge = e;
})(Me || (Me = {}));
(function(s) {
  s.registry = Le.create({
    type: "edge",
    process(e, t) {
      if (di.exist(e, !1))
        throw new Error("Edge with name '".concat(e, "' was registered by anthor Node"));
      if (typeof t == "function")
        return t.config({ shape: e }), t;
      let n = s;
      const { inherit: i = "edge" } = t, r = na(t, ["inherit"]);
      if (typeof i == "string") {
        const a = this.get(i || "edge");
        a == null && i ? this.onNotFound(i, "inherited") : n = a;
      } else
        n = i;
      r.constructorName == null && (r.constructorName = e);
      const o = n.define.call(n, r);
      return o.config({ shape: e }), o;
    }
  }), di.setEdgeRegistry(s.registry);
})(Me || (Me = {}));
(function(s) {
  let e = 0;
  function t(r) {
    return r ? oc(r) : (e += 1, "CustomEdge".concat(e));
  }
  function n(r) {
    const { constructorName: o, overwrite: a } = r, l = na(r, ["constructorName", "overwrite"]), c = ic(t(o || l.shape), this);
    return c.config(l), l.shape && s.registry.register(l.shape, c, a), c;
  }
  s.define = n;
  function i(r) {
    const o = r.shape || "edge", a = s.registry.get(o);
    return a ? new a(r) : s.registry.onNotFound(o);
  }
  s.create = i;
})(Me || (Me = {}));
(function(s) {
  const e = "basic.edge";
  s.config({
    shape: e,
    propHooks(t) {
      const { label: n, vertices: i } = t, r = na(t, ["label", "vertices"]);
      if (n) {
        r.labels == null && (r.labels = []);
        const o = typeof n == "string" ? s.parseStringLabel(n) : n;
        r.labels.push(o);
      }
      return i && Array.isArray(i) && (r.vertices = i.map((o) => M.create(o).toJSON())), r;
    }
  }), s.registry.register(e, s);
})(Me || (Me = {}));
var Ub = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class Cl extends yt {
  constructor(e, t = {}) {
    super(), this.length = 0, this.comparator = t.comparator || "zIndex", this.clean(), e && this.reset(e, { silent: !0 });
  }
  toJSON() {
    return this.cells.map((e) => e.toJSON());
  }
  add(e, t, n) {
    let i, r;
    typeof t == "number" ? (i = t, r = Object.assign({ merge: !1 }, n)) : (i = this.length, r = Object.assign({ merge: !1 }, t)), i > this.length && (i = this.length), i < 0 && (i += this.length + 1);
    const o = Array.isArray(e) ? e : [e], a = this.comparator && typeof t != "number" && r.sort !== !1, l = this.comparator || null;
    let c = !1;
    const u = [], d = [];
    return o.forEach((f) => {
      const g = this.get(f);
      g ? r.merge && !f.isSameStore(g) && (g.setProp(f.getProp(), n), d.push(g), a && !c && (l == null || typeof l == "function" ? c = g.hasChanged() : typeof l == "string" ? c = g.hasChanged(l) : c = l.some((p) => g.hasChanged(p)))) : (u.push(f), this.reference(f));
    }), u.length && (a && (c = !0), this.cells.splice(i, 0, ...u), this.length = this.cells.length), c && this.sort({ silent: !0 }), r.silent || (u.forEach((f, g) => {
      const p = {
        cell: f,
        index: i + g,
        options: r
      };
      this.trigger("added", p), r.dryrun || f.notify("added", Object.assign({}, p));
    }), c && this.trigger("sorted"), (u.length || d.length) && this.trigger("updated", {
      added: u,
      merged: d,
      removed: [],
      options: r
    })), this;
  }
  remove(e, t = {}) {
    const n = Array.isArray(e) ? e : [e], i = this.removeCells(n, t);
    return !t.silent && i.length > 0 && this.trigger("updated", {
      options: t,
      removed: i,
      added: [],
      merged: []
    }), Array.isArray(e) ? i : i[0];
  }
  removeCells(e, t) {
    const n = [];
    for (let i = 0; i < e.length; i += 1) {
      const r = this.get(e[i]);
      if (r == null)
        continue;
      const o = this.cells.indexOf(r);
      this.cells.splice(o, 1), this.length -= 1, delete this.map[r.id], n.push(r), this.unreference(r), t.dryrun || r.remove(), t.silent || (this.trigger("removed", { cell: r, index: o, options: t }), t.dryrun || r.notify("removed", { cell: r, index: o, options: t }));
    }
    return n;
  }
  reset(e, t = {}) {
    const n = this.cells.slice();
    if (n.forEach((i) => this.unreference(i)), this.clean(), this.add(e, Object.assign({ silent: !0 }, t)), !t.silent) {
      const i = this.cells.slice();
      this.trigger("reseted", {
        options: t,
        previous: n,
        current: i
      });
      const r = [], o = [];
      i.forEach((a) => {
        n.some((c) => c.id === a.id) || r.push(a);
      }), n.forEach((a) => {
        i.some((c) => c.id === a.id) || o.push(a);
      }), this.trigger("updated", { options: t, added: r, removed: o, merged: [] });
    }
    return this;
  }
  push(e, t) {
    return this.add(e, this.length, t);
  }
  pop(e) {
    const t = this.at(this.length - 1);
    return this.remove(t, e);
  }
  unshift(e, t) {
    return this.add(e, 0, t);
  }
  shift(e) {
    const t = this.at(0);
    return this.remove(t, e);
  }
  get(e) {
    if (e == null)
      return null;
    const t = typeof e == "string" || typeof e == "number" ? e : e.id;
    return this.map[t] || null;
  }
  has(e) {
    return this.get(e) != null;
  }
  at(e) {
    return e < 0 && (e += this.length), this.cells[e] || null;
  }
  first() {
    return this.at(0);
  }
  last() {
    return this.at(-1);
  }
  indexOf(e) {
    return this.cells.indexOf(e);
  }
  toArray() {
    return this.cells.slice();
  }
  sort(e = {}) {
    return this.comparator != null && (this.cells = _p(this.cells, this.comparator), e.silent || this.trigger("sorted")), this;
  }
  clone() {
    const e = this.constructor;
    return new e(this.cells.slice(), {
      comparator: this.comparator
    });
  }
  reference(e) {
    this.map[e.id] = e, e.on("*", this.notifyCellEvent, this);
  }
  unreference(e) {
    e.off("*", this.notifyCellEvent, this), delete this.map[e.id];
  }
  notifyCellEvent(e, t) {
    const n = t.cell;
    this.trigger("cell:".concat(e), t), n && (n.isNode() ? this.trigger("node:".concat(e), Object.assign(Object.assign({}, t), { node: n })) : n.isEdge() && this.trigger("edge:".concat(e), Object.assign(Object.assign({}, t), { edge: n })));
  }
  clean() {
    this.length = 0, this.cells = [], this.map = {};
  }
  dispose() {
    this.reset([]);
  }
}
Ub([
  Cl.dispose()
], Cl.prototype, "dispose", null);
var qb = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class Nt extends yt {
  get [Symbol.toStringTag]() {
    return Nt.toStringTag;
  }
  constructor(e = []) {
    super(), this.batches = {}, this.addings = /* @__PURE__ */ new WeakMap(), this.nodes = {}, this.edges = {}, this.outgoings = {}, this.incomings = {}, this.collection = new Cl(e), this.setup();
  }
  notify(e, t) {
    this.trigger(e, t);
    const n = this.graph;
    return n && (e === "sorted" || e === "reseted" || e === "updated" ? n.trigger("model:".concat(e), t) : n.trigger(e, t)), this;
  }
  setup() {
    const e = this.collection;
    e.on("sorted", () => this.notify("sorted", null)), e.on("updated", (t) => this.notify("updated", t)), e.on("cell:change:zIndex", () => this.sortOnChangeZ()), e.on("added", ({ cell: t }) => {
      this.onCellAdded(t);
    }), e.on("removed", (t) => {
      const n = t.cell;
      this.onCellRemoved(n, t.options), this.notify("cell:removed", t), n.isNode() ? this.notify("node:removed", Object.assign(Object.assign({}, t), { node: n })) : n.isEdge() && this.notify("edge:removed", Object.assign(Object.assign({}, t), { edge: n }));
    }), e.on("reseted", (t) => {
      this.onReset(t.current), this.notify("reseted", t);
    }), e.on("edge:change:source", ({ edge: t }) => this.onEdgeTerminalChanged(t, "source")), e.on("edge:change:target", ({ edge: t }) => {
      this.onEdgeTerminalChanged(t, "target");
    });
  }
  sortOnChangeZ() {
    this.collection.sort();
  }
  onCellAdded(e) {
    const t = e.id;
    e.isEdge() ? (e.updateParent(), this.edges[t] = !0, this.onEdgeTerminalChanged(e, "source"), this.onEdgeTerminalChanged(e, "target")) : this.nodes[t] = !0;
  }
  onCellRemoved(e, t) {
    const n = e.id;
    if (e.isEdge()) {
      delete this.edges[n];
      const i = e.getSource(), r = e.getTarget();
      if (i && i.cell) {
        const o = this.outgoings[i.cell], a = o ? o.indexOf(n) : -1;
        a >= 0 && (o.splice(a, 1), o.length === 0 && delete this.outgoings[i.cell]);
      }
      if (r && r.cell) {
        const o = this.incomings[r.cell], a = o ? o.indexOf(n) : -1;
        a >= 0 && (o.splice(a, 1), o.length === 0 && delete this.incomings[r.cell]);
      }
    } else
      delete this.nodes[n];
    t.clear || (t.disconnectEdges ? this.disconnectConnectedEdges(e, t) : this.removeConnectedEdges(e, t)), e.model === this && (e.model = null);
  }
  onReset(e) {
    this.nodes = {}, this.edges = {}, this.outgoings = {}, this.incomings = {}, e.forEach((t) => this.onCellAdded(t));
  }
  onEdgeTerminalChanged(e, t) {
    const n = t === "source" ? this.outgoings : this.incomings, i = e.previous(t);
    if (i && i.cell) {
      const o = se.isCell(i.cell) ? i.cell.id : i.cell, a = n[o], l = a ? a.indexOf(e.id) : -1;
      l >= 0 && (a.splice(l, 1), a.length === 0 && delete n[o]);
    }
    const r = e.getTerminal(t);
    if (r && r.cell) {
      const o = se.isCell(r.cell) ? r.cell.id : r.cell, a = n[o] || [];
      a.indexOf(e.id) === -1 && a.push(e.id), n[o] = a;
    }
  }
  prepareCell(e, t) {
    return !e.model && (!t || !t.dryrun) && (e.model = this), e.zIndex == null && e.setZIndex(this.getMaxZIndex() + 1, { silent: !0 }), e;
  }
  resetCells(e, t = {}) {
    return e.map((n) => this.prepareCell(n, Object.assign(Object.assign({}, t), { dryrun: !0 }))), this.collection.reset(e, t), e.map((n) => this.prepareCell(n, { options: t })), this;
  }
  clear(e = {}) {
    const t = this.getCells();
    if (t.length === 0)
      return this;
    const n = Object.assign(Object.assign({}, e), { clear: !0 });
    return this.batchUpdate("clear", () => {
      const i = t.sort((r, o) => {
        const a = r.isEdge() ? 1 : 2, l = o.isEdge() ? 1 : 2;
        return a - l;
      });
      for (; i.length > 0; ) {
        const r = i.shift();
        r && r.remove(n);
      }
    }, n), this;
  }
  addNode(e, t = {}) {
    const n = $e.isNode(e) ? e : this.createNode(e);
    return this.addCell(n, t), n;
  }
  updateNode(e, t = {}) {
    const n = this.createNode(e), i = n.getProp();
    return n.dispose(), this.updateCell(i, t);
  }
  createNode(e) {
    return $e.create(e);
  }
  addEdge(e, t = {}) {
    const n = Me.isEdge(e) ? e : this.createEdge(e);
    return this.addCell(n, t), n;
  }
  createEdge(e) {
    return Me.create(e);
  }
  updateEdge(e, t = {}) {
    const n = this.createEdge(e), i = n.getProp();
    return n.dispose(), this.updateCell(i, t);
  }
  addCell(e, t = {}) {
    return Array.isArray(e) ? this.addCells(e, t) : (!this.collection.has(e) && !this.addings.has(e) && (this.addings.set(e, !0), this.collection.add(this.prepareCell(e, t), t), e.eachChild((n) => this.addCell(n, t)), this.addings.delete(e)), this);
  }
  addCells(e, t = {}) {
    const n = e.length;
    if (n === 0)
      return this;
    const i = Object.assign(Object.assign({}, t), { position: n - 1, maxPosition: n - 1 });
    return this.startBatch("add", Object.assign(Object.assign({}, i), { cells: e })), e.forEach((r) => {
      this.addCell(r, i), i.position -= 1;
    }), this.stopBatch("add", Object.assign(Object.assign({}, i), { cells: e })), this;
  }
  updateCell(e, t = {}) {
    const n = e.id && this.getCell(e.id);
    return n ? this.batchUpdate("update", () => (Object.entries(e).forEach(([i, r]) => n.setProp(i, r, t)), !0), e) : !1;
  }
  removeCell(e, t = {}) {
    const n = typeof e == "string" ? this.getCell(e) : e;
    return n && this.has(n) ? this.collection.remove(n, t) : null;
  }
  updateCellId(e, t) {
    if (e.id === t)
      return;
    this.startBatch("update", { id: t }), e.prop("id", t);
    const n = e.clone({ keepId: !0 });
    return this.addCell(n), this.getConnectedEdges(e).forEach((r) => {
      const o = r.getSourceCell(), a = r.getTargetCell();
      o === e && r.setSource(Object.assign(Object.assign({}, r.getSource()), { cell: t })), a === e && r.setTarget(Object.assign(Object.assign({}, r.getTarget()), { cell: t }));
    }), this.removeCell(e), this.stopBatch("update", { id: t }), n;
  }
  removeCells(e, t = {}) {
    return e.length ? this.batchUpdate("remove", () => e.map((n) => this.removeCell(n, t))) : [];
  }
  removeConnectedEdges(e, t = {}) {
    const n = this.getConnectedEdges(e);
    return n.forEach((i) => {
      i.remove(t);
    }), n;
  }
  disconnectConnectedEdges(e, t = {}) {
    const n = typeof e == "string" ? e : e.id;
    this.getConnectedEdges(e).forEach((i) => {
      const r = i.getSourceCellId(), o = i.getTargetCellId();
      r === n && i.setSource({ x: 0, y: 0 }, t), o === n && i.setTarget({ x: 0, y: 0 }, t);
    });
  }
  has(e) {
    return this.collection.has(e);
  }
  total() {
    return this.collection.length;
  }
  indexOf(e) {
    return this.collection.indexOf(e);
  }
  /**
   * Returns a cell from the graph by its id.
   */
  getCell(e) {
    return this.collection.get(e);
  }
  /**
   * Returns all the nodes and edges in the graph.
   */
  getCells() {
    return this.collection.toArray();
  }
  /**
   * Returns the first cell (node or edge) in the graph. The first cell is
   * defined as the cell with the lowest `zIndex`.
   */
  getFirstCell() {
    return this.collection.first();
  }
  /**
   * Returns the last cell (node or edge) in the graph. The last cell is
   * defined as the cell with the highest `zIndex`.
   */
  getLastCell() {
    return this.collection.last();
  }
  /**
   * Returns the lowest `zIndex` value in the graph.
   */
  getMinZIndex() {
    const e = this.collection.first();
    return e && e.getZIndex() || 0;
  }
  /**
   * Returns the highest `zIndex` value in the graph.
   */
  getMaxZIndex() {
    const e = this.collection.last();
    return e && e.getZIndex() || 0;
  }
  getCellsFromCache(e) {
    return e ? Object.keys(e).map((t) => this.getCell(t)).filter((t) => t != null) : [];
  }
  /**
   * Returns all the nodes in the graph.
   */
  getNodes() {
    return this.getCellsFromCache(this.nodes);
  }
  /**
   * Returns all the edges in the graph.
   */
  getEdges() {
    return this.getCellsFromCache(this.edges);
  }
  /**
   * Returns all outgoing edges for the node.
   */
  getOutgoingEdges(e) {
    const t = typeof e == "string" ? e : e.id, n = this.outgoings[t];
    return n ? n.map((i) => this.getCell(i)).filter((i) => i && i.isEdge()) : null;
  }
  /**
   * Returns all incoming edges for the node.
   */
  getIncomingEdges(e) {
    const t = typeof e == "string" ? e : e.id, n = this.incomings[t];
    return n ? n.map((i) => this.getCell(i)).filter((i) => i && i.isEdge()) : null;
  }
  /**
   * Returns edges connected with cell.
   */
  getConnectedEdges(e, t = {}) {
    const n = [], i = typeof e == "string" ? this.getCell(e) : e;
    if (i == null)
      return n;
    const r = {}, o = t.indirect;
    let a = t.incoming, l = t.outgoing;
    a == null && l == null && (a = l = !0);
    const c = (u, d) => {
      const f = d ? this.getOutgoingEdges(u) : this.getIncomingEdges(u);
      if (f != null && f.forEach((g) => {
        r[g.id] || (n.push(g), r[g.id] = !0, o && (a && c(g, !1), l && c(g, !0)));
      }), o && u.isEdge()) {
        const g = d ? u.getTargetCell() : u.getSourceCell();
        g && g.isEdge() && (r[g.id] || (n.push(g), c(g, d)));
      }
    };
    if (l && c(i, !0), a && c(i, !1), t.deep) {
      const u = i.getDescendants({ deep: !0 }), d = {};
      u.forEach((g) => {
        g.isNode() && (d[g.id] = !0);
      });
      const f = (g, p) => {
        const m = p ? this.getOutgoingEdges(g.id) : this.getIncomingEdges(g.id);
        m != null && m.forEach((w) => {
          if (!r[w.id]) {
            const v = w.getSourceCell(), y = w.getTargetCell();
            if (!t.enclosed && v && d[v.id] && y && d[y.id])
              return;
            n.push(w), r[w.id] = !0;
          }
        });
      };
      u.forEach((g) => {
        g.isEdge() || (l && f(g, !0), a && f(g, !1));
      });
    }
    return n;
  }
  isBoundary(e, t) {
    const n = typeof e == "string" ? this.getCell(e) : e, i = t ? this.getIncomingEdges(n) : this.getOutgoingEdges(n);
    return i == null || i.length === 0;
  }
  getBoundaryNodes(e) {
    const t = [];
    return Object.keys(this.nodes).forEach((n) => {
      if (this.isBoundary(n, e)) {
        const i = this.getCell(n);
        i && t.push(i);
      }
    }), t;
  }
  /**
   * Returns an array of all the roots of the graph.
   */
  getRoots() {
    return this.getBoundaryNodes(!0);
  }
  /**
   * Returns an array of all the leafs of the graph.
   */
  getLeafs() {
    return this.getBoundaryNodes(!1);
  }
  /**
   * Returns `true` if the node is a root node, i.e. there is no edges
   * coming to the node.
   */
  isRoot(e) {
    return this.isBoundary(e, !0);
  }
  /**
   * Returns `true` if the node is a leaf node, i.e. there is no edges
   * going out from the node.
   */
  isLeaf(e) {
    return this.isBoundary(e, !1);
  }
  /**
   * Returns all the neighbors of node in the graph. Neighbors are all
   * the nodes connected to node via either incoming or outgoing edge.
   */
  getNeighbors(e, t = {}) {
    let n = t.incoming, i = t.outgoing;
    n == null && i == null && (n = i = !0);
    const o = this.getConnectedEdges(e, t).reduce((a, l) => {
      const c = l.hasLoop(t), u = l.getSourceCell(), d = l.getTargetCell();
      return n && u && u.isNode() && !a[u.id] && (c || u !== e && (!t.deep || !u.isDescendantOf(e))) && (a[u.id] = u), i && d && d.isNode() && !a[d.id] && (c || d !== e && (!t.deep || !d.isDescendantOf(e))) && (a[d.id] = d), a;
    }, {});
    if (e.isEdge()) {
      if (n) {
        const a = e.getSourceCell();
        a && a.isNode() && !o[a.id] && (o[a.id] = a);
      }
      if (i) {
        const a = e.getTargetCell();
        a && a.isNode() && !o[a.id] && (o[a.id] = a);
      }
    }
    return Object.keys(o).map((a) => o[a]);
  }
  /**
   * Returns `true` if `cell2` is a neighbor of `cell1`.
   */
  isNeighbor(e, t, n = {}) {
    let i = n.incoming, r = n.outgoing;
    return i == null && r == null && (i = r = !0), this.getConnectedEdges(e, n).some((o) => {
      const a = o.getSourceCell(), l = o.getTargetCell();
      return !!(i && a && a.id === t.id || r && l && l.id === t.id);
    });
  }
  getSuccessors(e, t = {}) {
    const n = [];
    return this.search(e, (i, r) => {
      i !== e && this.matchDistance(r, t.distance) && n.push(i);
    }, Object.assign(Object.assign({}, t), { outgoing: !0 })), n;
  }
  /**
   * Returns `true` if `cell2` is a successor of `cell1`.
   */
  isSuccessor(e, t, n = {}) {
    let i = !1;
    return this.search(e, (r, o) => {
      if (r === t && r !== e && this.matchDistance(o, n.distance))
        return i = !0, !1;
    }, Object.assign(Object.assign({}, n), { outgoing: !0 })), i;
  }
  getPredecessors(e, t = {}) {
    const n = [];
    return this.search(e, (i, r) => {
      i !== e && this.matchDistance(r, t.distance) && n.push(i);
    }, Object.assign(Object.assign({}, t), { incoming: !0 })), n;
  }
  /**
   * Returns `true` if `cell2` is a predecessor of `cell1`.
   */
  isPredecessor(e, t, n = {}) {
    let i = !1;
    return this.search(e, (r, o) => {
      if (r === t && r !== e && this.matchDistance(o, n.distance))
        return i = !0, !1;
    }, Object.assign(Object.assign({}, n), { incoming: !0 })), i;
  }
  matchDistance(e, t) {
    return t == null ? !0 : typeof t == "function" ? t(e) : Array.isArray(t) && t.includes(e) ? !0 : e === t;
  }
  /**
   * Returns the common ancestor of the passed cells.
   */
  getCommonAncestor(...e) {
    const t = [];
    return e.forEach((n) => {
      n && (Array.isArray(n) ? t.push(...n) : t.push(n));
    }), se.getCommonAncestor(...t);
  }
  /**
   * Returns an array of cells that result from finding nodes/edges that
   * are connected to any of the cells in the cells array. This function
   * loops over cells and if the current cell is a edge, it collects its
   * source/target nodes; if it is an node, it collects its incoming and
   * outgoing edges if both the edge terminal (source/target) are in the
   * cells array.
   */
  getSubGraph(e, t = {}) {
    const n = [], i = {}, r = [], o = [], a = (l) => {
      i[l.id] || (n.push(l), i[l.id] = l, l.isEdge() && o.push(l), l.isNode() && r.push(l));
    };
    return e.forEach((l) => {
      a(l), t.deep && l.getDescendants({ deep: !0 }).forEach((u) => a(u));
    }), o.forEach((l) => {
      const c = l.getSourceCell(), u = l.getTargetCell();
      c && !i[c.id] && (n.push(c), i[c.id] = c, c.isNode() && r.push(c)), u && !i[u.id] && (n.push(u), i[u.id] = u, u.isNode() && r.push(u));
    }), r.forEach((l) => {
      this.getConnectedEdges(l, t).forEach((u) => {
        const d = u.getSourceCell(), f = u.getTargetCell();
        !i[u.id] && d && i[d.id] && f && i[f.id] && (n.push(u), i[u.id] = u);
      });
    }), n;
  }
  /**
   * Clones the whole subgraph (including all the connected links whose
   * source/target is in the subgraph). If `options.deep` is `true`, also
   * take into account all the embedded cells of all the subgraph cells.
   *
   * Returns a map of the form: { [original cell ID]: [clone] }.
   */
  cloneSubGraph(e, t = {}) {
    const n = this.getSubGraph(e, t);
    return this.cloneCells(n);
  }
  cloneCells(e) {
    return se.cloneCells(e);
  }
  getNodesFromPoint(e, t) {
    const n = typeof e == "number" ? { x: e, y: t || 0 } : e;
    return this.getNodes().filter((i) => i.getBBox().containsPoint(n));
  }
  getNodesInArea(e, t, n, i, r) {
    const o = typeof e == "number" ? new R(e, t, n, i) : R.create(e), a = typeof e == "number" ? r : t, l = a && a.strict;
    return this.getNodes().filter((c) => {
      const u = c.getBBox();
      return l ? o.containsRect(u) : o.isIntersectWithRect(u);
    });
  }
  getEdgesInArea(e, t, n, i, r) {
    const o = typeof e == "number" ? new R(e, t, n, i) : R.create(e), a = typeof e == "number" ? r : t, l = a && a.strict;
    return this.getEdges().filter((c) => {
      const u = c.getBBox();
      return u.width === 0 ? u.inflate(1, 0) : u.height === 0 && u.inflate(0, 1), l ? o.containsRect(u) : o.isIntersectWithRect(u);
    });
  }
  getNodesUnderNode(e, t = {}) {
    const n = e.getBBox();
    return (t.by == null || t.by === "bbox" ? this.getNodesInArea(n) : this.getNodesFromPoint(n[t.by])).filter((r) => e.id !== r.id && !r.isDescendantOf(e));
  }
  /**
   * Returns the bounding box that surrounds all cells in the graph.
   */
  getAllCellsBBox() {
    return this.getCellsBBox(this.getCells());
  }
  /**
   * Returns the bounding box that surrounds all the given cells.
   */
  getCellsBBox(e, t = {}) {
    return se.getCellsBBox(e, t);
  }
  // #region search
  search(e, t, n = {}) {
    n.breadthFirst ? this.breadthFirstSearch(e, t, n) : this.depthFirstSearch(e, t, n);
  }
  breadthFirstSearch(e, t, n = {}) {
    const i = [], r = {}, o = {};
    for (i.push(e), o[e.id] = 0; i.length > 0; ) {
      const a = i.shift();
      if (a == null || r[a.id] || (r[a.id] = !0, J(t, this, a, o[a.id]) === !1))
        continue;
      this.getNeighbors(a, n).forEach((c) => {
        o[c.id] = o[a.id] + 1, i.push(c);
      });
    }
  }
  depthFirstSearch(e, t, n = {}) {
    const i = [], r = {}, o = {};
    for (i.push(e), o[e.id] = 0; i.length > 0; ) {
      const a = i.pop();
      if (a == null || r[a.id] || (r[a.id] = !0, J(t, this, a, o[a.id]) === !1))
        continue;
      const l = this.getNeighbors(a, n), c = i.length;
      l.forEach((u) => {
        o[u.id] = o[a.id] + 1, i.splice(c, 0, u);
      });
    }
  }
  // #endregion
  // #region shortest path
  /** *
   * Returns an array of IDs of nodes on the shortest
   * path between source and target.
   */
  getShortestPath(e, t, n = {}) {
    const i = {};
    this.getEdges().forEach((c) => {
      const u = c.getSourceCellId(), d = c.getTargetCellId();
      u && d && (i[u] || (i[u] = []), i[d] || (i[d] = []), i[u].push(d), n.directed || i[d].push(u));
    });
    const r = typeof e == "string" ? e : e.id, o = wl.run(i, r, n.weight), a = [];
    let l = typeof t == "string" ? t : t.id;
    for (o[l] && a.push(l); l = o[l]; )
      a.unshift(l);
    return a;
  }
  // #endregion
  // #region transform
  /**
   * Translate all cells in the graph by `tx` and `ty` pixels.
   */
  translate(e, t, n) {
    return this.getCells().filter((i) => !i.hasParent()).forEach((i) => i.translate(e, t, n)), this;
  }
  resize(e, t, n) {
    return this.resizeCells(e, t, this.getCells(), n);
  }
  resizeCells(e, t, n, i = {}) {
    const r = this.getCellsBBox(n);
    if (r) {
      const o = Math.max(e / r.width, 0), a = Math.max(t / r.height, 0), l = r.getOrigin();
      n.forEach((c) => c.scale(o, a, l, i));
    }
    return this;
  }
  // #endregion
  // #region serialize/deserialize
  toJSON(e = {}) {
    return Nt.toJSON(this.getCells(), e);
  }
  parseJSON(e) {
    return Nt.fromJSON(e);
  }
  fromJSON(e, t = {}) {
    const n = this.parseJSON(e);
    return this.resetCells(n, t), this;
  }
  // #endregion
  // #region batch
  startBatch(e, t = {}) {
    return this.batches[e] = (this.batches[e] || 0) + 1, this.notify("batch:start", { name: e, data: t }), this;
  }
  stopBatch(e, t = {}) {
    return this.batches[e] = (this.batches[e] || 0) - 1, this.notify("batch:stop", { name: e, data: t }), this;
  }
  batchUpdate(e, t, n = {}) {
    this.startBatch(e, n);
    const i = t();
    return this.stopBatch(e, n), i;
  }
  hasActiveBatch(e = Object.keys(this.batches)) {
    return (Array.isArray(e) ? e : [e]).some((n) => this.batches[n] > 0);
  }
  // #endregion
  dispose() {
    this.collection.dispose();
  }
}
qb([
  Nt.dispose()
], Nt.prototype, "dispose", null);
(function(s) {
  s.toStringTag = "X6.".concat(s.name);
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof s)
      return !0;
    const n = t[Symbol.toStringTag], i = t;
    return (n == null || n === s.toStringTag) && typeof i.addNode == "function" && typeof i.addEdge == "function" && i.collection != null;
  }
  s.isModel = e;
})(Nt || (Nt = {}));
(function(s) {
  function e(n, i = {}) {
    return {
      cells: n.map((r) => r.toJSON(i))
    };
  }
  s.toJSON = e;
  function t(n) {
    const i = [];
    return Array.isArray(n) ? i.push(...n) : (n.cells && i.push(...n.cells), n.nodes && n.nodes.forEach((r) => {
      r.shape == null && (r.shape = "rect"), i.push(r);
    }), n.edges && n.edges.forEach((r) => {
      r.shape == null && (r.shape = "edge"), i.push(r);
    })), i.map((r) => {
      const o = r.shape;
      if (o) {
        if ($e.registry.exist(o))
          return $e.create(r);
        if (Me.registry.exist(o))
          return Me.create(r);
      }
      throw new Error("The `shape` should be specified when creating a node/edge instance");
    });
  }
  s.fromJSON = t;
})(Nt || (Nt = {}));
var Gb = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
let $n = class extends $e {
  get label() {
    return this.getLabel();
  }
  set label(e) {
    this.setLabel(e);
  }
  getLabel() {
    return this.getAttrByPath("text/text");
  }
  setLabel(e, t) {
    return e == null ? this.removeLabel() : this.setAttrByPath("text/text", e, t), this;
  }
  removeLabel() {
    return this.removeAttrByPath("text/text"), this;
  }
};
(function(s) {
  s.bodyAttr = {
    fill: "#ffffff",
    stroke: "#333333",
    strokeWidth: 2
  }, s.labelAttr = {
    fontSize: 14,
    fill: "#000000",
    refX: 0.5,
    refY: 0.5,
    textAnchor: "middle",
    textVerticalAnchor: "middle",
    fontFamily: "Arial, helvetica, sans-serif"
  }, s.config({
    attrs: { text: Object.assign({}, s.labelAttr) },
    propHooks(e) {
      const { label: t } = e, n = Gb(e, ["label"]);
      return t && vi(n, "attrs/text/text", t), n;
    },
    visible: !0
  });
})($n || ($n = {}));
var Wb = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
function Jb(s, e = "body") {
  return [
    {
      tagName: s,
      selector: e
    },
    {
      tagName: "text",
      selector: "label"
    }
  ];
}
function Yb(s = "xlink:href") {
  return (t) => {
    const { imageUrl: n, imageWidth: i, imageHeight: r } = t, o = Wb(t, ["imageUrl", "imageWidth", "imageHeight"]);
    if (n != null || i != null || r != null) {
      const a = () => {
        if (o.attrs) {
          const l = o.attrs.image;
          n != null && (l[s] = n), i != null && (l.width = i), r != null && (l.height = r), o.attrs.image = l;
        }
      };
      o.attrs ? (o.attrs.image == null && (o.attrs.image = {}), a()) : (o.attrs = {
        image: {}
      }, a());
    }
    return o;
  };
}
function Ei(s, e, t = {}) {
  const n = {
    constructorName: s,
    markup: Jb(s, t.selector),
    attrs: {
      [s]: Object.assign({}, $n.bodyAttr)
    }
  };
  return (t.parent || $n).define(De(n, e, { shape: s }));
}
Ei("rect", {
  attrs: {
    body: {
      refWidth: "100%",
      refHeight: "100%"
    }
  }
});
const Xb = Me.define({
  shape: "edge",
  markup: [
    {
      tagName: "path",
      selector: "wrap",
      groupSelector: "lines",
      attrs: {
        fill: "none",
        cursor: "pointer",
        stroke: "transparent",
        strokeLinecap: "round"
      }
    },
    {
      tagName: "path",
      selector: "line",
      groupSelector: "lines",
      attrs: {
        fill: "none",
        pointerEvents: "none"
      }
    }
  ],
  attrs: {
    lines: {
      connection: !0,
      strokeLinejoin: "round"
    },
    wrap: {
      strokeWidth: 10
    },
    line: {
      stroke: "#333",
      strokeWidth: 2,
      targetMarker: "classic"
    }
  }
});
Ei("ellipse", {
  attrs: {
    body: {
      refCx: "50%",
      refCy: "50%",
      refRx: "50%",
      refRy: "50%"
    }
  }
});
var Zb = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
class fi extends $n {
  get points() {
    return this.getPoints();
  }
  set points(e) {
    this.setPoints(e);
  }
  getPoints() {
    return this.getAttrByPath("body/refPoints");
  }
  setPoints(e, t) {
    return e == null ? this.removePoints() : this.setAttrByPath("body/refPoints", fi.pointsToString(e), t), this;
  }
  removePoints() {
    return this.removeAttrByPath("body/refPoints"), this;
  }
}
(function(s) {
  function e(t) {
    return typeof t == "string" ? t : t.map((n) => Array.isArray(n) ? n.join(",") : M.isPointLike(n) ? "".concat(n.x, ", ").concat(n.y) : "").join(" ");
  }
  s.pointsToString = e, s.config({
    propHooks(t) {
      const { points: n } = t, i = Zb(t, ["points"]);
      if (n) {
        const r = e(n);
        r && vi(i, "attrs/body/refPoints", r);
      }
      return i;
    }
  });
})(fi || (fi = {}));
Ei("polygon", {}, { parent: fi });
Ei("polyline", {}, { parent: fi });
var Kb = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
$n.define({
  shape: "path",
  markup: [
    {
      tagName: "rect",
      selector: "bg"
    },
    {
      tagName: "path",
      selector: "body"
    },
    {
      tagName: "text",
      selector: "label"
    }
  ],
  attrs: {
    bg: {
      refWidth: "100%",
      refHeight: "100%",
      fill: "none",
      stroke: "none",
      pointerEvents: "all"
    },
    body: {
      fill: "none",
      stroke: "#000",
      strokeWidth: 2
    }
  },
  propHooks(s) {
    const { path: e } = s, t = Kb(s, ["path"]);
    return e && vi(t, "attrs/body/refD", e), t;
  }
});
var Qb = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
$n.define({
  shape: "text-block",
  markup: [
    {
      tagName: "rect",
      selector: "body"
    },
    In.SUPPORT_FOREIGNOBJECT ? {
      tagName: "foreignObject",
      selector: "foreignObject",
      children: [
        {
          tagName: "div",
          ns: Ue.xhtml,
          selector: "label",
          style: {
            width: "100%",
            height: "100%",
            position: "static",
            backgroundColor: "transparent",
            textAlign: "center",
            margin: 0,
            padding: "0px 5px",
            boxSizing: "border-box",
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
          }
        }
      ]
    } : {
      tagName: "text",
      selector: "label",
      attrs: {
        textAnchor: "middle"
      }
    }
  ],
  attrs: {
    body: Object.assign(Object.assign({}, $n.bodyAttr), { refWidth: "100%", refHeight: "100%" }),
    foreignObject: {
      refWidth: "100%",
      refHeight: "100%"
    },
    label: {
      style: {
        fontSize: 14
      }
    }
  },
  propHooks(s) {
    const { text: e } = s, t = Qb(s, ["text"]);
    return e && vi(t, "attrs/label/text", e), t;
  },
  attrHooks: {
    text: {
      set(s, { cell: e, view: t, refBBox: n, elem: i, attrs: r }) {
        if (i instanceof HTMLElement)
          i.textContent = s;
        else {
          const o = r.style || {}, a = { text: s, width: -5, height: "100%" }, l = Object.assign({ textVerticalAnchor: "middle" }, o), c = Xt.presets.textWrap;
          return J(c.set, this, a, {
            cell: e,
            view: t,
            elem: i,
            refBBox: n,
            attrs: l
          }), { fill: o.color || null };
        }
      },
      position(s, { refBBox: e, elem: t }) {
        if (t instanceof SVGElement)
          return e.getCenter();
      }
    }
  }
});
Ei("image", {
  attrs: {
    image: {
      refWidth: "100%",
      refHeight: "100%"
    }
  },
  propHooks: Yb()
}, {
  selector: "image"
});
Ei("circle", {
  attrs: {
    body: {
      refCx: "50%",
      refCy: "50%",
      refR: "50%"
    }
  }
});
class Rt extends Te {
  constructor() {
    super(...arguments), this.portsCache = {};
  }
  get [Symbol.toStringTag]() {
    return Rt.toStringTag;
  }
  getContainerClassName() {
    const e = [
      super.getContainerClassName(),
      this.prefixClassName("node")
    ];
    return this.can("nodeMovable") || e.push(this.prefixClassName("node-immovable")), e.join(" ");
  }
  updateClassName(e) {
    const t = e.target;
    if (t.hasAttribute("magnet")) {
      const n = this.prefixClassName("port-unconnectable");
      this.can("magnetConnectable") ? kt(t, n) : ie(t, n);
    } else {
      const n = this.prefixClassName("node-immovable");
      this.can("nodeMovable") ? this.removeClass(n) : this.addClass(n);
    }
  }
  isNodeView() {
    return !0;
  }
  confirmUpdate(e, t = {}) {
    let n = e;
    return this.hasAction(n, "ports") && (this.removePorts(), this.cleanPortsCache()), this.hasAction(n, "render") ? (this.render(), n = this.removeAction(n, [
      "render",
      "update",
      "resize",
      "translate",
      "rotate",
      "ports",
      "tools"
    ])) : (n = this.handleAction(n, "resize", () => this.resize(), "update"), n = this.handleAction(
      n,
      "update",
      () => this.update(),
      // `update()` will render ports when useCSSSelectors are enabled
      "ports"
    ), n = this.handleAction(n, "translate", () => this.translate()), n = this.handleAction(n, "rotate", () => this.rotate()), n = this.handleAction(n, "ports", () => this.renderPorts()), n = this.handleAction(n, "tools", () => {
      this.getFlag("tools") === e ? this.renderTools() : this.updateTools(t);
    })), n;
  }
  update(e) {
    this.cleanCache(), this.removePorts();
    const t = this.cell, n = t.getSize(), i = t.getAttrs();
    this.updateAttrs(this.container, i, {
      attrs: e === i ? null : e,
      rootBBox: new R(0, 0, n.width, n.height),
      selectors: this.selectors
    }), this.renderPorts();
  }
  renderMarkup() {
    const e = this.cell.markup;
    if (e) {
      if (typeof e == "string")
        throw new TypeError("Not support string markup.");
      return this.renderJSONMarkup(e);
    }
    throw new TypeError("Invalid node markup.");
  }
  renderJSONMarkup(e) {
    const t = this.parseJSONMarkup(e, this.container);
    this.selectors = t.selectors, this.container.appendChild(t.fragment);
  }
  render() {
    return this.empty(), this.renderMarkup(), this.resize(), this.updateTransform(), this.renderTools(), this;
  }
  resize() {
    this.cell.getAngle() && this.rotate(), this.update();
  }
  translate() {
    this.updateTransform();
  }
  rotate() {
    this.updateTransform();
  }
  getTranslationString() {
    const e = this.cell.getPosition();
    return "translate(".concat(e.x, ",").concat(e.y, ")");
  }
  getRotationString() {
    const e = this.cell.getAngle();
    if (e) {
      const t = this.cell.getSize();
      return "rotate(".concat(e, ",").concat(t.width / 2, ",").concat(t.height / 2, ")");
    }
  }
  updateTransform() {
    let e = this.getTranslationString();
    const t = this.getRotationString();
    t && (e += " ".concat(t)), this.container.setAttribute("transform", e);
  }
  // #region ports
  findPortElem(e, t) {
    const n = e ? this.portsCache[e] : null;
    if (!n)
      return null;
    const i = n.portContentElement, r = n.portContentSelectors || {};
    return this.findOne(t, i, r);
  }
  cleanPortsCache() {
    this.portsCache = {};
  }
  removePorts() {
    Object.values(this.portsCache).forEach((e) => {
      Qs(e.portElement);
    });
  }
  renderPorts() {
    const e = this.container, t = [];
    e.childNodes.forEach((o) => {
      t.push(o);
    });
    const n = this.cell.getParsedPorts(), i = Tc(n, "zIndex"), r = "auto";
    i[r] && i[r].forEach((o) => {
      const a = this.getPortElement(o);
      e.append(a), t.push(a);
    }), Object.keys(i).forEach((o) => {
      if (o !== r) {
        const a = parseInt(o, 10);
        this.appendPorts(i[o], a, t);
      }
    }), this.updatePorts();
  }
  appendPorts(e, t, n) {
    const i = e.map((r) => this.getPortElement(r));
    n[t] || t < 0 ? fc(n[Math.max(t, 0)], i) : Er(this.container, i);
  }
  getPortElement(e) {
    const t = this.portsCache[e.id];
    return t ? t.portElement : this.createPortElement(e);
  }
  createPortElement(e) {
    let t = be.renderMarkup(this.cell.getPortContainerMarkup());
    const n = t.elem;
    if (n == null)
      throw new Error("Invalid port container markup.");
    t = be.renderMarkup(this.getPortMarkup(e));
    const i = t.elem, r = t.selectors;
    if (i == null)
      throw new Error("Invalid port markup.");
    this.setAttrs({
      port: e.id,
      "port-group": e.group
    }, i);
    let o = "x6-port";
    e.group && (o += " x6-port-".concat(e.group)), ie(n, o), ie(n, "x6-port"), ie(i, "x6-port-body"), n.appendChild(i);
    let a = r, l, c;
    if (this.existPortLabel(e)) {
      if (t = be.renderMarkup(this.getPortLabelMarkup(e.label)), l = t.elem, c = t.selectors, l == null)
        throw new Error("Invalid port label markup.");
      if (r && c) {
        for (const d in c)
          if (r[d] && d !== this.rootSelector)
            throw new Error("Selectors within port must be unique.");
        a = Object.assign(Object.assign({}, r), c);
      }
      ie(l, "x6-port-label"), n.appendChild(l);
    }
    return this.portsCache[e.id] = {
      portElement: n,
      portSelectors: a,
      portLabelElement: l,
      portLabelSelectors: c,
      portContentElement: i,
      portContentSelectors: r
    }, this.graph.options.onPortRendered && this.graph.options.onPortRendered({
      port: e,
      node: this.cell,
      container: n,
      selectors: a,
      labelContainer: l,
      labelSelectors: c,
      contentContainer: i,
      contentSelectors: r
    }), n;
  }
  updatePorts() {
    const e = this.cell.getParsedGroups(), t = Object.keys(e);
    t.length === 0 ? this.updatePortGroup() : t.forEach((n) => this.updatePortGroup(n));
  }
  updatePortGroup(e) {
    const t = R.fromSize(this.cell.getSize()), n = this.cell.getPortsLayoutByGroup(e, t);
    for (let i = 0, r = n.length; i < r; i += 1) {
      const o = n[i], a = o.portId, l = this.portsCache[a] || {}, c = o.portLayout;
      if (this.applyPortTransform(l.portElement, c), o.portAttrs != null) {
        const d = {
          selectors: l.portSelectors || {}
        };
        o.portSize && (d.rootBBox = R.fromSize(o.portSize)), this.updateAttrs(l.portElement, o.portAttrs, d);
      }
      const u = o.labelLayout;
      if (u && l.portLabelElement && (this.applyPortTransform(l.portLabelElement, u, -(c.angle || 0)), u.attrs)) {
        const d = {
          selectors: l.portLabelSelectors || {}
        };
        o.labelSize && (d.rootBBox = R.fromSize(o.labelSize)), this.updateAttrs(l.portLabelElement, u.attrs, d);
      }
    }
  }
  applyPortTransform(e, t, n = 0) {
    const i = t.angle, r = t.position, o = We().rotate(n).translate(r.x || 0, r.y || 0).rotate(i || 0);
    ei(e, o, { absolute: !0 });
  }
  getPortMarkup(e) {
    return e.markup || this.cell.portMarkup;
  }
  getPortLabelMarkup(e) {
    return e.markup || this.cell.portLabelMarkup;
  }
  existPortLabel(e) {
    return e.attrs && e.attrs.text;
  }
  getEventArgs(e, t, n) {
    const i = this, r = i.cell, o = r;
    return t == null || n == null ? { e, view: i, node: r, cell: o } : { e, x: t, y: n, view: i, node: r, cell: o };
  }
  getPortEventArgs(e, t, n) {
    const i = this, r = i.cell, o = r;
    return n ? {
      e,
      x: n.x,
      y: n.y,
      view: i,
      node: r,
      cell: o,
      port: t
    } : { e, view: i, node: r, cell: o, port: t };
  }
  notifyMouseDown(e, t, n) {
    super.onMouseDown(e, t, n), this.notify("node:mousedown", this.getEventArgs(e, t, n));
  }
  notifyMouseMove(e, t, n) {
    super.onMouseMove(e, t, n), this.notify("node:mousemove", this.getEventArgs(e, t, n));
  }
  notifyMouseUp(e, t, n) {
    super.onMouseUp(e, t, n), this.notify("node:mouseup", this.getEventArgs(e, t, n));
  }
  notifyPortEvent(e, t, n) {
    const i = this.findAttr("port", t.target);
    if (i) {
      const r = t.type;
      e === "node:port:mouseenter" ? t.type = "mouseenter" : e === "node:port:mouseleave" && (t.type = "mouseleave"), this.notify(e, this.getPortEventArgs(t, i, n)), t.type = r;
    }
  }
  onClick(e, t, n) {
    super.onClick(e, t, n), this.notify("node:click", this.getEventArgs(e, t, n)), this.notifyPortEvent("node:port:click", e, { x: t, y: n });
  }
  onDblClick(e, t, n) {
    super.onDblClick(e, t, n), this.notify("node:dblclick", this.getEventArgs(e, t, n)), this.notifyPortEvent("node:port:dblclick", e, { x: t, y: n });
  }
  onContextMenu(e, t, n) {
    super.onContextMenu(e, t, n), this.notify("node:contextmenu", this.getEventArgs(e, t, n)), this.notifyPortEvent("node:port:contextmenu", e, { x: t, y: n });
  }
  onMouseDown(e, t, n) {
    this.isPropagationStopped(e) || (this.notifyMouseDown(e, t, n), this.notifyPortEvent("node:port:mousedown", e, { x: t, y: n }), this.startNodeDragging(e, t, n));
  }
  onMouseMove(e, t, n) {
    const i = this.getEventData(e), r = i.action;
    if (r === "magnet")
      this.dragMagnet(e, t, n);
    else {
      if (r === "move") {
        const a = i.targetView || this;
        a.dragNode(e, t, n), a.notify("node:moving", {
          e,
          x: t,
          y: n,
          view: a,
          cell: a.cell,
          node: a.cell
        });
      }
      this.notifyMouseMove(e, t, n), this.notifyPortEvent("node:port:mousemove", e, { x: t, y: n });
    }
    this.setEventData(e, i);
  }
  onMouseUp(e, t, n) {
    const i = this.getEventData(e), r = i.action;
    r === "magnet" ? this.stopMagnetDragging(e, t, n) : (this.notifyMouseUp(e, t, n), this.notifyPortEvent("node:port:mouseup", e, { x: t, y: n }), r === "move" && (i.targetView || this).stopNodeDragging(e, t, n));
    const o = i.targetMagnet;
    o && this.onMagnetClick(e, o, t, n), this.checkMouseleave(e);
  }
  onMouseOver(e) {
    super.onMouseOver(e), this.notify("node:mouseover", this.getEventArgs(e)), this.notifyPortEvent("node:port:mouseenter", e), this.notifyPortEvent("node:port:mouseover", e);
  }
  onMouseOut(e) {
    super.onMouseOut(e), this.notify("node:mouseout", this.getEventArgs(e)), this.notifyPortEvent("node:port:mouseleave", e), this.notifyPortEvent("node:port:mouseout", e);
  }
  onMouseEnter(e) {
    this.updateClassName(e), super.onMouseEnter(e), this.notify("node:mouseenter", this.getEventArgs(e));
  }
  onMouseLeave(e) {
    super.onMouseLeave(e), this.notify("node:mouseleave", this.getEventArgs(e));
  }
  onMouseWheel(e, t, n, i) {
    super.onMouseWheel(e, t, n, i), this.notify("node:mousewheel", Object.assign({ delta: i }, this.getEventArgs(e, t, n)));
  }
  onMagnetClick(e, t, n, i) {
    const r = this.graph;
    r.view.getMouseMovedCount(e) > r.options.clickThreshold || this.notify("node:magnet:click", Object.assign({ magnet: t }, this.getEventArgs(e, n, i)));
  }
  onMagnetDblClick(e, t, n, i) {
    this.notify("node:magnet:dblclick", Object.assign({ magnet: t }, this.getEventArgs(e, n, i)));
  }
  onMagnetContextMenu(e, t, n, i) {
    this.notify("node:magnet:contextmenu", Object.assign({ magnet: t }, this.getEventArgs(e, n, i)));
  }
  onMagnetMouseDown(e, t, n, i) {
    this.startMagnetDragging(e, n, i);
  }
  onCustomEvent(e, t, n, i) {
    this.notify("node:customevent", Object.assign({ name: t }, this.getEventArgs(e, n, i))), super.onCustomEvent(e, t, n, i);
  }
  prepareEmbedding(e) {
    const t = this.graph, i = this.getEventData(e).cell || this.cell, r = t.findViewByCell(i), o = t.snapToGrid(e.clientX, e.clientY);
    this.notify("node:embed", {
      e,
      node: i,
      view: r,
      cell: i,
      x: o.x,
      y: o.y,
      currentParent: i.getParent()
    });
  }
  processEmbedding(e, t) {
    const n = t.cell || this.cell, i = t.graph || this.graph, r = i.options.embedding, o = r.findParent;
    let a = typeof o == "function" ? J(o, i, {
      view: this,
      node: this.cell
    }).filter((f) => se.isCell(f) && this.cell.id !== f.id && !f.isDescendantOf(this.cell)) : i.model.getNodesUnderNode(n, {
      by: o
    });
    if (r.frontOnly && a.length > 0) {
      const f = Tc(a, "zIndex"), g = Op(Object.keys(f).map((p) => parseInt(p, 10)));
      g && (a = f[g]);
    }
    a = a.filter((f) => f.visible);
    let l = null;
    const c = t.candidateEmbedView, u = r.validate;
    for (let f = a.length - 1; f >= 0; f -= 1) {
      const g = a[f];
      if (c && c.cell.id === g.id) {
        l = c;
        break;
      } else {
        const p = g.findView(i);
        if (u && J(u, i, {
          child: this.cell,
          parent: p.cell,
          childView: this,
          parentView: p
        })) {
          l = p;
          break;
        }
      }
    }
    this.clearEmbedding(t), l && l.highlight(null, { type: "embedding" }), t.candidateEmbedView = l;
    const d = i.snapToGrid(e.clientX, e.clientY);
    this.notify("node:embedding", {
      e,
      cell: n,
      node: n,
      view: i.findViewByCell(n),
      x: d.x,
      y: d.y,
      currentParent: n.getParent(),
      candidateParent: l ? l.cell : null
    });
  }
  clearEmbedding(e) {
    const t = e.candidateEmbedView;
    t && (t.unhighlight(null, { type: "embedding" }), e.candidateEmbedView = null);
  }
  finalizeEmbedding(e, t) {
    this.graph.startBatch("embedding");
    const n = t.cell || this.cell, i = t.graph || this.graph, r = i.findViewByCell(n), o = n.getParent(), a = t.candidateEmbedView;
    if (a ? (a.unhighlight(null, { type: "embedding" }), t.candidateEmbedView = null, (o == null || o.id !== a.cell.id) && a.cell.insertChild(n, void 0, { ui: !0 })) : o && o.unembed(n, { ui: !0 }), i.model.getConnectedEdges(n, { deep: !0 }).forEach((l) => {
      l.updateParent({ ui: !0 });
    }), r && a) {
      const l = i.snapToGrid(e.clientX, e.clientY);
      r.notify("node:embedded", {
        e,
        cell: n,
        x: l.x,
        y: l.y,
        node: n,
        view: i.findViewByCell(n),
        previousParent: o,
        currentParent: n.getParent()
      });
    }
    this.graph.stopBatch("embedding");
  }
  getDelegatedView() {
    let e = this.cell, t = this;
    for (; t && !e.isEdge(); ) {
      if (!e.hasParent() || t.can("stopDelegateOnDragging"))
        return t;
      e = e.getParent(), t = this.graph.findViewByCell(e);
    }
    return null;
  }
  validateMagnet(e, t, n) {
    if (t.getAttribute("magnet") !== "passive") {
      const i = this.graph.options.connecting.validateMagnet;
      return i ? J(i, this.graph, {
        e: n,
        magnet: t,
        view: e,
        cell: e.cell
      }) : !0;
    }
    return !1;
  }
  startMagnetDragging(e, t, n) {
    if (!this.can("magnetConnectable"))
      return;
    e.stopPropagation();
    const i = e.currentTarget, r = this.graph;
    this.setEventData(e, {
      targetMagnet: i
    }), this.validateMagnet(this, i, e) ? (r.options.magnetThreshold <= 0 && this.startConnectting(e, i, t, n), this.setEventData(e, {
      action: "magnet"
    }), this.stopPropagation(e)) : this.onMouseDown(e, t, n), r.view.delegateDragEvents(e, this);
  }
  startConnectting(e, t, n, i) {
    this.graph.model.startBatch("add-edge");
    const r = this.createEdgeFromMagnet(t, n, i);
    r.setEventData(e, r.prepareArrowheadDragging("target", {
      x: n,
      y: i,
      isNewEdge: !0,
      fallbackAction: "remove"
    })), this.setEventData(e, { edgeView: r }), r.notifyMouseDown(e, n, i);
  }
  getDefaultEdge(e, t) {
    let n;
    const i = this.graph.options.connecting.createEdge;
    return i && (n = J(i, this.graph, {
      sourceMagnet: t,
      sourceView: e,
      sourceCell: e.cell
    })), n;
  }
  createEdgeFromMagnet(e, t, n) {
    const i = this.graph, r = i.model, o = this.getDefaultEdge(this, e);
    return o.setSource(Object.assign(Object.assign({}, o.getSource()), this.getEdgeTerminal(e, t, n, o, "source"))), o.setTarget(Object.assign(Object.assign({}, o.getTarget()), { x: t, y: n })), o.addTo(r, { async: !1, ui: !0 }), o.findView(i);
  }
  dragMagnet(e, t, n) {
    const i = this.getEventData(e), r = i.edgeView;
    if (r)
      r.onMouseMove(e, t, n), this.autoScrollGraph(e.clientX, e.clientY);
    else {
      const o = this.graph, a = o.options.magnetThreshold, l = this.getEventTarget(e), c = i.targetMagnet;
      if (a === "onleave") {
        if (c === l || c.contains(l))
          return;
      } else if (o.view.getMouseMovedCount(e) <= a)
        return;
      this.startConnectting(e, c, t, n);
    }
  }
  stopMagnetDragging(e, t, n) {
    const r = this.eventData(e).edgeView;
    r && (r.onMouseUp(e, t, n), this.graph.model.stopBatch("add-edge"));
  }
  notifyUnhandledMouseDown(e, t, n) {
    this.notify("node:unhandled:mousedown", {
      e,
      x: t,
      y: n,
      view: this,
      cell: this.cell,
      node: this.cell
    });
  }
  notifyNodeMove(e, t, n, i, r) {
    let o = [r];
    const a = this.graph.getPlugin("selection");
    if (a && a.isSelectionMovable()) {
      const l = a.getSelectedCells();
      l.includes(r) && (o = l.filter((c) => c.isNode()));
    }
    o.forEach((l) => {
      this.notify(e, {
        e: t,
        x: n,
        y: i,
        cell: l,
        node: l,
        view: l.findView(this.graph)
      });
    });
  }
  getRestrictArea(e) {
    const t = this.graph.options.translating.restrict, n = typeof t == "function" ? J(t, this.graph, e) : t;
    return typeof n == "number" ? this.graph.transform.getGraphArea().inflate(n) : n === !0 ? this.graph.transform.getGraphArea() : n || null;
  }
  startNodeDragging(e, t, n) {
    const i = this.getDelegatedView();
    if (i == null || !i.can("nodeMovable"))
      return this.notifyUnhandledMouseDown(e, t, n);
    this.setEventData(e, {
      targetView: i,
      action: "move"
    });
    const r = M.create(i.cell.getPosition());
    i.setEventData(e, {
      moving: !1,
      offset: r.diff(t, n),
      restrict: this.getRestrictArea(i)
    });
  }
  dragNode(e, t, n) {
    const i = this.cell, r = this.graph, o = r.getGridSize(), a = this.getEventData(e), l = a.offset, c = a.restrict;
    a.moving || (a.moving = !0, this.addClass("node-moving"), this.notifyNodeMove("node:move", e, t, n, this.cell)), this.autoScrollGraph(e.clientX, e.clientY);
    const u = ue.snapToGrid(t + l.x, o), d = ue.snapToGrid(n + l.y, o);
    i.setPosition(u, d, {
      restrict: c,
      deep: !0,
      ui: !0
    }), r.options.embedding.enabled && (a.embedding || (this.prepareEmbedding(e), a.embedding = !0), this.processEmbedding(e, a));
  }
  stopNodeDragging(e, t, n) {
    const i = this.getEventData(e);
    i.embedding && this.finalizeEmbedding(e, i), i.moving && (this.removeClass("node-moving"), this.notifyNodeMove("node:moved", e, t, n, this.cell)), i.moving = !1, i.embedding = !1;
  }
  // eslint-disable-next-line
  autoScrollGraph(e, t) {
    const n = this.graph.getPlugin("scroller");
    n && n.autoScroll(e, t);
  }
}
(function(s) {
  s.toStringTag = "X6.".concat(s.name);
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof s)
      return !0;
    const n = t[Symbol.toStringTag], i = t;
    return (n == null || n === s.toStringTag) && typeof i.isNodeView == "function" && typeof i.isEdgeView == "function" && typeof i.confirmUpdate == "function" && typeof i.update == "function" && typeof i.findPortElem == "function" && typeof i.resize == "function" && typeof i.rotate == "function" && typeof i.translate == "function";
  }
  s.isNodeView = e;
})(Rt || (Rt = {}));
Rt.config({
  isSvgElement: !0,
  priority: 0,
  bootstrap: ["render"],
  actions: {
    view: ["render"],
    markup: ["render"],
    attrs: ["update"],
    size: ["resize", "ports", "tools"],
    angle: ["rotate", "tools"],
    position: ["translate", "tools"],
    ports: ["ports"],
    tools: ["tools"]
  }
});
Rt.registry.register("node", Rt, !0);
var e5 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
class dn extends Te {
  constructor() {
    super(...arguments), this.POINT_ROUNDING = 2, this.labelDestroyFn = {};
  }
  get [Symbol.toStringTag]() {
    return dn.toStringTag;
  }
  getContainerClassName() {
    return [super.getContainerClassName(), this.prefixClassName("edge")].join(" ");
  }
  get sourceBBox() {
    const e = this.sourceView;
    if (!e) {
      const n = this.cell.getSource();
      return new R(n.x, n.y);
    }
    const t = this.sourceMagnet;
    return e.isEdgeElement(t) ? new R(this.sourceAnchor.x, this.sourceAnchor.y) : e.getBBoxOfElement(t || e.container);
  }
  get targetBBox() {
    const e = this.targetView;
    if (!e) {
      const n = this.cell.getTarget();
      return new R(n.x, n.y);
    }
    const t = this.targetMagnet;
    return e.isEdgeElement(t) ? new R(this.targetAnchor.x, this.targetAnchor.y) : e.getBBoxOfElement(t || e.container);
  }
  isEdgeView() {
    return !0;
  }
  confirmUpdate(e, t = {}) {
    let n = e;
    if (this.hasAction(n, "source")) {
      if (!this.updateTerminalProperties("source"))
        return n;
      n = this.removeAction(n, "source");
    }
    if (this.hasAction(n, "target")) {
      if (!this.updateTerminalProperties("target"))
        return n;
      n = this.removeAction(n, "target");
    }
    return this.hasAction(n, "render") ? (this.render(), n = this.removeAction(n, ["render", "update", "labels", "tools"]), n) : (n = this.handleAction(n, "update", () => this.update(t)), n = this.handleAction(n, "labels", () => this.onLabelsChange(t)), n = this.handleAction(n, "tools", () => this.renderTools()), n);
  }
  // #region render
  render() {
    return this.empty(), this.renderMarkup(), this.labelContainer = null, this.renderLabels(), this.update(), this.renderTools(), this;
  }
  renderMarkup() {
    const e = this.cell.markup;
    if (e) {
      if (typeof e == "string")
        throw new TypeError("Not support string markup.");
      return this.renderJSONMarkup(e);
    }
    throw new TypeError("Invalid edge markup.");
  }
  renderJSONMarkup(e) {
    const t = this.parseJSONMarkup(e, this.container);
    this.selectors = t.selectors, this.container.append(t.fragment);
  }
  customizeLabels() {
    if (this.labelContainer) {
      const e = this.cell, t = e.labels;
      for (let n = 0, i = t.length; n < i; n += 1) {
        const r = t[n], o = this.labelCache[n], a = this.labelSelectors[n], l = this.graph.options.onEdgeLabelRendered;
        if (l) {
          const c = l({
            edge: e,
            label: r,
            container: o,
            selectors: a
          });
          c && (this.labelDestroyFn[n] = c);
        }
      }
    }
  }
  destroyCustomizeLabels() {
    const e = this.cell.labels;
    if (this.labelCache && this.labelSelectors && this.labelDestroyFn)
      for (let t = 0, n = e.length; t < n; t += 1) {
        const i = this.labelDestroyFn[t], r = this.labelCache[t], o = this.labelSelectors[t];
        i && r && o && i({
          edge: this.cell,
          label: e[t],
          container: r,
          selectors: o
        });
      }
    this.labelDestroyFn = {};
  }
  renderLabels() {
    const e = this.cell, t = e.getLabels(), n = t.length;
    let i = this.labelContainer;
    if (this.labelCache = {}, this.labelSelectors = {}, n <= 0)
      return i && i.parentNode && i.parentNode.removeChild(i), this;
    i ? this.empty(i) : (i = Bt("g"), this.addClass(this.prefixClassName("edge-labels"), i), this.labelContainer = i);
    for (let r = 0, o = t.length; r < o; r += 1) {
      const a = t[r], l = this.normalizeLabelMarkup(this.parseLabelMarkup(a.markup));
      let c, u;
      if (l)
        c = l.node, u = l.selectors;
      else {
        const f = e.getDefaultLabel(), g = this.normalizeLabelMarkup(this.parseLabelMarkup(f.markup));
        c = g.node, u = g.selectors;
      }
      c.setAttribute("data-index", "".concat(r)), i.appendChild(c);
      const d = this.rootSelector;
      if (u[d])
        throw new Error("Ambiguous label root selector.");
      u[d] = c, this.labelCache[r] = c, this.labelSelectors[r] = u;
    }
    return i.parentNode == null && this.container.appendChild(i), this.updateLabels(), this.customizeLabels(), this;
  }
  onLabelsChange(e = {}) {
    this.destroyCustomizeLabels(), this.shouldRerenderLabels(e) ? this.renderLabels() : this.updateLabels(), this.updateLabelPositions();
  }
  shouldRerenderLabels(e = {}) {
    const t = this.cell.previous("labels");
    if (t == null)
      return !0;
    if ("propertyPathArray" in e && "propertyValue" in e) {
      const n = e.propertyPathArray || [], i = n.length;
      if (i > 1) {
        const r = n[1];
        if (t[r]) {
          if (i === 2)
            return typeof e.propertyValue == "object" && Dr(e.propertyValue, "markup");
          if (n[2] !== "markup")
            return !1;
        }
      }
    }
    return !0;
  }
  parseLabelMarkup(e) {
    return e ? typeof e == "string" ? this.parseLabelStringMarkup(e) : this.parseJSONMarkup(e) : null;
  }
  parseLabelStringMarkup(e) {
    const t = G.createVectors(e), n = document.createDocumentFragment();
    for (let i = 0, r = t.length; i < r; i += 1) {
      const o = t[i].node;
      n.appendChild(o);
    }
    return { fragment: n, selectors: {} };
  }
  normalizeLabelMarkup(e) {
    if (e == null)
      return;
    const t = e.fragment;
    if (!(t instanceof DocumentFragment) || !t.hasChildNodes())
      throw new Error("Invalid label markup.");
    let n;
    const i = t.childNodes;
    return i.length > 1 || i[0].nodeName.toUpperCase() !== "G" ? n = G.create("g").append(t) : n = G.create(i[0]), n.addClass(this.prefixClassName("edge-label")), {
      node: n.node,
      selectors: e.selectors
    };
  }
  updateLabels() {
    if (this.labelContainer) {
      const e = this.cell, t = e.labels, n = this.can("edgeLabelMovable"), i = e.getDefaultLabel();
      for (let r = 0, o = t.length; r < o; r += 1) {
        const a = this.labelCache[r], l = this.labelSelectors[r];
        a.setAttribute("cursor", n ? "move" : "default");
        const c = t[r], u = De({}, i.attrs, c.attrs);
        this.updateAttrs(a, u, {
          selectors: l,
          rootBBox: c.size ? R.fromSize(c.size) : void 0
        });
      }
    }
  }
  renderTools() {
    const e = this.cell.getTools();
    return this.addTools(e), this;
  }
  // #endregion
  // #region updating
  update(e = {}) {
    this.cleanCache(), this.updateConnection(e);
    const t = this.cell.getAttrs(), n = e5(t, ["text"]);
    return n != null && this.updateAttrs(this.container, n, {
      selectors: this.selectors
    }), this.updateLabelPositions(), this.updateTools(e), this;
  }
  removeRedundantLinearVertices(e = {}) {
    const t = this.cell, n = t.getVertices(), i = [this.sourceAnchor, ...n, this.targetAnchor], r = i.length, o = new Oe(i);
    o.simplify({ threshold: 0.01 });
    const a = o.points.map((c) => c.toJSON()), l = a.length;
    return r === l ? 0 : (t.setVertices(a.slice(1, l - 1), e), r - l);
  }
  getTerminalView(e) {
    switch (e) {
      case "source":
        return this.sourceView || null;
      case "target":
        return this.targetView || null;
      default:
        throw new Error("Unknown terminal type '".concat(e, "'"));
    }
  }
  getTerminalAnchor(e) {
    switch (e) {
      case "source":
        return M.create(this.sourceAnchor);
      case "target":
        return M.create(this.targetAnchor);
      default:
        throw new Error("Unknown terminal type '".concat(e, "'"));
    }
  }
  getTerminalConnectionPoint(e) {
    switch (e) {
      case "source":
        return M.create(this.sourcePoint);
      case "target":
        return M.create(this.targetPoint);
      default:
        throw new Error("Unknown terminal type '".concat(e, "'"));
    }
  }
  getTerminalMagnet(e, t = {}) {
    switch (e) {
      case "source": {
        if (t.raw)
          return this.sourceMagnet;
        const n = this.sourceView;
        return n ? this.sourceMagnet || n.container : null;
      }
      case "target": {
        if (t.raw)
          return this.targetMagnet;
        const n = this.targetView;
        return n ? this.targetMagnet || n.container : null;
      }
      default:
        throw new Error("Unknown terminal type '".concat(e, "'"));
    }
  }
  updateConnection(e = {}) {
    const t = this.cell;
    if (e.translateBy && t.isFragmentDescendantOf(e.translateBy)) {
      const n = e.tx || 0, i = e.ty || 0;
      this.routePoints = new Oe(this.routePoints).translate(n, i).points, this.translateConnectionPoints(n, i), this.path.translate(n, i);
    } else {
      const n = t.getVertices(), i = this.findAnchors(n);
      this.sourceAnchor = i.source, this.targetAnchor = i.target, this.routePoints = this.findRoutePoints(n);
      const r = this.findConnectionPoints(this.routePoints, this.sourceAnchor, this.targetAnchor);
      this.sourcePoint = r.source, this.targetPoint = r.target;
      const o = this.findMarkerPoints(this.routePoints, this.sourcePoint, this.targetPoint);
      this.path = this.findPath(this.routePoints, o.source || this.sourcePoint, o.target || this.targetPoint);
    }
    this.cleanCache();
  }
  findAnchors(e) {
    const t = this.cell, n = t.source, i = t.target, r = e[0], o = e[e.length - 1];
    return i.priority && !n.priority ? this.findAnchorsOrdered("target", o, "source", r) : this.findAnchorsOrdered("source", r, "target", o);
  }
  findAnchorsOrdered(e, t, n, i) {
    let r, o;
    const a = this.cell, l = a[e], c = a[n], u = this.getTerminalView(e), d = this.getTerminalView(n), f = this.getTerminalMagnet(e), g = this.getTerminalMagnet(n);
    if (u) {
      let p;
      t ? p = M.create(t) : d ? p = g : p = M.create(c), r = this.getAnchor(l.anchor, u, f, p, e);
    } else
      r = M.create(l);
    if (d) {
      const p = M.create(i || r);
      o = this.getAnchor(c.anchor, d, g, p, n);
    } else
      o = M.isPointLike(c) ? M.create(c) : new M();
    return {
      [e]: r,
      [n]: o
    };
  }
  getAnchor(e, t, n, i, r) {
    const o = t.isEdgeElement(n), a = this.graph.options.connecting;
    let l = typeof e == "string" ? { name: e } : e;
    if (!l) {
      const d = o ? (r === "source" ? a.sourceEdgeAnchor : a.targetEdgeAnchor) || a.edgeAnchor : (r === "source" ? a.sourceAnchor : a.targetAnchor) || a.anchor;
      l = typeof d == "string" ? { name: d } : d;
    }
    if (!l)
      throw new Error("Anchor should be specified.");
    let c;
    const u = l.name;
    if (o) {
      const d = hi.registry.get(u);
      if (typeof d != "function")
        return hi.registry.onNotFound(u);
      c = J(d, this, t, n, i, l.args || {}, r);
    } else {
      const d = ci.registry.get(u);
      if (typeof d != "function")
        return ci.registry.onNotFound(u);
      c = J(d, this, t, n, i, l.args || {}, r);
    }
    return c ? c.round(this.POINT_ROUNDING) : new M();
  }
  findRoutePoints(e = []) {
    const t = this.graph.options.connecting.router || On.presets.normal, n = this.cell.getRouter() || t;
    let i;
    if (typeof n == "function")
      i = J(n, this, e, {}, this);
    else {
      const r = typeof n == "string" ? n : n.name, o = typeof n == "string" ? {} : n.args || {}, a = r ? On.registry.get(r) : On.presets.normal;
      if (typeof a != "function")
        return On.registry.onNotFound(r);
      i = J(a, this, e, o, this);
    }
    return i == null ? e.map((r) => M.create(r)) : i.map((r) => M.create(r));
  }
  findConnectionPoints(e, t, n) {
    const i = this.cell, r = this.graph.options.connecting, o = i.getSource(), a = i.getTarget(), l = this.sourceView, c = this.targetView, u = e[0], d = e[e.length - 1];
    let f;
    if (l && !l.isEdgeElement(this.sourceMagnet)) {
      const p = this.sourceMagnet || l.container, m = u || n, w = new $(m, t), v = o.connectionPoint || r.sourceConnectionPoint || r.connectionPoint;
      f = this.getConnectionPoint(v, l, p, w, "source");
    } else
      f = t;
    let g;
    if (c && !c.isEdgeElement(this.targetMagnet)) {
      const p = this.targetMagnet || c.container, m = a.connectionPoint || r.targetConnectionPoint || r.connectionPoint, w = d || t, v = new $(w, n);
      g = this.getConnectionPoint(m, c, p, v, "target");
    } else
      g = n;
    return {
      source: f,
      target: g
    };
  }
  getConnectionPoint(e, t, n, i, r) {
    const o = i.end;
    if (e == null)
      return o;
    const a = typeof e == "string" ? e : e.name, l = typeof e == "string" ? {} : e.args, c = ui.registry.get(a);
    if (typeof c != "function")
      return ui.registry.onNotFound(a);
    const u = J(c, this, i, t, n, l || {}, r);
    return u ? u.round(this.POINT_ROUNDING) : o;
  }
  findMarkerPoints(e, t, n) {
    const i = (d) => {
      const f = this.cell.getAttrs(), g = Object.keys(f);
      for (let p = 0, m = g.length; p < m; p += 1) {
        const w = f[g[p]];
        if (w["".concat(d, "Marker")] || w["".concat(d, "-marker")]) {
          const v = w.strokeWidth || w["stroke-width"];
          if (v)
            return parseFloat(v);
          break;
        }
      }
      return null;
    }, r = e[0], o = e[e.length - 1];
    let a, l;
    const c = i("source");
    c && (a = t.clone().move(r || n, -c));
    const u = i("target");
    return u && (l = n.clone().move(o || t, -u)), this.sourceMarkerPoint = a || t.clone(), this.targetMarkerPoint = l || n.clone(), {
      source: a,
      target: l
    };
  }
  findPath(e, t, n) {
    const i = this.cell.getConnector() || this.graph.options.connecting.connector;
    let r, o, a;
    if (typeof i == "string" ? r = i : (r = i.name, o = i.args), r) {
      const c = ls.registry.get(r);
      if (typeof c != "function")
        return ls.registry.onNotFound(r);
      a = c;
    } else
      a = ls.presets.normal;
    const l = J(a, this, t, n, e, Object.assign(Object.assign({}, o), { raw: !0 }), this);
    return typeof l == "string" ? V.parse(l) : l;
  }
  translateConnectionPoints(e, t) {
    this.sourcePoint.translate(e, t), this.targetPoint.translate(e, t), this.sourceAnchor.translate(e, t), this.targetAnchor.translate(e, t), this.sourceMarkerPoint.translate(e, t), this.targetMarkerPoint.translate(e, t);
  }
  updateLabelPositions() {
    if (this.labelContainer == null)
      return this;
    if (!this.path)
      return this;
    const t = this.cell, n = t.getLabels();
    if (n.length === 0)
      return this;
    const i = t.getDefaultLabel(), r = this.normalizeLabelPosition(i.position);
    for (let o = 0, a = n.length; o < a; o += 1) {
      const l = n[o], c = this.labelCache[o];
      if (!c)
        continue;
      const u = this.normalizeLabelPosition(l.position), d = De({}, r, u), f = this.getLabelTransformationMatrix(d);
      c.setAttribute("transform", xi(f));
    }
    return this;
  }
  updateTerminalProperties(e) {
    const t = this.cell, n = this.graph, i = t[e], r = i && i.cell, o = "".concat(e, "View");
    if (!r)
      return this[o] = null, this.updateTerminalMagnet(e), !0;
    const a = n.getCellById(r);
    if (!a)
      throw new Error("Edge's ".concat(e, ' node with id "').concat(r, '" not exists'));
    const l = a.findView(n);
    return l ? (this[o] = l, this.updateTerminalMagnet(e), !0) : !1;
  }
  updateTerminalMagnet(e) {
    const t = "".concat(e, "Magnet"), n = this.getTerminalView(e);
    if (n) {
      let i = n.getMagnetFromEdgeTerminal(this.cell[e]);
      i === n.container && (i = null), this[t] = i;
    } else
      this[t] = null;
  }
  getLabelPositionAngle(e) {
    const t = this.cell.getLabelAt(e);
    return t && t.position && typeof t.position == "object" && t.position.angle || 0;
  }
  getLabelPositionArgs(e) {
    const t = this.cell.getLabelAt(e);
    if (t && t.position && typeof t.position == "object")
      return t.position.options;
  }
  getDefaultLabelPositionArgs() {
    const e = this.cell.getDefaultLabel();
    if (e && e.position && typeof e.position == "object")
      return e.position.options;
  }
  mergeLabelPositionArgs(e, t) {
    return e === null ? null : e === void 0 ? t === null ? null : t : De({}, t, e);
  }
  // #endregion
  getConnection() {
    return this.path != null ? this.path.clone() : null;
  }
  getConnectionPathData() {
    if (this.path == null)
      return "";
    const e = this.cache.pathCache;
    return Dr(e, "data") || (e.data = this.path.serialize()), e.data || "";
  }
  getConnectionSubdivisions() {
    if (this.path == null)
      return null;
    const e = this.cache.pathCache;
    return Dr(e, "segmentSubdivisions") || (e.segmentSubdivisions = this.path.getSegmentSubdivisions()), e.segmentSubdivisions;
  }
  getConnectionLength() {
    if (this.path == null)
      return 0;
    const e = this.cache.pathCache;
    return Dr(e, "length") || (e.length = this.path.length({
      segmentSubdivisions: this.getConnectionSubdivisions()
    })), e.length;
  }
  getPointAtLength(e) {
    return this.path == null ? null : this.path.pointAtLength(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getPointAtRatio(e) {
    return this.path == null ? null : (un(e) && (e = parseFloat(e) / 100), this.path.pointAt(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    }));
  }
  getTangentAtLength(e) {
    return this.path == null ? null : this.path.tangentAtLength(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getTangentAtRatio(e) {
    return this.path == null ? null : this.path.tangentAt(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getClosestPoint(e) {
    return this.path == null ? null : this.path.closestPoint(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getClosestPointLength(e) {
    return this.path == null ? null : this.path.closestPointLength(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getClosestPointRatio(e) {
    return this.path == null ? null : this.path.closestPointNormalizedLength(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getLabelPosition(e, t, n, i) {
    const r = { distance: 0 };
    let o = 0, a;
    typeof n == "number" ? (o = n, a = i) : a = n, a != null && (r.options = a);
    const l = a && a.absoluteOffset, c = !(a && a.absoluteDistance), u = a && a.absoluteDistance && a.reverseDistance, d = this.path, f = {
      segmentSubdivisions: this.getConnectionSubdivisions()
    }, g = new M(e, t), p = d.closestPointT(g, f), m = this.getConnectionLength() || 0;
    let w = d.lengthAtT(p, f);
    c && (w = m > 0 ? w / m : 0), u && (w = -1 * (m - w) || 1), r.distance = w;
    let v;
    l || (v = d.tangentAtT(p));
    let y;
    if (v)
      y = v.pointOffset(g);
    else {
      const b = d.pointAtT(p), x = g.diff(b);
      y = { x: x.x, y: x.y };
    }
    return r.offset = y, r.angle = o, r;
  }
  normalizeLabelPosition(e) {
    return typeof e == "number" ? { distance: e } : e;
  }
  getLabelTransformationMatrix(e) {
    const t = this.normalizeLabelPosition(e), n = t.options || {}, i = t.angle || 0, r = t.distance, o = r > 0 && r <= 1;
    let a = 0;
    const l = { x: 0, y: 0 }, c = t.offset;
    c && (typeof c == "number" ? a = c : (c.x != null && (l.x = c.x), c.y != null && (l.y = c.y)));
    const u = l.x !== 0 || l.y !== 0 || a === 0, d = n.keepGradient, f = n.ensureLegibility, g = this.path, p = { segmentSubdivisions: this.getConnectionSubdivisions() }, m = o ? r * this.getConnectionLength() : r, w = g.tangentAtLength(m, p);
    let v, y = i;
    if (w) {
      if (u)
        v = w.start, v.translate(l);
      else {
        const b = w.clone();
        b.rotate(-90, w.start), b.setLength(a), v = b.end;
      }
      d && (y = w.angle() + i, f && (y = de.normalize((y + 90) % 180 - 90)));
    } else
      v = g.start, u && v.translate(l);
    return We().translate(v.x, v.y).rotate(y);
  }
  getVertexIndex(e, t) {
    const i = this.cell.getVertices(), r = this.getClosestPointLength(new M(e, t));
    let o = 0;
    if (r != null)
      for (const a = i.length; o < a; o += 1) {
        const l = i[o], c = this.getClosestPointLength(l);
        if (c != null && r < c)
          break;
      }
    return o;
  }
  getEventArgs(e, t, n) {
    const i = this, r = i.cell, o = r;
    return t == null || n == null ? { e, view: i, edge: r, cell: o } : { e, x: t, y: n, view: i, edge: r, cell: o };
  }
  notifyUnhandledMouseDown(e, t, n) {
    this.notify("edge:unhandled:mousedown", {
      e,
      x: t,
      y: n,
      view: this,
      cell: this.cell,
      edge: this.cell
    });
  }
  notifyMouseDown(e, t, n) {
    super.onMouseDown(e, t, n), this.notify("edge:mousedown", this.getEventArgs(e, t, n));
  }
  notifyMouseMove(e, t, n) {
    super.onMouseMove(e, t, n), this.notify("edge:mousemove", this.getEventArgs(e, t, n));
  }
  notifyMouseUp(e, t, n) {
    super.onMouseUp(e, t, n), this.notify("edge:mouseup", this.getEventArgs(e, t, n));
  }
  onClick(e, t, n) {
    super.onClick(e, t, n), this.notify("edge:click", this.getEventArgs(e, t, n));
  }
  onDblClick(e, t, n) {
    super.onDblClick(e, t, n), this.notify("edge:dblclick", this.getEventArgs(e, t, n));
  }
  onContextMenu(e, t, n) {
    super.onContextMenu(e, t, n), this.notify("edge:contextmenu", this.getEventArgs(e, t, n));
  }
  onMouseDown(e, t, n) {
    this.notifyMouseDown(e, t, n), this.startEdgeDragging(e, t, n);
  }
  onMouseMove(e, t, n) {
    const i = this.getEventData(e);
    switch (i.action) {
      case "drag-label": {
        this.dragLabel(e, t, n);
        break;
      }
      case "drag-arrowhead": {
        this.dragArrowhead(e, t, n);
        break;
      }
      case "drag-edge": {
        this.dragEdge(e, t, n);
        break;
      }
    }
    return this.notifyMouseMove(e, t, n), i;
  }
  onMouseUp(e, t, n) {
    const i = this.getEventData(e);
    switch (i.action) {
      case "drag-label": {
        this.stopLabelDragging(e, t, n);
        break;
      }
      case "drag-arrowhead": {
        this.stopArrowheadDragging(e, t, n);
        break;
      }
      case "drag-edge": {
        this.stopEdgeDragging(e, t, n);
        break;
      }
    }
    return this.notifyMouseUp(e, t, n), this.checkMouseleave(e), i;
  }
  onMouseOver(e) {
    super.onMouseOver(e), this.notify("edge:mouseover", this.getEventArgs(e));
  }
  onMouseOut(e) {
    super.onMouseOut(e), this.notify("edge:mouseout", this.getEventArgs(e));
  }
  onMouseEnter(e) {
    super.onMouseEnter(e), this.notify("edge:mouseenter", this.getEventArgs(e));
  }
  onMouseLeave(e) {
    super.onMouseLeave(e), this.notify("edge:mouseleave", this.getEventArgs(e));
  }
  onMouseWheel(e, t, n, i) {
    super.onMouseWheel(e, t, n, i), this.notify("edge:mousewheel", Object.assign({ delta: i }, this.getEventArgs(e, t, n)));
  }
  onCustomEvent(e, t, n, i) {
    if (kf(e.target, "edge-tool", this.container)) {
      if (e.stopPropagation(), this.can("useEdgeTools")) {
        if (t === "edge:remove") {
          this.cell.remove({ ui: !0 });
          return;
        }
        this.notify("edge:customevent", Object.assign({ name: t }, this.getEventArgs(e, n, i)));
      }
      this.notifyMouseDown(e, n, i);
    } else
      this.notify("edge:customevent", Object.assign({ name: t }, this.getEventArgs(e, n, i))), super.onCustomEvent(e, t, n, i);
  }
  onLabelMouseDown(e, t, n) {
    this.notifyMouseDown(e, t, n), this.startLabelDragging(e, t, n), this.getEventData(e).stopPropagation && e.stopPropagation();
  }
  // #region drag edge
  startEdgeDragging(e, t, n) {
    if (!this.can("edgeMovable")) {
      this.notifyUnhandledMouseDown(e, t, n);
      return;
    }
    this.setEventData(e, {
      x: t,
      y: n,
      moving: !1,
      action: "drag-edge"
    });
  }
  dragEdge(e, t, n) {
    const i = this.getEventData(e);
    i.moving || (i.moving = !0, this.addClass("edge-moving"), this.notify("edge:move", {
      e,
      x: t,
      y: n,
      view: this,
      cell: this.cell,
      edge: this.cell
    })), this.cell.translate(t - i.x, n - i.y, { ui: !0 }), this.setEventData(e, { x: t, y: n }), this.notify("edge:moving", {
      e,
      x: t,
      y: n,
      view: this,
      cell: this.cell,
      edge: this.cell
    });
  }
  stopEdgeDragging(e, t, n) {
    const i = this.getEventData(e);
    i.moving && (this.removeClass("edge-moving"), this.notify("edge:moved", {
      e,
      x: t,
      y: n,
      view: this,
      cell: this.cell,
      edge: this.cell
    })), i.moving = !1;
  }
  // #endregion
  // #region drag arrowhead
  prepareArrowheadDragging(e, t) {
    const n = this.getTerminalMagnet(e), i = {
      action: "drag-arrowhead",
      x: t.x,
      y: t.y,
      isNewEdge: t.isNewEdge === !0,
      terminalType: e,
      initialMagnet: n,
      initialTerminal: Ua(this.cell[e]),
      fallbackAction: t.fallbackAction || "revert",
      getValidateConnectionArgs: this.createValidateConnectionArgs(e),
      options: t.options
    };
    return this.beforeArrowheadDragging(i), i;
  }
  createValidateConnectionArgs(e) {
    const t = [];
    t[4] = e, t[5] = this;
    let n, i = 0, r = 0;
    e === "source" ? (i = 2, n = "target") : (r = 2, n = "source");
    const o = this.cell[n], a = o.cell;
    if (a) {
      let l;
      const c = t[i] = this.graph.findViewByCell(a);
      c && (l = c.getMagnetFromEdgeTerminal(o), l === c.container && (l = void 0)), t[i + 1] = l;
    }
    return (l, c) => (t[r] = l, t[r + 1] = l.container === c ? void 0 : c, t);
  }
  beforeArrowheadDragging(e) {
    e.zIndex = this.cell.zIndex, this.cell.toFront();
    const t = this.container.style;
    e.pointerEvents = t.pointerEvents, t.pointerEvents = "none", this.graph.options.connecting.highlight && this.highlightAvailableMagnets(e);
  }
  afterArrowheadDragging(e) {
    e.zIndex != null && (this.cell.setZIndex(e.zIndex, { ui: !0 }), e.zIndex = null);
    const t = this.container;
    t.style.pointerEvents = e.pointerEvents || "", this.graph.options.connecting.highlight && this.unhighlightAvailableMagnets(e);
  }
  validateConnection(e, t, n, i, r, o, a) {
    const l = this.graph.options.connecting, c = l.allowLoop, u = l.allowNode, d = l.allowEdge, f = l.allowPort, g = l.allowMulti, p = l.validateConnection, m = o ? o.cell : null, w = r === "target" ? n : e, v = r === "target" ? i : t;
    let y = !0;
    const b = (x) => {
      const C = r === "source" ? a ? a.port : null : m ? m.getSourcePortId() : null, A = r === "target" ? a ? a.port : null : m ? m.getTargetPortId() : null;
      return J(x, this.graph, {
        edge: m,
        edgeView: o,
        sourceView: e,
        targetView: n,
        sourcePort: C,
        targetPort: A,
        sourceMagnet: t,
        targetMagnet: i,
        sourceCell: e ? e.cell : null,
        targetCell: n ? n.cell : null,
        type: r
      });
    };
    if (c != null && (typeof c == "boolean" ? !c && e === n && (y = !1) : y = b(c)), y && f != null && (typeof f == "boolean" ? !f && v && (y = !1) : y = b(f)), y && d != null && (typeof d == "boolean" ? !d && dn.isEdgeView(w) && (y = !1) : y = b(d)), y && u != null && v == null && (typeof u == "boolean" ? !u && Rt.isNodeView(w) && (y = !1) : y = b(u)), y && g != null && o) {
      const x = o.cell, C = r === "source" ? a : x.getSource(), A = r === "target" ? a : x.getTarget(), k = a ? this.graph.getCellById(a.cell) : null;
      if (C && A && C.cell && A.cell && k)
        if (typeof g == "function")
          y = b(g);
        else {
          const O = this.graph.model.getConnectedEdges(k, {
            outgoing: r === "source",
            incoming: r === "target"
          });
          O.length && (g === "withPort" ? O.some((D) => {
            const N = D.getSource(), F = D.getTarget();
            return N && F && N.cell === C.cell && F.cell === A.cell && N.port != null && N.port === C.port && F.port != null && F.port === A.port;
          }) && (y = !1) : g || O.some((D) => {
            const N = D.getSource(), F = D.getTarget();
            return N && F && N.cell === C.cell && F.cell === A.cell;
          }) && (y = !1));
        }
    }
    return y && p != null && (y = b(p)), y;
  }
  allowConnectToBlank(e) {
    const t = this.graph, i = t.options.connecting.allowBlank;
    if (typeof i != "function")
      return !!i;
    const r = t.findViewByCell(e), o = e.getSourceCell(), a = e.getTargetCell(), l = t.findViewByCell(o), c = t.findViewByCell(a);
    return J(i, t, {
      edge: e,
      edgeView: r,
      sourceCell: o,
      targetCell: a,
      sourceView: l,
      targetView: c,
      sourcePort: e.getSourcePortId(),
      targetPort: e.getTargetPortId(),
      sourceMagnet: r.sourceMagnet,
      targetMagnet: r.targetMagnet
    });
  }
  validateEdge(e, t, n) {
    const i = this.graph;
    if (!this.allowConnectToBlank(e)) {
      const o = e.getSourceCellId(), a = e.getTargetCellId();
      if (!(o && a))
        return !1;
    }
    const r = i.options.connecting.validateEdge;
    return r ? J(r, i, {
      edge: e,
      type: t,
      previous: n
    }) : !0;
  }
  arrowheadDragging(e, t, n, i) {
    i.x = t, i.y = n, i.currentTarget !== e && (i.currentMagnet && i.currentView && i.currentView.unhighlight(i.currentMagnet, {
      type: "magnetAdsorbed"
    }), i.currentView = this.graph.findViewByElem(e), i.currentView ? (i.currentMagnet = i.currentView.findMagnet(e), i.currentMagnet && this.validateConnection(...i.getValidateConnectionArgs(i.currentView, i.currentMagnet), i.currentView.getEdgeTerminal(i.currentMagnet, t, n, this.cell, i.terminalType)) ? i.currentView.highlight(i.currentMagnet, {
      type: "magnetAdsorbed"
    }) : i.currentMagnet = null) : i.currentMagnet = null), i.currentTarget = e, this.cell.prop(i.terminalType, { x: t, y: n }, Object.assign(Object.assign({}, i.options), { ui: !0 }));
  }
  arrowheadDragged(e, t, n) {
    const i = e.currentView, r = e.currentMagnet;
    if (!r || !i)
      return;
    i.unhighlight(r, { type: "magnetAdsorbed" });
    const o = e.terminalType, a = i.getEdgeTerminal(r, t, n, this.cell, o);
    this.cell.setTerminal(o, a, { ui: !0 });
  }
  snapArrowhead(e, t, n) {
    const i = this.graph, { snap: r, allowEdge: o } = i.options.connecting, a = typeof r == "object" && r.radius || 50, l = typeof r == "object" && r.anchor || "center", c = i.renderer.findViewsInArea({
      x: e - a,
      y: t - a,
      width: 2 * a,
      height: 2 * a
    }, { nodeOnly: !0 });
    if (o) {
      const x = i.renderer.findEdgeViewsFromPoint({ x: e, y: t }, a).filter((C) => C !== this);
      c.push(...x);
    }
    const u = n.closestView || null, d = n.closestMagnet || null;
    n.closestView = null, n.closestMagnet = null;
    let f, g = Number.MAX_SAFE_INTEGER;
    const p = new M(e, t);
    c.forEach((x) => {
      if (x.container.getAttribute("magnet") !== "false") {
        if (x.isNodeView())
          f = l === "center" ? x.cell.getBBox().getCenter().distance(p) : x.cell.getBBox().getNearestPointToPoint(p).distance(p);
        else if (x.isEdgeView()) {
          const C = x.getClosestPoint(p);
          C ? f = C.distance(p) : f = Number.MAX_SAFE_INTEGER;
        }
        f < a && f < g && (d === x.container || this.validateConnection(...n.getValidateConnectionArgs(x, null), x.getEdgeTerminal(x.container, e, t, this.cell, n.terminalType))) && (g = f, n.closestView = x, n.closestMagnet = x.container);
      }
      x.container.querySelectorAll("[magnet]").forEach((C) => {
        if (C.getAttribute("magnet") !== "false") {
          const A = x.getBBoxOfElement(C);
          f = p.distance(A.getCenter()), f < a && f < g && (d === C || this.validateConnection(...n.getValidateConnectionArgs(x, C), x.getEdgeTerminal(C, e, t, this.cell, n.terminalType))) && (g = f, n.closestView = x, n.closestMagnet = C);
        }
      });
    });
    let m;
    const w = n.terminalType, v = n.closestView, y = n.closestMagnet, b = d !== y;
    if (u && b && u.unhighlight(d, {
      type: "magnetAdsorbed"
    }), v) {
      if (!b)
        return;
      v.highlight(y, {
        type: "magnetAdsorbed"
      }), m = v.getEdgeTerminal(y, e, t, this.cell, w);
    } else
      m = { x: e, y: t };
    this.cell.setTerminal(w, m, {}, Object.assign(Object.assign({}, n.options), { ui: !0 }));
  }
  snapArrowheadEnd(e) {
    const t = e.closestView, n = e.closestMagnet;
    t && n && (t.unhighlight(n, {
      type: "magnetAdsorbed"
    }), e.currentMagnet = t.findMagnet(n)), e.closestView = null, e.closestMagnet = null;
  }
  finishEmbedding(e) {
    this.graph.options.embedding.enabled && this.cell.updateParent() && (e.zIndex = null);
  }
  fallbackConnection(e) {
    switch (e.fallbackAction) {
      case "remove":
        this.cell.remove({ ui: !0 });
        break;
      case "revert":
      default:
        this.cell.prop(e.terminalType, e.initialTerminal, {
          ui: !0
        });
        break;
    }
  }
  notifyConnectionEvent(e, t) {
    const n = e.terminalType, i = e.initialTerminal, r = this.cell[n];
    if (r && !Me.equalTerminals(i, r)) {
      const a = this.graph, l = i, c = l.cell ? a.getCellById(l.cell) : null, u = l.port, d = c ? a.findViewByCell(c) : null, f = c || e.isNewEdge ? null : M.create(i).toJSON(), g = r, p = g.cell ? a.getCellById(g.cell) : null, m = g.port, w = p ? a.findViewByCell(p) : null, v = p ? null : M.create(r).toJSON();
      this.notify("edge:connected", {
        e: t,
        previousCell: c,
        previousPort: u,
        previousView: d,
        previousPoint: f,
        currentCell: p,
        currentView: w,
        currentPort: m,
        currentPoint: v,
        previousMagnet: e.initialMagnet,
        currentMagnet: e.currentMagnet,
        edge: this.cell,
        view: this,
        type: n,
        isNew: e.isNewEdge
      });
    }
  }
  highlightAvailableMagnets(e) {
    const t = this.graph, n = t.model.getCells();
    e.marked = {};
    for (let i = 0, r = n.length; i < r; i += 1) {
      const o = t.findViewByCell(n[i]);
      if (!o || o.cell.id === this.cell.id)
        continue;
      const a = Array.prototype.slice.call(o.container.querySelectorAll("[magnet]"));
      o.container.getAttribute("magnet") !== "false" && a.push(o.container);
      const l = a.filter((c) => this.validateConnection(...e.getValidateConnectionArgs(o, c), o.getEdgeTerminal(c, e.x, e.y, this.cell, e.terminalType)));
      if (l.length > 0) {
        for (let c = 0, u = l.length; c < u; c += 1)
          o.highlight(l[c], { type: "magnetAvailable" });
        o.highlight(null, { type: "nodeAvailable" }), e.marked[o.cell.id] = l;
      }
    }
  }
  unhighlightAvailableMagnets(e) {
    const t = e.marked || {};
    Object.keys(t).forEach((n) => {
      const i = this.graph.findViewByCell(n);
      i && (t[n].forEach((o) => {
        i.unhighlight(o, { type: "magnetAvailable" });
      }), i.unhighlight(null, { type: "nodeAvailable" }));
    }), e.marked = null;
  }
  startArrowheadDragging(e, t, n) {
    if (!this.can("arrowheadMovable")) {
      this.notifyUnhandledMouseDown(e, t, n);
      return;
    }
    const r = e.target.getAttribute("data-terminal"), o = this.prepareArrowheadDragging(r, { x: t, y: n });
    this.setEventData(e, o);
  }
  dragArrowhead(e, t, n) {
    const i = this.getEventData(e);
    this.graph.options.connecting.snap ? this.snapArrowhead(t, n, i) : this.arrowheadDragging(this.getEventTarget(e), t, n, i);
  }
  stopArrowheadDragging(e, t, n) {
    const i = this.graph, r = this.getEventData(e);
    i.options.connecting.snap ? this.snapArrowheadEnd(r) : this.arrowheadDragged(r, t, n), this.validateEdge(this.cell, r.terminalType, r.initialTerminal) ? (this.finishEmbedding(r), this.notifyConnectionEvent(r, e)) : this.fallbackConnection(r), this.afterArrowheadDragging(r);
  }
  // #endregion
  // #region drag lable
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  startLabelDragging(e, t, n) {
    if (this.can("edgeLabelMovable")) {
      const i = e.currentTarget, r = parseInt(i.getAttribute("data-index"), 10), o = this.getLabelPositionAngle(r), a = this.getLabelPositionArgs(r), l = this.getDefaultLabelPositionArgs(), c = this.mergeLabelPositionArgs(a, l);
      this.setEventData(e, {
        index: r,
        positionAngle: o,
        positionArgs: c,
        stopPropagation: !0,
        action: "drag-label"
      });
    } else
      this.setEventData(e, { stopPropagation: !0 });
    this.graph.view.delegateDragEvents(e, this);
  }
  dragLabel(e, t, n) {
    const i = this.getEventData(e), r = this.cell.getLabelAt(i.index), o = De({}, r, {
      position: this.getLabelPosition(t, n, i.positionAngle, i.positionArgs)
    });
    this.cell.setLabelAt(i.index, o);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  stopLabelDragging(e, t, n) {
  }
}
(function(s) {
  s.toStringTag = "X6.".concat(s.name);
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof s)
      return !0;
    const n = t[Symbol.toStringTag], i = t;
    return (n == null || n === s.toStringTag) && typeof i.isNodeView == "function" && typeof i.isEdgeView == "function" && typeof i.confirmUpdate == "function" && typeof i.update == "function" && typeof i.getConnection == "function";
  }
  s.isEdgeView = e;
})(dn || (dn = {}));
dn.config({
  isSvgElement: !0,
  priority: 1,
  bootstrap: ["render", "source", "target"],
  actions: {
    view: ["render"],
    markup: ["render"],
    attrs: ["update"],
    source: ["source", "update"],
    target: ["target", "update"],
    router: ["update"],
    connector: ["update"],
    labels: ["labels"],
    defaultLabel: ["labels"],
    tools: ["tools"],
    vertices: ["vertices", "update"]
  }
});
dn.registry.register("edge", dn, !0);
var t5 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class Zt extends ve {
  /** Graph's `this.container` is from outer, should not dispose */
  get disposeContainer() {
    return !1;
  }
  get options() {
    return this.graph.options;
  }
  constructor(e) {
    super(), this.graph = e;
    const { selectors: t, fragment: n } = be.parseJSONMarkup(Zt.markup);
    this.background = t.background, this.grid = t.grid, this.svg = t.svg, this.defs = t.defs, this.viewport = t.viewport, this.primer = t.primer, this.stage = t.stage, this.decorator = t.decorator, this.overlay = t.overlay, this.container = this.options.container, this.restore = Zt.snapshoot(this.container), ie(this.container, this.prefixClassName("graph")), Er(this.container, n), this.delegateEvents();
  }
  delegateEvents() {
    const e = this.constructor;
    return super.delegateEvents(e.events), this;
  }
  /**
   * Guard the specified event. If the event is not interesting, it
   * returns `true`, otherwise returns `false`.
   */
  guard(e, t) {
    return e.type === "mousedown" && e.button === 2 || this.options.guard && this.options.guard(e, t) ? !0 : e.data && e.data.guarded !== void 0 ? e.data.guarded : !(t && t.cell && se.isCell(t.cell) || this.svg === e.target || this.container === e.target || this.svg.contains(e.target));
  }
  findView(e) {
    return this.graph.findViewByElem(e);
  }
  onDblClick(e) {
    this.options.preventDefaultDblClick && e.preventDefault();
    const t = this.normalizeEvent(e), n = this.findView(t.target);
    if (this.guard(t, n))
      return;
    const i = this.graph.snapToGrid(t.clientX, t.clientY);
    n ? n.onDblClick(t, i.x, i.y) : this.graph.trigger("blank:dblclick", {
      e: t,
      x: i.x,
      y: i.y
    });
  }
  onClick(e) {
    if (this.getMouseMovedCount(e) <= this.options.clickThreshold) {
      const t = this.normalizeEvent(e), n = this.findView(t.target);
      if (this.guard(t, n))
        return;
      const i = this.graph.snapToGrid(t.clientX, t.clientY);
      n ? n.onClick(t, i.x, i.y) : this.graph.trigger("blank:click", {
        e: t,
        x: i.x,
        y: i.y
      });
    }
  }
  isPreventDefaultContextMenu(e) {
    let t = this.options.preventDefaultContextMenu;
    return typeof t == "function" && (t = J(t, this.graph, { view: e })), t;
  }
  onContextMenu(e) {
    const t = this.normalizeEvent(e), n = this.findView(t.target);
    if (this.isPreventDefaultContextMenu(n) && e.preventDefault(), this.guard(t, n))
      return;
    const i = this.graph.snapToGrid(t.clientX, t.clientY);
    n ? n.onContextMenu(t, i.x, i.y) : this.graph.trigger("blank:contextmenu", {
      e: t,
      x: i.x,
      y: i.y
    });
  }
  delegateDragEvents(e, t) {
    e.data == null && (e.data = {}), this.setEventData(e, {
      currentView: t || null,
      mouseMovedCount: 0,
      startPosition: {
        x: e.clientX,
        y: e.clientY
      }
    });
    const n = this.constructor;
    this.delegateDocumentEvents(n.documentEvents, e.data), this.undelegateEvents();
  }
  getMouseMovedCount(e) {
    return this.getEventData(e).mouseMovedCount || 0;
  }
  onMouseDown(e) {
    const t = this.normalizeEvent(e), n = this.findView(t.target);
    if (this.guard(t, n))
      return;
    this.options.preventDefaultMouseDown && e.preventDefault();
    const i = this.graph.snapToGrid(t.clientX, t.clientY);
    n ? n.onMouseDown(t, i.x, i.y) : (this.options.preventDefaultBlankAction && ["touchstart"].includes(t.type) && e.preventDefault(), this.graph.trigger("blank:mousedown", {
      e: t,
      x: i.x,
      y: i.y
    })), this.delegateDragEvents(t, n);
  }
  onMouseMove(e) {
    const t = this.getEventData(e), n = t.startPosition;
    if (n && n.x === e.clientX && n.y === e.clientY || (t.mouseMovedCount == null && (t.mouseMovedCount = 0), t.mouseMovedCount += 1, t.mouseMovedCount <= this.options.moveThreshold))
      return;
    const r = this.normalizeEvent(e), o = this.graph.snapToGrid(r.clientX, r.clientY), a = t.currentView;
    a ? a.onMouseMove(r, o.x, o.y) : this.graph.trigger("blank:mousemove", {
      e: r,
      x: o.x,
      y: o.y
    }), this.setEventData(r, t);
  }
  onMouseUp(e) {
    this.undelegateDocumentEvents();
    const t = this.normalizeEvent(e), n = this.graph.snapToGrid(t.clientX, t.clientY), r = this.getEventData(e).currentView;
    if (r ? r.onMouseUp(t, n.x, n.y) : this.graph.trigger("blank:mouseup", {
      e: t,
      x: n.x,
      y: n.y
    }), !e.isPropagationStopped()) {
      const o = new Wt(e, {
        type: "click",
        data: e.data
      });
      this.onClick(o);
    }
    e.stopImmediatePropagation(), this.delegateEvents();
  }
  onMouseOver(e) {
    const t = this.normalizeEvent(e), n = this.findView(t.target);
    if (!this.guard(t, n))
      if (n)
        n.onMouseOver(t);
      else {
        if (this.container === t.target)
          return;
        this.graph.trigger("blank:mouseover", { e: t });
      }
  }
  onMouseOut(e) {
    const t = this.normalizeEvent(e), n = this.findView(t.target);
    if (!this.guard(t, n))
      if (n)
        n.onMouseOut(t);
      else {
        if (this.container === t.target)
          return;
        this.graph.trigger("blank:mouseout", { e: t });
      }
  }
  onMouseEnter(e) {
    const t = this.normalizeEvent(e), n = this.findView(t.target);
    if (this.guard(t, n))
      return;
    const i = this.graph.findViewByElem(t.relatedTarget);
    if (n) {
      if (i === n)
        return;
      n.onMouseEnter(t);
    } else {
      if (i)
        return;
      this.graph.trigger("graph:mouseenter", { e: t });
    }
  }
  onMouseLeave(e) {
    const t = this.normalizeEvent(e), n = this.findView(t.target);
    if (this.guard(t, n))
      return;
    const i = this.graph.findViewByElem(t.relatedTarget);
    if (n) {
      if (i === n)
        return;
      n.onMouseLeave(t);
    } else {
      if (i)
        return;
      this.graph.trigger("graph:mouseleave", { e: t });
    }
  }
  onMouseWheel(e) {
    const t = this.normalizeEvent(e), n = this.findView(t.target);
    if (this.guard(t, n))
      return;
    const i = t.originalEvent, r = this.graph.snapToGrid(i.clientX, i.clientY), o = Math.max(-1, Math.min(1, i.wheelDelta || -i.detail));
    n ? n.onMouseWheel(t, r.x, r.y, o) : this.graph.trigger("blank:mousewheel", {
      e: t,
      delta: o,
      x: r.x,
      y: r.y
    });
  }
  onCustomEvent(e) {
    const t = e.currentTarget, n = t.getAttribute("event") || t.getAttribute("data-event");
    if (n) {
      const i = this.findView(t);
      if (i) {
        const r = this.normalizeEvent(e);
        if (this.guard(r, i))
          return;
        const o = this.graph.snapToGrid(r.clientX, r.clientY);
        i.onCustomEvent(r, n, o.x, o.y);
      }
    }
  }
  handleMagnetEvent(e, t) {
    const n = e.currentTarget, i = n.getAttribute("magnet");
    if (i && i.toLowerCase() !== "false") {
      const r = this.findView(n);
      if (r) {
        const o = this.normalizeEvent(e);
        if (this.guard(o, r))
          return;
        const a = this.graph.snapToGrid(o.clientX, o.clientY);
        J(t, this.graph, r, o, n, a.x, a.y);
      }
    }
  }
  onMagnetMouseDown(e) {
    this.handleMagnetEvent(e, (t, n, i, r, o) => {
      t.onMagnetMouseDown(n, i, r, o);
    });
  }
  onMagnetDblClick(e) {
    this.handleMagnetEvent(e, (t, n, i, r, o) => {
      t.onMagnetDblClick(n, i, r, o);
    });
  }
  onMagnetContextMenu(e) {
    const t = this.findView(e.target);
    this.isPreventDefaultContextMenu(t) && e.preventDefault(), this.handleMagnetEvent(e, (n, i, r, o, a) => {
      n.onMagnetContextMenu(i, r, o, a);
    });
  }
  onLabelMouseDown(e) {
    const t = e.currentTarget, n = this.findView(t);
    if (n) {
      const i = this.normalizeEvent(e);
      if (this.guard(i, n))
        return;
      const r = this.graph.snapToGrid(i.clientX, i.clientY);
      n.onLabelMouseDown(i, r.x, r.y);
    }
  }
  onImageDragStart() {
    return !1;
  }
  dispose() {
    this.undelegateEvents(), this.undelegateDocumentEvents(), this.restore(), this.restore = () => {
    };
  }
}
t5([
  ve.dispose()
], Zt.prototype, "dispose", null);
(function(s) {
  const e = "".concat(jt.prefixCls, "-graph");
  s.markup = [
    {
      ns: Ue.xhtml,
      tagName: "div",
      selector: "background",
      className: "".concat(e, "-background")
    },
    {
      ns: Ue.xhtml,
      tagName: "div",
      selector: "grid",
      className: "".concat(e, "-grid")
    },
    {
      ns: Ue.svg,
      tagName: "svg",
      selector: "svg",
      className: "".concat(e, "-svg"),
      attrs: {
        width: "100%",
        height: "100%",
        "xmlns:xlink": Ue.xlink
      },
      children: [
        {
          tagName: "defs",
          selector: "defs"
        },
        {
          tagName: "g",
          selector: "viewport",
          className: "".concat(e, "-svg-viewport"),
          children: [
            {
              tagName: "g",
              selector: "primer",
              className: "".concat(e, "-svg-primer")
            },
            {
              tagName: "g",
              selector: "stage",
              className: "".concat(e, "-svg-stage")
            },
            {
              tagName: "g",
              selector: "decorator",
              className: "".concat(e, "-svg-decorator")
            },
            {
              tagName: "g",
              selector: "overlay",
              className: "".concat(e, "-svg-overlay")
            }
          ]
        }
      ]
    }
  ];
  function t(n) {
    const i = n.cloneNode();
    return n.childNodes.forEach((r) => i.appendChild(r)), () => {
      for (Cr(n); n.attributes.length > 0; )
        n.removeAttribute(n.attributes[0].name);
      for (let r = 0, o = i.attributes.length; r < o; r += 1) {
        const a = i.attributes[r];
        n.setAttribute(a.name, a.value);
      }
      i.childNodes.forEach((r) => n.appendChild(r));
    };
  }
  s.snapshoot = t;
})(Zt || (Zt = {}));
(function(s) {
  const e = jt.prefixCls;
  s.events = {
    dblclick: "onDblClick",
    contextmenu: "onContextMenu",
    touchstart: "onMouseDown",
    mousedown: "onMouseDown",
    mouseover: "onMouseOver",
    mouseout: "onMouseOut",
    mouseenter: "onMouseEnter",
    mouseleave: "onMouseLeave",
    mousewheel: "onMouseWheel",
    DOMMouseScroll: "onMouseWheel",
    ["mouseenter  .".concat(e, "-cell")]: "onMouseEnter",
    ["mouseleave  .".concat(e, "-cell")]: "onMouseLeave",
    ["mouseenter  .".concat(e, "-cell-tools")]: "onMouseEnter",
    ["mouseleave  .".concat(e, "-cell-tools")]: "onMouseLeave",
    ["mousedown   .".concat(e, "-cell [event]")]: "onCustomEvent",
    ["touchstart  .".concat(e, "-cell [event]")]: "onCustomEvent",
    ["mousedown   .".concat(e, "-cell [data-event]")]: "onCustomEvent",
    ["touchstart  .".concat(e, "-cell [data-event]")]: "onCustomEvent",
    ["dblclick    .".concat(e, "-cell [magnet]")]: "onMagnetDblClick",
    ["contextmenu .".concat(e, "-cell [magnet]")]: "onMagnetContextMenu",
    ["mousedown   .".concat(e, "-cell [magnet]")]: "onMagnetMouseDown",
    ["touchstart  .".concat(e, "-cell [magnet]")]: "onMagnetMouseDown",
    ["dblclick    .".concat(e, "-cell [data-magnet]")]: "onMagnetDblClick",
    ["contextmenu .".concat(e, "-cell [data-magnet]")]: "onMagnetContextMenu",
    ["mousedown   .".concat(e, "-cell [data-magnet]")]: "onMagnetMouseDown",
    ["touchstart  .".concat(e, "-cell [data-magnet]")]: "onMagnetMouseDown",
    ["dragstart   .".concat(e, "-cell image")]: "onImageDragStart",
    ["mousedown   .".concat(e, "-edge .").concat(e, "-edge-label")]: "onLabelMouseDown",
    ["touchstart  .".concat(e, "-edge .").concat(e, "-edge-label")]: "onLabelMouseDown"
  }, s.documentEvents = {
    mousemove: "onMouseMove",
    touchmove: "onMouseMove",
    mouseup: "onMouseUp",
    touchend: "onMouseUp",
    touchcancel: "onMouseUp"
  };
})(Zt || (Zt = {}));
const n5 = ".x6-graph {\n  position: relative;\n  overflow: hidden;\n  outline: none;\n  touch-action: none;\n}\n.x6-graph-background,\n.x6-graph-grid,\n.x6-graph-svg {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.x6-graph-background-stage,\n.x6-graph-grid-stage,\n.x6-graph-svg-stage {\n  user-select: none;\n}\n.x6-graph.x6-graph-pannable {\n  cursor: grab;\n  cursor: -moz-grab;\n  cursor: -webkit-grab;\n}\n.x6-graph.x6-graph-panning {\n  cursor: grabbing;\n  cursor: -moz-grabbing;\n  cursor: -webkit-grabbing;\n  user-select: none;\n}\n.x6-node {\n  cursor: move;\n  /* stylelint-disable-next-line */\n}\n.x6-node.x6-node-immovable {\n  cursor: default;\n}\n.x6-node * {\n  -webkit-user-drag: none;\n}\n.x6-node .scalable * {\n  vector-effect: non-scaling-stroke;\n}\n.x6-node [magnet='true'] {\n  cursor: crosshair;\n  transition: opacity 0.3s;\n}\n.x6-node [magnet='true']:hover {\n  opacity: 0.7;\n}\n.x6-node foreignObject {\n  display: block;\n  overflow: visible;\n  background-color: transparent;\n}\n.x6-node foreignObject > body {\n  position: static;\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  overflow: visible;\n  background-color: transparent;\n}\n.x6-edge .source-marker,\n.x6-edge .target-marker {\n  vector-effect: non-scaling-stroke;\n}\n.x6-edge .connection {\n  stroke-linejoin: round;\n  fill: none;\n}\n.x6-edge .connection-wrap {\n  cursor: move;\n  opacity: 0;\n  fill: none;\n  stroke: #000;\n  stroke-width: 15;\n  stroke-linecap: round;\n  stroke-linejoin: round;\n}\n.x6-edge .connection-wrap:hover {\n  opacity: 0.4;\n  stroke-opacity: 0.4;\n}\n.x6-edge .vertices {\n  cursor: move;\n  opacity: 0;\n}\n.x6-edge .vertices .vertex {\n  fill: #1abc9c;\n}\n.x6-edge .vertices .vertex :hover {\n  fill: #34495e;\n  stroke: none;\n}\n.x6-edge .vertices .vertex-remove {\n  cursor: pointer;\n  fill: #fff;\n}\n.x6-edge .vertices .vertex-remove-area {\n  cursor: pointer;\n  opacity: 0.1;\n}\n.x6-edge .vertices .vertex-group:hover .vertex-remove-area {\n  opacity: 1;\n}\n.x6-edge .arrowheads {\n  cursor: move;\n  opacity: 0;\n}\n.x6-edge .arrowheads .arrowhead {\n  fill: #1abc9c;\n}\n.x6-edge .arrowheads .arrowhead :hover {\n  fill: #f39c12;\n  stroke: none;\n}\n.x6-edge .tools {\n  cursor: pointer;\n  opacity: 0;\n}\n.x6-edge .tools .tool-options {\n  display: none;\n}\n.x6-edge .tools .tool-remove circle {\n  fill: #f00;\n}\n.x6-edge .tools .tool-remove path {\n  fill: #fff;\n}\n.x6-edge:hover .vertices,\n.x6-edge:hover .arrowheads,\n.x6-edge:hover .tools {\n  opacity: 1;\n}\n.x6-highlight-opacity {\n  opacity: 0.3;\n}\n.x6-cell-tool-editor {\n  position: relative;\n  display: inline-block;\n  min-height: 1em;\n  margin: 0;\n  padding: 0;\n  line-height: 1;\n  white-space: normal;\n  text-align: center;\n  vertical-align: top;\n  overflow-wrap: normal;\n  outline: none;\n  transform-origin: 0 0;\n  -webkit-user-drag: none;\n}\n.x6-edge-tool-editor {\n  border: 1px solid #275fc5;\n  border-radius: 2px;\n}\n";
class Je extends hn {
  get options() {
    return this.graph.options;
  }
  get model() {
    return this.graph.model;
  }
  get view() {
    return this.graph.view;
  }
  constructor(e) {
    super(), this.graph = e, this.init();
  }
  init() {
  }
}
var s5 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class El extends Je {
  init() {
    u3("core", n5);
  }
  dispose() {
    d3("core");
  }
}
s5([
  El.dispose()
], El.prototype, "dispose", null);
var i5 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
}, dr;
(function(s) {
  function e(t) {
    const { grid: n, panning: i, mousewheel: r, embedding: o } = t, a = i5(
      t,
      ["grid", "panning", "mousewheel", "embedding"]
    ), l = t.container;
    if (l != null)
      a.width == null && (a.width = l.clientWidth), a.height == null && (a.height = l.clientHeight);
    else
      throw new Error("Ensure the container of the graph is specified and valid");
    const c = De({}, s.defaults, a), u = { size: 10, visible: !1 };
    return typeof n == "number" ? c.grid = { size: n, visible: !1 } : typeof n == "boolean" ? c.grid = Object.assign(Object.assign({}, u), { visible: n }) : c.grid = Object.assign(Object.assign({}, u), n), [
      "panning",
      "mousewheel",
      "embedding"
    ].forEach((f) => {
      const g = t[f];
      typeof g == "boolean" ? c[f].enabled = g : c[f] = Object.assign(Object.assign({}, c[f]), g);
    }), c;
  }
  s.get = e;
})(dr || (dr = {}));
(function(s) {
  s.defaults = {
    x: 0,
    y: 0,
    scaling: {
      min: 0.01,
      max: 16
    },
    grid: {
      size: 10,
      visible: !1
    },
    background: !1,
    panning: {
      enabled: !1,
      eventTypes: ["leftMouseDown"]
    },
    mousewheel: {
      enabled: !1,
      factor: 1.2,
      zoomAtMousePosition: !0
    },
    highlighting: {
      default: {
        name: "stroke",
        args: {
          padding: 3
        }
      },
      nodeAvailable: {
        name: "className",
        args: {
          className: jt.prefix("available-node")
        }
      },
      magnetAvailable: {
        name: "className",
        args: {
          className: jt.prefix("available-magnet")
        }
      }
    },
    connecting: {
      snap: !1,
      allowLoop: !0,
      allowNode: !0,
      allowEdge: !1,
      allowPort: !0,
      allowBlank: !0,
      allowMulti: !0,
      highlight: !1,
      anchor: "center",
      edgeAnchor: "ratio",
      connectionPoint: "boundary",
      router: "normal",
      connector: "normal",
      validateConnection({ type: e, sourceView: t, targetView: n }) {
        return (e === "target" ? n : t) != null;
      },
      createEdge() {
        return new Xb();
      }
    },
    translating: {
      restrict: !1
    },
    embedding: {
      enabled: !1,
      findParent: "bbox",
      frontOnly: !0,
      validate: () => !0
    },
    moveThreshold: 0,
    clickThreshold: 0,
    magnetThreshold: 0,
    preventDefaultDblClick: !0,
    preventDefaultMouseDown: !1,
    preventDefaultContextMenu: !0,
    preventDefaultBlankAction: !0,
    interacting: {
      edgeLabelMovable: !1
    },
    async: !0,
    virtual: !1,
    guard: () => !1
  };
})(dr || (dr = {}));
var r5 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
}, o5 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
class bc extends Je {
  get elem() {
    return this.view.grid;
  }
  get grid() {
    return this.options.grid;
  }
  init() {
    this.startListening(), this.draw(this.grid);
  }
  startListening() {
    this.graph.on("scale", this.update, this), this.graph.on("translate", this.update, this);
  }
  stopListening() {
    this.graph.off("scale", this.update, this), this.graph.off("translate", this.update, this);
  }
  setVisible(e) {
    this.grid.visible !== e && (this.grid.visible = e, this.update());
  }
  getGridSize() {
    return this.grid.size;
  }
  setGridSize(e) {
    this.grid.size = Math.max(e, 1), this.update();
  }
  show() {
    this.setVisible(!0), this.update();
  }
  hide() {
    this.setVisible(!1), this.update();
  }
  clear() {
    this.elem.style.backgroundImage = "";
  }
  draw(e) {
    this.clear(), this.instance = null, Object.assign(this.grid, e), this.patterns = this.resolveGrid(e), this.update();
  }
  update(e = {}) {
    const t = this.grid.size;
    if (t <= 1 || !this.grid.visible)
      return this.clear();
    const n = this.graph.matrix(), i = this.getInstance(), r = Array.isArray(e) ? e : [e];
    this.patterns.forEach((l, c) => {
      const u = "pattern_".concat(c), d = n.a || 1, f = n.d || 1, { update: g, markup: p } = l, m = o5(l, ["update", "markup"]), w = Object.assign(Object.assign(Object.assign({}, m), r[c]), {
        sx: d,
        sy: f,
        ox: n.e || 0,
        oy: n.f || 0,
        width: t * d,
        height: t * f
      });
      i.has(u) || i.add(u, G.create("pattern", { id: u, patternUnits: "userSpaceOnUse" }, G.createVectors(p)).node);
      const v = i.get(u);
      typeof g == "function" && g(v.childNodes[0], w);
      let y = w.ox % w.width;
      y < 0 && (y += w.width);
      let b = w.oy % w.height;
      b < 0 && (b += w.height), ge(v, {
        x: y,
        y: b,
        width: w.width,
        height: w.height
      });
    });
    const o = new XMLSerializer().serializeToString(i.root), a = "url(data:image/svg+xml;base64,".concat(btoa(o), ")");
    this.elem.style.backgroundImage = a;
  }
  getInstance() {
    return this.instance || (this.instance = new _n()), this.instance;
  }
  resolveGrid(e) {
    if (!e)
      return [];
    const t = e.type;
    if (t == null)
      return [
        Object.assign(Object.assign({}, _n.presets.dot), e.args)
      ];
    const n = _n.registry.get(t);
    if (n) {
      let i = e.args || [];
      return Array.isArray(i) || (i = [i]), Array.isArray(n) ? n.map((r, o) => Object.assign(Object.assign({}, r), i[o])) : [Object.assign(Object.assign({}, n), i[0])];
    }
    return _n.registry.onNotFound(t);
  }
  dispose() {
    this.stopListening(), this.clear();
  }
}
r5([
  Je.dispose()
], bc.prototype, "dispose", null);
class Rg extends Je {
  get container() {
    return this.graph.view.container;
  }
  get viewport() {
    return this.graph.view.viewport;
  }
  get stage() {
    return this.graph.view.stage;
  }
  init() {
    this.resize();
  }
  /**
   * Returns the current transformation matrix of the graph.
   */
  getMatrix() {
    const e = this.viewport.getAttribute("transform");
    return e !== this.viewportTransformString && (this.viewportMatrix = this.viewport.getCTM(), this.viewportTransformString = e), We(this.viewportMatrix);
  }
  /**
   * Sets new transformation with the given `matrix`
   */
  setMatrix(e) {
    const t = We(e), n = xi(t);
    this.viewport.setAttribute("transform", n), this.viewportMatrix = t, this.viewportTransformString = n;
  }
  resize(e, t) {
    let n = e === void 0 ? this.options.width : e, i = t === void 0 ? this.options.height : t;
    this.options.width = n, this.options.height = i, typeof n == "number" && (n = Math.round(n)), typeof i == "number" && (i = Math.round(i)), this.container.style.width = n == null ? "" : "".concat(n, "px"), this.container.style.height = i == null ? "" : "".concat(i, "px");
    const r = this.getComputedSize();
    return this.graph.trigger("resize", Object.assign({}, r)), this;
  }
  getComputedSize() {
    let e = this.options.width, t = this.options.height;
    return Lc(e) || (e = this.container.clientWidth), Lc(t) || (t = this.container.clientHeight), { width: e, height: t };
  }
  getScale() {
    return n3(this.getMatrix());
  }
  scale(e, t = e, n = 0, i = 0) {
    if (e = this.clampScale(e), t = this.clampScale(t), n || i) {
      const o = this.getTranslation(), a = o.tx - n * (e - 1), l = o.ty - i * (t - 1);
      (a !== o.tx || l !== o.ty) && this.translate(a, l);
    }
    const r = this.getMatrix();
    return r.a = e, r.d = t, this.setMatrix(r), this.graph.trigger("scale", { sx: e, sy: t, ox: n, oy: i }), this;
  }
  clampScale(e) {
    const t = this.graph.options.scaling;
    return Mt(e, t.min || 0.01, t.max || 16);
  }
  getZoom() {
    return this.getScale().sx;
  }
  zoom(e, t) {
    t = t || {};
    let n = e, i = e;
    const r = this.getScale(), o = this.getComputedSize();
    let a = o.width / 2, l = o.height / 2;
    if (t.absolute || (n += r.sx, i += r.sy), t.scaleGrid && (n = Math.round(n / t.scaleGrid) * t.scaleGrid, i = Math.round(i / t.scaleGrid) * t.scaleGrid), t.maxScale && (n = Math.min(t.maxScale, n), i = Math.min(t.maxScale, i)), t.minScale && (n = Math.max(t.minScale, n), i = Math.max(t.minScale, i)), t.center && (a = t.center.x, l = t.center.y), n = this.clampScale(n), i = this.clampScale(i), a || l) {
      const c = this.getTranslation(), u = a - (a - c.tx) * (n / r.sx), d = l - (l - c.ty) * (i / r.sy);
      (u !== c.tx || d !== c.ty) && this.translate(u, d);
    }
    return this.scale(n, i), this;
  }
  getRotation() {
    return s3(this.getMatrix());
  }
  rotate(e, t, n) {
    if (t == null || n == null) {
      const r = le.getBBox(this.stage);
      t = r.width / 2, n = r.height / 2;
    }
    const i = this.getMatrix().translate(t, n).rotate(e).translate(-t, -n);
    return this.setMatrix(i), this;
  }
  getTranslation() {
    return i3(this.getMatrix());
  }
  translate(e, t) {
    const n = this.getMatrix();
    n.e = e || 0, n.f = t || 0, this.setMatrix(n);
    const i = this.getTranslation();
    return this.options.x = i.tx, this.options.y = i.ty, this.graph.trigger("translate", Object.assign({}, i)), this;
  }
  setOrigin(e, t) {
    return this.translate(e || 0, t || 0);
  }
  fitToContent(e, t, n, i) {
    if (typeof e == "object") {
      const b = e;
      e = b.gridWidth || 1, t = b.gridHeight || 1, n = b.padding || 0, i = b;
    } else
      e = e || 1, t = t || 1, n = n || 0, i == null && (i = {});
    const r = ms(n), o = i.border || 0, a = i.contentArea ? R.create(i.contentArea) : this.getContentArea(i);
    o > 0 && a.inflate(o);
    const l = this.getScale(), c = this.getTranslation(), u = l.sx, d = l.sy;
    a.x *= u, a.y *= d, a.width *= u, a.height *= d;
    let f = Math.max(Math.ceil((a.width + a.x) / e), 1) * e, g = Math.max(Math.ceil((a.height + a.y) / t), 1) * t, p = 0, m = 0;
    (i.allowNewOrigin === "negative" && a.x < 0 || i.allowNewOrigin === "positive" && a.x >= 0 || i.allowNewOrigin === "any") && (p = Math.ceil(-a.x / e) * e, p += r.left, f += p), (i.allowNewOrigin === "negative" && a.y < 0 || i.allowNewOrigin === "positive" && a.y >= 0 || i.allowNewOrigin === "any") && (m = Math.ceil(-a.y / t) * t, m += r.top, g += m), f += r.right, g += r.bottom, f = Math.max(f, i.minWidth || 0), g = Math.max(g, i.minHeight || 0), f = Math.min(f, i.maxWidth || Number.MAX_SAFE_INTEGER), g = Math.min(g, i.maxHeight || Number.MAX_SAFE_INTEGER);
    const w = this.getComputedSize(), v = f !== w.width || g !== w.height;
    return (p !== c.tx || m !== c.ty) && this.translate(p, m), v && this.resize(f, g), new R(-p / u, -m / d, f / u, g / d);
  }
  scaleContentToFit(e = {}) {
    this.scaleContentToFitImpl(e);
  }
  scaleContentToFitImpl(e = {}, t = !0) {
    let n, i;
    if (e.contentArea) {
      const v = e.contentArea;
      n = this.graph.localToGraph(v), i = M.create(v);
    } else
      n = this.getContentBBox(e), i = this.graph.graphToLocal(n);
    if (!n.width || !n.height)
      return;
    const r = ms(e.padding), o = e.minScale || 0, a = e.maxScale || Number.MAX_SAFE_INTEGER, l = e.minScaleX || o, c = e.maxScaleX || a, u = e.minScaleY || o, d = e.maxScaleY || a;
    let f;
    if (e.viewportArea)
      f = e.viewportArea;
    else {
      const v = this.getComputedSize(), y = this.getTranslation();
      f = {
        x: y.tx,
        y: y.ty,
        width: v.width,
        height: v.height
      };
    }
    f = R.create(f).moveAndExpand({
      x: r.left,
      y: r.top,
      width: -r.left - r.right,
      height: -r.top - r.bottom
    });
    const g = this.getScale();
    let p = f.width / n.width * g.sx, m = f.height / n.height * g.sy;
    e.preserveAspectRatio !== !1 && (p = m = Math.min(p, m));
    const w = e.scaleGrid;
    if (w && (p = w * Math.floor(p / w), m = w * Math.floor(m / w)), p = Mt(p, l, c), m = Mt(m, u, d), this.scale(p, m), t) {
      const v = this.options, y = f.x - i.x * p - v.x, b = f.y - i.y * m - v.y;
      this.translate(y, b);
    }
  }
  getContentArea(e = {}) {
    return e.useCellGeometry !== !1 ? this.model.getAllCellsBBox() || new R() : le.getBBox(this.stage);
  }
  getContentBBox(e = {}) {
    return this.graph.localToGraph(this.getContentArea(e));
  }
  getGraphArea() {
    const e = R.fromSize(this.getComputedSize());
    return this.graph.graphToLocal(e);
  }
  zoomToRect(e, t = {}) {
    const n = R.create(e), i = this.graph;
    t.contentArea = n, t.viewportArea == null && (t.viewportArea = {
      x: i.options.x,
      y: i.options.y,
      width: this.options.width,
      height: this.options.height
    }), this.scaleContentToFitImpl(t, !1);
    const r = n.getCenter();
    return this.centerPoint(r.x, r.y), this;
  }
  zoomToFit(e = {}) {
    return this.zoomToRect(this.getContentArea(e), e);
  }
  centerPoint(e, t) {
    const n = this.getComputedSize(), i = this.getScale(), r = this.getTranslation(), o = n.width / 2, a = n.height / 2;
    e = typeof e == "number" ? e : o, t = typeof t == "number" ? t : a, e = o - e * i.sx, t = a - t * i.sy, (r.tx !== e || r.ty !== t) && this.translate(e, t);
  }
  centerContent(e) {
    const n = this.graph.getContentArea(e).getCenter();
    this.centerPoint(n.x, n.y);
  }
  centerCell(e) {
    return this.positionCell(e, "center");
  }
  positionPoint(e, t, n) {
    const i = this.getComputedSize();
    t = Lt(t, Math.max(0, i.width)), t < 0 && (t = i.width + t), n = Lt(n, Math.max(0, i.height)), n < 0 && (n = i.height + n);
    const r = this.getTranslation(), o = this.getScale(), a = t - e.x * o.sx, l = n - e.y * o.sy;
    (r.tx !== a || r.ty !== l) && this.translate(a, l);
  }
  positionRect(e, t) {
    const n = R.create(e);
    switch (t) {
      case "center":
        return this.positionPoint(n.getCenter(), "50%", "50%");
      case "top":
        return this.positionPoint(n.getTopCenter(), "50%", 0);
      case "top-right":
        return this.positionPoint(n.getTopRight(), "100%", 0);
      case "right":
        return this.positionPoint(n.getRightMiddle(), "100%", "50%");
      case "bottom-right":
        return this.positionPoint(n.getBottomRight(), "100%", "100%");
      case "bottom":
        return this.positionPoint(n.getBottomCenter(), "50%", "100%");
      case "bottom-left":
        return this.positionPoint(n.getBottomLeft(), 0, "100%");
      case "left":
        return this.positionPoint(n.getLeftMiddle(), 0, "50%");
      case "top-left":
        return this.positionPoint(n.getTopLeft(), 0, 0);
      default:
        return this;
    }
  }
  positionCell(e, t) {
    const n = e.getBBox();
    return this.positionRect(n, t);
  }
  positionContent(e, t) {
    const n = this.graph.getContentArea(t);
    return this.positionRect(n, e);
  }
}
var a5 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class vc extends Je {
  get elem() {
    return this.view.background;
  }
  init() {
    this.startListening(), this.options.background && this.draw(this.options.background);
  }
  startListening() {
    this.graph.on("scale", this.update, this), this.graph.on("translate", this.update, this);
  }
  stopListening() {
    this.graph.off("scale", this.update, this), this.graph.off("translate", this.update, this);
  }
  updateBackgroundImage(e = {}) {
    let t = e.size || "auto auto", n = e.position || "center";
    const i = this.graph.transform.getScale(), r = this.graph.translate();
    if (typeof n == "object") {
      const o = r.tx + i.sx * (n.x || 0), a = r.ty + i.sy * (n.y || 0);
      n = "".concat(o, "px ").concat(a, "px");
    }
    typeof t == "object" && (t = R.fromSize(t).scale(i.sx, i.sy), t = "".concat(t.width, "px ").concat(t.height, "px")), this.elem.style.backgroundSize = t, this.elem.style.backgroundPosition = n;
  }
  drawBackgroundImage(e, t = {}) {
    if (!(e instanceof HTMLImageElement)) {
      this.elem.style.backgroundImage = "";
      return;
    }
    const n = this.optionsCache;
    if (n && n.image !== t.image)
      return;
    let i;
    const r = t.opacity, o = t.size;
    let a = t.repeat || "no-repeat";
    const l = ar.registry.get(a);
    if (typeof l == "function") {
      const u = t.quality || 1;
      e.width *= u, e.height *= u;
      const d = l(e, t);
      if (!(d instanceof HTMLCanvasElement))
        throw new Error("Background pattern must return an HTML Canvas instance");
      i = d.toDataURL("image/png"), t.repeat && a !== t.repeat ? a = t.repeat : a = "repeat", typeof o == "object" ? (o.width *= d.width / e.width, o.height *= d.height / e.height) : o === void 0 && (t.size = {
        width: d.width / u,
        height: d.height / u
      });
    } else
      i = e.src, o === void 0 && (t.size = {
        width: e.width,
        height: e.height
      });
    n != null && typeof t.size == "object" && t.image === n.image && t.repeat === n.repeat && t.quality === n.quality && (n.size = Ua(t.size));
    const c = this.elem.style;
    c.backgroundImage = "url(".concat(i, ")"), c.backgroundRepeat = a, c.opacity = r == null || r >= 1 ? "" : "".concat(r), this.updateBackgroundImage(t);
  }
  updateBackgroundColor(e) {
    this.elem.style.backgroundColor = e || "";
  }
  updateBackgroundOptions(e) {
    this.graph.options.background = e;
  }
  update() {
    this.optionsCache && this.updateBackgroundImage(this.optionsCache);
  }
  draw(e) {
    const t = e || {};
    if (this.updateBackgroundOptions(e), this.updateBackgroundColor(t.color), t.image) {
      this.optionsCache = Ua(t);
      const n = document.createElement("img");
      n.onload = () => this.drawBackgroundImage(n, e), n.setAttribute("crossorigin", "anonymous"), n.src = t.image;
    } else
      this.drawBackgroundImage(null), this.optionsCache = null;
  }
  clear() {
    this.draw();
  }
  dispose() {
    this.clear(), this.stopListening();
  }
}
a5([
  Je.dispose()
], vc.prototype, "dispose", null);
var l5 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class xc extends Je {
  get widgetOptions() {
    return this.options.panning;
  }
  get pannable() {
    return this.widgetOptions && this.widgetOptions.enabled === !0;
  }
  init() {
    this.onRightMouseDown = this.onRightMouseDown.bind(this), this.onSpaceKeyDown = this.onSpaceKeyDown.bind(this), this.onSpaceKeyUp = this.onSpaceKeyUp.bind(this), this.startListening(), this.updateClassName();
  }
  startListening() {
    this.graph.on("blank:mousedown", this.onMouseDown, this), this.graph.on("node:unhandled:mousedown", this.onMouseDown, this), this.graph.on("edge:unhandled:mousedown", this.onMouseDown, this), Xe.on(this.graph.container, "mousedown", this.onRightMouseDown), Xe.on(document.body, {
      keydown: this.onSpaceKeyDown,
      keyup: this.onSpaceKeyUp
    }), this.mousewheelHandle = new zf(this.graph.container, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this)), this.mousewheelHandle.enable();
  }
  stopListening() {
    this.graph.off("blank:mousedown", this.onMouseDown, this), this.graph.off("node:unhandled:mousedown", this.onMouseDown, this), this.graph.off("edge:unhandled:mousedown", this.onMouseDown, this), Xe.off(this.graph.container, "mousedown", this.onRightMouseDown), Xe.off(document.body, {
      keydown: this.onSpaceKeyDown,
      keyup: this.onSpaceKeyUp
    }), this.mousewheelHandle && this.mousewheelHandle.disable();
  }
  allowPanning(e, t) {
    return e.spaceKey = this.isSpaceKeyPressed, this.pannable && ti.isMatch(e, this.widgetOptions.modifiers, t);
  }
  startPanning(e) {
    const t = this.view.normalizeEvent(e);
    this.clientX = t.clientX, this.clientY = t.clientY, this.panning = !0, this.updateClassName(), Xe.on(document.body, {
      "mousemove.panning touchmove.panning": this.pan.bind(this),
      "mouseup.panning touchend.panning": this.stopPanning.bind(this),
      "mouseleave.panning": this.stopPanning.bind(this)
    }), Xe.on(window, "mouseup.panning", this.stopPanning.bind(this));
  }
  pan(e) {
    const t = this.view.normalizeEvent(e), n = t.clientX - this.clientX, i = t.clientY - this.clientY;
    this.clientX = t.clientX, this.clientY = t.clientY, this.graph.translateBy(n, i);
  }
  // eslint-disable-next-line
  stopPanning(e) {
    this.panning = !1, this.updateClassName(), Xe.off(document.body, ".panning"), Xe.off(window, ".panning");
  }
  updateClassName() {
    const e = this.view.container, t = this.view.prefixClassName("graph-panning"), n = this.view.prefixClassName("graph-pannable");
    this.pannable ? this.panning ? (ie(e, t), kt(e, n)) : (kt(e, t), ie(e, n)) : (kt(e, t), kt(e, n));
  }
  onMouseDown({ e }) {
    if (!this.allowBlankMouseDown(e))
      return;
    const t = this.graph.getPlugin("selection"), n = t && t.allowRubberband(e, !0);
    (this.allowPanning(e, !0) || this.allowPanning(e) && !n) && this.startPanning(e);
  }
  onRightMouseDown(e) {
    const t = this.widgetOptions.eventTypes;
    t != null && t.includes("rightMouseDown") && e.button === 2 && this.allowPanning(e, !0) && this.startPanning(e);
  }
  onMouseWheel(e, t, n) {
    this.graph.translateBy(-t, -n);
  }
  onSpaceKeyDown(e) {
    e.which === 32 && (this.isSpaceKeyPressed = !0);
  }
  onSpaceKeyUp(e) {
    e.which === 32 && (this.isSpaceKeyPressed = !1);
  }
  allowBlankMouseDown(e) {
    const t = this.widgetOptions.eventTypes;
    return (t == null ? void 0 : t.includes("leftMouseDown")) && e.button === 0 || (t == null ? void 0 : t.includes("mouseWheelDown")) && e.button === 1;
  }
  allowMouseWheel(e) {
    var t;
    return this.pannable && !e.ctrlKey && ((t = this.widgetOptions.eventTypes) === null || t === void 0 ? void 0 : t.includes("mouseWheel"));
  }
  autoPanning(e, t) {
    const i = this.graph.getGraphArea();
    let r = 0, o = 0;
    e <= i.left + 10 && (r = -10), t <= i.top + 10 && (o = -10), e >= i.right - 10 && (r = 10), t >= i.bottom - 10 && (o = 10), (r !== 0 || o !== 0) && this.graph.translateBy(-r, -o);
  }
  enablePanning() {
    this.pannable || (this.widgetOptions.enabled = !0, this.updateClassName());
  }
  disablePanning() {
    this.pannable && (this.widgetOptions.enabled = !1, this.updateClassName());
  }
  dispose() {
    this.stopListening();
  }
}
l5([
  Je.dispose()
], xc.prototype, "dispose", null);
var c5 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class Cc extends Je {
  constructor() {
    super(...arguments), this.cumulatedFactor = 1;
  }
  get widgetOptions() {
    return this.options.mousewheel;
  }
  init() {
    this.container = this.graph.container, this.target = this.widgetOptions.global ? document : this.container, this.mousewheelHandle = new zf(this.target, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this)), this.widgetOptions.enabled && this.enable(!0);
  }
  get disabled() {
    return this.widgetOptions.enabled !== !0;
  }
  enable(e) {
    (this.disabled || e) && (this.widgetOptions.enabled = !0, this.mousewheelHandle.enable());
  }
  disable() {
    this.disabled || (this.widgetOptions.enabled = !1, this.mousewheelHandle.disable());
  }
  allowMouseWheel(e) {
    const t = this.widgetOptions.guard;
    return (t == null || t(e)) && ti.isMatch(e, this.widgetOptions.modifiers);
  }
  onMouseWheel(e) {
    const t = this.widgetOptions.guard;
    if ((t == null || t(e)) && ti.isMatch(e, this.widgetOptions.modifiers)) {
      const n = this.widgetOptions.factor || 1.2;
      this.currentScale == null && (this.startPos = { x: e.clientX, y: e.clientY }, this.currentScale = this.graph.transform.getScale().sx), e.deltaY < 0 ? this.currentScale < 0.15 ? this.cumulatedFactor = (this.currentScale + 0.01) / this.currentScale : (this.cumulatedFactor = Math.round(this.currentScale * n * 20) / 20 / this.currentScale, this.cumulatedFactor === 1 && (this.cumulatedFactor = 1.05)) : this.currentScale <= 0.15 ? this.cumulatedFactor = (this.currentScale - 0.01) / this.currentScale : (this.cumulatedFactor = Math.round(this.currentScale * (1 / n) * 20) / 20 / this.currentScale, this.cumulatedFactor === 1 && (this.cumulatedFactor = 0.95)), this.cumulatedFactor = Math.max(0.01, Math.min(this.currentScale * this.cumulatedFactor, 160) / this.currentScale);
      const r = this.currentScale;
      let o = this.graph.transform.clampScale(r * this.cumulatedFactor);
      const a = this.widgetOptions.minScale || Number.MIN_SAFE_INTEGER, l = this.widgetOptions.maxScale || Number.MAX_SAFE_INTEGER;
      if (o = Mt(o, a, l), o !== r)
        if (this.widgetOptions.zoomAtMousePosition) {
          const u = !!this.graph.getPlugin("scroller") ? this.graph.clientToLocal(this.startPos) : this.graph.clientToGraph(this.startPos);
          this.graph.zoom(o, {
            absolute: !0,
            center: u.clone()
          });
        } else
          this.graph.zoom(o, { absolute: !0 });
      this.currentScale = null, this.cumulatedFactor = 1;
    }
  }
  dispose() {
    this.disable();
  }
}
c5([
  hn.dispose()
], Cc.prototype, "dispose", null);
var h5 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class Bg extends Je {
  init() {
    this.resetRenderArea = Tp(this.resetRenderArea, 200, {
      leading: !0
    }), this.resetRenderArea(), this.startListening();
  }
  startListening() {
    this.graph.on("translate", this.resetRenderArea, this), this.graph.on("scale", this.resetRenderArea, this), this.graph.on("resize", this.resetRenderArea, this);
  }
  stopListening() {
    this.graph.off("translate", this.resetRenderArea, this), this.graph.off("scale", this.resetRenderArea, this), this.graph.off("resize", this.resetRenderArea, this);
  }
  enableVirtualRender() {
    this.options.virtual = !0, this.resetRenderArea();
  }
  disableVirtualRender() {
    this.options.virtual = !1, this.graph.renderer.setRenderArea(void 0);
  }
  resetRenderArea() {
    if (this.options.virtual) {
      const e = this.graph.getGraphArea();
      this.graph.renderer.setRenderArea(e);
    }
  }
  dispose() {
    this.stopListening();
  }
}
h5([
  Je.dispose()
], Bg.prototype, "dispose", null);
class u5 {
  constructor() {
    this.isFlushing = !1, this.isFlushPending = !1, this.scheduleId = 0, this.queue = [], this.frameInterval = 33, this.initialTime = Date.now();
  }
  queueJob(e) {
    if (e.priority & nn.PRIOR)
      e.cb();
    else {
      const t = this.findInsertionIndex(e);
      t >= 0 && this.queue.splice(t, 0, e);
    }
  }
  queueFlush() {
    !this.isFlushing && !this.isFlushPending && (this.isFlushPending = !0, this.scheduleJob());
  }
  queueFlushSync() {
    !this.isFlushing && !this.isFlushPending && (this.isFlushPending = !0, this.flushJobsSync());
  }
  clearJobs() {
    this.queue.length = 0, this.isFlushing = !1, this.isFlushPending = !1, this.cancelScheduleJob();
  }
  flushJobs() {
    this.isFlushPending = !1, this.isFlushing = !0;
    const e = this.getCurrentTime();
    let t;
    for (; (t = this.queue.shift()) && (t.cb(), !(this.getCurrentTime() - e >= this.frameInterval)); )
      ;
    this.isFlushing = !1, this.queue.length && this.queueFlush();
  }
  flushJobsSync() {
    this.isFlushPending = !1, this.isFlushing = !0;
    let e;
    for (; e = this.queue.shift(); )
      try {
        e.cb();
      } catch (t) {
        console.log(t);
      }
    this.isFlushing = !1;
  }
  findInsertionIndex(e) {
    let t = 0, n = this.queue.length, i = n - 1;
    const r = e.priority;
    for (; t <= i; ) {
      const o = (i - t >> 1) + t;
      r <= this.queue[o].priority ? t = o + 1 : (n = o, i = o - 1);
    }
    return n;
  }
  scheduleJob() {
    "requestIdleCallback" in window ? (this.scheduleId && this.cancelScheduleJob(), this.scheduleId = window.requestIdleCallback(this.flushJobs.bind(this), {
      timeout: 100
    })) : (this.scheduleId && this.cancelScheduleJob(), this.scheduleId = window.setTimeout(this.flushJobs.bind(this)));
  }
  cancelScheduleJob() {
    "cancelIdleCallback" in window ? (this.scheduleId && window.cancelIdleCallback(this.scheduleId), this.scheduleId = 0) : (this.scheduleId && clearTimeout(this.scheduleId), this.scheduleId = 0);
  }
  getCurrentTime() {
    return typeof performance == "object" && typeof performance.now == "function" ? performance.now() : Date.now() - this.initialTime;
  }
}
var nn;
(function(s) {
  s[s.Update = 2] = "Update", s[s.RenderEdge = 4] = "RenderEdge", s[s.RenderNode = 8] = "RenderNode", s[s.PRIOR = 1048576] = "PRIOR";
})(nn || (nn = {}));
var d5 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class Re extends hn {
  get model() {
    return this.graph.model;
  }
  get container() {
    return this.graph.view.stage;
  }
  constructor(e) {
    super(), this.views = {}, this.willRemoveViews = {}, this.queue = new u5(), this.graph = e, this.init();
  }
  init() {
    this.startListening(), this.renderViews(this.model.getCells());
  }
  startListening() {
    this.model.on("reseted", this.onModelReseted, this), this.model.on("cell:added", this.onCellAdded, this), this.model.on("cell:removed", this.onCellRemoved, this), this.model.on("cell:change:zIndex", this.onCellZIndexChanged, this), this.model.on("cell:change:visible", this.onCellVisibleChanged, this);
  }
  stopListening() {
    this.model.off("reseted", this.onModelReseted, this), this.model.off("cell:added", this.onCellAdded, this), this.model.off("cell:removed", this.onCellRemoved, this), this.model.off("cell:change:zIndex", this.onCellZIndexChanged, this), this.model.off("cell:change:visible", this.onCellVisibleChanged, this);
  }
  onModelReseted({ options: e }) {
    this.queue.clearJobs(), this.removeZPivots(), this.resetViews();
    const t = this.model.getCells();
    this.renderViews(t, Object.assign(Object.assign({}, e), { queue: t.map((n) => n.id) }));
  }
  onCellAdded({ cell: e, options: t }) {
    this.renderViews([e], t);
  }
  onCellRemoved({ cell: e }) {
    this.removeViews([e]);
  }
  onCellZIndexChanged({ cell: e, options: t }) {
    const n = this.views[e.id];
    n && this.requestViewUpdate(n.view, Re.FLAG_INSERT, t, nn.Update, !0);
  }
  onCellVisibleChanged({ cell: e, current: t }) {
    this.toggleVisible(e, !!t);
  }
  requestViewUpdate(e, t, n = {}, i = nn.Update, r = !0) {
    const o = e.cell.id, a = this.views[o];
    if (!a)
      return;
    a.flag = t, a.options = n, (e.hasAction(t, ["translate", "resize", "rotate"]) || n.async === !1) && (i = nn.PRIOR, r = !1), this.queue.queueJob({
      id: o,
      priority: i,
      cb: () => {
        this.renderViewInArea(e, t, n);
        const u = n.queue;
        if (u) {
          const d = u.indexOf(e.cell.id);
          d >= 0 && u.splice(d, 1), u.length === 0 && this.graph.trigger("render:done");
        }
      }
    }), this.getEffectedEdges(e).forEach((u) => {
      this.requestViewUpdate(u.view, u.flag, n, i, !1);
    }), r && this.flush();
  }
  setRenderArea(e) {
    this.renderArea = e, this.flushWaitingViews();
  }
  isViewMounted(e) {
    if (e == null)
      return !1;
    const t = this.views[e.cell.id];
    return t ? t.state === Re.ViewState.MOUNTED : !1;
  }
  renderViews(e, t = {}) {
    e.sort((n, i) => n.isNode() && i.isEdge() ? -1 : 0), e.forEach((n) => {
      const i = n.id, r = this.views;
      let o = 0, a = r[i];
      if (a)
        o = Re.FLAG_INSERT;
      else {
        const l = this.createCellView(n);
        l && (l.graph = this.graph, o = Re.FLAG_INSERT | l.getBootstrapFlag(), a = {
          view: l,
          flag: o,
          options: t,
          state: Re.ViewState.CREATED
        }, this.views[i] = a);
      }
      a && this.requestViewUpdate(a.view, o, t, this.getRenderPriority(a.view), !1);
    }), this.flush();
  }
  renderViewInArea(e, t, n = {}) {
    const i = e.cell, r = i.id, o = this.views[r];
    if (!o)
      return;
    let a = 0;
    this.isUpdatable(e) ? (a = this.updateView(e, t, n), o.flag = a) : o.state === Re.ViewState.MOUNTED ? (a = this.updateView(e, t, n), o.flag = a) : o.state = Re.ViewState.WAITING, a && i.isEdge() && !(a & e.getFlag(["source", "target"])) && this.queue.queueJob({
      id: r,
      priority: nn.RenderEdge,
      cb: () => {
        this.updateView(e, t, n);
      }
    });
  }
  removeViews(e) {
    e.forEach((t) => {
      const n = t.id, i = this.views[n];
      i && (this.willRemoveViews[n] = i, delete this.views[n], this.queue.queueJob({
        id: n,
        priority: this.getRenderPriority(i.view),
        cb: () => {
          this.removeView(i.view);
        }
      }));
    }), this.flush();
  }
  flush() {
    this.graph.options.async ? this.queue.queueFlush() : this.queue.queueFlushSync();
  }
  flushWaitingViews() {
    Object.values(this.views).forEach((e) => {
      if (e && e.state === Re.ViewState.WAITING) {
        const { view: t, flag: n, options: i } = e;
        this.requestViewUpdate(t, n, i, this.getRenderPriority(t), !1);
      }
    }), this.flush();
  }
  updateView(e, t, n = {}) {
    if (e == null)
      return 0;
    if (Te.isCellView(e)) {
      if (t & Re.FLAG_REMOVE)
        return this.removeView(e.cell), 0;
      t & Re.FLAG_INSERT && (this.insertView(e), t ^= Re.FLAG_INSERT);
    }
    return t ? e.confirmUpdate(t, n) : 0;
  }
  insertView(e) {
    const t = this.views[e.cell.id];
    if (t) {
      const n = e.cell.getZIndex(), i = this.addZPivot(n);
      this.container.insertBefore(e.container, i), e.cell.isVisible() || this.toggleVisible(e.cell, !1), t.state = Re.ViewState.MOUNTED, this.graph.trigger("view:mounted", { view: e });
    }
  }
  resetViews() {
    this.willRemoveViews = Object.assign(Object.assign({}, this.views), this.willRemoveViews), Object.values(this.willRemoveViews).forEach((e) => {
      e && this.removeView(e.view);
    }), this.views = {}, this.willRemoveViews = {};
  }
  removeView(e) {
    const t = e.cell, n = this.willRemoveViews[t.id];
    n && e && (n.view.remove(), delete this.willRemoveViews[t.id], this.graph.trigger("view:unmounted", { view: e }));
  }
  toggleVisible(e, t) {
    const n = this.model.getConnectedEdges(e);
    for (let r = 0, o = n.length; r < o; r += 1) {
      const a = n[r];
      if (t) {
        const l = a.getSourceCell(), c = a.getTargetCell();
        if (l && !l.isVisible() || c && !c.isVisible())
          continue;
        this.toggleVisible(a, !0);
      } else
        this.toggleVisible(a, !1);
    }
    const i = this.views[e.id];
    i && Sr(i.view.container, {
      display: t ? "unset" : "none"
    });
  }
  addZPivot(e = 0) {
    this.zPivots == null && (this.zPivots = {});
    const t = this.zPivots;
    let n = t[e];
    if (n)
      return n;
    n = t[e] = document.createComment("z-index:".concat(e + 1));
    let i = -1 / 0;
    for (const o in t) {
      const a = +o;
      a < e && a > i && (i = a, e - 1);
    }
    const r = this.container;
    if (i !== -1 / 0) {
      const o = t[i];
      r.insertBefore(n, o.nextSibling);
    } else
      r.insertBefore(n, r.firstChild);
    return n;
  }
  removeZPivots() {
    this.zPivots && Object.values(this.zPivots).forEach((e) => {
      e && e.parentNode && e.parentNode.removeChild(e);
    }), this.zPivots = {};
  }
  createCellView(e) {
    const t = { graph: this.graph }, n = this.graph.options.createCellView;
    if (n) {
      const r = J(n, this.graph, e);
      if (r)
        return new r(e, t);
      if (r === null)
        return null;
    }
    const i = e.view;
    if (i != null && typeof i == "string") {
      const r = Te.registry.get(i);
      return r ? new r(e, t) : Te.registry.onNotFound(i);
    }
    return e.isNode() ? new Rt(e, t) : e.isEdge() ? new dn(e, t) : null;
  }
  getEffectedEdges(e) {
    const t = [], n = e.cell, i = this.model.getConnectedEdges(n);
    for (let r = 0, o = i.length; r < o; r += 1) {
      const a = i[r], l = this.views[a.id];
      if (!l)
        continue;
      const c = l.view;
      if (!this.isViewMounted(c))
        continue;
      const u = ["update"];
      a.getTargetCell() === n && u.push("target"), a.getSourceCell() === n && u.push("source"), t.push({
        id: a.id,
        view: c,
        flag: c.getFlag(u)
      });
    }
    return t;
  }
  isUpdatable(e) {
    if (e.isNodeView())
      return this.renderArea ? this.renderArea.isIntersectWithRect(e.cell.getBBox()) : !0;
    if (e.isEdgeView()) {
      const t = e.cell, n = t.getSourceCell(), i = t.getTargetCell();
      if (this.renderArea && n && i)
        return this.renderArea.isIntersectWithRect(n.getBBox()) || this.renderArea.isIntersectWithRect(i.getBBox());
    }
    return !0;
  }
  getRenderPriority(e) {
    return e.cell.isNode() ? nn.RenderNode : nn.RenderEdge;
  }
  dispose() {
    this.stopListening(), Object.keys(this.views).forEach((e) => {
      this.views[e].view.dispose();
    }), this.views = {};
  }
}
d5([
  hn.dispose()
], Re.prototype, "dispose", null);
(function(s) {
  s.FLAG_INSERT = 1 << 30, s.FLAG_REMOVE = 1 << 29, s.FLAG_RENDER = (1 << 26) - 1;
})(Re || (Re = {}));
(function(s) {
  (function(e) {
    e[e.CREATED = 0] = "CREATED", e[e.MOUNTED = 1] = "MOUNTED", e[e.WAITING = 2] = "WAITING";
  })(s.ViewState || (s.ViewState = {}));
})(Re || (Re = {}));
var f5 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class Ec extends Je {
  constructor() {
    super(...arguments), this.schedule = new Re(this.graph);
  }
  requestViewUpdate(e, t, n = {}) {
    this.schedule.requestViewUpdate(e, t, n);
  }
  isViewMounted(e) {
    return this.schedule.isViewMounted(e);
  }
  setRenderArea(e) {
    this.schedule.setRenderArea(e);
  }
  findViewByElem(e) {
    if (e == null)
      return null;
    const t = this.options.container, n = typeof e == "string" ? t.querySelector(e) : e instanceof Element ? e : e[0];
    if (n) {
      const i = this.graph.view.findAttr("data-cell-id", n);
      if (i) {
        const r = this.schedule.views;
        if (r[i])
          return r[i].view;
      }
    }
    return null;
  }
  findViewByCell(e) {
    if (e == null)
      return null;
    const t = se.isCell(e) ? e.id : e, n = this.schedule.views;
    return n[t] ? n[t].view : null;
  }
  findViewsFromPoint(e) {
    const t = { x: e.x, y: e.y };
    return this.model.getCells().map((n) => this.findViewByCell(n)).filter((n) => n != null ? le.getBBox(n.container, {
      target: this.view.stage
    }).containsPoint(t) : !1);
  }
  findEdgeViewsFromPoint(e, t = 5) {
    return this.model.getEdges().map((n) => this.findViewByCell(n)).filter((n) => {
      if (n != null) {
        const i = n.getClosestPoint(e);
        if (i)
          return i.distance(e) <= t;
      }
      return !1;
    });
  }
  findViewsInArea(e, t = {}) {
    const n = R.create(e);
    return this.model.getCells().map((i) => this.findViewByCell(i)).filter((i) => {
      if (i) {
        if (t.nodeOnly && !i.isNodeView())
          return !1;
        const r = le.getBBox(i.container, {
          target: this.view.stage
        });
        return r.width === 0 ? r.inflate(1, 0) : r.height === 0 && r.inflate(0, 1), t.strict ? n.containsRect(r) : n.isIntersectWithRect(r);
      }
      return !1;
    });
  }
  dispose() {
    this.schedule.dispose();
  }
}
f5([
  Je.dispose()
], Ec.prototype, "dispose", null);
var Qh = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
class Fg extends Je {
  get cid() {
    return this.graph.view.cid;
  }
  get svg() {
    return this.view.svg;
  }
  get defs() {
    return this.view.defs;
  }
  isDefined(e) {
    return this.svg.getElementById(e) != null;
  }
  filter(e) {
    let t = e.id;
    const n = e.name;
    if (t || (t = "filter-".concat(n, "-").concat(this.cid, "-").concat(Da(JSON.stringify(e)))), !this.isDefined(t)) {
      const i = ii.registry.get(n);
      if (i == null)
        return ii.registry.onNotFound(n);
      const r = i(e.args || {}), o = Object.assign(Object.assign({ x: -1, y: -1, width: 3, height: 3, filterUnits: "objectBoundingBox" }, e.attrs), { id: t });
      G.create(be.sanitize(r), o).appendTo(this.defs);
    }
    return t;
  }
  gradient(e) {
    let t = e.id;
    const n = e.type;
    if (t || (t = "gradient-".concat(n, "-").concat(this.cid, "-").concat(Da(JSON.stringify(e)))), !this.isDefined(t)) {
      const r = e.stops.map((l) => {
        const c = l.opacity != null && Number.isFinite(l.opacity) ? l.opacity : 1;
        return '<stop offset="'.concat(l.offset, '" stop-color="').concat(l.color, '" stop-opacity="').concat(c, '"/>');
      }), o = "<".concat(n, ">").concat(r.join(""), "</").concat(n, ">"), a = Object.assign({ id: t }, e.attrs);
      G.create(o, a).appendTo(this.defs);
    }
    return t;
  }
  marker(e) {
    const { id: t, refX: n, refY: i, markerUnits: r, markerOrient: o, tagName: a, children: l } = e, c = Qh(e, ["id", "refX", "refY", "markerUnits", "markerOrient", "tagName", "children"]);
    let u = t;
    if (u || (u = "marker-".concat(this.cid, "-").concat(Da(JSON.stringify(e)))), !this.isDefined(u)) {
      a !== "path" && delete c.d;
      const d = G.create("marker", {
        refX: n,
        refY: i,
        id: u,
        overflow: "visible",
        orient: o != null ? o : "auto",
        markerUnits: r || "userSpaceOnUse"
      }, l ? l.map((f) => {
        var { tagName: g } = f, p = Qh(f, ["tagName"]);
        return G.create("".concat(g) || "path", sr(Object.assign(Object.assign({}, c), p)));
      }) : [G.create(a || "path", sr(c))]);
      this.defs.appendChild(d.node);
    }
    return u;
  }
  remove(e) {
    const t = this.svg.getElementById(e);
    t && t.parentNode && t.parentNode.removeChild(t);
  }
}
class $g extends Je {
  getClientMatrix() {
    return We(this.view.stage.getScreenCTM());
  }
  /**
   * Returns coordinates of the graph viewport, relative to the window.
   */
  getClientOffset() {
    const e = this.view.svg.getBoundingClientRect();
    return new M(e.left, e.top);
  }
  /**
   * Returns coordinates of the graph viewport, relative to the document.
   */
  getPageOffset() {
    return this.getClientOffset().translate(window.scrollX, window.scrollY);
  }
  snapToGrid(e, t) {
    return (typeof e == "number" ? this.clientToLocalPoint(e, t) : this.clientToLocalPoint(e.x, e.y)).snapToGrid(this.graph.getGridSize());
  }
  localToGraphPoint(e, t) {
    const n = M.create(e, t);
    return le.transformPoint(n, this.graph.matrix());
  }
  localToClientPoint(e, t) {
    const n = M.create(e, t);
    return le.transformPoint(n, this.getClientMatrix());
  }
  localToPagePoint(e, t) {
    return (typeof e == "number" ? this.localToGraphPoint(e, t) : this.localToGraphPoint(e)).translate(this.getPageOffset());
  }
  localToGraphRect(e, t, n, i) {
    const r = R.create(e, t, n, i);
    return le.transformRectangle(r, this.graph.matrix());
  }
  localToClientRect(e, t, n, i) {
    const r = R.create(e, t, n, i);
    return le.transformRectangle(r, this.getClientMatrix());
  }
  localToPageRect(e, t, n, i) {
    return (typeof e == "number" ? this.localToGraphRect(e, t, n, i) : this.localToGraphRect(e)).translate(this.getPageOffset());
  }
  graphToLocalPoint(e, t) {
    const n = M.create(e, t);
    return le.transformPoint(n, this.graph.matrix().inverse());
  }
  clientToLocalPoint(e, t) {
    const n = M.create(e, t);
    return le.transformPoint(n, this.getClientMatrix().inverse());
  }
  clientToGraphPoint(e, t) {
    const n = M.create(e, t);
    return le.transformPoint(n, this.graph.matrix().multiply(this.getClientMatrix().inverse()));
  }
  pageToLocalPoint(e, t) {
    const i = M.create(e, t).diff(this.getPageOffset());
    return this.graphToLocalPoint(i);
  }
  graphToLocalRect(e, t, n, i) {
    const r = R.create(e, t, n, i);
    return le.transformRectangle(r, this.graph.matrix().inverse());
  }
  clientToLocalRect(e, t, n, i) {
    const r = R.create(e, t, n, i);
    return le.transformRectangle(r, this.getClientMatrix().inverse());
  }
  clientToGraphRect(e, t, n, i) {
    const r = R.create(e, t, n, i);
    return le.transformRectangle(r, this.graph.matrix().multiply(this.getClientMatrix().inverse()));
  }
  pageToLocalRect(e, t, n, i) {
    const r = R.create(e, t, n, i), o = this.getPageOffset();
    return r.x -= o.x, r.y -= o.y, this.graphToLocalRect(r);
  }
}
var g5 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class Oo extends Je {
  constructor() {
    super(...arguments), this.highlights = {};
  }
  init() {
    this.startListening();
  }
  startListening() {
    this.graph.on("cell:highlight", this.onCellHighlight, this), this.graph.on("cell:unhighlight", this.onCellUnhighlight, this);
  }
  stopListening() {
    this.graph.off("cell:highlight", this.onCellHighlight, this), this.graph.off("cell:unhighlight", this.onCellUnhighlight, this);
  }
  onCellHighlight({ view: e, magnet: t, options: n = {} }) {
    const i = this.resolveHighlighter(n);
    if (!i)
      return;
    const r = this.getHighlighterId(t, i);
    if (!this.highlights[r]) {
      const o = i.highlighter;
      o.highlight(e, t, Object.assign({}, i.args)), this.highlights[r] = {
        cellView: e,
        magnet: t,
        highlighter: o,
        args: i.args
      };
    }
  }
  onCellUnhighlight({ magnet: e, options: t = {} }) {
    const n = this.resolveHighlighter(t);
    if (!n)
      return;
    const i = this.getHighlighterId(e, n);
    this.unhighlight(i);
  }
  resolveHighlighter(e) {
    const t = this.options;
    let n = e.highlighter;
    if (n == null) {
      const a = e.type;
      n = a && t.highlighting[a] || t.highlighting.default;
    }
    if (n == null)
      return null;
    const i = typeof n == "string" ? {
      name: n
    } : n, r = i.name, o = cn.registry.get(r);
    return o == null ? cn.registry.onNotFound(r) : (cn.check(r, o), {
      name: r,
      highlighter: o,
      args: i.args || {}
    });
  }
  getHighlighterId(e, t) {
    return hc(e), t.name + e.id + JSON.stringify(t.args);
  }
  unhighlight(e) {
    const t = this.highlights[e];
    t && (t.highlighter.unhighlight(t.cellView, t.magnet, t.args), delete this.highlights[e]);
  }
  dispose() {
    Object.keys(this.highlights).forEach((e) => this.unhighlight(e)), this.stopListening();
  }
}
g5([
  Oo.dispose()
], Oo.prototype, "dispose", null);
var p5 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class zg extends Je {
  getScroller() {
    const e = this.graph.getPlugin("scroller");
    return e && e.options.enabled ? e : null;
  }
  getContainer() {
    const e = this.getScroller();
    return e ? e.container.parentElement : this.graph.container.parentElement;
  }
  getSensorTarget() {
    const e = this.options.autoResize;
    if (e)
      return typeof e == "boolean" ? this.getContainer() : e;
  }
  init() {
    if (this.options.autoResize) {
      const t = this.getSensorTarget();
      t && Co.bind(t, () => {
        const n = t.offsetWidth, i = t.offsetHeight;
        this.resize(n, i);
      });
    }
  }
  resize(e, t) {
    const n = this.getScroller();
    n ? n.resize(e, t) : this.graph.transform.resize(e, t);
  }
  dispose() {
    Co.clear(this.graph.container);
  }
}
p5([
  Je.dispose()
], zg.prototype, "dispose", null);
var m5 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class et extends yt {
  get container() {
    return this.options.container;
  }
  get [Symbol.toStringTag]() {
    return et.toStringTag;
  }
  constructor(e) {
    super(), this.installedPlugins = /* @__PURE__ */ new Set(), this.options = dr.get(e), this.css = new El(this), this.view = new Zt(this), this.defs = new Fg(this), this.coord = new $g(this), this.transform = new Rg(this), this.highlight = new Oo(this), this.grid = new bc(this), this.background = new vc(this), this.options.model ? this.model = this.options.model : (this.model = new Nt(), this.model.graph = this), this.renderer = new Ec(this), this.panning = new xc(this), this.mousewheel = new Cc(this), this.virtualRender = new Bg(this), this.size = new zg(this);
  }
  // #region model
  isNode(e) {
    return e.isNode();
  }
  isEdge(e) {
    return e.isEdge();
  }
  resetCells(e, t = {}) {
    return this.model.resetCells(e, t), this;
  }
  clearCells(e = {}) {
    return this.model.clear(e), this;
  }
  toJSON(e = {}) {
    return this.model.toJSON(e);
  }
  parseJSON(e) {
    return this.model.parseJSON(e);
  }
  fromJSON(e, t = {}) {
    return this.model.fromJSON(e, t), this;
  }
  getCellById(e) {
    return this.model.getCell(e);
  }
  addNode(e, t = {}) {
    return this.model.addNode(e, t);
  }
  addNodes(e, t = {}) {
    return this.addCell(e.map((n) => $e.isNode(n) ? n : this.createNode(n)), t);
  }
  createNode(e) {
    return this.model.createNode(e);
  }
  removeNode(e, t = {}) {
    return this.model.removeCell(e, t);
  }
  addEdge(e, t = {}) {
    return this.model.addEdge(e, t);
  }
  addEdges(e, t = {}) {
    return this.addCell(e.map((n) => Me.isEdge(n) ? n : this.createEdge(n)), t);
  }
  removeEdge(e, t = {}) {
    return this.model.removeCell(e, t);
  }
  createEdge(e) {
    return this.model.createEdge(e);
  }
  addCell(e, t = {}) {
    return this.model.addCell(e, t), this;
  }
  removeCell(e, t = {}) {
    return this.model.removeCell(e, t);
  }
  removeCells(e, t = {}) {
    return this.model.removeCells(e, t);
  }
  removeConnectedEdges(e, t = {}) {
    return this.model.removeConnectedEdges(e, t);
  }
  disconnectConnectedEdges(e, t = {}) {
    return this.model.disconnectConnectedEdges(e, t), this;
  }
  hasCell(e) {
    return this.model.has(e);
  }
  getCells() {
    return this.model.getCells();
  }
  getCellCount() {
    return this.model.total();
  }
  /**
   * Returns all the nodes in the graph.
   */
  getNodes() {
    return this.model.getNodes();
  }
  /**
   * Returns all the edges in the graph.
   */
  getEdges() {
    return this.model.getEdges();
  }
  /**
   * Returns all outgoing edges for the node.
   */
  getOutgoingEdges(e) {
    return this.model.getOutgoingEdges(e);
  }
  /**
   * Returns all incoming edges for the node.
   */
  getIncomingEdges(e) {
    return this.model.getIncomingEdges(e);
  }
  /**
   * Returns edges connected with cell.
   */
  getConnectedEdges(e, t = {}) {
    return this.model.getConnectedEdges(e, t);
  }
  /**
   * Returns an array of all the roots of the graph.
   */
  getRootNodes() {
    return this.model.getRoots();
  }
  /**
   * Returns an array of all the leafs of the graph.
   */
  getLeafNodes() {
    return this.model.getLeafs();
  }
  /**
   * Returns `true` if the node is a root node, i.e.
   * there is no  edges coming to the node.
   */
  isRootNode(e) {
    return this.model.isRoot(e);
  }
  /**
   * Returns `true` if the node is a leaf node, i.e.
   * there is no edges going out from the node.
   */
  isLeafNode(e) {
    return this.model.isLeaf(e);
  }
  /**
   * Returns all the neighbors of node in the graph. Neighbors are all
   * the nodes connected to node via either incoming or outgoing edge.
   */
  getNeighbors(e, t = {}) {
    return this.model.getNeighbors(e, t);
  }
  /**
   * Returns `true` if `cell2` is a neighbor of `cell1`.
   */
  isNeighbor(e, t, n = {}) {
    return this.model.isNeighbor(e, t, n);
  }
  getSuccessors(e, t = {}) {
    return this.model.getSuccessors(e, t);
  }
  /**
   * Returns `true` if `cell2` is a successor of `cell1`.
   */
  isSuccessor(e, t, n = {}) {
    return this.model.isSuccessor(e, t, n);
  }
  getPredecessors(e, t = {}) {
    return this.model.getPredecessors(e, t);
  }
  /**
   * Returns `true` if `cell2` is a predecessor of `cell1`.
   */
  isPredecessor(e, t, n = {}) {
    return this.model.isPredecessor(e, t, n);
  }
  getCommonAncestor(...e) {
    return this.model.getCommonAncestor(...e);
  }
  /**
   * Returns an array of cells that result from finding nodes/edges that
   * are connected to any of the cells in the cells array. This function
   * loops over cells and if the current cell is a edge, it collects its
   * source/target nodes; if it is an node, it collects its incoming and
   * outgoing edges if both the edge terminal (source/target) are in the
   * cells array.
   */
  getSubGraph(e, t = {}) {
    return this.model.getSubGraph(e, t);
  }
  /**
   * Clones the whole subgraph (including all the connected links whose
   * source/target is in the subgraph). If `options.deep` is `true`, also
   * take into account all the embedded cells of all the subgraph cells.
   *
   * Returns a map of the form: { [original cell ID]: [clone] }.
   */
  cloneSubGraph(e, t = {}) {
    return this.model.cloneSubGraph(e, t);
  }
  cloneCells(e) {
    return this.model.cloneCells(e);
  }
  getNodesFromPoint(e, t) {
    return this.model.getNodesFromPoint(e, t);
  }
  getNodesInArea(e, t, n, i, r) {
    return this.model.getNodesInArea(e, t, n, i, r);
  }
  getNodesUnderNode(e, t = {}) {
    return this.model.getNodesUnderNode(e, t);
  }
  searchCell(e, t, n = {}) {
    return this.model.search(e, t, n), this;
  }
  /** *
   * Returns an array of IDs of nodes on the shortest
   * path between source and target.
   */
  getShortestPath(e, t, n = {}) {
    return this.model.getShortestPath(e, t, n);
  }
  /**
   * Returns the bounding box that surrounds all cells in the graph.
   */
  getAllCellsBBox() {
    return this.model.getAllCellsBBox();
  }
  /**
   * Returns the bounding box that surrounds all the given cells.
   */
  getCellsBBox(e, t = {}) {
    return this.model.getCellsBBox(e, t);
  }
  startBatch(e, t = {}) {
    this.model.startBatch(e, t);
  }
  stopBatch(e, t = {}) {
    this.model.stopBatch(e, t);
  }
  batchUpdate(e, t, n) {
    const i = typeof e == "string" ? e : "update", r = typeof e == "string" ? t : e, o = typeof t == "function" ? n : t;
    this.startBatch(i, o);
    const a = r();
    return this.stopBatch(i, o), a;
  }
  updateCellId(e, t) {
    return this.model.updateCellId(e, t);
  }
  // #endregion
  // #region view
  findView(e) {
    return se.isCell(e) ? this.findViewByCell(e) : this.findViewByElem(e);
  }
  findViews(e) {
    return R.isRectangleLike(e) ? this.findViewsInArea(e) : M.isPointLike(e) ? this.findViewsFromPoint(e) : [];
  }
  findViewByCell(e) {
    return this.renderer.findViewByCell(e);
  }
  findViewByElem(e) {
    return this.renderer.findViewByElem(e);
  }
  findViewsFromPoint(e, t) {
    const n = typeof e == "number" ? { x: e, y: t } : e;
    return this.renderer.findViewsFromPoint(n);
  }
  findViewsInArea(e, t, n, i, r) {
    const o = typeof e == "number" ? {
      x: e,
      y: t,
      width: n,
      height: i
    } : e, a = typeof e == "number" ? r : t;
    return this.renderer.findViewsInArea(o, a);
  }
  matrix(e) {
    return typeof e > "u" ? this.transform.getMatrix() : (this.transform.setMatrix(e), this);
  }
  resize(e, t) {
    const n = this.getPlugin("scroller");
    return n ? n.resize(e, t) : this.transform.resize(e, t), this;
  }
  scale(e, t = e, n = 0, i = 0) {
    return typeof e > "u" ? this.transform.getScale() : (this.transform.scale(e, t, n, i), this);
  }
  zoom(e, t) {
    const n = this.getPlugin("scroller");
    if (n) {
      if (typeof e > "u")
        return n.zoom();
      n.zoom(e, t);
    } else {
      if (typeof e > "u")
        return this.transform.getZoom();
      this.transform.zoom(e, t);
    }
    return this;
  }
  zoomTo(e, t = {}) {
    const n = this.getPlugin("scroller");
    return n ? n.zoom(e, Object.assign(Object.assign({}, t), { absolute: !0 })) : this.transform.zoom(e, Object.assign(Object.assign({}, t), { absolute: !0 })), this;
  }
  zoomToRect(e, t = {}) {
    const n = this.getPlugin("scroller");
    return n ? n.zoomToRect(e, t) : this.transform.zoomToRect(e, t), this;
  }
  zoomToFit(e = {}) {
    const t = this.getPlugin("scroller");
    return t ? t.zoomToFit(e) : this.transform.zoomToFit(e), this;
  }
  rotate(e, t, n) {
    return typeof e > "u" ? this.transform.getRotation() : (this.transform.rotate(e, t, n), this);
  }
  translate(e, t) {
    return typeof e > "u" ? this.transform.getTranslation() : (this.transform.translate(e, t), this);
  }
  translateBy(e, t) {
    const n = this.translate(), i = n.tx + e, r = n.ty + t;
    return this.translate(i, r);
  }
  getGraphArea() {
    return this.transform.getGraphArea();
  }
  getContentArea(e = {}) {
    return this.transform.getContentArea(e);
  }
  getContentBBox(e = {}) {
    return this.transform.getContentBBox(e);
  }
  fitToContent(e, t, n, i) {
    return this.transform.fitToContent(e, t, n, i);
  }
  scaleContentToFit(e = {}) {
    return this.transform.scaleContentToFit(e), this;
  }
  /**
   * Position the center of graph to the center of the viewport.
   */
  center(e) {
    return this.centerPoint(e);
  }
  centerPoint(e, t, n) {
    const i = this.getPlugin("scroller");
    return i ? i.centerPoint(e, t, n) : this.transform.centerPoint(e, t), this;
  }
  centerContent(e) {
    const t = this.getPlugin("scroller");
    return t ? t.centerContent(e) : this.transform.centerContent(e), this;
  }
  centerCell(e, t) {
    const n = this.getPlugin("scroller");
    return n ? n.centerCell(e, t) : this.transform.centerCell(e), this;
  }
  positionPoint(e, t, n, i = {}) {
    const r = this.getPlugin("scroller");
    return r ? r.positionPoint(e, t, n, i) : this.transform.positionPoint(e, t, n), this;
  }
  positionRect(e, t, n) {
    const i = this.getPlugin("scroller");
    return i ? i.positionRect(e, t, n) : this.transform.positionRect(e, t), this;
  }
  positionCell(e, t, n) {
    const i = this.getPlugin("scroller");
    return i ? i.positionCell(e, t, n) : this.transform.positionCell(e, t), this;
  }
  positionContent(e, t) {
    const n = this.getPlugin("scroller");
    return n ? n.positionContent(e, t) : this.transform.positionContent(e, t), this;
  }
  snapToGrid(e, t) {
    return this.coord.snapToGrid(e, t);
  }
  pageToLocal(e, t, n, i) {
    return R.isRectangleLike(e) ? this.coord.pageToLocalRect(e) : typeof e == "number" && typeof t == "number" && typeof n == "number" && typeof i == "number" ? this.coord.pageToLocalRect(e, t, n, i) : this.coord.pageToLocalPoint(e, t);
  }
  localToPage(e, t, n, i) {
    return R.isRectangleLike(e) ? this.coord.localToPageRect(e) : typeof e == "number" && typeof t == "number" && typeof n == "number" && typeof i == "number" ? this.coord.localToPageRect(e, t, n, i) : this.coord.localToPagePoint(e, t);
  }
  clientToLocal(e, t, n, i) {
    return R.isRectangleLike(e) ? this.coord.clientToLocalRect(e) : typeof e == "number" && typeof t == "number" && typeof n == "number" && typeof i == "number" ? this.coord.clientToLocalRect(e, t, n, i) : this.coord.clientToLocalPoint(e, t);
  }
  localToClient(e, t, n, i) {
    return R.isRectangleLike(e) ? this.coord.localToClientRect(e) : typeof e == "number" && typeof t == "number" && typeof n == "number" && typeof i == "number" ? this.coord.localToClientRect(e, t, n, i) : this.coord.localToClientPoint(e, t);
  }
  localToGraph(e, t, n, i) {
    return R.isRectangleLike(e) ? this.coord.localToGraphRect(e) : typeof e == "number" && typeof t == "number" && typeof n == "number" && typeof i == "number" ? this.coord.localToGraphRect(e, t, n, i) : this.coord.localToGraphPoint(e, t);
  }
  graphToLocal(e, t, n, i) {
    return R.isRectangleLike(e) ? this.coord.graphToLocalRect(e) : typeof e == "number" && typeof t == "number" && typeof n == "number" && typeof i == "number" ? this.coord.graphToLocalRect(e, t, n, i) : this.coord.graphToLocalPoint(e, t);
  }
  clientToGraph(e, t, n, i) {
    return R.isRectangleLike(e) ? this.coord.clientToGraphRect(e) : typeof e == "number" && typeof t == "number" && typeof n == "number" && typeof i == "number" ? this.coord.clientToGraphRect(e, t, n, i) : this.coord.clientToGraphPoint(e, t);
  }
  // #endregion
  // #region defs
  defineFilter(e) {
    return this.defs.filter(e);
  }
  defineGradient(e) {
    return this.defs.gradient(e);
  }
  defineMarker(e) {
    return this.defs.marker(e);
  }
  // #endregion
  // #region grid
  getGridSize() {
    return this.grid.getGridSize();
  }
  setGridSize(e) {
    return this.grid.setGridSize(e), this;
  }
  showGrid() {
    return this.grid.show(), this;
  }
  hideGrid() {
    return this.grid.hide(), this;
  }
  clearGrid() {
    return this.grid.clear(), this;
  }
  drawGrid(e) {
    return this.grid.draw(e), this;
  }
  // #endregion
  // #region background
  updateBackground() {
    return this.background.update(), this;
  }
  drawBackground(e, t) {
    const n = this.getPlugin("scroller");
    return n != null && (this.options.background == null || !t) ? n.drawBackground(e, t) : this.background.draw(e), this;
  }
  clearBackground(e) {
    const t = this.getPlugin("scroller");
    return t != null && (this.options.background == null || !e) ? t.clearBackground(e) : this.background.clear(), this;
  }
  // #endregion
  // #region virtual-render
  enableVirtualRender() {
    return this.virtualRender.enableVirtualRender(), this;
  }
  disableVirtualRender() {
    return this.virtualRender.disableVirtualRender(), this;
  }
  // #endregion
  // #region mousewheel
  isMouseWheelEnabled() {
    return !this.mousewheel.disabled;
  }
  enableMouseWheel() {
    return this.mousewheel.enable(), this;
  }
  disableMouseWheel() {
    return this.mousewheel.disable(), this;
  }
  toggleMouseWheel(e) {
    return e == null ? this.isMouseWheelEnabled() ? this.disableMouseWheel() : this.enableMouseWheel() : e ? this.enableMouseWheel() : this.disableMouseWheel(), this;
  }
  // #endregion
  // #region panning
  isPannable() {
    const e = this.getPlugin("scroller");
    return e ? e.isPannable() : this.panning.pannable;
  }
  enablePanning() {
    const e = this.getPlugin("scroller");
    return e ? e.enablePanning() : this.panning.enablePanning(), this;
  }
  disablePanning() {
    const e = this.getPlugin("scroller");
    return e ? e.disablePanning() : this.panning.disablePanning(), this;
  }
  togglePanning(e) {
    return e == null ? this.isPannable() ? this.disablePanning() : this.enablePanning() : e !== this.isPannable() && (e ? this.enablePanning() : this.disablePanning()), this;
  }
  // #endregion
  // #region plugin
  use(e, ...t) {
    return this.installedPlugins.has(e) || (this.installedPlugins.add(e), e.init(this, ...t)), this;
  }
  getPlugin(e) {
    return Array.from(this.installedPlugins).find((t) => t.name === e);
  }
  getPlugins(e) {
    return Array.from(this.installedPlugins).filter((t) => e.includes(t.name));
  }
  enablePlugins(e) {
    let t = e;
    Array.isArray(t) || (t = [t]);
    const n = this.getPlugins(t);
    return n == null || n.forEach((i) => {
      var r;
      (r = i == null ? void 0 : i.enable) === null || r === void 0 || r.call(i);
    }), this;
  }
  disablePlugins(e) {
    let t = e;
    Array.isArray(t) || (t = [t]);
    const n = this.getPlugins(t);
    return n == null || n.forEach((i) => {
      var r;
      (r = i == null ? void 0 : i.disable) === null || r === void 0 || r.call(i);
    }), this;
  }
  isPluginEnabled(e) {
    var t;
    const n = this.getPlugin(e);
    return (t = n == null ? void 0 : n.isEnabled) === null || t === void 0 ? void 0 : t.call(n);
  }
  disposePlugins(e) {
    let t = e;
    Array.isArray(t) || (t = [t]);
    const n = this.getPlugins(t);
    return n == null || n.forEach((i) => {
      i.dispose(), this.installedPlugins.delete(i);
    }), this;
  }
  // #endregion
  // #region dispose
  dispose(e = !0) {
    e && this.model.dispose(), this.css.dispose(), this.defs.dispose(), this.grid.dispose(), this.coord.dispose(), this.transform.dispose(), this.highlight.dispose(), this.background.dispose(), this.mousewheel.dispose(), this.panning.dispose(), this.view.dispose(), this.renderer.dispose(), this.installedPlugins.forEach((t) => {
      t.dispose();
    });
  }
}
m5([
  yt.dispose()
], et.prototype, "dispose", null);
(function(s) {
  s.View = Zt, s.Renderer = Ec, s.MouseWheel = Cc, s.DefsManager = Fg, s.GridManager = bc, s.CoordManager = $g, s.TransformManager = Rg, s.HighlightManager = Oo, s.BackgroundManager = vc, s.PanningManager = xc;
})(et || (et = {}));
(function(s) {
  s.toStringTag = "X6.".concat(s.name);
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof s)
      return !0;
    const n = t[Symbol.toStringTag];
    return n == null || n === s.toStringTag;
  }
  s.isGraph = e;
})(et || (et = {}));
(function(s) {
  function e(t, n) {
    const i = t instanceof HTMLElement ? new s({ container: t }) : new s(t);
    return n != null && i.fromJSON(n), i;
  }
  s.render = e;
})(et || (et = {}));
(function(s) {
  s.registerNode = $e.registry.register, s.registerEdge = Me.registry.register, s.registerView = Te.registry.register, s.registerAttr = Xt.registry.register, s.registerGrid = _n.registry.register, s.registerFilter = ii.registry.register, s.registerNodeTool = ai.registry.register, s.registerEdgeTool = li.registry.register, s.registerBackground = ar.registry.register, s.registerHighlighter = cn.registry.register, s.registerPortLayout = as.registry.register, s.registerPortLabelLayout = ri.registry.register, s.registerMarker = Bn.registry.register, s.registerRouter = On.registry.register, s.registerConnector = ls.registry.register, s.registerAnchor = ci.registry.register, s.registerEdgeAnchor = hi.registry.register, s.registerConnectionPoint = ui.registry.register;
})(et || (et = {}));
(function(s) {
  s.unregisterNode = $e.registry.unregister, s.unregisterEdge = Me.registry.unregister, s.unregisterView = Te.registry.unregister, s.unregisterAttr = Xt.registry.unregister, s.unregisterGrid = _n.registry.unregister, s.unregisterFilter = ii.registry.unregister, s.unregisterNodeTool = ai.registry.unregister, s.unregisterEdgeTool = li.registry.unregister, s.unregisterBackground = ar.registry.unregister, s.unregisterHighlighter = cn.registry.unregister, s.unregisterPortLayout = as.registry.unregister, s.unregisterPortLabelLayout = ri.registry.unregister, s.unregisterMarker = Bn.registry.unregister, s.unregisterRouter = On.registry.unregister, s.unregisterConnector = ls.registry.unregister, s.unregisterAnchor = ci.registry.unregister, s.unregisterEdgeAnchor = hi.registry.unregister, s.unregisterConnectionPoint = ui.registry.unregister;
})(et || (et = {}));
var w5 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
}, y5 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
class bs extends $e {
}
(function(s) {
  class e extends Rt {
    init() {
      super.init(), this.cell.on("change:*", this.onCellChangeAny, this);
    }
    onCellChangeAny({ key: n }) {
      const i = s.shapeMaps[this.cell.shape];
      if (i) {
        const { effect: r } = i;
        (!r || r.includes(n)) && this.renderHTMLComponent();
      }
    }
    confirmUpdate(n) {
      const i = super.confirmUpdate(n);
      return this.handleAction(i, e.action, () => this.renderHTMLComponent());
    }
    renderHTMLComponent() {
      const n = this.selectors && this.selectors.foContent;
      if (n) {
        Cr(n);
        const i = s.shapeMaps[this.cell.shape];
        if (!i)
          return;
        let { html: r } = i;
        typeof r == "function" && (r = r(this.cell)), r && (typeof r == "string" ? n.innerHTML = r : Er(n, r));
      }
    }
    dispose() {
      this.cell.off("change:*", this.onCellChangeAny, this);
    }
  }
  w5([
    e.dispose()
  ], e.prototype, "dispose", null), s.View = e, function(t) {
    t.action = "html", t.config({
      bootstrap: [t.action],
      actions: {
        html: t.action
      }
    }), Rt.registry.register("html-view", t, !0);
  }(e = s.View || (s.View = {}));
})(bs || (bs = {}));
(function(s) {
  s.config({
    view: "html-view",
    markup: [
      {
        tagName: "rect",
        selector: "body"
      },
      Object.assign({}, be.getForeignObjectMarkup()),
      {
        tagName: "text",
        selector: "label"
      }
    ],
    attrs: {
      body: {
        fill: "none",
        stroke: "none",
        refWidth: "100%",
        refHeight: "100%"
      },
      fo: {
        refWidth: "100%",
        refHeight: "100%"
      }
    }
  }), $e.registry.register("html", s, !0);
})(bs || (bs = {}));
(function(s) {
  s.shapeMaps = {};
  function e(t) {
    const { shape: n, html: i, effect: r, inherit: o } = t, a = y5(t, ["shape", "html", "effect", "inherit"]);
    if (!n)
      throw new Error("should specify shape in config");
    s.shapeMaps[n] = {
      html: i,
      effect: r
    }, et.registerNode(n, Object.assign({ inherit: o || "html" }, a), !0);
  }
  s.register = e;
})(bs || (bs = {}));
var p9 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function b5(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
function v5(s, e, t, n) {
  return n === void 0 && (n = "height"), t === "center" ? (s[n] + e[n]) / 2 : s.height;
}
var Wn = {
  assign: Object.assign,
  getHeight: v5
}, Vg = Wn, Sc = 18, x5 = Sc * 2, eu = Sc, C5 = {
  getId: function(e) {
    return e.id || e.name;
  },
  getPreH: function(e) {
    return e.preH || 0;
  },
  getPreV: function(e) {
    return e.preV || 0;
  },
  getHGap: function(e) {
    return e.hgap || eu;
  },
  getVGap: function(e) {
    return e.vgap || eu;
  },
  getChildren: function(e) {
    return e.children;
  },
  getHeight: function(e) {
    return e.height || x5;
  },
  getWidth: function(e) {
    var t = e.label || " ";
    return e.width || t.split("").length * Sc;
  }
};
function To(s, e) {
  var t = this;
  if (t.vgap = t.hgap = 0, s instanceof To)
    return s;
  t.data = s;
  var n = e.getHGap(s), i = e.getVGap(s);
  return t.preH = e.getPreH(s), t.preV = e.getPreV(s), t.width = e.getWidth(s), t.height = e.getHeight(s), t.width += t.preH, t.height += t.preV, t.id = e.getId(s), t.x = t.y = 0, t.depth = 0, t.children || (t.children = []), t.addGap(n, i), t;
}
Vg.assign(To.prototype, {
  isRoot: function() {
    return this.depth === 0;
  },
  isLeaf: function() {
    return this.children.length === 0;
  },
  addGap: function(e, t) {
    var n = this;
    n.hgap += e, n.vgap += t, n.width += 2 * e, n.height += 2 * t;
  },
  eachNode: function(e) {
    for (var t = this, n = [t], i; i = n.shift(); )
      e(i), n = i.children.concat(n);
  },
  DFTraverse: function(e) {
    this.eachNode(e);
  },
  BFTraverse: function(e) {
    for (var t = this, n = [t], i; i = n.shift(); )
      e(i), n = n.concat(i.children);
  },
  getBoundingBox: function() {
    var e = {
      left: Number.MAX_VALUE,
      top: Number.MAX_VALUE,
      width: 0,
      height: 0
    };
    return this.eachNode(function(t) {
      e.left = Math.min(e.left, t.x), e.top = Math.min(e.top, t.y), e.width = Math.max(e.width, t.x + t.width), e.height = Math.max(e.height, t.y + t.height);
    }), e;
  },
  // translate
  translate: function(e, t) {
    e === void 0 && (e = 0), t === void 0 && (t = 0), this.eachNode(function(n) {
      n.x += e, n.y += t, n.x += n.preH, n.y += n.preV;
    });
  },
  right2left: function() {
    var e = this, t = e.getBoundingBox();
    e.eachNode(function(n) {
      n.x = n.x - (n.x - t.left) * 2 - n.width;
    }), e.translate(t.width, 0);
  },
  bottom2top: function() {
    var e = this, t = e.getBoundingBox();
    e.eachNode(function(n) {
      n.y = n.y - (n.y - t.top) * 2 - n.height;
    }), e.translate(0, t.height);
  }
});
function E5(s, e, t) {
  e === void 0 && (e = {}), e = Vg.assign({}, C5, e);
  var n = new To(s, e), i = [n], r;
  if (!t && !s.collapsed) {
    for (; r = i.shift(); )
      if (!r.data.collapsed) {
        var o = e.getChildren(r.data), a = o ? o.length : 0;
        if (r.children = new Array(a), o && a)
          for (var l = 0; l < a; l++) {
            var c = new To(o[l], e);
            r.children[l] = c, i.push(c), c.parent = r, c.depth = r.depth + 1;
          }
      }
  }
  return n;
}
var Hg = E5, S5 = Hg, A5 = /* @__PURE__ */ function() {
  function s(t, n) {
    n === void 0 && (n = {});
    var i = this;
    i.options = n, i.rootNode = S5(t, n);
  }
  var e = s.prototype;
  return e.execute = function() {
    throw new Error("please override this method");
  }, s;
}(), sa = A5;
function Ti(s, e, t, n) {
  n === void 0 && (n = []);
  var i = this;
  i.w = s || 0, i.h = e || 0, i.y = t || 0, i.x = 0, i.c = n || [], i.cs = n.length, i.prelim = 0, i.mod = 0, i.shift = 0, i.change = 0, i.tl = null, i.tr = null, i.el = null, i.er = null, i.msel = 0, i.mser = 0;
}
Ti.fromNode = function(s, e) {
  if (!s)
    return null;
  var t = [];
  return s.children.forEach(function(n) {
    t.push(Ti.fromNode(n, e));
  }), e ? new Ti(s.height, s.width, s.x, t) : new Ti(s.width, s.height, s.y, t);
};
function Ug(s, e, t) {
  t ? s.y += e : s.x += e, s.children.forEach(function(n) {
    Ug(n, e, t);
  });
}
function qg(s, e) {
  var t = e ? s.y : s.x;
  return s.children.forEach(function(n) {
    t = Math.min(qg(n, e), t);
  }), t;
}
function M5(s, e) {
  var t = qg(s, e);
  Ug(s, -t, e);
}
function Gg(s, e, t) {
  t ? e.y = s.x : e.x = s.x, s.c.forEach(function(n, i) {
    Gg(n, e.children[i], t);
  });
}
function Wg(s, e, t) {
  t === void 0 && (t = 0), e ? (s.x = t, t += s.width) : (s.y = t, t += s.height), s.children.forEach(function(n) {
    Wg(n, e, t);
  });
}
var k5 = function(s, e) {
  e === void 0 && (e = {});
  var t = e.isHorizontal;
  function n(y) {
    if (y.cs === 0) {
      i(y);
      return;
    }
    n(y.c[0]);
    for (var b = w(c(y.c[0].el), 0, null), x = 1; x < y.cs; ++x) {
      n(y.c[x]);
      var C = c(y.c[x].er);
      r(y, x, b), b = w(C, x, b);
    }
    f(y), i(y);
  }
  function i(y) {
    y.cs === 0 ? (y.el = y, y.er = y, y.msel = y.mser = 0) : (y.el = y.c[0].el, y.msel = y.c[0].msel, y.er = y.c[y.cs - 1].er, y.mser = y.c[y.cs - 1].mser);
  }
  function r(y, b, x) {
    for (var C = y.c[b - 1], A = C.mod, k = y.c[b], O = k.mod; C !== null && k !== null; ) {
      c(C) > x.low && (x = x.nxt);
      var P = A + C.prelim + C.w - (O + k.prelim);
      P > 0 && (O += P, o(y, b, x.index, P));
      var D = c(C), N = c(k);
      D <= N && (C = l(C), C !== null && (A += C.mod)), D >= N && (k = a(k), k !== null && (O += k.mod));
    }
    !C && k ? u(y, b, k, O) : C && !k && d(y, b, C, A);
  }
  function o(y, b, x, C) {
    y.c[b].mod += C, y.c[b].msel += C, y.c[b].mser += C, p(y, b, x, C);
  }
  function a(y) {
    return y.cs === 0 ? y.tl : y.c[0];
  }
  function l(y) {
    return y.cs === 0 ? y.tr : y.c[y.cs - 1];
  }
  function c(y) {
    return y.y + y.h;
  }
  function u(y, b, x, C) {
    var A = y.c[0].el;
    A.tl = x;
    var k = C - x.mod - y.c[0].msel;
    A.mod += k, A.prelim -= k, y.c[0].el = y.c[b].el, y.c[0].msel = y.c[b].msel;
  }
  function d(y, b, x, C) {
    var A = y.c[b].er;
    A.tr = x;
    var k = C - x.mod - y.c[b].mser;
    A.mod += k, A.prelim -= k, y.c[b].er = y.c[b - 1].er, y.c[b].mser = y.c[b - 1].mser;
  }
  function f(y) {
    y.prelim = (y.c[0].prelim + y.c[0].mod + y.c[y.cs - 1].mod + y.c[y.cs - 1].prelim + y.c[y.cs - 1].w) / 2 - y.w / 2;
  }
  function g(y, b) {
    b += y.mod, y.x = y.prelim + b, m(y);
    for (var x = 0; x < y.cs; x++)
      g(y.c[x], b);
  }
  function p(y, b, x, C) {
    if (x !== b - 1) {
      var A = b - x;
      y.c[x + 1].shift += C / A, y.c[b].shift -= C / A, y.c[b].change -= C - C / A;
    }
  }
  function m(y) {
    for (var b = 0, x = 0, C = 0; C < y.cs; C++)
      b += y.c[C].shift, x += b + y.c[C].change, y.c[C].mod += x;
  }
  function w(y, b, x) {
    for (; x !== null && y >= x.low; )
      x = x.nxt;
    return {
      low: y,
      index: b,
      nxt: x
    };
  }
  Wg(s, t);
  var v = Ti.fromNode(s, t);
  return n(v), g(v, 0), Gg(v, s, t), M5(s, t), s;
}, tu = Hg, Jg = function(s, e) {
  for (var t = tu(s.data, e, !0), n = tu(s.data, e, !0), i = s.children.length, r = Math.round(i / 2), o = e.getSide || function(u, d) {
    return d < r ? "right" : "left";
  }, a = 0; a < i; a++) {
    var l = s.children[a], c = o(l, a);
    c === "right" ? n.children.push(l) : t.children.push(l);
  }
  return t.eachNode(function(u) {
    u.isRoot() || (u.side = "left");
  }), n.eachNode(function(u) {
    u.isRoot() || (u.side = "right");
  }), {
    left: t,
    right: n
  };
}, P5 = Jg, En = [
  "LR",
  // left to right
  "RL",
  // right to left
  "TB",
  // top to bottom
  "BT",
  // bottom to top
  "H",
  // horizontal
  "V"
  // vertical
], _5 = ["LR", "RL", "H"], O5 = function(e) {
  return _5.indexOf(e) > -1;
}, T5 = En[0], Ac = function(s, e, t) {
  var n = e.direction || T5;
  if (e.isHorizontal = O5(n), n && En.indexOf(n) === -1)
    throw new TypeError("Invalid direction: " + n);
  if (n === En[0])
    t(s, e);
  else if (n === En[1])
    t(s, e), s.right2left();
  else if (n === En[2])
    t(s, e);
  else if (n === En[3])
    t(s, e), s.bottom2top();
  else if (n === En[4] || n === En[5]) {
    var i = P5(s, e), r = i.left, o = i.right;
    t(r, e), t(o, e), e.isHorizontal ? r.right2left() : r.bottom2top(), o.translate(r.x - o.x, r.y - o.y), s.x = r.x, s.y = o.y;
    var a = s.getBoundingBox();
    e.isHorizontal ? a.top < 0 && s.translate(0, -a.top) : a.left < 0 && s.translate(-a.left, 0);
  }
  var l = e.fixedRoot;
  return l === void 0 && (l = !0), l && s.translate(-(s.x + s.width / 2 + s.hgap), -(s.y + s.height / 2 + s.vgap)), s;
};
function L5(s, e) {
  s.prototype = Object.create(e.prototype), s.prototype.constructor = s, Sl(s, e);
}
function Sl(s, e) {
  return Sl = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, Sl(s, e);
}
var N5 = sa, D5 = k5, I5 = Ac, j5 = Wn, R5 = /* @__PURE__ */ function(s) {
  function e() {
    return s.apply(this, arguments) || this;
  }
  L5(e, s);
  var t = e.prototype;
  return t.execute = function() {
    var i = this;
    return I5(i.rootNode, i.options, D5);
  }, e;
}(N5), B5 = {};
function F5(s, e) {
  return e = j5.assign({}, B5, e), new R5(s, e).execute();
}
var $5 = F5, z5 = Wn;
function V5(s, e) {
  e === void 0 && (e = []);
  var t = this;
  t.x = t.y = 0, t.leftChild = t.rightChild = null, t.height = 0, t.children = e;
}
var H5 = {
  isHorizontal: !0,
  nodeSep: 20,
  nodeSize: 20,
  rankSep: 200,
  subTreeSep: 10
};
function Yg(s, e, t) {
  t ? (e.x = s.x, e.y = s.y) : (e.x = s.y, e.y = s.x), s.children.forEach(function(n, i) {
    Yg(n, e.children[i], t);
  });
}
var U5 = function(s, e) {
  e === void 0 && (e = {}), e = z5.assign({}, H5, e);
  var t = 0;
  function n(l) {
    if (!l)
      return null;
    l.width = 0, l.depth && l.depth > t && (t = l.depth);
    var c = l.children, u = c.length, d = new V5(l.height, []);
    return c.forEach(function(f, g) {
      var p = n(f);
      d.children.push(p), g === 0 && (d.leftChild = p), g === u - 1 && (d.rightChild = p);
    }), d.originNode = l, d.isLeaf = l.isLeaf(), d;
  }
  function i(l) {
    if (l.isLeaf || l.children.length === 0)
      l.drawingDepth = t;
    else {
      var c = l.children.map(function(d) {
        return i(d);
      }), u = Math.min.apply(null, c);
      l.drawingDepth = u - 1;
    }
    return l.drawingDepth;
  }
  var r;
  function o(l) {
    l.x = l.drawingDepth * e.rankSep, l.isLeaf ? (l.y = 0, r && (l.y = r.y + r.height + e.nodeSep, l.originNode.parent !== r.originNode.parent && (l.y += e.subTreeSep)), r = l) : (l.children.forEach(function(c) {
      o(c);
    }), l.y = (l.leftChild.y + l.rightChild.y) / 2);
  }
  var a = n(s);
  return i(a), o(a), Yg(a, s, e.isHorizontal), s;
};
function q5(s, e) {
  s.prototype = Object.create(e.prototype), s.prototype.constructor = s, Al(s, e);
}
function Al(s, e) {
  return Al = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, Al(s, e);
}
var G5 = sa, W5 = U5, J5 = Ac, Y5 = Wn, X5 = /* @__PURE__ */ function(s) {
  function e() {
    return s.apply(this, arguments) || this;
  }
  q5(e, s);
  var t = e.prototype;
  return t.execute = function() {
    var i = this;
    return i.rootNode.width = 0, J5(i.rootNode, i.options, W5);
  }, e;
}(G5), Z5 = {};
function K5(s, e) {
  return e = Y5.assign({}, Z5, e), new X5(s, e).execute();
}
var Q5 = K5, nu = Wn;
function ev(s, e, t, n, i) {
  var r = typeof t == "function" ? t(s) : t * s.depth;
  if (!n)
    try {
      if (s.id === s.parent.children[0].id) {
        s.x += r, s.y = e ? e.y : 0;
        return;
      }
    } catch (l) {
    }
  if (s.x += r, e) {
    if (s.y = e.y + nu.getHeight(e, s, i), e.parent && s.parent.id !== e.parent.id) {
      var o = e.parent, a = o.y + nu.getHeight(o, s, i);
      s.y = a > s.y ? a : s.y;
    }
  } else
    s.y = 0;
}
var tv = function(s, e, t, n) {
  var i = null;
  s.eachNode(function(r) {
    ev(r, i, e, t, n), i = r;
  });
};
function nv(s, e) {
  s.prototype = Object.create(e.prototype), s.prototype.constructor = s, Ml(s, e);
}
function Ml(s, e) {
  return Ml = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, Ml(s, e);
}
var sv = sa, Gr = tv, iv = Jg, rv = Wn, Li = [
  "LR",
  // left to right
  "RL",
  // right to left
  "H"
  // horizontal
], ov = Li[0], av = /* @__PURE__ */ function(s) {
  function e() {
    return s.apply(this, arguments) || this;
  }
  nv(e, s);
  var t = e.prototype;
  return t.execute = function() {
    var i = this, r = i.options, o = i.rootNode;
    r.isHorizontal = !0;
    var a = r.indent, l = a === void 0 ? 20 : a, c = r.dropCap, u = c === void 0 ? !0 : c, d = r.direction, f = d === void 0 ? ov : d, g = r.align;
    if (f && Li.indexOf(f) === -1)
      throw new TypeError("Invalid direction: " + f);
    if (f === Li[0])
      Gr(o, l, u, g);
    else if (f === Li[1])
      Gr(o, l, u, g), o.right2left();
    else if (f === Li[2]) {
      var p = iv(o, r), m = p.left, w = p.right;
      Gr(m, l, u, g), m.right2left(), Gr(w, l, u, g);
      var v = m.getBoundingBox();
      w.translate(v.width, 0), o.x = w.x - o.width / 2;
    }
    return o;
  }, e;
}(sv), lv = {};
function cv(s, e) {
  return e = rv.assign({}, lv, e), new av(s, e).execute();
}
var hv = cv, uv = Wn;
function Xg(s, e) {
  var t = 0;
  return s.children.length ? s.children.forEach(function(n) {
    t += Xg(n, e);
  }) : t = s.height, s._subTreeSep = e.getSubTreeSep(s.data), s.totalHeight = Math.max(s.height, t) + 2 * s._subTreeSep, s.totalHeight;
}
function Zg(s) {
  var e = s.children, t = e.length;
  if (t) {
    e.forEach(function(l) {
      Zg(l);
    });
    var n = e[0], i = e[t - 1], r = i.y - n.y + i.height, o = 0;
    if (e.forEach(function(l) {
      o += l.totalHeight;
    }), r > s.height)
      s.y = n.y + r / 2 - s.height / 2;
    else if (e.length !== 1 || s.height > o) {
      var a = s.y + (s.height - r) / 2 - n.y;
      e.forEach(function(l) {
        l.translate(0, a);
      });
    } else
      s.y = (n.y + n.height / 2 + i.y + i.height / 2) / 2 - s.height / 2;
  }
}
var dv = {
  getSubTreeSep: function() {
    return 0;
  }
}, fv = function(s, e) {
  e === void 0 && (e = {}), e = uv.assign({}, dv, e), s.parent = {
    x: 0,
    width: 0,
    height: 0,
    y: 0
  }, s.BFTraverse(function(t) {
    t.x = t.parent.x + t.parent.width;
  }), s.parent = null, Xg(s, e), s.startY = 0, s.y = s.totalHeight / 2 - s.height / 2, s.eachNode(function(t) {
    var n = t.children, i = n.length;
    if (i) {
      var r = n[0];
      if (r.startY = t.startY + t._subTreeSep, i === 1)
        r.y = t.y + t.height / 2 - r.height / 2;
      else {
        r.y = r.startY + r.totalHeight / 2 - r.height / 2;
        for (var o = 1; o < i; o++) {
          var a = n[o];
          a.startY = n[o - 1].startY + n[o - 1].totalHeight, a.y = a.startY + a.totalHeight / 2 - a.height / 2;
        }
      }
    }
  }), Zg(s);
};
function gv(s, e) {
  s.prototype = Object.create(e.prototype), s.prototype.constructor = s, kl(s, e);
}
function kl(s, e) {
  return kl = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, kl(s, e);
}
var pv = sa, mv = fv, wv = Ac, yv = Wn, bv = /* @__PURE__ */ function(s) {
  function e() {
    return s.apply(this, arguments) || this;
  }
  gv(e, s);
  var t = e.prototype;
  return t.execute = function() {
    var i = this;
    return wv(i.rootNode, i.options, mv);
  }, e;
}(pv), vv = {};
function xv(s, e) {
  return e = yv.assign({}, vv, e), new bv(s, e).execute();
}
var Cv = xv, Ev = {
  compactBox: $5,
  dendrogram: Q5,
  indented: hv,
  mindmap: Cv
}, Sv = Ev;
const Av = /* @__PURE__ */ b5(Sv);
class Kg {
  constructor(e) {
    /**
     * 当前x6图形实例
     *
     * @author chitanda
     * @date 2023-11-09 18:11:46
     * @type {Graph}
     */
    E(this, "g");
    this.g = e;
  }
  /**
   * 由外部调用进行初始化(不可以重写)
   *
   * @return {*}  {Promise<void>}
   */
  init() {
    return this.onInit();
  }
  /**
   * 初始化(子类重写)
   *
   * @protected
   * @return {*}  {void}
   */
  onInit() {
  }
  /**
   * 监听消息变更
   *
   * @protected
   * @param {IPortalMessage} msg
   * @return {*}  {void}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onMessageChange(e) {
  }
  /**
   * 销毁
   *
   * @return {*}  {void}
   */
  destroy() {
  }
  /**
   * 加载图形数据
   *
   * @return {*}  {Promise<void>}
   */
  load() {
  }
  /**
   * 初始化数据
   */
  initData(e) {
    return e && e.length ? e.map((t) => t.shape === "mind-map" ? this.getMindMap(t) : t) : [];
  }
  /**
   * 获取思维导图
   */
  getMindMap(e) {
    return Av.mindmap(e, {
      direction: "H",
      getHeight(t) {
        return t.height;
      },
      getWidth(t) {
        return t.width;
      },
      getHGap() {
        return 40;
      },
      getVGap() {
        return 20;
      },
      getSide: () => "right"
    });
  }
}
class Mv extends Kg {
  constructor(t, n, i) {
    super(t);
    E(this, "ns");
    E(this, "nodeModel", {});
    E(this, "opt", {});
    // 默认初始化数据
    E(this, "items", []);
    E(this, "nodeKey");
    // 父控制器
    E(this, "x6Ctrl");
    this.nodeModel = i, this.x6Ctrl = n, this.nodeKey = this.nodeModel.nodeKey, this.ns = this.nodeModel.ns, this.register(), this.init();
  }
  onInit() {
    super.onInit();
  }
  register() {
    const t = this, { readonly: n } = this.nodeModel;
    bs.register({
      effect: ["data"],
      ...t.opt,
      shape: "mind-map-".concat(t.nodeKey),
      html(i) {
        const r = i.getData(), o = document.createElement("div");
        if (o.className = t.ns.b("custom-html-node"), !n) {
          o.onclick = (c) => {
            t.prevent(c), t.g.emit("mind-map:click", c, r);
          }, o.ondblclick = (c) => {
            t.prevent(c), t.g.emit("mind-map:dblclick", c, r);
          };
          const l = document.createElement("div");
          l.innerHTML = '<svg t="1721380398285" class="add-node-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1711" width="1em" height="1em"><path d="M512 170.67c-23.56 0-42.67 19.1-42.67 42.67v256h-256c-23.56 0-42.67 19.1-42.67 42.67s19.1 42.67 42.67 42.67h256v256c0 23.56 19.1 42.67 42.67 42.67s42.67-19.1 42.67-42.67v-256h256c23.56 0 42.67-19.1 42.67-42.67s-19.1-42.67-42.67-42.67h-256v-256c0-23.57-19.11-42.67-42.67-42.67z" p-id="1712"></path></svg>', l.className = t.ns.be(
            "custom-html-node",
            "add-item-icon-box"
          ), l.onclick = (c) => {
            t.prevent(c), t.g.emit("mind-map:add-topic", c, r);
          }, o.appendChild(l);
        }
        const a = t.createReadonlyNode.bind(t)(r);
        return o.append(a), o;
      }
    }), this.g.on("mind-map:dblclick", (i, r) => {
      let { target: o } = i, { parentNode: a } = o;
      a.classList.add("is-activated");
      const l = this.createEditNode(r);
      l.onblur = (c) => {
        this.prevent(c), this.onNodeEditBlur(c, r);
      }, l.onclick = this.prevent, l.ondblclick = this.prevent, a.appendChild(l), l.focus(), l.focus(), l.setSelectionRange(0, r.label.length), o.remove(), o = null, a = null;
    }), this.g.on("mind-map:click", (i) => {
      i.target.parentNode.classList.add(
        "is-activated"
      );
    });
  }
  /**
   * 加载
   */
  load() {
    const t = this.x6Ctrl.getData();
    this.items = this.initData(t), this.g.addNodes(this.addNodes(this.items));
  }
  /**
   * 新增节点数据
   */
  addNodes(t) {
    const n = [];
    return t.forEach((i) => {
      i.data && i.data.shape === "mind-map" ? this.createMindMapCell(i).forEach((o) => {
        n.push(o);
      }) : n.push(i);
    }), n;
  }
  // 创建思维导图项
  createMindMapCell(t) {
    const n = [];
    if (t) {
      const { children: i } = t;
      n.push(this.getMindMapCellItem(t)), i && (i != null && i.length) && i.forEach((r) => {
        n.push(...this.createMindMapCell(r));
      });
    }
    return n;
  }
  // 获取思维导图cell项
  getMindMapCellItem(t) {
    const { data: n } = t;
    return {
      id: n.id,
      shape: "mind-map-".concat(this.nodeKey),
      x: t.x,
      y: t.y,
      width: n.width,
      height: n.height,
      label: n.label,
      type: n.type,
      data: n,
      attrs: {
        body: {
          strokeWidth: 1,
          fill: "#fff",
          rx: 6,
          ry: 6
        }
      }
    };
  }
  // 获取样式
  getStyle(t, n) {
    return {
      width: "".concat(t, "px"),
      height: "".concat(n, "px"),
      lineHeight: "".concat(n, "px")
    };
  }
  // 创建只读节点
  createReadonlyNode(t) {
    const { label: n, width: i, height: r } = t, o = this.getStyle(i, r), a = document.createElement("div");
    return a.className = this.ns.be("custom-html-node", "readonly-node"), Object.assign(a.style, { ...o }), a.textContent = n, "".concat(n).length > 5 && (a.title = n), a;
  }
  // 创建编辑节点
  createEditNode(t) {
    const n = document.createElement("input");
    return n.setAttribute("value", t.label), n.setAttribute("type", "text"), Object.assign(n.style, {
      ...this.getStyle(t.width, t.height),
      textAlign: "center",
      lineHeight: "100%"
    }), n.className = this.ns.be("custom-html-node", "edit-node"), n;
  }
  // 处理单个节点编辑完成后失焦
  onNodeEditBlur(t, n) {
    const i = t.target, r = i.value || "", o = i.parentNode;
    i.remove();
    const a = this.createReadonlyNode(n);
    a.textContent = r, this.g.emit("mind-map:blur", t, n, r), o.appendChild(a);
  }
  // 阻止事件
  prevent(t) {
    t.stopPropagation(), t.preventDefault();
  }
}
class kv extends Kg {
  constructor(t, n, i = {}) {
    super(t);
    /**
     * 连线模型
     */
    E(this, "linkModel", {});
    /**
     * 连线配置参数
     */
    E(this, "opt", {
      inherit: "edge"
    });
    /**
     * 默认初始化数据
     */
    E(this, "items", []);
    /**
     * 父控制器
     */
    E(this, "x6Ctrl");
    this.linkModel = i, this.x6Ctrl = n, this.register();
  }
  onInit() {
    super.onInit();
  }
  register() {
    et.registerEdge(
      "mind-map-edge",
      {
        connector: {
          name: "mind-map"
        },
        attrs: {
          line: {
            targetMarker: "",
            stroke: "var(--ibiz-color-primary)",
            strokeWidth: 2
          }
        },
        zIndex: 0,
        ...this.opt
      },
      !0
    ), et.registerConnector("mind-map-connector", this.MindMapConnector, !0);
  }
  // 思维导图连接器计算
  MindMapConnector(t, n) {
    const i = Math.abs(n.x - t.x), r = new V();
    r.appendSegment(V.createSegment("M", t.x, t.y)), r.appendSegment(V.createSegment("L", t.x, t.y));
    const o = t.x < n.x ? t.x + i / 2 : t.x - i / 2, a = t.y, l = t.x < n.x ? n.x - i / 2 : n.x + i / 2, c = n.y;
    return r.appendSegment(
      V.createSegment("C", o, a, l, c, n.x, n.y)
    ), r.serialize();
  }
  load() {
    const t = this.x6Ctrl.getData();
    this.items = this.initData(t);
    const n = this.addEdges(this.items);
    this.g.addEdges(n);
  }
  /**
   * 新增节点数据
   */
  addEdges(t) {
    const n = [];
    return t.forEach((i) => {
      i.data && i.data.shape === "mind-map" ? i.children && i.children.length && n.push(...this.handleMindMap(i)) : n.push(i);
    }), n;
  }
  handleMindMap(t) {
    const n = [];
    return t && t.children && t.children.forEach((i) => {
      n.push(this.createMinMapCell(i, t)), i.children && i.children && n.push(...this.handleMindMap(i));
    }), n;
  }
  createMinMapCell(t, n) {
    if (t.data && t.data.shape === "mind-map") {
      const { id: i } = t;
      return {
        shape: "mind-map-edge",
        source: {
          cell: n.id,
          anchor: {
            name: "right",
            args: {
              dx: 0
            }
          }
        },
        target: {
          cell: i,
          anchor: {
            name: "left"
          }
        },
        connector: {
          name: "mind-map-connector"
          // 使用自定义连接器
        },
        data: t
      };
    }
    return t;
  }
}
class Pv {
  /**
   * Creates an instance of X6Controller.
   * @param {IPanelController} panel
   * @param {HTMLElement} dom
   * @param {X6Options} [defaultParams={}]
   */
  constructor(e, t = {}, n = {}) {
    /**
     * 事件触发器
     * @author lxm
     * @date 2023-04-25 09:36:31
     * @type {ControllerEvent}
     */
    E(this, "evt", new hu(
      this.getEventArgs.bind(this)
    ));
    /**
     * 当前x6图形实例
     *
     * @type {IParams}
     */
    E(this, "g");
    /**
     * 节点控制器
     *
     * @type {X6NodeController}
     */
    E(this, "node");
    /**
     * 连线适控制器
     *
     * @type {X6LinkController}
     */
    E(this, "link");
    /**
     * 默认配置参数
     */
    E(this, "defaultParams");
    // 备份数据
    E(this, "backupData", []);
    // 选中数据
    E(this, "selection", []);
    /**
     * 初始化聚焦
     */
    E(this, "internalFocus", !1);
    // 默认初始化数据
    E(this, "defaultData", []);
    /**
     * x6图形配置
     *
     * @protected
     * @type {IParams}
     */
    E(this, "graphOptions", {
      connecting: {
        // 表示使用节点或图形元素上定义的锚点作为连接点
        connectionPoint: "anchor"
      },
      interacting: {
        // 禁止拖动
        nodeMovable: !1
      },
      // 平移
      panning: !0
    });
    this.defaultParams = n, this.defaultData = n.defaultData, this.backupData = Nr(this.defaultData), Object.assign(this.graphOptions, t), this.graphOptions.container = e, this.graphOptions.mousewheel = {
      enabled: !0,
      global: !0,
      modifiers: ["ctrl", "meta"],
      zoomAtMousePosition: !0,
      guard(i) {
        var r, o;
        return ((o = (r = i.target) == null ? void 0 : r.parentNode) == null ? void 0 : o.id) === "diagram-".concat(n.nodeKey);
      }
    }, this.g = new et(this.graphOptions), this.link = new kv(this.g, this, {}), this.node = new Mv(this.g, this, {
      nodeKey: this.defaultParams.nodeKey,
      ns: this.defaultParams.ns,
      readonly: this.defaultParams.readonly
    }), this.defaultParams.readonly || this.g.disablePanning(), this.init();
  }
  /**
   * 获取事件的基础参数
   * @author lxm
   * @date 2023-04-25 11:03:44
   * @return {*}  {Omit<EventBase, 'eventName'>}
   */
  getEventArgs() {
    return {
      context: {},
      params: {},
      data: [],
      targetName: "",
      view: {}
    };
  }
  /**
   * 初始化
   */
  init() {
    this.initEvents(), this.load();
  }
  /**
   * 初始化事件
   */
  initEvents() {
    this.g.on("mind-map:add-topic", (e, t) => {
      const { id: n } = t;
      this.addChildNode(n) && this.refresh();
    }), this.g.on("mind-map:click", (e, t) => {
      this.clearSelection(), this.selection = [{ data: t, node: e.target.parentNode }], e.target.parentNode.classList.add(
        "is-activated"
      ), this.internalFocus = !0;
    }), this.g.on(
      "mind-map:blur",
      (e, t, n) => {
        this.updateNode(t.id, n || "") || this.refresh(), this.internalFocus = !1, this.evt.emit("onNodeBlur", void 0);
      }
    );
  }
  /**
   * 清除选中
   */
  clearSelection() {
    this.selection && this.selection.length > 0 && (this.selection[0].node.classList.remove("is-activated"), this.selection[0].node = null, this.selection = []);
  }
  /**
   * 新增子节点
   */
  addChildNode(e) {
    const t = this.findItem(this.backupData, e), n = t == null ? void 0 : t.node;
    if (n) {
      const i = n.children ? n.children.length : 0, r = {
        id: "".concat(e, "-").concat(i + 1),
        type: "topic-child",
        shape: "mind-map",
        label: "",
        width: 120,
        height: 30
      };
      if (r)
        return n.children ? n.children.push(r) : Object.assign(n, { children: [r] }), this.defaultData = Nr(this.backupData), r;
    }
    return null;
  }
  /**
   * 更新节点
   */
  updateNode(e, t) {
    const n = this.findItem(this.backupData, e), i = n == null ? void 0 : n.parent;
    if (i && i.children) {
      const { children: r } = i, o = r.findIndex((a) => a.id === e);
      return r[o].label = t, this.defaultData = Nr(this.backupData), !0;
    }
    return !1;
  }
  // 遍历item
  findItem(e, t) {
    let n = null;
    return e && e.length && e.forEach((i) => {
      if (i.id === t && (n = {
        parent: null,
        node: i
      }), i.children && i.children) {
        const r = this.findItem(i.children, t);
        r && (n = {
          parent: r.parent || i,
          node: r.node
        });
      }
    }), n;
  }
  /**
   * 删除节点
   */
  removeNode(e) {
    const t = this.findItem(this.backupData, e), n = t == null ? void 0 : t.parent;
    if (n && n.children) {
      const { children: i } = n, r = i.findIndex((o) => o.id === e);
      return i.splice(r, 1), this.defaultData = Nr(this.backupData), !0;
    }
    return !1;
  }
  /**
   * 改变是否可平移状态
   */
  togglePanning() {
    this.g.togglePanning();
  }
  /**
   * 禁用平移
   */
  disablePanning() {
    this.g.disablePanning();
  }
  /**
   * 初始化
   */
  getData() {
    return this.defaultData;
  }
  /**
   * 加载
   */
  async load() {
    this.node.load(), this.link.load(), this.g.centerContent();
  }
  /**
   * 刷新
   */
  async refresh() {
    this.g.clearCells({ refresh: !0 }), await this.load();
  }
  /**
   * 销毁
   */
  destroy() {
    this.g.dispose(), this.node.destroy(), this.link.destroy();
  }
}
const _v = /* @__PURE__ */ ye({
  name: "IBizDiagramBoard",
  props: As(),
  emits: ["change"],
  setup(s) {
    const e = me("diagram-board"), t = L(), n = L(), i = L(!1), r = L();
    r.value = h6();
    let o, a = c6();
    if (s.data) {
      const {
        data: v
      } = s.data;
      a = v;
    }
    const l = async () => {
      o == null || o.destroy();
    }, c = () => {
      var b;
      s.isFocus && ((b = t.value) == null || b.focus());
      const {
        offsetWidth: v,
        offsetHeight: y
      } = t.value;
      o = new Pv(n.value, {
        width: v,
        height: y
      }, {
        ns: e,
        nodeKey: s.nodeKey,
        readonly: s.readonly,
        defaultData: a
      }), o.g.zoomToFit(), o.g.zoom(-0.2), o.evt.on("onNodeBlur", () => {
        s.change({
          data: o == null ? void 0 : o.defaultData
        }, {
          isUpdate: !0
        });
      });
    }, u = () => {
      l(), o.internalFocus = !0, s.change("", {
        isDelete: !0
      });
    }, d = (v) => {
      switch (v.type) {
        case "delete":
          u();
          break;
        case "panning":
          o.togglePanning();
          break;
      }
    }, f = () => S("div", {
      class: e.b("top-tool-bar")
    }, [r.value.map((v) => S("div", {
      class: [e.be("top-tool-bar", "item"), e.be("top-tool-bar", "item-".concat(v.type))],
      title: v.text,
      onClick: () => d(v)
    }, [S("div", {
      class: e.bem("top-tool-bar", "item", "content"),
      innerHTML: v.icon || v.text
    }, null)]))]), g = async () => {
      i.value || (i.value = !0);
    }, p = () => {
      if (o) {
        if (o.clearSelection(), o.internalFocus)
          return;
        s.change({
          data: o == null ? void 0 : o.defaultData
        }), i.value = !1;
      }
    }, m = this;
    let w = new ResizeObserver(() => {
      t.value && t.value.offsetWidth !== 0 && (c.bind(m)(), w.disconnect(), w = null);
    });
    return fn(() => {
      n.value && (w.observe(n.value), t.value.addEventListener("click", () => {
        var v;
        o.clearSelection(), (v = t.value) == null || v.focus();
      }), t.value.addEventListener("keydown", (v) => {
        o.internalFocus = !1, (v.key === "Backspace" || v.key === "Delete") && o && o.selection && o.selection.length > 0 && o.removeNode(o.selection[0].data.id) && (o.clearSelection(), o.refresh());
      }));
    }), fr(() => {
      l();
    }), {
      ns: e,
      diagramRef: n,
      diagramBoxRef: t,
      diagramBoxActivate: i,
      onFocus: g,
      onBlur: p,
      renderTopToolBar: f
    };
  },
  render() {
    return S("div", {
      ref: "diagramBoxRef",
      class: [this.ns.b(), this.readonly ? this.ns.m("readonly") : "", this.ns.is("activated", this.diagramBoxActivate)],
      tabindex: "0",
      onFocus: this.onFocus,
      onBlur: this.onBlur
    }, [!this.readonly && this.diagramBoxActivate ? this.renderTopToolBar() : "", S("div", {
      id: "diagram-".concat(this.nodeKey),
      ref: "diagramRef"
    }, null)]);
  }
});
const Ov = (s, e) => {
  if (s === 0 || e === 0)
    return 0;
  let t = s / e * 100;
  return t < 0 ? t = 0 : t > 100 && (t = 100), t;
}, Tv = /* @__PURE__ */ ye({
  name: "IBizAudio",
  props: As(),
  setup(s) {
    const e = me("audio"), t = L(""), n = L(0), i = L("");
    if (s.data) {
      const {
        name: O,
        size: P,
        url: D
      } = s.data;
      t.value = O, n.value = P, i.value = D;
    }
    const r = L(!1), o = L("00:00"), a = L("00:00"), l = L(), c = L(), u = L(), d = L(0), f = L(0), g = L(0), p = qe(() => {
      const O = n.value <= 0 ? 0 : Math.round(n.value / 1048576 * 10) / 10;
      return "".concat(O, " MB");
    }), m = () => {
      if (l.value) {
        d.value = l.value.duration, Number.isNaN(d.value) && (d.value = 0);
        const O = parseInt((d.value / 60).toString(), 10);
        let P = O.toString();
        O < 10 && (P = "0".concat(O.toString()));
        const D = Math.round(d.value % 60);
        let N = D.toString();
        D < 10 && (N = "0".concat(D.toString())), a.value = "".concat(P, ":").concat(N);
      }
    }, w = () => {
      f.value = l.value.currentTime;
      const O = Math.floor(f.value), P = parseInt((O / 60).toString(), 10);
      let D = P.toString();
      P < 10 && (D = "0".concat(P.toString()));
      const N = Math.round(O % 60);
      let F = N.toString();
      N < 10 && (F = "0".concat(N.toString())), o.value = "".concat(D, ":").concat(F), a.value === "00:00" && m();
    }, v = () => {
      r.value = !1, l.value.load(), o.value = "00:00";
    }, y = () => {
      l.value.addEventListener("timeupdate", () => {
        w(), l.value && (g.value = Ov(f.value, d.value));
      }, !1), l.value.addEventListener("ended", () => {
        v();
      }), l.value.oncanplaythrough = () => {
        m();
      };
    }, b = () => {
      l.value.paused ? (l.value.play(), r.value = !0) : (l.value.pause(), r.value = !1);
    }, x = (O) => {
    };
    return fn(() => {
      l.value && y();
    }), {
      ns: e,
      realAudioTime: o,
      totalAudioTime: a,
      isPlay: r,
      audioRef: l,
      bar: c,
      slid: u,
      percentage: g,
      fileName: t,
      fileSizeText: p,
      audioSrc: i,
      play: b,
      renderStop: () => S("svg", {
        class: "icon",
        viewBox: "0 0 1024 1024",
        version: "1.1",
        xmlns: "http:// www.w3.org/2000/svg",
        "p-id": "3144",
        width: "1em",
        height: "1em"
      }, [S("path", {
        d: "M209.645253 863.934444l201.049992 0 0-703.866842L209.645253 160.067602 209.645253 863.934444zM611.804588 863.934444l201.113437 0 0-703.866842L611.804588 160.067602 611.804588 863.934444z",
        "p-id": "3145"
      }, null)]),
      renderArrowSvg: () => S("svg", {
        class: "icon",
        viewBox: "0 0 1024 1024",
        version: "1.1",
        xmlns: "http:// www.w3.org/2000/svg",
        "p-id": "2304",
        width: "1em",
        height: "1em"
      }, [S("path", {
        d: "M768 512 256 0 256 1024Z",
        "p-id": "2305"
      }, null)]),
      renderAudioSvg: () => S("svg", {
        class: "icon audio-icon",
        viewBox: "0 0 1092 1024",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg",
        "p-id": "4287",
        width: "1em",
        height: "1em"
      }, [S("path", {
        d: "M394.24 429.056v378.368c0 83.456-67.584 150.528-150.528 150.528-83.456 0-150.528-67.584-150.528-150.528 0-83.456 67.584-150.528 150.528-150.528 25.6 0 49.152 6.144 70.144 17.408V395.776 194.048c0-19.456 13.824-36.352 33.28-39.424l550.4-95.232c24.576-4.096 47.104 14.848 47.104 39.424v611.84c0 83.456-67.584 150.528-150.528 150.528-83.456 0-150.528-67.584-150.528-150.528 0-83.456 67.584-150.528 150.528-150.528 25.6 0 49.152 6.144 70.144 17.408V347.648L394.24 429.056z m0-81.408L864.256 266.24V146.432L394.24 228.352v119.296zM243.2 877.568c38.912 0 70.144-31.744 70.144-70.144 0-38.912-31.744-70.144-70.144-70.144s-70.144 31.744-70.144 70.144c0 38.4 31.744 70.144 70.144 70.144z m550.912-96.256c38.912 0 70.144-31.744 70.144-70.144 0-38.912-31.744-70.144-70.144-70.144-38.912 0-70.144 31.744-70.144 70.144 0 38.4 31.232 70.144 70.144 70.144z",
        "p-id": "4288"
      }, null)]),
      onSliderChange: x
    };
  },
  render() {
    const s = S("div", {
      class: [this.ns.e("content")],
      ref: "componentRef"
    }, [S("div", {
      class: this.ns.e("left")
    }, [S("div", {
      class: [this.ns.e("play"), this.ns.is("active", this.isPlay)],
      onClick: () => this.play()
    }, [this.isPlay ? this.renderStop() : this.renderArrowSvg()])]), S("div", {
      class: this.ns.e("wrapper")
    }, [S("div", {
      class: this.ns.em("wrapper", "top")
    }, [S("span", null, [this.fileName]), S("span", {
      class: this.ns.em("wrapper", "file-size")
    }, [this.fileSizeText])]), S("div", {
      class: this.ns.em("wrapper", "time-bar")
    }, [S("div", {
      class: this.ns.em("wrapper", "time")
    }, [this.realAudioTime]), S("div", {
      class: this.ns.em("wrapper", "slider")
    }, [S(Ee("el-slider"), {
      modelValue: this.percentage,
      "onUpdate:modelValue": (e) => this.percentage = e,
      max: 100,
      min: 0,
      disabled: !0,
      onChange: this.onSliderChange
    }, null)]), S("div", {
      class: this.ns.em("wrapper", "time")
    }, [this.totalAudioTime])])]), S("audio", {
      ref: "audioRef",
      src: this.audioSrc
    }, null)]);
    return S("div", {
      ref: "audio",
      class: [this.ns.b(), this.disabled ? this.ns.m("disabled") : "", this.readonly ? this.ns.m("readonly") : ""]
    }, [s]);
  }
});
const Lv = /* @__PURE__ */ ye({
  name: "IBizFiles",
  props: As(),
  setup(s) {
    const e = me("files"), t = L(""), n = L(!1), i = qe(() => {
      const g = {};
      return s.data && Object.assign(g, s.data), g;
    }), r = [{
      type: "download",
      text: "下载",
      color: "rgb(245,108,108,0.2)",
      icon: '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fit="" height="1em" width="1em" preserveAspectRatio="xMidYMid meet" focusable="false"><g stroke-width="1" fill-rule="evenodd"><path d="M7.393 9.953V1.02h1.2v9.06l2.717-2.716.88-.817.817.817-4.95 4.95-4.95-4.95.847-.847 1.16 1.165.004-.004 2.275 2.275zM16 9v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V9h1.2v5.8h13.6V9H16z" id="ajb下载"></path></g></svg>'
    }, {
      type: "separator",
      text: "|"
    }, {
      type: "delete",
      text: "删除",
      icon: "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em'> <g stroke-width='1' fill-rule='evenodd'> <path d='M4.002 3.403V1a1 1 0 0 1 1-1h6.003a1 1 0 0 1 1 1v2.403h3.396a.6.6 0 1 1 0 1.2h-1.395V15a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4.603H.6a.6.6 0 1 1 0-1.2h3.4zm8.804 1.205H3.2V14.8h9.605V4.608zM5.202 1.2v2.155h5.603V1.2H5.202zm.6 6.417a.6.6 0 0 1 1.201 0v4.758a.6.6 0 0 1-1.2 0V7.617zm3.202 0a.6.6 0 0 1 1.2 0v4.758a.6.6 0 0 1-1.2 0V7.617z'></path> </g></svg>"
    }], o = () => {
      const g = i.value.url || "";
      g && ibiz.util.file.fileDownload(g, i.value.name);
    }, a = () => {
      s.change("", {
        isDelete: !0
      });
    };
    return {
      ns: e,
      file: i,
      toolBars: r,
      visible: n,
      hoverToolBarItemKey: t,
      onToolItemClick: (g) => {
        if (g.type !== "separator")
          switch (g.type) {
            case "download":
              o();
              break;
            case "delete":
              a();
              break;
          }
      },
      onMouseover: (g) => {
        t.value = g.type;
      },
      onMouseout: () => {
        t.value = "";
      },
      onShow: () => {
        n.value = !0;
      },
      onHide: () => {
        n.value = !1;
      }
    };
  },
  render() {
    const s = S("div", {
      ref: "referenceRef",
      class: this.ns.e("reference")
    }, [S("span", {
      class: this.ns.em("reference", "file-type")
    }, [tf(this.file.type)]), this.file.name && S("span", {
      class: this.ns.em("reference", "file-name")
    }, [this.file.name])]), e = S(Ee("el-popover"), {
      trigger: "click",
      ref: "popoverRef",
      width: "auto",
      "hide-after": 0,
      placement: "top-start",
      "popper-class": [this.ns.e("popover"), "".concat(this.nodeKey)],
      onShow: this.onShow,
      onHide: this.onHide
    }, {
      default: () => S("div", {
        class: this.ns.be("popover", "content")
      }, [this.toolBars.map((t) => S("div", {
        class: [this.ns.be("popover", "tool-item"), this.ns.be("popover", "tool-item-".concat(t.type)), this.ns.is(t.type, !!t.type)],
        title: t.text,
        onClick: () => this.onToolItemClick(t),
        onMouseover: () => this.onMouseover(t),
        onMouseout: () => this.onMouseout()
      }, [S("div", {
        class: this.ns.bem("popover", "tool-item", "content"),
        innerHTML: t.icon || t.text
      }, null)]))]),
      reference: () => s
    });
    return S("div", {
      ref: "files",
      class: [this.ns.b(), this.readonly ? this.ns.m("readonly") : "", this.ns.is("hover-tool-bar-item", !!this.hoverToolBarItemKey || this.visible), this.ns.is(this.hoverToolBarItemKey, !!this.hoverToolBarItemKey)]
    }, [e]);
  }
});
const Nv = /* @__PURE__ */ ye({
  name: "IBizLayoutToolBar",
  props: {
    modal: {
      type: Object,
      required: !0
    }
  },
  setup(s) {
    const e = me("layout-toolbar"), t = [{
      type: "delete",
      text: "删除",
      icon: "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em'> <g stroke-width='1' fill-rule='evenodd'> <path d='M4.002 3.403V1a1 1 0 0 1 1-1h6.003a1 1 0 0 1 1 1v2.403h3.396a.6.6 0 1 1 0 1.2h-1.395V15a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4.603H.6a.6.6 0 1 1 0-1.2h3.4zm8.804 1.205H3.2V14.8h9.605V4.608zM5.202 1.2v2.155h5.603V1.2H5.202zm.6 6.417a.6.6 0 0 1 1.201 0v4.758a.6.6 0 0 1-1.2 0V7.617zm3.202 0a.6.6 0 0 1 1.2 0v4.758a.6.6 0 0 1-1.2 0V7.617z'></path> </g></svg>"
    }], n = async () => {
      var o;
      if (s.modal) {
        const a = {
          ok: !0,
          data: [{
            value: "",
            params: {
              isDelete: !0
            }
          }]
        };
        (o = s.modal) == null || o.dismiss(a);
      }
    }, i = (o) => {
      if (o.type !== "separator")
        switch (o.type) {
          case "delete":
            n();
            break;
        }
    };
    return {
      ns: e,
      renderToolBar: () => S("div", {
        class: e.e("content")
      }, [t.map((o) => S("div", {
        class: [e.e("tool-item"), e.e("tool-item-".concat(o.type))],
        title: o.text,
        onClick: () => i(o)
      }, [S("div", {
        class: e.em("tool-item", "content"),
        innerHTML: o.icon || o.text
      }, null)]))])
    };
  },
  render() {
    return S("div", {
      class: [this.ns.b()]
    }, [this.renderToolBar()]);
  }
});
class Dv extends HTMLElement {
  constructor() {
    super(...arguments);
    E(this, "vueAppKey", nt());
    E(this, "vueApp");
  }
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  // 自定义元素从页面中移除
  disconnectedCallback() {
    var t;
    (t = this.vueApp) == null || t.unmount(), Wo(this.vueAppKey);
  }
  async attributeChangedCallback(t, n, i) {
    var r;
    if (t === "data-value") {
      if (i && n === i)
        return;
      const o = JSON.parse(i), { type: a, value: l, params: c = {} } = o, { readonly: u, isAdd: d } = c, f = (p) => {
        const m = new CustomEvent("dateElemEvent", {
          detail: { type: a, value: p },
          bubbles: !0,
          // 事件是否冒泡
          composed: !0
          // 事件是否能够穿过 shadow DOM 边界
        });
        this.dispatchEvent(m);
      };
      (r = this.vueApp) == null || r.unmount(), this.vueApp = vs(Ew, {
        data: l,
        nodeKey: this.vueAppKey,
        isFocus: !!d,
        readonly: !!u,
        change: (p) => f(p)
      }), this.innerHTML = "";
      const g = document.createElement("span");
      g.classList.add("elem-box"), g.part.add("container"), this.vueApp.use(Nl, {
        locale: Cw
      }), this.vueApp.mount(g), this.appendChild(g);
    }
  }
}
class Iv extends HTMLElement {
  constructor() {
    super(...arguments);
    E(this, "vueAppKey", nt());
    E(this, "vueApp");
  }
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  // 自定义元素从页面中移除
  disconnectedCallback() {
    var t;
    (t = this.vueApp) == null || t.unmount(), Wo(this.vueAppKey);
  }
  async attributeChangedCallback(t, n, i) {
    var r;
    if (t === "data-value") {
      if (i && n === i)
        return;
      const o = JSON.parse(i), { type: a, value: l, params: c = {} } = o, { readonly: u, isAdd: d } = c, f = (p, m) => {
        const w = new CustomEvent("labelElemEvent", {
          detail: { type: a, value: p, params: m },
          bubbles: !0,
          // 事件是否冒泡
          composed: !0
          // 事件是否能够穿过 shadow DOM 边界
        });
        this.dispatchEvent(w);
      };
      (r = this.vueApp) == null || r.unmount(), this.vueApp = vs(Sw, {
        data: l,
        nodeKey: this.vueAppKey,
        isFocus: !!d,
        readonly: !!u,
        change: (p, m) => f(p, m)
      }), this.innerHTML = "";
      const g = document.createElement("span");
      g.classList.add("elem-box"), g.part.add("container"), this.vueApp.use(Nl), this.vueApp.mount(g), this.appendChild(g);
    }
  }
}
class jv extends HTMLElement {
  constructor() {
    super(...arguments);
    E(this, "vueAppKey", nt());
    E(this, "vueApp");
  }
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  // 自定义元素从页面中移除
  disconnectedCallback() {
    var t;
    (t = this.vueApp) == null || t.unmount();
  }
  async attributeChangedCallback(t, n, i) {
    var r;
    if (t === "data-value") {
      if (i && n === i)
        return;
      const o = JSON.parse(i), { type: a, value: l, params: c = {} } = o, { readonly: u, isAdd: d } = c, f = (p, m) => {
        const w = new CustomEvent("promptBoxElemEvent", {
          detail: { type: a, value: p, params: m },
          bubbles: !0,
          // 事件是否冒泡
          composed: !0
          // 事件是否能够穿过 shadow DOM 边界
        });
        this.dispatchEvent(w);
      };
      (r = this.vueApp) == null || r.unmount(), this.innerHTML = "", this.vueApp = vs(_w, {
        data: l,
        nodeKey: this.vueAppKey,
        isFocus: !!d,
        readonly: !!u,
        change: (p, m) => f(p, m)
      });
      const g = document.createElement("span");
      g.classList.add("elem-box"), g.part.add("container"), this.vueApp.component(Mc.name, Mc), this.vueApp.mount(g), this.appendChild(g);
    }
  }
}
class Rv extends HTMLElement {
  constructor() {
    super(...arguments);
    E(this, "vueAppKey", nt());
    E(this, "vueApp");
  }
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  // 自定义元素从页面中移除
  disconnectedCallback() {
    var t;
    (t = this.vueApp) == null || t.unmount();
  }
  async attributeChangedCallback(t, n, i) {
    var r;
    if (t === "data-value") {
      if (i && n === i)
        return;
      const o = JSON.parse(i), { type: a, value: l, params: c = {} } = o, { isUpdate: u, readonly: d, isAdd: f } = c, g = (m, w) => {
        const v = new CustomEvent("mindMapElemEvent", {
          detail: { type: a, value: m, params: w },
          bubbles: !0,
          // 事件是否冒泡
          composed: !0
          // 事件是否能够穿过 shadow DOM 边界
        });
        this.dispatchEvent(v);
      };
      (r = this.vueApp) == null || r.unmount(), this.vueApp = vs(_v, {
        data: l,
        nodeKey: this.vueAppKey,
        isFocus: !!f || !!u,
        readonly: !!d,
        change: (m, w) => g(m, w)
      }), this.innerHTML = "";
      const p = document.createElement("span");
      p.classList.add("elem-box"), p.part.add("container"), this.vueApp.mount(p), this.appendChild(p);
    }
  }
}
class Bv extends HTMLElement {
  constructor() {
    super(...arguments);
    E(this, "vueAppKey", nt());
    E(this, "vueApp");
  }
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  // 自定义元素从页面中移除
  disconnectedCallback() {
    var t;
    (t = this.vueApp) == null || t.unmount();
  }
  async attributeChangedCallback(t, n, i) {
    var r;
    if (t === "data-value") {
      if (i && n === i)
        return;
      const o = JSON.parse(i), { type: a, value: l, params: c = {} } = o, { readonly: u, isAdd: d } = c, f = (p) => {
        const m = new CustomEvent("audioElemEvent", {
          detail: { type: a, value: p },
          bubbles: !0,
          // 事件是否冒泡
          composed: !0
          // 事件是否能够穿过 shadow DOM 边界
        });
        this.dispatchEvent(m);
      };
      (r = this.vueApp) == null || r.unmount(), this.innerHTML = "", this.vueApp = vs(Tv, {
        data: l,
        nodeKey: this.vueAppKey,
        isFocus: !!d,
        readonly: !!u,
        change: (p) => f(p)
      });
      const g = document.createElement("span");
      g.classList.add("elem-box"), g.part.add("container"), this.vueApp.component(kc.name, kc), this.vueApp.mount(g), this.appendChild(g);
    }
  }
}
class Fv extends HTMLElement {
  constructor() {
    super(...arguments);
    E(this, "vueAppKey", nt());
    E(this, "vueApp");
  }
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  // 自定义元素从页面中移除
  disconnectedCallback() {
    var t;
    (t = this.vueApp) == null || t.unmount(), Wo(this.vueAppKey);
  }
  async attributeChangedCallback(t, n, i) {
    var r;
    if (t === "data-value") {
      if (i && n === i)
        return;
      const o = JSON.parse(i), { type: a, value: l, params: c = {} } = o, { readonly: u, isAdd: d } = c, f = (p, m) => {
        const w = new CustomEvent("formulaElemEvent", {
          detail: { type: a, value: p, params: m },
          bubbles: !0,
          // 事件是否冒泡
          composed: !0
          // 事件是否能够穿过 shadow DOM 边界
        });
        this.dispatchEvent(w);
      };
      (r = this.vueApp) == null || r.unmount(), this.vueApp = vs(l6, {
        data: l,
        nodeKey: this.vueAppKey,
        isFocus: !!d,
        readonly: !!u,
        change: (p, m) => f(p, m)
      }), this.innerHTML = "";
      const g = document.createElement("span");
      g.classList.add("elem-box"), g.part.add("container"), this.vueApp.component(Pc.name, Pc), this.vueApp.mount(g), this.appendChild(g);
    }
  }
}
class $v extends HTMLElement {
  // eslint-disable-next-line no-useless-constructor, no-empty-function
  constructor() {
    super();
    /**
     * 是否只读
     */
    E(this, "readonly", !1);
    /**
     * 弹框
     */
    E(this, "overlay");
  }
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  // 处理鼠标按下
  handleMousedown(t) {
    t.button === 0 && this.classList.remove("is-activated");
  }
  // 元素创建
  connectedCallback() {
    if (this.classList.add("layout-elem"), this.readonly)
      return;
    const t = this, n = (r, o) => {
      const a = new CustomEvent("labelElemEvent", {
        detail: { type: "insert-layout", value: r, params: o },
        bubbles: !0,
        // 事件是否冒泡
        composed: !0
        // 事件是否能够穿过 shadow DOM 边界
      });
      this.dispatchEvent(a);
    }, i = async (r) => {
      t.overlay = Vs(Nv, {
        placement: "top-start"
      }), await t.overlay.present(r);
      const o = await t.overlay.onWillDismiss();
      if (o.ok && o.data && o.data.length > 0) {
        const { value: a, params: l } = o.data[0];
        n(a, l);
      }
      t.overlay = null;
    };
    this.onclick = (r) => {
      var o;
      ((o = "".concat(r.target.nodeName)) == null ? void 0 : o.toLocaleLowerCase()) === "layout-elem" && !r.target.classList.contains("is-activated") && (r.target.classList.add("is-activated"), i(r.target));
    }, document.addEventListener("mousedown", this.handleMousedown.bind(this));
  }
  // 自定义元素从页面中移除
  disconnectedCallback() {
    this.overlay && (this.overlay.dismiss(), this.overlay = null), document.removeEventListener("mousedown", this.handleMousedown.bind(this));
  }
  async attributeChangedCallback(t, n, i) {
    if (t === "data-value") {
      if (i && n === i)
        return;
      const r = JSON.parse(i), { params: o = {} } = r, { readonly: a } = o;
      this.readonly = !!a;
    }
  }
}
class zv extends HTMLElement {
  // eslint-disable-next-line no-useless-constructor, no-empty-function
  constructor() {
    super();
    E(this, "vueAppKey", nt());
    E(this, "vueApp");
  }
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  connectedCallback() {
    this.classList.add("layout-column-elem");
  }
  // 自定义元素从页面中移除
  disconnectedCallback() {
    var t;
    (t = this.vueApp) == null || t.unmount(), Wo(this.vueAppKey);
  }
  async attributeChangedCallback(t, n, i) {
  }
}
class Vv extends HTMLElement {
  constructor() {
    super(...arguments);
    E(this, "vueAppKey", nt());
    E(this, "vueApp");
  }
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  // 自定义元素从页面中移除
  disconnectedCallback() {
    var t;
    (t = this.vueApp) == null || t.unmount();
  }
  async attributeChangedCallback(t, n, i) {
    var r;
    if (t === "data-value") {
      if (i && n === i)
        return;
      const o = JSON.parse(i), { type: a, value: l, params: c = {} } = o, { readonly: u, isAdd: d } = c, f = (p, m) => {
        const w = new CustomEvent("filesElemEvent", {
          detail: { type: a, value: p, params: m },
          bubbles: !0,
          // 事件是否冒泡
          composed: !0
          // 事件是否能够穿过 shadow DOM 边界
        });
        this.dispatchEvent(w);
      };
      (r = this.vueApp) == null || r.unmount(), this.innerHTML = "", this.vueApp = vs(Lv, {
        data: l,
        nodeKey: this.vueAppKey,
        isFocus: !!d,
        readonly: !!u,
        change: (p, m) => f(p, m)
      });
      const g = document.createElement("span");
      g.classList.add("elem-box"), g.part.add("container"), this.vueApp.use(Nl), this.vueApp.mount(g), this.appendChild(g);
    }
  }
}
class Hv {
  /**
   * Creates an instance of MarkerController.
   * @param {IData} option
   * @memberof MarkerController
   */
  constructor() {
    /**
     * 模型
     *
     * @type {IEditor}
     * @memberof MarkerController
     */
    E(this, "model");
    /**
     * 上下文
     *
     * @type {IContext}
     */
    E(this, "context");
    /**
     * 视图参数
     *
     * @type {IParams}
     */
    E(this, "params");
    /**
     * 表单数据
     *
     * @type {IData}
     * @memberof MarkerController
     */
    E(this, "data", {});
    /**
     * 编辑器示例
     *
     * @type {IDomEditor}
     * @memberof MarkerController
     */
    E(this, "editor");
    /**
     * 引用请求url
     *
     * @type {string}
     * @memberof MarkerController
     */
    E(this, "quoteUrl", "");
    /**
     * 人员UI转化
     */
    E(this, "quoteFieldMap", {
      id: "id",
      name: "name"
    });
    /**
     * 代码表map
     *
     * @type {IData}
     * @memberof MarkerController
     */
    E(this, "quoteCodelistMap", /* @__PURE__ */ new Map());
    /**
     * 请求方法
     *
     * @type {('post' | 'get')}
     * @memberof MarkerController
     */
    E(this, "quoteMethod", "post");
    /**
     * 请求参数
     *
     * @type {IData}
     * @memberof MarkerController
     */
    E(this, "quoteParams", {});
    /**
     * 转换脚本
     *
     * @type {string}
     * @memberof MenTionController
     */
    E(this, "quoteScript", "`#{id=${data.id},name=${data.name},identifier=${data.identifier},icon=${data.icon}}`");
    /**
     * 逆转换脚本
     *
     * @type {string}
     * @memberof MenTionController
     */
    E(this, "quoteInScript", "value.replaceAll(/#{id=(.+?),name=(.+?),identifier=(.+?),icon=((.|[\\t\\r\\f\\n\\s])+?)}/g,(x, id, name, identifier, icon) => {return controller.getNodeInfo({ id, name, identifier, icon })})");
    /**
     * 编辑器参数
     *
     * @type {IData}
     * @memberof MarkerController
     */
    E(this, "editorParams");
    /**
     * 用户数据
     *
     * @type {IData[]}
     * @memberof MarkerController
     */
    E(this, "items", []);
    /**
     * 气泡容器
     *
     * @type {IOverlayPopoverContainer}
     * @memberof MarkerController
     */
    E(this, "overlay", null);
    /**
     * 编辑器事件
     *
     * @type {ControllerEvent<commentEvent>}
     * @memberof MarkerController
     */
    E(this, "evt");
    /**
     * 是否正在执行
     *
     * @private
     * @type {boolean}
     * @memberof MarkerController
     */
    E(this, "execting", !1);
    /**
     * 搜索字段
     *
     * @type {string}
     * @memberof MarkerController
     */
    E(this, "query", "");
    /**
     * 当前页
     *
     * @type {number}
     * @memberof MarkerController
     */
    E(this, "curPage", 0);
    /**
     * 分页条数
     *
     * @type {number}
     * @memberof MarkerController
     */
    E(this, "size", 20);
    /**
     * 预定义阻止捕获事件code
     *
     * @type {number[]}
     * @memberof MarkerController
     */
    E(this, "presetPreventEvents", [13, 38, 40]);
    /**
     * 预定义阻止冒泡事件code
     *
     * @type {number[]}
     * @memberof MarkerController
     */
    E(this, "presetPreventPropEvents", [27]);
    /**
     * @description 提及项链接视图id
     * @type {string}
     * @memberof HtmlCommentController
     */
    E(this, "linkViewId", "plmweb.recent_redirect_view");
    /**
     * @description 代码表对象
     * @type {IData}
     * @memberof MarkerController
     */
    E(this, "codeListMap", {});
    /**
     * 删除回调
     *
     * @type {NOOP}
     * @memberof MarkerController
     */
    E(this, "cleanup", Pt);
    this.registerNode();
  }
  /**
   * 声明'@'插件
   *
   * @template T
   * @param {T} editor
   * @return {*}
   * @memberof MarkerController
   */
  markerPlugin(e) {
    const { insertText: t, isInline: n, isVoid: i } = e;
    return e.insertText = (r) => {
      if (!this.editor) {
        t(r);
        return;
      }
      if (!this.editor.isFocused()) {
        t(r);
        return;
      }
      if (we.getSelectedElems(e).some((l) => e.isVoid(l))) {
        t(r);
        return;
      }
      t(r), r === "#" && !this.execting && setTimeout(() => {
        this.query = "", this.showModal();
      }, 0);
    }, e.isInline = (r) => we.getNodeType(r) === "marker" ? !0 : n(r), e.isVoid = (r) => we.getNodeType(r) === "marker" ? !0 : i(r), e;
  }
  registerNode() {
    window.markerIsRegiter || (ht.registerModule(J4), window.markerIsRegiter = !0), ht.registerPlugin(this.markerPlugin.bind(this));
  }
  /**
   * 初始化
   *
   * @param {IDomEditor} editor
   * @memberof MarkerController
   */
  async init(e, t) {
    if (this.model = t.model, this.context = t.context, this.params = t.params, this.evt = t.evt, this.data = t.data, this.editor = e, this.editorParams = this.model.editorParams, this.editorParams) {
      const {
        QUOTEURL: i,
        QUOTEFIELDMAP: r,
        QUOTEMETHOD: o,
        QUOTESCRIPT: a,
        QUOTEINSCRIPT: l,
        QUOTEPARAMS: c,
        QUOTECODELISTMAP: u,
        LINKVIEWID: d
      } = this.editorParams;
      if (i && (this.quoteUrl = i), r && (this.quoteFieldMap = JSON.parse(r)), o && (this.quoteMethod = o.toLowerCase()), c && (this.quoteParams = JSON.parse(c)), a && (this.quoteScript = a), l && (this.quoteInScript = l), u) {
        const f = JSON.parse(u);
        await this.setCodeListMap(f);
      }
      d && (this.linkViewId = d);
    }
    const n = this.editor.getEditableContainer();
    n && (this.cleanup = pi(n, "keydown", (i) => {
      var r;
      this.execting && this.presetPreventEvents.includes(i.keyCode) && i.preventDefault(), this.execting && this.presetPreventPropEvents.includes(i.keyCode) && (i.stopPropagation(), (r = this.overlay) == null || r.dismiss());
    })), this.evt.on("openPopper", () => {
      this.execting = !0;
    }), this.evt.on("closePopper", () => {
      this.execting = !1;
    });
  }
  onDestroyed() {
    this.cleanup !== Pt && this.cleanup(), this.overlay && this.overlay.dismiss();
  }
  // 设置代码表map
  async setCodeListMap(e) {
    for (const t in e) {
      const n = await this.loadCodeList(e[t]);
      n && this.quoteCodelistMap.set(t, n);
    }
  }
  // 显示弹框
  showModal() {
    if (!this.quoteUrl) {
      ibiz.log.error("未配置提及项QUOTEURL编辑器参数！");
      return;
    }
    const e = document.getSelection();
    if (!e)
      return;
    const { focusNode: t } = e;
    t && this.openPopover(t.parentNode).then(
      (n) => {
        n.length > 0 && this.insertNode(n[0]);
      }
    );
  }
  findCodeListItem(e, t) {
    if (e) {
      const n = e.find((i) => i.value == t);
      if (n)
        return n;
      for (let i = 0; i < e.length; i++) {
        const r = this.findCodeListItem(
          e[i].children,
          t
        );
        if (r)
          return r;
      }
    }
  }
  /**
   * 插入#
   *
   * @param {IDomEditor} editor
   * @memberof MarkerController
   */
  insertNode(e) {
    if (this.quoteCodelistMap.has("type") && e.owner_subtype) {
      const n = this.quoteCodelistMap.get("type"), i = this.findCodeListItem(
        n.codeListItems,
        e.owner_subtype
      );
      i && i.sysImage && Object.assign(e, {
        icon: i.sysImage.rawContent
      });
    }
    const t = {
      type: "marker",
      script: this.quoteScript,
      data: e,
      children: [{ text: "" }]
    };
    this.editor.restoreSelection(), this.editor.deleteBackward("character");
    for (let n = 0; n < this.query.length; n++)
      this.editor.deleteBackward("character");
    this.editor.insertNode(t), this.editor.move(1);
  }
  /**
   * 获取节点信息
   *
   * @param {IData} data
   * @memberof MenTionController
   */
  getNodeInfo(e) {
    if (!e.icon && this.quoteCodelistMap.has("type") && e.owner_subtype) {
      const t = this.quoteCodelistMap.get("type"), n = this.findCodeListItem(
        t.codeListItems,
        e.owner_subtype
      );
      n && n.sysImage && Object.assign(e, {
        icon: n.sysImage.rawContent
      });
    }
    return Object.assign(e, { script: this.quoteScript }), '<span data-w-e-type="marker" data-w-e-is-void data-w-e-is-inline data-value="'.concat(encodeURIComponent(
      JSON.stringify(e)
    ), '"></span>');
  }
  /**
   * 解析marker节点
   *
   * @param {string} value
   * @return {*}
   * @memberof MarkerController
   */
  parseNode(e) {
    return Dt.execScriptFn(
      { value: e, controller: this },
      this.quoteInScript,
      {
        singleRowReturn: !0,
        isAsync: !1
      }
    );
  }
  /**
   * 处理公共参数
   *
   * @param {IData} data
   * @param {IContext} context
   * @param {IParams} params
   * @return {*}  {{ context: IContext; params: IParams }}
   * @memberof MarkerController
   */
  handlePublicParams(e, t, n) {
    const { navigateContexts: i, navigateParams: r } = this.model;
    let o = {};
    i && e && (o = Hi(i, e, n, t));
    const a = Object.assign(t.clone(), o);
    let l = {};
    return r && e && (l = Hi(r, e, n, t)), { context: a, params: l };
  }
  /**
   * 获取提及项信息
   *
   * @param {IData} data
   * @return {*}  {Promise<IData[]>}
   * @memberof MarkerController
   */
  load(e = {}) {
    const { context: t, params: n } = this.handlePublicParams(
      this.data,
      this.context,
      this.params
    ), i = e.isInitialLoad === !0, r = e.isLoadMore === !0;
    i ? this.curPage = 0 : r && (this.curPage += 1);
    const o = Dt.execScriptFn(
      { data: this.data, context: t, params: n },
      this.quoteUrl,
      {
        singleRowReturn: !0,
        isAsync: !1
      }
    ), a = {
      ...n,
      query: this.query,
      size: this.size,
      page: this.curPage,
      ...this.quoteParams
    };
    return ibiz.net[this.quoteMethod](o, a);
  }
  /**
   * 转换ui数据
   *
   * @param {IData[]} data
   * @return {*}  {IData[]}
   * @memberof MarkerController
   */
  toUIData(e) {
    return e.map((t) => {
      const n = {};
      return Object.keys(this.quoteFieldMap).forEach((i) => {
        n[i] = t[this.quoteFieldMap[i]];
      }), n;
    });
  }
  /**
   * 打开用户列表气泡框
   *
   * @param {HTMLElement} event
   * @memberof MarkerController
   */
  async openPopover(e) {
    this.overlay = ibiz.overlay.createPopover(
      this.createOverlayView(),
      void 0,
      {
        placement: "bottom-start",
        autoClose: !0,
        width: "300px",
        noArrow: !0
      }
    ), await this.overlay.present(e), this.evt.emit("openPopper", void 0), this.execting = !0;
    const t = await this.overlay.onWillDismiss();
    return this.execting = !1, this.evt.emit("closePopper", void 0), t.data || [];
  }
  createOverlayView() {
    return (e) => cs(X4, {
      controller: this,
      modal: e
    });
  }
  /**
   * 加载代码表
   *
   * @param {string} appCodeListId
   * @return {*}  {(Promise<IData | undefined>)}
   * @memberof MarkerController
   */
  async loadCodeList(e) {
    const t = ibiz.hub.getApp(this.context.srfappid), n = t.codeList.getCodeList(e), i = await t.codeList.get(
      e,
      this.context,
      this.params
    );
    return { codeList: n, codeListItems: i };
  }
  /**
   * @description 处理点击事件
   * @param {MouseEvent} event
   * @memberof MarkerController
   */
  handleClick(e) {
    const { nodeName: t, dataset: n } = e.target;
    if (t && t === "MENTION-ELEM") {
      const i = n.value || "", r = this.context.clone(), o = yp(this.params), a = JSON.parse(i);
      if (!a.owner_type)
        return;
      r.srfkey = a.id;
      const l = a.owner_subtype || a.type;
      o.owner_subtype = l, l === "page" ? o.article_page = a.owner_id : o[l] = a.owner_id, o[a.owner_type] = a.recent_parent, delete a.script, delete a.icon, delete a.id, Object.assign(o, a), a && this.linkViewId && ibiz.commands.execute(
        cp.TAG,
        this.linkViewId,
        r,
        o
      );
    }
  }
  /**
   * @description 解析评论节点
   * @param {IData} data
   * @return {*}
   * @memberof CommentItemRawItemEditorController
   */
  parseCommentTag(e) {
    let { icon: t } = e;
    const n = JSON.stringify(e);
    if (!e.icon && e.owner_subtype && this.quoteCodelistMap.has("type")) {
      const i = this.quoteCodelistMap.get("type"), r = this.findCodeListItem(
        i.codeListItems,
        e.owner_subtype
      );
      r && r.sysImage && (t = r.sysImage.rawContent || "");
    }
    return "<span markerClick='marker' params='".concat(n, "' class='comment-tag is-click'>").concat(t, " ").concat(e.identifier, " ").concat(e.name, "</span>");
  }
}
function Uv(s) {
  const { script: e = "", data: t = {} } = s, n = Dt.execScriptFn({ data: t }, e, {
    singleRowReturn: !0,
    isAsync: !1
  });
  return "".concat(n);
}
const qv = {
  type: "mention",
  elemToHtml: Uv
};
function Gv(s) {
  const e = decodeURIComponent(s.getAttribute("data-value") || ""), t = JSON.parse(e);
  return {
    type: "mention",
    script: t.script,
    data: t,
    children: [{ text: "" }]
  };
}
const Wv = {
  selector: 'span[data-w-e-type="mention"]',
  parseElemHtml: Gv
};
function Jv(s) {
  const { data: e = {} } = s, t = {
    name: "@".concat(e.name),
    id: e.id
  };
  return wn(
    "mention-elem",
    {
      dataset: { value: JSON.stringify(t) },
      props: {
        contentEditable: !1
        // 不可编辑
      }
    },
    []
  );
}
const Yv = {
  type: "mention",
  renderElem: Jv
};
class Xv {
  constructor() {
    E(this, "title", "提及成员");
    E(this, "tag", "button");
    E(this, "iconSvg", '<svg t="1705979200437" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4218" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M23.7 555c0-339.3 247-550 533.8-550 295.6 0 442.8 165.9 442.8 401.6 0 210.8-93.5 361.7-237 361.7-63.6 0-108.5-26.2-137.2-78.6-48.6 51.1-96 79.8-174.6 79.8-116 0-178.4-77.3-178.4-193.3 0-209.5 131-323 251.9-323 64.9 0 102.3 24.9 122.2 68.6l11.2-58.6 114.7 1.2L727 510.1c-7.5 36.2-11.2 63.6-11.2 81.1 0 44.9 22.5 71.1 56.1 71.1 63.6 0 106-89.8 106-243.2 0-205.8-114.7-300.6-323-300.6-220.8 0-405.4 163.4-405.4 436.5 0 238.2 132.2 350.5 390.4 350.5 94.8 0 174.6-12.5 255.7-36.2v109.8c-88.6 26.2-177.1 39.9-263.2 39.9-329.1 0-508.7-168.4-508.7-464z m585-44.9c3.7-20 6.2-39.9 6.2-53.6 0-56.1-15-96-83.6-96-83.6 0-133.5 108.5-133.5 212 0 44.9 13.7 88.6 77.3 88.6 73.7-0.1 114.9-57.4 133.6-151z" fill="#333333" p-id="4219"></path></svg>');
  }
  // 菜单是否需要激活（如选中加粗文本，“加粗”菜单会激活），用不到则返回 false
  isActive(e) {
    return !1;
  }
  // 获取菜单执行时的 value ，用不到则返回空 字符串或 false
  getValue(e) {
    return "";
  }
  // 菜单是否需要禁用（如选中 H1 ，“引用”菜单被禁用），用不到则返回 false
  isDisabled(e) {
    return !1;
  }
  // 点击菜单时触发的函数
  exec(e, t) {
    e.insertText("@");
  }
}
const Zv = {
  key: "mention",
  factory() {
    return new Xv();
  }
}, Kv = {
  renderElems: [Yv],
  elemsToHtml: [qv],
  parseElemsHtml: [Wv],
  menus: [Zv]
};
class Qv {
  /**
   * Creates an instance of MenTionController.
   * @param {IData} option
   * @memberof MenTionController
   */
  constructor() {
    /**
     *云系统操作者Map
     *
     * @memberof MenTionController
     */
    E(this, "operatorMap", /* @__PURE__ */ new Map());
    /**
     * 模型
     *
     * @type {IEditor}
     * @memberof MenTionController
     */
    E(this, "model");
    /**
     * 上下文
     *
     * @type {IContext}
     */
    E(this, "context");
    /**
     * 视图参数
     *
     * @type {IParams}
     */
    E(this, "params");
    /**
     * 表单数据
     *
     * @type {IData}
     * @memberof MenTionController
     */
    E(this, "data", {});
    /**
     * 编辑器示例
     *
     * @type {IDomEditor}
     * @memberof MenTionController
     */
    E(this, "editor");
    /**
     * 用户请求url
     *
     * @type {string}
     * @memberof MenTionController
     */
    E(this, "userUrl", "");
    /**
     * 人员UI转化
     */
    E(this, "userFieldMap", {
      id: "id",
      name: "name",
      title: "title"
    });
    /**
     * 请求方法
     *
     * @type {('post' | 'get')}
     * @memberof MenTionController
     */
    E(this, "userMethod", "post");
    /**
     * 转换脚本
     *
     * @type {string}
     * @memberof MenTionController
     */
    E(this, "userScript", "`@{userid=${data.id},name=${data.name}}`");
    /**
     * 逆转换脚本
     *
     * @type {string}
     * @memberof MenTionController
     */
    E(this, "userInScript", "value.replaceAll(/@{userid=(.+?),name=(.+?)}/g,(x, id, name) => {return controller.getNodeInfo({ id, name })})");
    /**
     * 编辑器参数
     *
     * @type {IData}
     * @memberof MenTionController
     */
    E(this, "editorParams");
    /**
     * 用户数据
     *
     * @type {IData[]}
     * @memberof MenTionController
     */
    E(this, "items", []);
    /**
     * 气泡容器
     *
     * @type {IOverlayPopoverContainer}
     * @memberof MenTionController
     */
    E(this, "overlay", null);
    /**
     * 编辑器事件
     *
     * @type {ControllerEvent<commentEvent>}
     * @memberof MenTionController
     */
    E(this, "evt");
    /**
     * 是否正在执行
     *
     * @private
     * @type {boolean}
     * @memberof MenTionController
     */
    E(this, "execting", !1);
    /**
     * 搜索字段
     *
     * @type {string}
     * @memberof MenTionController
     */
    E(this, "query", "");
    /**
     * 当前页
     *
     * @type {number}
     * @memberof MenTionController
     */
    E(this, "curPage", 0);
    /**
     * 分页条数
     *
     * @type {number}
     * @memberof MenTionController
     */
    E(this, "size", 20);
    /**
     * 预定义阻止捕获事件code
     *
     * @type {number[]}
     * @memberof MenTionController
     */
    E(this, "presetPreventEvents", [13, 38, 40]);
    /**
     * 预定义阻止冒泡事件code
     *
     * @type {number[]}
     * @memberof MenTionController
     */
    E(this, "presetPreventPropEvents", [27]);
    /**
     * 删除回调
     *
     * @type {NOOP}
     * @memberof MenTionController
     */
    E(this, "cleanup", Pt);
    this.registerNode();
  }
  /**
   * 声明'@'插件
   *
   * @template T
   * @param {T} editor
   * @return {*}
   * @memberof MenTionController
   */
  mentionPlugin(e) {
    const { insertText: t, isInline: n, isVoid: i } = e;
    return e.insertText = (r) => {
      if (!this.editor) {
        t(r);
        return;
      }
      if (!this.editor.isFocused()) {
        t(r);
        return;
      }
      if (we.getSelectedElems(e).some((l) => e.isVoid(l))) {
        t(r);
        return;
      }
      t(r), r === "@" && !this.execting && setTimeout(() => {
        this.query = "", this.showModal();
      }, 0);
    }, e.isInline = (r) => we.getNodeType(r) === "mention" ? !0 : n(r), e.isVoid = (r) => we.getNodeType(r) === "mention" ? !0 : i(r), e;
  }
  registerNode() {
    window.mentionIsRegiter || (ht.registerModule(Kv), window.mentionIsRegiter = !0), ht.registerPlugin(this.mentionPlugin.bind(this));
  }
  /**
   * 初始化
   *
   * @param {IDomEditor} editor
   * @memberof MenTionController
   */
  async init(e, t) {
    if (this.model = t.model, this.context = t.context, this.params = t.params, this.evt = t.evt, this.data = t.data, this.editor = e, this.editorParams = this.model.editorParams, this.editorParams) {
      const { USERURL: i, USERFIELDMAP: r, USERMETHOD: o, USERSCRIPT: a, USERINSCRIPT: l } = this.editorParams;
      if (i && (this.userUrl = i), r) {
        const c = JSON.parse(r);
        Object.assign(this.userFieldMap, c);
      }
      o && (this.userMethod = o.toLowerCase()), a && (this.userScript = a), l && (this.userInScript = l);
    }
    const n = this.editor.getEditableContainer();
    n && (this.cleanup = pi(n, "keydown", (i) => {
      var r;
      this.execting && this.presetPreventEvents.includes(i.keyCode) && i.preventDefault(), this.execting && this.presetPreventPropEvents.includes(i.keyCode) && (i.stopPropagation(), (r = this.overlay) == null || r.dismiss());
    })), await this.getOperatorUserList(), this.evt.on("openPopper", () => {
      this.execting = !0;
    }), this.evt.on("closePopper", () => {
      this.execting = !1;
    });
  }
  /**
   * 获取云系统操作者
   *
   * @memberof MenTionController
   */
  async getOperatorUserList() {
    const e = await ibiz.hub.getApp(this.context.srfappid);
    let t = [];
    t = await e.codeList.get(
      "SysOperator",
      this.context,
      this.params
    ), this.operatorMap = new Map(
      t.map((n) => [n.value, n])
    );
  }
  onDestroyed() {
    this.cleanup !== Pt && this.cleanup(), this.overlay && this.overlay.dismiss();
  }
  // 显示弹框
  showModal() {
    if (!this.userUrl) {
      ibiz.log.error("未配置提及用户USERURL编辑器参数！");
      return;
    }
    const e = document.getSelection();
    if (!e)
      return;
    const { focusNode: t } = e;
    t && this.openUserPopover(t.parentNode).then(
      (n) => {
        n.length > 0 && this.insertNode(n[0]);
      }
    );
  }
  /**
   * 插入@
   *
   * @param {IDomEditor} editor
   * @memberof MenTionController
   */
  insertNode(e) {
    const t = {
      type: "mention",
      script: this.userScript,
      data: e,
      children: [{ text: "" }]
    };
    this.editor.restoreSelection(), this.editor.deleteBackward("character");
    for (let n = 0; n < this.query.length; n++)
      this.editor.deleteBackward("character");
    this.editor.insertNode(t), this.editor.move(1);
  }
  /**
   * 获取节点信息
   *
   * @param {IData} data
   * @memberof MenTionController
   */
  getNodeInfo(e) {
    return Object.assign(e, { script: this.userScript }), '<span data-w-e-type="mention" data-w-e-is-void data-w-e-is-inline data-value="'.concat(encodeURIComponent(
      JSON.stringify(e)
    ), '"></span>');
  }
  /**
   * 解析mention节点
   *
   * @param {string} value
   * @return {*}
   * @memberof MenTionController
   */
  parseNode(e) {
    return Dt.execScriptFn(
      { value: e, controller: this },
      this.userInScript,
      {
        singleRowReturn: !0,
        isAsync: !1
      }
    );
  }
  /**
   * 处理公共参数
   *
   * @param {IData} data
   * @param {IContext} context
   * @param {IParams} params
   * @return {*}  {{ context: IContext; params: IParams }}
   * @memberof MenTionController
   */
  handlePublicParams(e, t, n) {
    const { navigateContexts: i, navigateParams: r } = this.model;
    let o = {};
    i && e && (o = Hi(i, e, n, t));
    const a = Object.assign(t.clone(), o);
    let l = {};
    return r && e && (l = Hi(r, e, n, t)), { context: a, params: l };
  }
  /**
   * 获取用户信息
   *
   * @param {IData} data
   * @return {*}  {Promise<IData[]>}
   * @memberof MenTionController
   */
  getUsers(e = {}) {
    const { context: t, params: n } = this.handlePublicParams(
      this.data,
      this.context,
      this.params
    ), i = e.isInitialLoad === !0, r = e.isLoadMore === !0;
    i ? this.curPage = 0 : r && (this.curPage += 1);
    const o = Dt.execScriptFn(
      { data: this.data, context: t, params: n },
      this.userUrl,
      {
        singleRowReturn: !0,
        isAsync: !1
      }
    ), a = {
      ...n,
      query: this.query,
      size: this.size,
      page: this.curPage
    };
    return ibiz.net[this.userMethod](o, a);
  }
  /**
   * 转换ui数据
   *
   * @param {IData[]} data
   * @return {*}  {IData[]}
   * @memberof MenTionController
   */
  toUIData(e) {
    return e.map((t) => {
      const n = {};
      return Object.keys(this.userFieldMap).forEach((i) => {
        n[i] = t[this.userFieldMap[i]];
      }), n;
    });
  }
  /**
   * 打开用户列表气泡框
   *
   * @param {HTMLElement} event
   * @memberof MenTionController
   */
  async openUserPopover(e) {
    this.overlay = ibiz.overlay.createPopover(
      this.createOverlayView(),
      void 0,
      {
        placement: "bottom-start",
        autoClose: !0,
        width: "300px",
        noArrow: !0
      }
    ), await this.overlay.present(e), this.evt.emit("openPopper", void 0), this.execting = !0;
    const t = await this.overlay.onWillDismiss();
    return this.execting = !1, this.evt.emit("closePopper", void 0), t.data || [];
  }
  createOverlayView() {
    return (e) => cs(Y4, {
      controller: this,
      modal: e
    });
  }
}
function e7(s) {
  const { script: e = "", data: t = {} } = s, n = Dt.execScriptFn({ data: t }, e, {
    singleRowReturn: !0,
    isAsync: !1
  });
  return "".concat(n);
}
const t7 = {
  type: "page",
  elemToHtml: e7
};
function n7(s) {
  const e = decodeURIComponent(s.getAttribute("data-value") || ""), t = JSON.parse(e);
  return {
    type: "page",
    script: t.script,
    data: t,
    children: [{ text: "" }]
  };
}
const s7 = {
  selector: 'span[data-w-e-type="page"]',
  parseElemHtml: n7
};
function i7(s) {
  const { data: e = {} } = s, t = {
    name: "".concat(e.name),
    id: e.id
  };
  return wn(
    "mention-elem",
    {
      dataset: { value: JSON.stringify(t) },
      props: {
        contentEditable: !1
        // 不可编辑
      }
    },
    []
  );
}
const r7 = {
  type: "Page",
  renderElem: i7
};
class o7 {
  constructor() {
    E(this, "title", "页面");
    E(this, "tag", "button");
    E(this, "iconSvg", '<svg t="1707293566679" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6103" width="200" height="200"><path d="M288 512l256 0C561.92 512 576 497.92 576 480 576 462.08 561.92 448 544 448l-256 0C270.08 448 256 462.08 256 480 256 497.92 270.08 512 288 512zM768 64 192 64C121.6 64 64 121.6 64 192l0 576c0 70.4 57.6 128 128 128l576 0c70.4 0 128-57.6 128-128L896 192C896 121.6 838.4 64 768 64zM832 768c0 35.2-28.8 64-64 64L192 832c-35.2 0-64-28.8-64-64L128 192c0-35.2 28.8-64 64-64l576 0c35.2 0 64 28.8 64 64L832 768zM672 256l-384 0C270.08 256 256 270.08 256 288 256 305.92 270.08 320 288 320l384 0C689.92 320 704 305.92 704 288 704 270.08 689.92 256 672 256zM608 640l-320 0C270.08 640 256 654.08 256 672l0 0C256 689.92 270.08 704 288 704l320 0c17.92 0 32-14.08 32-32l0 0C640 654.08 625.92 640 608 640z" p-id="6104"></path></svg>');
  }
  // 菜单是否需要激活（如选中加粗文本，“加粗”菜单会激活），用不到则返回 false
  isActive(e) {
    return !1;
  }
  // 获取菜单执行时的 value ，用不到则返回空 字符串或 false
  getValue(e) {
    return "";
  }
  // 菜单是否需要禁用（如选中 H1 ，“引用”菜单被禁用），用不到则返回 false
  isDisabled(e) {
    return !1;
  }
  // 点击菜单时触发的函数
  exec(e, t) {
    throw new io("暂未支持上传页面！");
  }
}
const a7 = {
  key: "page",
  factory() {
    return new o7();
  }
}, l7 = {
  renderElems: [r7],
  elemsToHtml: [t7],
  parseElemsHtml: [s7],
  menus: [a7]
};
class c7 {
  /**
   * Creates an instance of PageController.
   * @param {IData} option
   * @memberof PageController
   */
  constructor() {
    /**
     * 模型
     *
     * @type {IEditor}
     * @memberof PageController
     */
    E(this, "model");
    /**
     * 上下文
     *
     * @type {IContext}
     */
    E(this, "context");
    /**
     * 视图参数
     *
     * @type {IParams}
     */
    E(this, "params");
    /**
     * 表单数据
     *
     * @type {IData}
     * @memberof PageController
     */
    E(this, "data", {});
    /**
     * 编辑器示例
     *
     * @type {IDomEditor}
     * @memberof PageController
     */
    E(this, "editor");
    /**
     * 编辑器参数
     *
     * @type {IData}
     * @memberof PageController
     */
    E(this, "editorParams");
    /**
     * 用户数据
     *
     * @type {IData[]}
     * @memberof PageController
     */
    E(this, "items", []);
    /**
     * 编辑器事件
     *
     * @type {ControllerEvent<commentEvent>}
     * @memberof PageController
     */
    E(this, "evt");
    /**
     * 是否正在执行
     *
     * @private
     * @type {boolean}
     * @memberof PageController
     */
    E(this, "execting", !1);
    this.registerNode();
  }
  registerNode() {
    window.pageIsRegiter || (ht.registerModule(l7), window.pageIsRegiter = !0);
  }
  /**
   * 初始化
   *
   * @param {IDomEditor} editor
   * @memberof PageController
   */
  async init(e, t) {
    this.model = t.model, this.context = t.context, this.params = t.params, this.evt = t.evt, this.data = t.data, this.editor = e, this.editorParams = this.model.editorParams;
  }
  /**
   * 控制器销毁
   *
   * @memberof PageController
   */
  onDestroyed() {
  }
  /**
   * 插入节点
   *
   * @param {IDomEditor} editor
   * @memberof PageController
   */
  insertNode(e) {
  }
  /**
   * 解析mention节点
   *
   * @param {string} value
   * @return {*}
   * @memberof PageController
   */
  parseNode(e) {
    return e;
  }
}
const h7 = {
  type: "emoji",
  renderElem: (s) => {
    const { data: e = {} } = s;
    return wn(
      "emoji-elem",
      {
        dataset: { value: e.emoji ? Ha(e.emoji) : "" },
        props: {
          contentEditable: !1
          // 不可编辑
        }
      },
      []
    );
  }
}, u7 = {
  type: "emoji",
  elemToHtml: (s) => {
    const { data: e } = s;
    return "<span data-w-e-type=\"emoji\" class='emoji'>".concat(e.emoji, "</span>");
  }
}, d7 = {
  selector: 'span[data-w-e-type="emoji"]',
  parseElemHtml: (s) => ({
    data: {
      emoji: s.innerHTML
    },
    type: "emoji",
    children: [{ text: "" }]
  })
};
class f7 {
  /**
   * Creates an instance of EmojiButtonMenu.
   * @memberof EmojiButtonMenu
   */
  constructor() {
    /**
     * 标题
     *
     * @memberof EmojiButtonMenu
     */
    E(this, "title", "表情");
    /**
     * 菜单类型
     *
     * @memberof EmojiButtonMenu
     */
    E(this, "tag", "button");
    /**
     * 菜单图标
     *
     * @memberof EmojiButtonMenu
     */
    E(this, "iconSvg", "<svg viewBox='0 0 1040 1024' version='1.1' xmlns='http://www.w3.org/2000/svg' p-id='1490' width='1em' height='1em' stroke='var(--w-e-toolbar-color)' > <path stroke-width='38' d='M512.075261 1024A511.774217 511.774217 0 1 1 730.482434 48.769072a37.630457 37.630457 0 1 1-32.061149 68.035867 436.513303 436.513303 0 1 0 250.468323 395.270322 37.630457 37.630457 0 0 1 75.260914 0 512.526826 512.526826 0 0 1-512.075261 511.924739z' p-id='1491' ></path> <path stroke-width='38' d='M333.857416 344.0929a57.348817 57.348817 0 1 0 57.348817 57.348817 57.499339 57.499339 0 0 0-57.348817-57.348817zM686.53006 344.0929a57.348817 57.348817 0 1 0 57.348817 57.348817 57.348817 57.348817 0 0 0-57.348817-57.348817zM515.236219 783.165074c-162.864619 0-262.359547-141.942084-262.359547-219.159782a30.104366 30.104366 0 0 1 60.208731 0c0 48.618551 76.314567 158.951051 202.150816 158.951051s193.571072-134.114949 193.571072-158.951051a30.104366 30.104366 0 0 1 60.208731 0c0 54.488902-90.012054 219.159782-253.779803 219.159782zM1009.549904 207.720123h-67.132735V139.985301a30.104366 30.104366 0 1 0-60.208732 0v67.734822h-67.734822a30.104366 30.104366 0 0 0-30.104366 30.104366 30.104366 30.104366 0 0 0 30.104366 30.104366h67.734822v67.734823a30.104366 30.104366 0 0 0 60.208732 0v-67.734823h67.734823a30.104366 30.104366 0 0 0 30.104365-30.104366 30.104366 30.104366 0 0 0-30.706453-30.104366z' p-id='1492' ></path> </svg>");
  }
  /**
   * 菜单是否需要激活（如选中加粗文本，“加粗”菜单会激活），用不到则返回 false
   *
   * @return {*}  {boolean}
   * @memberof EmojiButtonMenu
   */
  isActive() {
    return !1;
  }
  /**
   * 获取菜单执行时的 value ，用不到则返回空 字符串或 false
   *
   * @return {*}  {(string | boolean)}
   * @memberof EmojiButtonMenu
   */
  getValue() {
    return !1;
  }
  /**
   * 菜单是否需要禁用（如选中 H1 ，“引用”菜单被禁用），用不到则返回 false
   *
   * @return {*}  {boolean}
   * @memberof EmojiButtonMenu
   */
  isDisabled() {
    return !1;
  }
  /**
   * 点击菜单时触发的函数
   *
   * @param {IDomEditor} editor
   * @memberof EmojiButtonMenu
   */
  exec(e) {
    e.emit("openEmojiSelect");
  }
}
const g7 = {
  key: "emoji",
  factory() {
    return new f7();
  }
}, p7 = {
  renderElems: [h7],
  elemsToHtml: [u7],
  parseElemsHtml: [d7],
  menus: [g7]
};
class m7 {
  /**
   * Creates an instance of EmojiController.
   * @param {IData} option
   * @memberof EmojiController
   */
  constructor() {
    /**
     * 编辑器示例
     *
     * @type {IDomEditor}
     * @memberof EmojiController
     */
    E(this, "editor");
    /**
     * 气泡容器
     *
     * @type {IOverlayPopoverContainer}
     * @memberof EmojiController
     */
    E(this, "overlay", null);
    /**
     * 预定义阻止捕获事件code
     *
     * @type {number[]}
     * @memberof EmojiController
     */
    E(this, "presetPreventEvents", [13, 38, 40]);
    /**
     * 预定义阻止冒泡事件code
     *
     * @type {number[]}
     * @memberof EmojiController
     */
    E(this, "presetPreventPropEvents", [27]);
    /**
     * 编辑器事件
     *
     * @type {ControllerEvent<commentEvent>}
     * @memberof EmojiController
     */
    E(this, "evt");
    /**
     * 删除回调
     *
     * @type {NOOP}
     * @memberof EmojiController
     */
    E(this, "cleanup", Pt);
    this.registerNode();
  }
  /**
   * 声明' :'插件
   *
   * @template T
   * @param {T} editor
   * @return {*}
   * @memberof EmojiController
   */
  emojiPlugin(e) {
    const { isInline: t, isVoid: n } = e;
    return e.isInline = (i) => we.getNodeType(i) === "emoji" ? !0 : t(i), e.isVoid = (i) => we.getNodeType(i) === "emoji" ? !0 : n(i), e;
  }
  registerNode() {
    window.emojiIsRegiter || (ht.registerModule(p7), window.emojiIsRegiter = !0), ht.registerPlugin(this.emojiPlugin.bind(this));
  }
  /**
   * 初始化
   *
   * @param {IDomEditor} editor
   * @memberof EmojiController
   */
  async init(e, t) {
    this.editor = e, this.evt = t.evt, this.listenEvent();
  }
  /**
   * 监听事件
   *
   * @private
   * @memberof EmojiController
   */
  listenEvent() {
    const e = this.editor.getEditableContainer();
    this.editor.on("openEmojiSelect", () => this.openEmojiSelect()), this.cleanup = pi(e, "keydown", (t) => {
      var n;
      this.overlay && this.presetPreventEvents.includes(t.keyCode) && t.preventDefault(), this.overlay && this.presetPreventPropEvents.includes(t.keyCode) && (t.stopPropagation(), (n = this.overlay) == null || n.dismiss());
    }), this.evt.on("onChange", (t) => {
      var r;
      const { eventArg: n } = t, i = /[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]/gu;
      if (n && ((r = n.match(i)) != null && r.length)) {
        const a = n.replaceAll(
          /<span([^>]+?)>([^<]*?)([\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}])([^<]*?)<\/span>/gu,
          "$3"
        ).replaceAll(i, (l) => "<span data-w-e-type=\"emoji\" class='emoji'>".concat(ro(
          l
        ), "</span>"));
        this.editor.setHtml(a);
      }
    });
  }
  /**
   * 打开表情选择
   *
   * @memberof EmojiController
   */
  async openEmojiSelect() {
    const e = document.getSelection(), { focusNode: t } = e;
    t && (this.overlay = ibiz.overlay.createPopover(
      (n) => cs(Z4, {
        controller: this,
        modal: n
      }),
      void 0,
      {
        width: "auto",
        noArrow: !0,
        autoClose: !0,
        placement: "bottom-start"
      }
    ), await this.overlay.present(t.parentNode), this.overlay.onWillDismiss().then((n) => {
      var o;
      const i = n, r = (o = i.data) == null ? void 0 : o[0];
      i.ok && r && this.addEmojiNode(r), this.overlay = null;
    }));
  }
  /**
   * 添加表情
   *
   * @param {string} data
   * @memberof EmojiController
   */
  addEmojiNode(e) {
    const t = {
      data: e,
      type: "emoji",
      children: [{ text: "" }]
    };
    this.editor.restoreSelection(), this.editor.insertNode(t), this.editor.move(1);
  }
  /**
   * 解析emoji节点
   *
   * @param {string} value
   * @return {*}
   * @memberof EmojiController
   */
  parseNode(e) {
    return Dt.execScriptFn(
      { value: e, controller: this },
      'value.replaceAll(/\\{\\"\\emoji\\":\\"(.+?)\\"\\}/g,(x, emoji) => {return \'<span data-w-e-type="emoji" class="emoji">\'+emoji+\'</span>\'})',
      {
        singleRowReturn: !0,
        isAsync: !1
      }
    );
  }
  onDestroyed() {
    this.cleanup !== Pt && this.cleanup(), this.overlay && this.overlay.dismiss();
  }
}
class w7 {
  /**
   * Creates an instance of IFilesButtonMenu.
   * @memberof IFilesButtonMenu
   */
  constructor() {
    /**
     * 标题
     *
     * @memberof IFilesButtonMenu
     */
    E(this, "title", "本地文件");
    /**
     * 菜单类型
     *
     * @memberof IFilesButtonMenu
     */
    E(this, "tag", "button");
    /**
     * 菜单图标
     *
     * @memberof IFilesButtonMenu
     */
    E(this, "iconSvg", '<svg width="1em" height="1em" viewBox="0 0 28 28" version="1.1" xmlns="http://www.w3.org/2000/svg" fit=""> <title>本地文件</title> <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <g id="icon"> <rect x="0" y="0" width="28" height="28" rx="4"></rect> <path d="M24,0 C26.209139,0 28,1.790861 28,4 L28,24 C28,26.209139 26.209139,28 24,28 L4,28 C1.790861,28 0,26.209139 0,24 L0,4 C0,1.790861 1.790861,0 4,0 L24,0 Z M24,1 L4,1 C2.34314575,1 1,2.34314575 1,4 L1,24 C1,25.6568542 2.34314575,27 4,27 L24,27 C25.6568542,27 27,25.6568542 27,24 L27,4 C27,2.34314575 25.6568542,1 24,1 Z" id="矩形" fill-rule="nonzero"></path> <g transform="translate(2.331723, 6.223395)"> <path d="M10.8586379,9.82567869 C10.8586379,11.3135682 9.65287619,12.519741 8.16549379,12.519741 C6.6781114,12.519741 5.47234973,11.3135682 5.47237295,9.83060072 L5.43152142,5.5040927 C5.4288277,5.21612692 5.65998761,4.98048085 5.94785525,4.97776249 C6.23572289,4.97504413 6.47128863,5.20628285 6.47400607,5.49424863 L6.51485711,9.82567869 C6.51485711,10.737611 7.25387232,11.4768781 8.16549379,11.4768781 C9.07711526,11.4768781 9.81613048,10.737611 9.81613048,9.82567869 L9.81613048,5.02838197 C9.81613048,3.65522549 8.5992671,2.52563899 7.0795486,2.52563899 C5.55983011,2.52563899 4.34296673,3.65522549 4.34296673,5.02838197 L4.34296673,10.0065309 C4.34296673,12.103884 6.05369893,13.8053486 8.16549379,13.8053486 C10.2772887,13.8053486 11.9880209,12.103884 11.9880209,10.0065309 L11.9880209,5.5222302 C11.9880209,5.23425158 12.2213941,5.00079879 12.5092745,5.00079879 C12.797155,5.00079879 13.0305282,5.23425158 13.0305282,5.5222302 L13.0305282,10.0065309 C13.0305282,12.6811932 10.8517067,14.8482114 8.16549379,14.8482114 C5.47928093,14.8482114 3.30045935,12.6811932 3.30045935,10.0065309 L3.30045935,5.02838197 C3.30045935,3.06112766 5.0007613,1.48277617 7.0795486,1.48277617 C9.15833591,1.48277617 10.8586379,3.06112766 10.8586379,5.02838197 Z" id="形状结合" transform="translate(8.165494, 8.165494) rotate(-315.000000) translate(-8.165494, -8.165494) "></path> <path d="M16.8515613,7.68286899 L19.1408313,7.68286899 C19.3985642,7.68286899 19.6074979,7.89180277 19.6074979,8.14953566 C19.6074979,8.40726854 19.3985642,8.61620232 19.1408313,8.61620232 L16.8515613,8.61620232 C16.5938284,8.61620232 16.3848947,8.40726854 16.3848947,8.14953566 C16.3848947,7.89180277 16.5938284,7.68286899 16.8515613,7.68286899 Z" id="矩形备份-74"></path> <path d="M16.8515613,3.33760726 L21.3127216,3.33760726 C21.5704545,3.33760726 21.7793883,3.54654104 21.7793883,3.80427393 C21.7793883,4.06200681 21.5704545,4.27094059 21.3127216,4.27094059 L16.8515613,4.27094059 C16.5938284,4.27094059 16.3848947,4.06200681 16.3848947,3.80427393 C16.3848947,3.54654104 16.5938284,3.33760726 16.8515613,3.33760726 Z" id="矩形备份-75"></path> <path d="M16.8515613,12.0281307 L21.3127216,12.0281307 C21.5704545,12.0281307 21.7793883,12.2370645 21.7793883,12.4947974 C21.7793883,12.7525303 21.5704545,12.9614641 21.3127216,12.9614641 L16.8515613,12.9614641 C16.5938284,12.9614641 16.3848947,12.7525303 16.3848947,12.4947974 C16.3848947,12.2370645 16.5938284,12.0281307 16.8515613,12.0281307 Z" id="矩形备份-77"></path> </g> </g> </g></svg>');
  }
  /**
   * 菜单是否需要激活（如选中加粗文本，“加粗”菜单会激活），用不到则返回 false
   *
   * @return {*}  {boolean}
   * @memberof IFilesButtonMenu
   */
  isActive() {
    return !1;
  }
  /**
   * 获取菜单执行时的 value ，用不到则返回空 字符串或 false
   *
   * @return {*}  {(string | boolean)}
   * @memberof IFilesButtonMenu
   */
  getValue() {
    return !1;
  }
  /**
   * 菜单是否需要禁用（如选中 H1 ，“引用”菜单被禁用），用不到则返回 false
   *
   * @return {*}  {boolean}
   * @memberof IFilesButtonMenu
   */
  isDisabled() {
    return !1;
  }
  /**
   * 点击菜单时触发的函数
   *
   * @param {IDomEditor} editor
   * @memberof IFilesButtonMenu
   */
  exec(e) {
    e.emit("openFilesUpload");
  }
}
const y7 = {
  type: "insert",
  renderElem: (s, e) => {
    const { data: t = {} } = s;
    return wn(
      "".concat(t.type || "", "-elem"),
      {
        dataset: { value: JSON.stringify(t) },
        props: {
          contentEditable: !1
          // 不可编辑
        }
      },
      e
    );
  }
}, b7 = {
  type: "insert",
  elemToHtml: (s) => {
    const { data: e = {} } = s;
    return "<span data-w-e-type=\"insert\" class='insert'>".concat(JSON.stringify({
      type: e.type,
      value: e.value
    }), "</span>");
  }
}, v7 = {
  selector: 'span[data-w-e-type="insert"]',
  parseElemHtml: (s) => ({
    data: JSON.parse(s.innerHTML) || {},
    type: "insert",
    children: [{ text: "" }]
  })
}, x7 = {
  type: "layout",
  renderElem: (s, e) => wn(
    "layout-elem",
    {
      props: {
        class: "layout"
      }
    },
    e || []
  )
}, C7 = {
  type: "layout",
  elemToHtml: (s, e) => "<layout-elem data-w-e-type=\"layout\" class='layout'>".concat(e, "</layout-elem>")
}, E7 = {
  selector: 'layout-elem[data-w-e-type="layout"]',
  parseElemHtml: (s, e) => ({
    type: "layout",
    children: e
  })
}, S7 = {
  type: "layout-column",
  renderElem: (s, e) => wn(
    "layout-column-elem",
    {
      props: {
        class: "layout-column"
      }
    },
    e || []
  )
}, A7 = {
  type: "layout-column",
  elemToHtml: (s, e) => "<layout-column-elem data-w-e-type=\"layout-column\" class='layout-column'>".concat(e, "</layout-column-elem>")
}, M7 = {
  selector: 'layout-column-elem[data-w-e-type="layout-column"]',
  parseElemHtml: (s, e) => ({
    type: "layout-column",
    children: e
  })
};
class k7 {
  /**
   * Creates an instance of InsertButtonMenu.
   * @memberof InsertButtonMenu
   */
  constructor() {
    /**
     * 标题
     *
     * @memberof InsertButtonMenu
     */
    E(this, "title", "插入");
    /**
     * 菜单类型
     *
     * @memberof InsertButtonMenu
     */
    E(this, "tag", "button");
    /**
     * 菜单图标
     *
     * @memberof InsertButtonMenu
     */
    E(this, "iconSvg", "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em' class='insert-icon' fill='var(--ibiz-color-primary)'><g stroke-width='1' fill-rule='evenodd'> <path d='M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16zm-.6-8.6H4v1.2h3.4V12h1.2V8.6H12V7.4H8.6V4H7.4v3.4z'></path></g></svg>");
  }
  /**
   * 菜单是否需要激活（如选中加粗文本，“加粗”菜单会激活），用不到则返回 false
   *
   * @return {*}  {boolean}
   * @memberof InsertButtonMenu
   */
  isActive() {
    return !1;
  }
  /**
   * 获取菜单执行时的 value ，用不到则返回空 字符串或 false
   *
   * @return {*}  {(string | boolean)}
   * @memberof InsertButtonMenu
   */
  getValue() {
    return !1;
  }
  /**
   * 菜单是否需要禁用（如选中 H1 ，“引用”菜单被禁用），用不到则返回 false
   *
   * @return {*}  {boolean}
   * @memberof InsertButtonMenu
   */
  isDisabled() {
    return !1;
  }
  /**
   * 点击菜单时触发的函数
   *
   * @param {IDomEditor} editor
   * @memberof InsertButtonMenu
   */
  exec(e) {
    e.emit("openInsertSelect");
  }
}
const P7 = {
  key: "insert",
  factory() {
    return new k7();
  }
}, _7 = {
  key: "files",
  factory() {
    return new w7();
  }
}, O7 = {
  renderElems: [
    y7,
    x7,
    S7
  ],
  elemsToHtml: [
    b7,
    C7,
    A7
  ],
  parseElemsHtml: [
    v7,
    E7,
    M7
  ],
  menus: [P7, _7]
};
function Qg(s, e, t) {
  if (s.length > 0) {
    const n = e[s[0]];
    if (n && n.type === t)
      return !0;
    if (n && n.children)
      return s.splice(0, 1), Qg(s, n.children, t);
  }
  return !1;
}
function $a(s, e) {
  const { selection: t, children: n } = s;
  if (t) {
    const { path: i } = t.anchor;
    return Qg([...i], n, e);
  }
  return !1;
}
function T7(s, e) {
  const t = e.selection;
  if (t == null)
    return "";
  const n = xs.string(s), i = t.anchor.offset, o = n.slice(0, i).split("\n"), a = o.length;
  return a === 0 ? "" : o[a - 1];
}
function za(s, e, t) {
  var r;
  const n = (r = ne) == null ? void 0 : r.nodes(s, {
    at: e,
    match: (o) => we.getNodeType(o) === t
  });
  let i = !1;
  for (const o of n)
    i = !0;
  return i;
}
function ep(s, e) {
  if (s.length > 0)
    for (let t = 0; t < s.length; t++) {
      const n = s[t];
      if (n.type === e || n.data && n.data && n.data.type === e)
        return n;
      if (n.children)
        return ep(n.children || [], e);
    }
}
function Va(s, e, t, n = !1) {
  for (let i of s.values())
    if (i.isInline === n && ep([t[e[0]]], i.type))
      return !0;
  return !1;
}
function su(s) {
  const { selection: e, children: t } = s;
  if (e) {
    const { path: n } = e.anchor, i = t[n[0]] || {};
    return i && i.children && i.children.length === 1 ? !i.children[0].text : !(i && i.children && i.children.length > 1);
  }
  return !0;
}
function iu(s) {
  const { selection: e, children: t } = s;
  if (e) {
    const { path: n } = e.anchor, i = t[n[0] + 1] || {};
    return i && i.children && i.children.length === 1 ? !i.children[0].text : !(i && i.children && i.children.length > 1);
  }
  return !0;
}
function Wr(s, e) {
  He.removeNodes(s, {
    at: e
  });
  let t = setTimeout(() => {
    s.move(1), s.focus(), clearTimeout(t), t = null;
  }, 0);
}
function L7(s, e, t) {
  He.setNodes(
    s,
    {
      children: [{ text: "" }],
      data: t,
      type: "insert"
    },
    {
      at: e
    }
  ), s.move(1), s.focus();
}
function ru(s, e) {
  const { selection: t } = s;
  if (t == null || ct.isExpanded(t))
    return !1;
  const n = we.getSelectedNodeByType(s, e);
  if (n === null)
    return !1;
  const { children: i } = n;
  if (i.length !== 1)
    return !1;
  const { text: r } = i[0];
  return r === "";
}
const tp = (s) => {
  const { selection: e } = s;
  return e && ct.isCollapsed(e) ? ne.above(s, {
    match: (n) => Ui.isElementType(n, "layout-column")
  }) : null;
}, ou = (s) => {
  const e = tp(s);
  if (e) {
    const [, t] = e, n = ne.start(s, t);
    return so.equals(s.selection.anchor, n);
  }
  return !1;
}, N7 = (s) => {
  const e = tp(s);
  if (e) {
    const [, t] = e, n = ne.end(s, t);
    return so.equals(s.selection.anchor, n);
  }
  return !1;
}, D7 = (s) => {
  const { selection: e } = s;
  if (e && ct.isCollapsed(e)) {
    const [t] = ne.node(s, e);
    if (pe.isText(t) && /^(\s*\n\s*)+$/.test(t.text))
      return !0;
  }
  return !1;
}, I7 = (s) => {
  const { selection: e } = s;
  if (e && ct.isCollapsed(e)) {
    const [t] = ne.node(s, e);
    if (pe.isText(t) && t.text === "")
      return !0;
  }
  return !1;
};
class j7 {
  /**
   * Creates an instance of InsertController.
   * @memberof InsertController
   */
  constructor() {
    /**
     * 模型
     *
     * @type {IEditor}
     * @memberof MenTionController
     */
    E(this, "model");
    /**
     * 上下文
     *
     * @type {IContext}
     */
    E(this, "context");
    /**
     * 视图参数
     *
     * @type {IParams}
     */
    E(this, "params");
    /**
     * 表单数据
     *
     * @type {IData}
     * @memberof MenTionController
     */
    E(this, "data", {});
    /**
     * 编辑器示例
     *
     * @type {IDomEditor}
     * @memberof MenTionController
     */
    E(this, "editor");
    /**
     * 编辑器参数
     *
     * @type {IData}
     * @memberof MenTionController
     */
    E(this, "editorParams");
    /**
     * 编辑器示例
     *
     * @type {IDomEditor}
     * @memberof InsertController
     */
    E(this, "wangEditor");
    /**
     * 编辑内容区
     */
    E(this, "container");
    /**
     * 气泡容器
     *
     * @type {IOverlayPopoverContainer}
     * @memberof InsertController
     */
    E(this, "overlay", null);
    /**
     * 预定义阻止捕获事件code
     *
     * @type {number[]}
     * @memberof InsertController
     */
    E(this, "presetPreventEvents", [13, 38, 40]);
    /**
     * 预定义阻止冒泡事件code
     *
     * @type {number[]}
     * @memberof InsertController
     */
    E(this, "presetPreventPropEvents", [27]);
    /**
     * 插入项
     *
     * @type {number[]}
     * @memberof InsertController
     */
    E(this, "insertMap", ef());
    /**
     * 删除回调
     *
     * @type {NOOP}
     * @memberof InsertController
     */
    E(this, "cleanup", Pt);
    this.registerNode();
  }
  /**
   * 声明插件
   *
   * @template T
   * @param {T} editor
   * @return {*}
   * @memberof InsertController
   */
  insertPlugin(e) {
    const {
      isInline: t,
      isVoid: n,
      insertBreak: i,
      insertNode: r,
      deleteBackward: o,
      normalizeNode: a,
      deleteForward: l
    } = e;
    return e.isInline = (c) => we.getNodeType(c) === "insert" ? !0 : t(c), e.isVoid = (c) => we.getNodeType(c) === "insert" ? !0 : n(c), e.insertBreak = () => {
      const c = we.getSelectedNodeByType(e, "layout");
      if (c) {
        const u = T7(
          c,
          e
        );
        if (u) {
          const d = u.match(/^\s+/);
          if (d !== null && d[0] != null) {
            const f = d[0];
            e.insertText("\n".concat(f));
            return;
          }
        }
        e.insertText("\n");
        return;
      }
      i();
    }, e.insertNode = (c) => {
      const { maxLength: u } = e.getConfig(), d = we.getSelectedNodeByType(e, "layout");
      if (d && c.type && c.type === "layout")
        return;
      if (d) {
        const p = this.insertMap.find(
          (m) => m.type === c.data.type
        );
        p && p.isInline && (D7(e) || ou(e) && I7(e)) && e.insertText(" ");
      }
      if (!u) {
        r(c);
        return;
      }
      const f = we.getLeftLengthOfMaxLength(e);
      if (f <= 0)
        return;
      const g = xs.string(c);
      f < g.length || r(c);
    }, e.normalizeNode = ([c, u]) => {
      if (we.getNodeType(c) === "layout" && we.isLastNode(e, c)) {
        const g = we.genEmptyParagraph();
        He.insertNodes(e, g, { at: [u[0] + 1] });
        return;
      }
      return a([c, u]);
    }, e.deleteBackward = (c) => {
      const u = we.getSelectedNodeByType(e, "layout"), { selection: d } = e;
      if (!u && d) {
        const f = ne.before(e, d);
        if (f && (za(
          e,
          f,
          "layout"
        ) || !u && Va(this.insertMap, f.path, e.children))) {
          Wr(e, [f.path[0]]);
          return;
        }
      }
      u && ru(e, "layout-column") || ou(e) || o(c);
    }, e.deleteForward = (c) => {
      const u = we.getSelectedNodeByType(e, "layout"), { selection: d } = e;
      if (!u && d) {
        const f = ne.after(e, d);
        if (f) {
          const g = za(
            e,
            f,
            "layout"
          ), p = su(e), m = p ? d.focus.path[0] : f.path[0];
          if (g) {
            Wr(e, [m]);
            return;
          }
          if (Va(this.insertMap, f.path, e.children)) {
            Wr(e, [m]), p && e.moveReverse(1), this.handleMove(39);
            return;
          }
        }
      }
      u && ru(e, "layout-column") || N7(e) || l(c);
    }, e;
  }
  registerNode() {
    window.insertIsRegiter || (ht.registerModule(O7), window.insertIsRegiter = !0), ht.registerPlugin(this.insertPlugin.bind(this));
  }
  /**
   * 初始化
   *
   * @param {IDomEditor} editor
   * @memberof InsertController
   */
  async init(e, t) {
    this.model = t.model, this.context = t.context, this.params = t.params, this.data = t.data, this.editorParams = this.model.editorParams, this.wangEditor = e, this.listenEvent();
  }
  /**
   * 监听事件
   *
   * @private
   * @memberof InsertController
   */
  listenEvent() {
    const e = this.wangEditor.getEditableContainer();
    this.cleanup = pi(e, "keydown", (t) => {
      var n;
      this.overlay && this.presetPreventEvents.includes(t.keyCode) && t.preventDefault(), this.overlay && this.presetPreventPropEvents.includes(t.keyCode) && (t.stopPropagation(), (n = this.overlay) == null || n.dismiss());
    }), e.addEventListener("keyup", this.handleKeyup.bind(this)), e.addEventListener("mouseup", this.handleMouseup.bind(this)), this.wangEditor.on("openInsertSelect", () => this.openInsertSelect()), this.wangEditor.on("openFilesUpload", () => this.openFilesUpload()), e.addEventListener(
      "dateElemEvent",
      this.handleInsertChange.bind(this)
    ), e.addEventListener(
      "labelElemEvent",
      this.handleInsertChange.bind(this)
    ), e.addEventListener(
      "promptBoxElemEvent",
      this.handleInsertChange.bind(this)
    ), e.addEventListener(
      "mindMapElemEvent",
      this.handleInsertChange.bind(this)
    ), e.addEventListener(
      "audioElemEvent",
      this.handleInsertChange.bind(this)
    ), e.addEventListener(
      "filesElemEvent",
      this.handleInsertChange.bind(this)
    ), e.addEventListener(
      "formulaElemEvent",
      this.handleInsertChange.bind(this)
    ), e.addEventListener(
      "layoutElemEvent",
      this.handleInsertChange.bind(this)
    ), this.container = e;
  }
  /**
   * 处理按键抬起
   */
  handleKeyup(e) {
    this.handleMove(e.keyCode);
  }
  /**
   * 处理鼠标抬起
   */
  handleMouseup() {
    this.handleMove(39);
  }
  /**
   * 处理移动
   * 37, 38, 39, 40 上下左右键
   */
  handleMove(e) {
    if ([37, 38, 39, 40].includes(e) && this.wangEditor.selection) {
      const { children: t, selection: n } = this.wangEditor;
      if (n && n.focus.path && !za(this.wangEditor, n.focus.path, "layout") && Va(this.insertMap, n.focus.path, t)) {
        if ([37, 38].includes(e) ? this.wangEditor.moveReverse(2) : [39, 40].includes(e) && this.wangEditor.move(2), n.focus.path[0] === 0) {
          this.handleMove(39);
          return;
        }
        this.handleMove(e);
      }
    }
  }
  /**
   * 处理插入项值改变
   */
  handleInsertChange(e) {
    const t = this.getCustomNodePath(e.target), { params: n } = e.detail;
    if (n && n.isDelete) {
      Wr(this.wangEditor, t);
      return;
    }
    e.detail && L7(this.wangEditor, t, e.detail);
  }
  /**
   * 获取自定义元素path
   *
   * @param {Element} element 自定义元素节点
   * @memberof InsertController
   * @returns {number[]}
   */
  getCustomNodePath(e) {
    const t = we.toSlateNode(this.wangEditor, e);
    return we.findPath(this.wangEditor, t);
  }
  /**
   * 打开插入选择
   *
   * @memberof InsertController
   */
  async openInsertSelect() {
    let e;
    const t = we.getToolbar(this.wangEditor);
    if (t) {
      const i = t.toolbarItems.find((r) => {
        const { $elem: o } = r, l = o[0].querySelectorAll("[data-menu-key]")[0];
        return (l ? l.getAttribute("data-menu-key") : "") === "insert" ? l : !1;
      });
      e = i ? i.$button[0] : !1;
    }
    if (e) {
      const n = await this.openPopover(
        e
      );
      n.ok && n.data && n.data.length > 0 && (n.data.length > 1 && (this.wangEditor.focus(), !iu(this.wangEditor) && !$a(this.wangEditor, "layout") && (this.wangEditor.insertBreak(), this.wangEditor.moveReverse(1))), n.data.forEach((i, r) => {
        setTimeout(() => {
          this.addNode(i, "insert");
        }, 200 * r);
      })), this.overlay = null;
    }
  }
  /**
   * 打开文件上传
   *
   * @memberof InsertController
   */
  async openFilesUpload() {
    const e = await ibiz.overlay.modal(
      (t) => cs(nf, {
        modal: t,
        context: this.context,
        viewParams: this.params,
        actionParams: this.editorParams
      }),
      void 0,
      { width: "auto", height: "auto" }
    );
    e.ok && e.data && e.data.length > 0 && (this.wangEditor.focus(), e.data.forEach((t, n) => {
      const i = {
        type: "files",
        value: t,
        params: { isAdd: !0 }
      };
      setTimeout(() => {
        this.addNode(i, "insert");
      }, 200 * n);
    }));
  }
  /**
   * 添加节点
   *
   * @param {IData} data
   * @param {string} type
   * @memberof InsertController
   */
  addNode(e, t) {
    const n = { data: e, type: t, children: [{ text: "" }] };
    switch (this.wangEditor.restoreSelection(), e.type) {
      case "prompt-box":
      case "mind-map":
      case "audio":
        !su(this.wangEditor) && !$a(this.wangEditor, "layout") && this.wangEditor.insertBreak(), this.wangEditor.insertNode(n), iu(this.wangEditor) && !$a(this.wangEditor, "layout") && this.wangEditor.insertBreak();
        break;
      case "layout":
        Object.assign(n, {
          type: "layout",
          children: [
            { type: "layout-column", children: [{ text: "" }] },
            { type: "layout-column", children: [{ text: "" }] }
          ]
        }), this.wangEditor.insertNode(n);
        break;
      default:
        this.wangEditor.insertNode(n), this.wangEditor.move(1);
        break;
    }
    this.handleMove(39);
  }
  /**
   * 打开弹窗
   *
   * @param {HTMLElement} target
   * @returns {Promise<IModalData>}
   */
  async openPopover(e, t = {}) {
    return this.overlay = ibiz.overlay.createPopover(
      this.createOverlayView(),
      void 0,
      {
        width: "auto",
        noArrow: !0,
        autoClose: !0,
        placement: "bottom-start",
        ...t
      }
    ), await this.overlay.present(e), await this.overlay.onWillDismiss();
  }
  /**
   * 创建弹窗内元素
   *
   * @param {JSX.Element | string} component
   * @returns {VNode}
   */
  createOverlayView() {
    return (e) => cs(xw, {
      modal: e,
      context: this.context,
      viewParams: this.params,
      actionParams: this.editorParams
    });
  }
  /**
   * 解析emoji节点
   *
   * @param {string} value
   * @return {*}
   * @memberof InsertController
   * @memberof InsertController
   */
  parseNode(e) {
    return e;
  }
  /**
   * 销毁
   *
   * @memberof InsertController
   */
  onDestroyed() {
    this.container && (this.container.removeEventListener("keyup", this.handleKeyup.bind(this)), this.container.removeEventListener(
      "mouseup",
      this.handleMouseup.bind(this)
    ), this.container.removeEventListener(
      "dateElemEvent",
      this.handleInsertChange.bind(this)
    ), this.container.removeEventListener(
      "labelElemEvent",
      this.handleInsertChange.bind(this)
    ), this.container.removeEventListener(
      "promptBoxElemEvent",
      this.handleInsertChange.bind(this)
    ), this.container.removeEventListener(
      "mindMapElemEvent",
      this.handleInsertChange.bind(this)
    ), this.container.removeEventListener(
      "audioElemEvent",
      this.handleInsertChange.bind(this)
    ), this.container.removeEventListener(
      "filesElemEvent",
      this.handleInsertChange.bind(this)
    ), this.container.removeEventListener(
      "formulaElemEvent",
      this.handleInsertChange.bind(this)
    ), this.container.removeEventListener(
      "layoutElemEvent",
      this.handleInsertChange.bind(this)
    ), this.container = null), this.cleanup !== Pt && this.cleanup(), this.overlay && this.overlay.dismiss();
  }
}
class qt {
  /**
   * 初始化
   *
   * @static
   * @memberof CustomNodeFactory
   */
  static init(e) {
    this.registerMap.set("mention", Qv), this.registerMap.set("marker", Hv), this.registerMap.set("attachments", _4), this.registerMap.set("codesnippet", F4), this.registerMap.set("page", c7), this.registerMap.set("emoji", m7), this.registerMap.set("insert", j7), this.presetNodes.forEach((t) => {
      this.registerPlugin({
        type: t,
        id: "".concat(t).concat(e)
      });
    });
  }
  /**
   * 注册节点适配器
   *
   * @public
   * @memberof CustomNodeFactory
   */
  static registerPlugin(e) {
    const { type: t, id: n } = e;
    if (this.customNodeMap.has(n))
      return this.customNodeMap.get(n);
    const i = this.registerMap.get(t);
    if (i) {
      const r = new i();
      return this.customNodeMap.set(n, r), r;
    }
  }
  /**
   * 根据uuid获取注册插件
   *
   * @static
   * @param {string} id
   * @return {*}
   * @memberof CustomNodeFactory
   */
  static getPluginsById(e) {
    const t = [];
    return this.presetNodes.forEach((n) => {
      this.customNodeMap.has("".concat(n).concat(e)) && t.push(this.customNodeMap.get("".concat(n).concat(e)));
    }), t;
  }
  /**
   * @description 获取控制器
   * @static
   * @param {string} id
   * @param {string} type
   * @return {*}
   * @memberof CustomNodeFactory
   */
  static getControllerById(e, t) {
    return this.customNodeMap.get("".concat(t).concat(e));
  }
  /**
   * 卸载节点适配器
   *
   * @public
   * @memberof CustomNodeFactory
   */
  static unregisterPlugin(e) {
    const { id: t } = e;
    this.customNodeMap.has(t) && this.customNodeMap.delete(t);
  }
  /**
   * 初始化
   *
   * @static
   * @memberof CustomNodeFactory
   */
  static destroy(e) {
    this.presetNodes.forEach((t) => {
      this.unregisterPlugin({
        id: "".concat(t).concat(e)
      });
    }), this.registerMap.delete("mention"), this.registerMap.delete("marker"), this.registerMap.delete("attachments"), this.registerMap.delete("codesnippet"), this.registerMap.delete("page"), this.registerMap.delete("emoji"), this.registerMap.delete("insert");
  }
}
/**
 * 自定义节点
 *
 * @static
 * @type {IData}
 * @memberof CustomNodeFactory
 */
E(qt, "customNodeMap", /* @__PURE__ */ new Map()), /**
 * 预置注册表
 *
 * @type {Map<string, any>}
 * @memberof CustomNodeFactory
 */
E(qt, "registerMap", /* @__PURE__ */ new Map()), /**
 * 预置注册节点
 *
 * @static
 * @memberof CustomNodeFactory
 */
E(qt, "presetNodes", [
  "mention",
  "marker",
  "attachments",
  "codesnippet",
  "page",
  "emoji",
  "insert"
]);
class R7 extends HTMLElement {
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  attributeChangedCallback(e, t, n) {
    if (e === "data-value") {
      if (n && t === n)
        return;
      const i = JSON.parse(n), r = this.attachShadow({ mode: "open" }), o = r.ownerDocument;
      if (i.icon) {
        const l = o.createElement("span");
        l.part.add("svg"), l.innerHTML = i.icon, r.appendChild(l);
      }
      if (i.identifier) {
        const l = o.createElement("span");
        l.part.add("identifier"), l.innerHTML = i.identifier, r.appendChild(l);
      }
      if (i.name) {
        const l = o.createElement("span");
        l.part.add("name"), l.innerHTML = i.name, r.appendChild(l);
      }
      const a = o.createElement("style");
      a.innerHTML = "\n      svg {\n        height: 1em;\n        width: 1em;\n      }\n    ", r.appendChild(a);
    }
  }
}
class B7 extends HTMLElement {
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  attributeChangedCallback(e, t, n) {
    if (e === "data-value") {
      if (n && t === n)
        return;
      const i = this.attachShadow({ mode: "open" }), o = i.ownerDocument.createElement("span");
      o.innerHTML = n, o.part.add("box"), o.classList.add("emoji-elem_box"), i.appendChild(o);
    }
  }
}
class F7 {
  constructor() {
    E(this, "title", "格式刷");
    E(this, "tag", "button");
    E(this, "fragment", []);
    E(this, "format", {});
    E(this, "editor", null);
    E(this, "excting", !1);
    E(this, "iconSvg", '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fit="" height="1em" width="1em" preserveAspectRatio="xMidYMid meet" focusable="false"><g id="aqseditor/paintformat" stroke-width="1" fill-rule="evenodd"><path d="M3 5.24h10V2H3v3.24zM13.299 1H2.701A.701.701 0 0 0 2 1.701v3.838c0 .387.314.701.701.701h6.236L7.621 7.438h-.002v2.233h-.768v5.184L9.404 13.1V9.671h-.585V7.97l1.9-1.73h2.58A.701.701 0 0 0 14 5.539V1.701A.701.701 0 0 0 13.299 1z" id="aqsFill-1"></path></g></svg>');
    E(this, "setPaintFormat", () => {
      if (!this.editor)
        return;
      const e = this.editor.getSelectionText();
      if (e && Object.keys(this.format).length > 0) {
        const t = { ...this.format, text: e };
        this.editor.insertNode(t), this.excting || this.clearFormat();
      }
    });
    E(this, "onPaintFormat", Ll(this.setPaintFormat, 500, !1));
    E(this, "throttleHandle", this.throttle(this.handle, 300));
  }
  // 菜单是否需要激活（如选中加粗文本，“加粗”菜单会激活），用不到则返回 false
  isActive(e) {
    return Object.keys(this.format).length > 0;
  }
  // 获取菜单执行时的 value ，用不到则返回空 字符串或 false
  getValue(e) {
    return "";
  }
  // 菜单是否需要禁用（如选中 H1 ，“引用”菜单被禁用），用不到则返回 false
  isDisabled(e) {
    return !1;
  }
  calcFormat(e) {
    if (e.length > 0) {
      const { children: t } = e[0];
      t.forEach((n) => {
        Object.assign(this.format, n);
      });
    }
  }
  clearFormat() {
    this.format = {};
    const e = this.editor.getEditableContainer();
    e && e.classList.remove("is-paint-format");
    const t = document.querySelector(
      "button[data-menu-key='paintformat']"
    );
    t && t.classList.remove("active");
  }
  throttle(e, t) {
    let n = null;
    return function(...i) {
      n || (n = setTimeout(() => {
        e.apply(this, i), n = null, this.excting = !0;
      }, t));
    };
  }
  handle(e) {
    if (this.excting) {
      this.clearFormat(), this.excting = !1;
      return;
    }
    const t = e.getFragment();
    this.calcFormat(t), this.editor = e;
    const n = this.editor.getEditableContainer();
    n && n.classList.add("is-paint-format"), e.deselect(), e.on("change", this.onPaintFormat), e.on("clickOutside", () => {
      this.clearFormat(), this.excting = !1;
    });
  }
  // 点击菜单时触发的函数
  exec(e) {
    this.throttleHandle(e);
  }
}
const $7 = {
  key: "paintformat",
  factory() {
    return new F7();
  }
};
class z7 {
  constructor() {
    // TS 语法
    E(this, "title", "AI询问");
    E(this, "iconSvg", '<svg xmlns="http://www.w3.org/2000/svg" version="1.1"> <text x="0" y="13" font-size="16" fill="black">AI</text></svg>');
    E(this, "tag", "button");
  }
  // 菜单是否需要激活（如选中加粗文本，“加粗”菜单会激活），用不到则返回 false
  isActive(e) {
    return !1;
  }
  // 获取菜单执行时的 value ，用不到则返回空 字符串或 false
  getValue(e) {
    return "aichart";
  }
  // 菜单是否需要禁用（如选中 H1 ，“引用”菜单被禁用），用不到则返回 false
  isDisabled(e) {
    return !1;
  }
  // 点击菜单时触发的函数
  exec(e, t) {
    e.emit("aiClick");
  }
}
function V7(s) {
  const { url: e, children: t } = s;
  let n = "_blank";
  return e.startsWith("./#/") && (n = "_self"), '<a href="'.concat(e, '" target="').concat(n, '">').concat(t[0].text, "</a>");
}
const H7 = {
  type: "link",
  elemToHtml: V7
};
class U7 {
  constructor() {
    E(this, "title", "查看连接");
    E(this, "iconSvg", '<svg viewBox="0 0 1024 1024"><path d="M924.402464 1023.068211H0.679665V99.345412h461.861399v98.909208H99.596867v725.896389h725.896389V561.206811h98.909208z" p-id="10909"></path><path d="M930.805104 22.977336l69.965436 69.965436-453.492405 453.492404-69.965435-69.901489z" p-id="10910"></path><path d="M1022.464381 304.030081h-98.917201V99.345412H709.230573V0.428211h313.233808z"></path></svg>');
    E(this, "tag", "button");
  }
  getSelectedLinkElem(e) {
    const t = we.getSelectedNodeByType(e, "link");
    return t == null ? null : t;
  }
  getValue(e) {
    const t = this.getSelectedLinkElem(e);
    return t && t.url || "";
  }
  isActive() {
    return !1;
  }
  isDisabled(e) {
    return e.selection == null || this.getSelectedLinkElem(e) == null;
  }
  exec(e, t) {
    if (!this.isDisabled(e)) {
      if (!t || typeof t != "string")
        throw new Error("打开链接失败, 路径为 '".concat(t, "'"));
      t.toString().startsWith("./#/") ? window.open("".concat(window.location.pathname).concat(t.slice(1)), "_self") : window.open(t, "_blank");
    }
  }
}
const q7 = {
  key: "customViewLink",
  factory() {
    return new U7();
  }
}, G7 = {
  menus: [q7],
  elemsToHtml: [H7]
};
class W7 extends hp {
  constructor() {
    super(...arguments);
    /**
     * 用户头像数据
     *
     * @type {string}
     * @memberof HtmlCommentController
     */
    E(this, "userAvatar", "");
    /**
     * 上传参数
     */
    E(this, "uploadParams");
    /**
     * 下载参数
     */
    E(this, "exportParams");
    /**
     * 最小高度
     *
     * @type {number}
     * @memberof HtmlCommentController
     */
    E(this, "minHeight", 48);
    /**
     * 最大高度
     *
     * @type {number}
     * @memberof HtmlCommentController
     */
    E(this, "maxHeight", 315);
    /**
     * 是否折叠
     *
     * @type {Ref<boolean>}
     * @memberof HtmlCommentController
     */
    E(this, "collapsed", L(!0));
    /**
     * @description 是否存在文件
     * @type {Ref<boolean>}
     * @memberof HtmlCommentController
     */
    E(this, "hasFile", L(!1));
    /**
     * 是否隐藏
     *
     * @type {Ref<boolean>}
     * @memberof HtmlCommentController
     */
    E(this, "hidden", L(!1));
    /**
     * 回复
     *
     * @type {string}
     * @memberof HtmlCommentController
     */
    E(this, "reply", L(""));
    /**
     * 回复脚本
     *
     * @type {string}
     * @memberof HtmlCommentController
     */
    E(this, "replyScript", "");
    /**
     * 编辑器模式
     *
     * @type {('comment' | 'default')}
     * @memberof HtmlCommentController
     */
    E(this, "mode", "comment");
    /**
     * 插入工具栏项
     *
     * @type {IData[]}
     * @memberof HtmlCommentController
     */
    E(this, "insertKeys", []);
    /**
     * 绘制模式
     *
     * @type {IData[]}
     * @memberof HtmlCommentController
     */
    E(this, "renderMode", "HTML");
    /**
     * 保存间隔
     *
     * @type {IData[]}
     * @memberof HtmlCommentController
     */
    E(this, "saveInterval", 3e3);
    /**
     * 抛值模式
     *
     * @type {IData[]}
     * @memberof HtmlCommentController
     */
    E(this, "emitMode", "BUTTON");
    /**
     * 唯一标识
     *
     * @type {string}
     * @memberof HtmlCommentController
     */
    E(this, "uuid", nt());
    /**
     * 实时编辑（协同编辑）
     */
    E(this, "enableRealtime", !1);
    /**
     * 协同编辑key
     *
     * @author tony001
     * @date 2024-12-20 17:12:36
     * @type {(string | undefined)}
     */
    E(this, "collaborateKey");
    /**
     * 编辑器实例
     */
    E(this, "editor");
    /**
     * 自动保存间隔
     * - 默认30秒
     * @private
     * @type {number}
     * @memberof HtmlCommentController
     */
    E(this, "autoSaveInterval", 3e4);
    /**
     * 定时器
     *
     * @private
     * @type {(NodeJS.Timeout | null)}
     * @memberof HtmlCommentController
     */
    E(this, "timer", null);
    /**
     * 应用实体服务
     *
     * @type {IAppDEService}
     * @memberof HtmlCommentController
     */
    E(this, "deService");
    /**
     * 自填模式
     *
     * @author chitanda
     * @date 2023-10-12 10:10:52
     * @type {IAppDEACMode}
     */
    E(this, "deACMode");
    /**
     * AI 聊天自填模式
     *
     * @author chitanda
     * @date 2023-10-12 10:10:37
     * @type {boolean}
     */
    E(this, "chatCompletion", !1);
    /**
     * @description 额外能力（本地文件、代码段、页面）
     * @type {string}
     * @memberof HtmlCommentController
     */
    E(this, "expMenuKeys", "file;code;page");
    /**
     * @description 额外属性
     * @type {IData[]}
     * @memberof HtmlCommentController
     */
    E(this, "expFields", []);
    E(this, "evt", new hu(
      this.getEventArgs.bind(this)
    ));
  }
  /**
   * @description 提及项控制器
   * @readonly
   * @memberof HtmlCommentController
   */
  get markerController() {
    return qt.getControllerById(this.uuid, "marker");
  }
  getEventArgs() {
    return {
      context: this.context,
      params: this.params,
      data: [],
      eventArg: "",
      targetName: this.model.name,
      view: this.getView()
    };
  }
  async onInit() {
    await super.onInit(), await this.getCurrentUserAvatar();
    const { model: t } = this;
    if (t.appDEACModeId && (this.deACMode = await up(
      t.appDEACModeId,
      t.appDataEntityId,
      this.context.srfappid
    ), this.deACMode && this.deACMode.actype === "CHATCOMPLETION" && (this.deService = await ibiz.hub.getApp(t.appId).deService.getService(this.context, t.appDataEntityId), this.chatCompletion = !0)), this.registerCustomElem(), this.editorParams) {
      const {
        uploadParams: n,
        exportParams: i,
        MINHEIGHT: r,
        MAXHEIGHT: o,
        REPLYSCRIPT: a,
        MODE: l,
        INSERTKEYS: c,
        RENDERMODE: u,
        SAVEINTERVAL: d,
        EMITMODE: f,
        DEFAULTCOLLAPSE: g,
        ENABLEREALTIME: p,
        COLLABORATEKEY: m,
        EXPMENUKEYS: w,
        EXTFIELDVALUE: v
      } = this.editorParams;
      if (n)
        try {
          this.uploadParams = JSON.parse(n);
        } catch (y) {
          ibiz.log.error(
            "编辑器[".concat(ibiz.log.error(
              y
            ), "]编辑器参数 uploadParams 非 json 格式")
          );
        }
      if (i)
        try {
          this.exportParams = JSON.parse(i);
        } catch (y) {
          ibiz.log.error(
            "编辑器[".concat(ibiz.log.error(
              y
            ), "]编辑器参数 exportParams 非 json 格式")
          );
        }
      r && (this.minHeight = Number(r)), o && (this.maxHeight = Number(o)), a && (this.replyScript = a), l && (this.mode = l.toLowerCase()), c && (this.insertKeys = JSON.parse(c)), u && (this.renderMode = u), d && (this.saveInterval = Lp(d)), f && (this.emitMode = f), g && (this.collapsed.value = !Object.is(g, "TRUE") && !Object.is(g, "true")), p && (this.enableRealtime = Object.is(p, "TRUE") || Object.is(p, "true")), m && (this.collaborateKey = Hi(
        { collaboratekey: m },
        this.parent.data || {},
        this.params,
        this.context
      ).collaboratekey), w && (this.expMenuKeys = w), v && (this.expFields = v.split(";").map((y) => {
        const [b, x] = y.split(":");
        return { name: b, value: x };
      }));
    }
    qt.init(this.uuid), this.evt.on("onChange", () => {
      if (this.parent.form)
        return;
      const n = ibiz.uiDomainManager.get(this.context.srfsessionid);
      n && n.dataChange();
    }), this.listenViewDestroyed();
  }
  /**
   * 注册自定义元素
   *
   * @private
   * @memberof HtmlCommentController
   */
  registerCustomElem() {
    window.customElements.get("mention-elem") || window.customElements.define("mention-elem", R7), window.customElements.get("emoji-elem") || window.customElements.define("emoji-elem", B7), window.paintFormatIsRegiter || (ht.registerMenu($7), window.paintFormatIsRegiter = !0), window.aichartRegister || (ht.registerMenu({
      key: "aichart",
      factory() {
        return new z7();
      }
    }), window.aichartRegister = !0), window.customLinkIsRegiter || (ht.registerModule(G7), window.customLinkIsRegiter = !0);
  }
  /**
   * 初始化
   *
   * @param {IDomEditor} editor
   * @memberof HtmlCommentController
   */
  async onCreated(t, n, i) {
    const r = qt.getPluginsById(this.uuid);
    for (let o = 0; o < r.length; o++)
      await r[o].init(t, {
        model: this.model,
        data: n,
        toolbarConfig: i,
        controller: this,
        context: this.context,
        params: this.params,
        evt: this.evt
      });
  }
  /**
   * 组件销毁
   *
   * @memberof HtmlCollapseController
   */
  onDestroyed() {
    qt.getPluginsById(this.uuid).forEach((n) => {
      n.onDestroyed();
    }), qt.destroy(this.uuid);
  }
  /**
   * 处理视图销毁
   *
   * @memberof HtmlCommentController
   */
  listenViewDestroyed() {
    const t = this.getView();
    t && t.evt.on("onDestroyed", () => {
      this.onDestroyed();
    });
  }
  /**
   * 解析所有注册节点
   *
   * @param {string} value
   * @return {*}
   * @memberof HtmlCommentController
   */
  parseNode(t) {
    let n = t;
    return qt.getPluginsById(this.uuid).forEach((r) => {
      n = r.parseNode(n);
    }), n;
  }
  /**
   * 设置html
   *
   * @param {string} value
   * @memberof HtmlCommentController
   */
  async setValue(t) {
    let n = t.replace(/&nbsp;/g, " ");
    n.includes("&") && (n = n.replace(/&/g, "&amp;")), this.collapsed.value = !1, this.hidden.value = !0, await Ye(), this.hidden.value = !1, await Ye();
    const i = this.parseNode(n);
    this.evt.emit("setHtml", {
      eventArg: i
    });
  }
  /**
   * 设置回复,data: {name: string, content: string}
   *
   * @param {IData} data
   * @memberof HtmlCommentController
   */
  setReply(t) {
    this.reply.value = Xs.getEmojiCustomHtml(
      "".concat(t.name, ": ").concat(t.content)
    ), this.evt.emit("onSetReply", {
      eventArg: this.reply.value
    });
  }
  /**
   * 删除回复
   *
   * @memberof HtmlCommentController
   */
  removeReply() {
    this.reply.value = "", this.evt.emit("onRemoveReply", {
      eventArg: this.reply.value
    });
  }
  /**
   * 清空
   *
   * @memberof HtmlCommentController
   */
  clear() {
    this.reply.value = "", this.evt.emit("onRemoveReply", {
      eventArg: this.reply.value
    }), this.evt.emit("clear", {
      eventArg: ""
    }), this.collapsed.value = !0;
  }
  /**
   * @description 聚焦
   * @memberof HtmlCommentController
   */
  focus() {
    this.evt.emit("focus", void 0), this.collapsed.value = !1;
  }
  /**
   * @description 失焦
   * @memberof HtmlCommentController
   */
  blur() {
    this.evt.emit("blur", void 0), this.collapsed.value = !0;
  }
  /**
   * 请求url获取文件流，并用JS触发文件下载
   *
   * @author lxm
   * @date 2022-11-17 14:11:09
   * @param {string} url
   * @param {IData} file
   */
  fileDownload(t) {
    ibiz.net.request(t.url, {
      method: "get",
      responseType: "blob",
      baseURL: ""
      // 已经有baseURL了，这里无需再写
    }).then((n) => {
      if (n.status !== 200)
        throw new io("下载文件失败");
      if (n.data) {
        const i = t.name;
        Cp(n.data, i);
      } else
        throw new io("文件流数据不存在");
    });
  }
  /**
   * 切换折叠
   *
   * @memberof HtmlCommentController
   */
  toggleCollapse(t) {
    this.collapsed.value = !t && !this.collapsed.value;
  }
  /**
   * 绘制模式为json时，需要将返回数据的json内容转html
   *
   * @author ljx
   * @date 2024-03-09 15:11:09
   * @param {string} url
   * @param {IData} file
   */
  jsonToHtml(t) {
    let n = "";
    try {
      const i = JSON.parse(t);
      n = mp({
        content: i
      }).getHtml();
    } catch (i) {
      n = t, ibiz.log.error("JSON字符串转换错误", i);
    }
    return n;
  }
  /**
   * 绘制模式为json时，处理抛值数据
   *
   * @author ljx
   * @date 2024-03-09 15:11:09
   * @param {string} url
   * @param {IData} file
   */
  toJson(t = []) {
    let n = "";
    try {
      n = JSON.stringify(t);
    } catch (i) {
      ibiz.log.error("JSON字符串转换错误");
    }
    return n;
  }
  /**
   * 获取当前用户头像
   *
   * @memberof HtmlCommentController
   */
  async getCurrentUserAvatar() {
    var i, r;
    const t = await ibiz.hub.getApp(this.context.srfappid);
    let n = [];
    if (n = await t.codeList.get(
      "SysOperator",
      this.context,
      this.params
    ), this.context.srfuserid) {
      const o = n.filter((a) => a.value === this.context.srfuserid);
      o && o.length > 0 && (this.userAvatar = ((r = (i = o[0]) == null ? void 0 : i.data) == null ? void 0 : r.iconurl) || "");
    }
  }
  /**
   * 获取当前视图
   *
   * @return {*}
   * @memberof HtmlCommentController
   */
  getView() {
    const t = this.parent.form || this.parent.grid || this.parent.panel;
    if (t)
      return t.view;
  }
  /**
   * @description 处理点击
   * @param {MouseEvent} event
   * @memberof HtmlCommentController
   */
  handleClick(t) {
    qt.getPluginsById(this.uuid).forEach((i) => {
      i.handleClick && i.handleClick(t);
    });
  }
}
class J7 {
  constructor() {
    E(this, "formEditor", "HtmlComment");
    E(this, "gridEditor", "HtmlComment");
  }
  async createController(e, t) {
    const n = new W7(e, t);
    return await n.init(), n;
  }
}
const Y7 = pp(Oa, function(s) {
  window.customElements.get("layout-elem") || window.customElements.define("layout-elem", $v), window.customElements.get("layout-column-elem") || window.customElements.define("layout-column-elem", zv), window.customElements.get("date-elem") || window.customElements.define("date-elem", Dv), window.customElements.get("label-elem") || window.customElements.define("label-elem", Iv), window.customElements.get("prompt-box-elem") || window.customElements.define("prompt-box-elem", jv), window.customElements.get("mind-map-elem") || window.customElements.define("mind-map-elem", Rv), window.customElements.get("audio-elem") || window.customElements.define("audio-elem", Bv), window.customElements.get("files-elem") || window.customElements.define("files-elem", Vv), window.customElements.get("formula-elem") || window.customElements.define("formula-elem", Fv), s.component(hl.name, hl), s.component(oo.name, oo), s.component(Oa.name, Oa), dp(
    "EDITOR_CUSTOMSTYLE_COMMENT",
    () => new J7()
  );
}), m9 = {
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type
  install(s) {
    s.use(Y7), s.component(
      "IBizHtmlContent",
      ap(() => Promise.resolve().then(() => Dp))
    );
  }
};
export {
  Y7 as I,
  p9 as c,
  b5 as g,
  m9 as i
};
