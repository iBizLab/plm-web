import '../../../../../../../@antv_x6-geometry@2.0.5/node_modules/@antv/x6-geometry/es/index.mjs';
import '../../../../../../../@antv_x6-common@2.0.16/node_modules/@antv/x6-common/es/index.mjs';
import { getPointAtEdge, resolve } from '../node-anchor/util.mjs';
import { getClosestPoint } from './closest.mjs';
import { Line } from '../../../../../../../@antv_x6-geometry@2.0.5/node_modules/@antv/x6-geometry/es/line.mjs';
import { call } from '../../../../../../../@antv_x6-common@2.0.16/node_modules/@antv/x6-common/es/function/function.mjs';

const orthogonal = function (view, magnet, refPoint, options) {
    const OFFSET = 1e6;
    const path = view.getConnection();
    const segmentSubdivisions = view.getConnectionSubdivisions();
    const vLine = new Line(refPoint.clone().translate(0, OFFSET), refPoint.clone().translate(0, -OFFSET));
    const hLine = new Line(refPoint.clone().translate(OFFSET, 0), refPoint.clone().translate(-OFFSET, 0));
    const vIntersections = vLine.intersect(path, {
        segmentSubdivisions,
    });
    const hIntersections = hLine.intersect(path, {
        segmentSubdivisions,
    });
    const intersections = [];
    if (vIntersections) {
        intersections.push(...vIntersections);
    }
    if (hIntersections) {
        intersections.push(...hIntersections);
    }
    if (intersections.length > 0) {
        return refPoint.closest(intersections);
    }
    if (options.fallbackAt != null) {
        return getPointAtEdge(view, options.fallbackAt);
    }
    return call(getClosestPoint, this, view, magnet, refPoint, options);
};
const orth = resolve(orthogonal);

export { orth };
