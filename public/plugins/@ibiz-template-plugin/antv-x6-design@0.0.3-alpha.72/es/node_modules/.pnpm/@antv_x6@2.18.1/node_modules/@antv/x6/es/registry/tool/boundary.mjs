import '../../../../../../../@antv_x6-common@2.0.16/node_modules/@antv/x6-common/es/index.mjs';
import { ToolsView } from '../../view/tool.mjs';
import { getViewBBox } from './util.mjs';
import { addClass } from '../../../../../../../@antv_x6-common@2.0.16/node_modules/@antv/x6-common/es/dom/class.mjs';
import { kebablizeAttrs, attr } from '../../../../../../../@antv_x6-common@2.0.16/node_modules/@antv/x6-common/es/dom/attr.mjs';
import { normalizeSides } from '../../../../../../../@antv_x6-common@2.0.16/node_modules/@antv/x6-common/es/number/number.mjs';
import { rotate } from '../../../../../../../@antv_x6-common@2.0.16/node_modules/@antv/x6-common/es/dom/transform.mjs';

var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class Boundary extends ToolsView.ToolItem {
    onRender() {
        addClass(this.container, this.prefixClassName('cell-tool-boundary'));
        if (this.options.attrs) {
            const _a = this.options.attrs, { class: className } = _a, attrs = __rest(_a, ["class"]);
            attr(this.container, kebablizeAttrs(attrs));
            if (className) {
                addClass(this.container, className);
            }
        }
        this.update();
    }
    update() {
        const view = this.cellView;
        const options = this.options;
        const { useCellGeometry, rotate: rotate$1 } = options;
        const padding = normalizeSides(options.padding);
        let bbox = getViewBBox(view, useCellGeometry).moveAndExpand({
            x: -padding.left,
            y: -padding.top,
            width: padding.left + padding.right,
            height: padding.top + padding.bottom,
        });
        const cell = view.cell;
        if (cell.isNode()) {
            const angle = cell.getAngle();
            if (angle) {
                if (rotate$1) {
                    const origin = cell.getBBox().getCenter();
                    rotate(this.container, angle, origin.x, origin.y, {
                        absolute: true,
                    });
                }
                else {
                    bbox = bbox.bbox(angle);
                }
            }
        }
        attr(this.container, bbox.toJSON());
        return this;
    }
}
(function (Boundary) {
    Boundary.config({
        name: 'boundary',
        tagName: 'rect',
        padding: 10,
        useCellGeometry: true,
        attrs: {
            fill: 'none',
            stroke: '#333',
            'stroke-width': 0.5,
            'stroke-dasharray': '5, 5',
            'pointer-events': 'none',
        },
    });
})(Boundary || (Boundary = {}));

export { Boundary };
